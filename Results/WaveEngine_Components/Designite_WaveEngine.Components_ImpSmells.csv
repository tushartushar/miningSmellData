Implementation smell,Namespace,Class,File,Method,Description
Long Method,WaveEngine.Components.Animation,Animation3D,C:\repos\WaveEngine_Components\Shared\Animation\Animation3D.cs,Update,The method has 123 lines of code.
Long Method,WaveEngine.Components.Cameras,FreeCamera3DBehavior,C:\repos\WaveEngine_Components\Shared\Cameras\FreeCamera3DBehavior.cs,HandleInput,The method has 112 lines of code.
Long Method,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,DeltaFunction,The method has 101 lines of code.
Long Method,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,DeltaFunction,The method has 100 lines of code.
Long Method,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,DeltaFunction,The method has 100 lines of code.
Long Method,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,DeltaFunction,The method has 100 lines of code.
Long Method,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The method has 273 lines of code.
Long Method,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The method has 148 lines of code.
Long Method,WaveEngine.Components.Graphics2D,SpriteRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\SpriteRenderer.cs,RefreshSliceCache,The method has 112 lines of code.
Long Method,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The method has 349 lines of code.
Long Method,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The method has 144 lines of code.
Long Method,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The method has 121 lines of code.
Long Method,WaveEngine.Components.UI,GridControl,C:\repos\WaveEngine_Components\Shared\UI\Grid\GridControl.cs,Measure,The method has 183 lines of code.
Long Method,WaveEngine.Components.UI,ImageControl,C:\repos\WaveEngine_Components\Shared\UI\Image\ImageControl.cs,Arrange,The method has 114 lines of code.
Long Method,WaveEngine.Components.UI,TextControl,C:\repos\WaveEngine_Components\Shared\UI\TextBlock\TextControl.cs,UpdateSize,The method has 206 lines of code.
Long Method,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The method has 235 lines of code.
Complex Method,WaveEngine.Components.Animation,Animation2D,C:\repos\WaveEngine_Components\Shared\Animation\Animation2D.cs,PlayAnimation,Cyclomatic complexity of the method is 9
Complex Method,WaveEngine.Components.Animation,Animation3D,C:\repos\WaveEngine_Components\Shared\Animation\Animation3D.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,WaveEngine.Components.Cameras,FreeCamera3DBehavior,C:\repos\WaveEngine_Components\Shared\Cameras\FreeCamera3DBehavior.cs,HandleInput,Cyclomatic complexity of the method is 9
Complex Method,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,Cyclomatic complexity of the method is 11
Complex Method,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,Cyclomatic complexity of the method is 10
Complex Method,WaveEngine.Components.Graphics2D,SpriteRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\SpriteRenderer.cs,RefreshSliceCache,Cyclomatic complexity of the method is 9
Complex Method,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,GenerateCollisionInfo,Cyclomatic complexity of the method is 8
Complex Method,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,Cyclomatic complexity of the method is 11
Complex Method,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,Cyclomatic complexity of the method is 10
Complex Method,WaveEngine.Components.Graphics3D,SkinnedModelRenderer,C:\repos\WaveEngine_Components\Shared\Graphics3D\SkinnedModelRenderer.cs,Draw,Cyclomatic complexity of the method is 12
Complex Method,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,Cyclomatic complexity of the method is 12
Complex Method,WaveEngine.Components.Primitives,Sphere,C:\repos\WaveEngine_Components\Shared\Primitives\Sphere.cs,Sphere,Cyclomatic complexity of the method is 10
Complex Method,WaveEngine.Components.UI,GridControl,C:\repos\WaveEngine_Components\Shared\UI\Grid\GridControl.cs,Measure,Cyclomatic complexity of the method is 38
Complex Method,WaveEngine.Components.UI,WrapPanelControl,C:\repos\WaveEngine_Components\Shared\UI\Wrap\WrapPanelControl.cs,Measure,Cyclomatic complexity of the method is 9
Complex Method,WaveEngine.Components.VR,VRCameraRig,C:\repos\WaveEngine_Components\Shared\VR\VRCameraRig.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,WaveEngine.Components.VR,VRCameraRig,C:\repos\WaveEngine_Components\Shared\VR\VRCameraRig.cs,InstantiateOVRHierarchy,Cyclomatic complexity of the method is 12
Long Parameter List,WaveEngine.Components.Animation,Animation2D,C:\repos\WaveEngine_Components\Shared\Animation\Animation2D.cs,PlayAnimation,The method has 5 parameters. Parameters: name' startFrame' endFrame' loop' backwards
Long Parameter List,WaveEngine.Components.Animation,Animation2D,C:\repos\WaveEngine_Components\Shared\Animation\Animation2D.cs,PlayAnimation,The method has 6 parameters. Parameters: name' startFrame' endFrame' loop' backwards' framesPerSecond
Long Parameter List,WaveEngine.Components.Animation,Animation3D,C:\repos\WaveEngine_Components\Shared\Animation\Animation3D.cs,PlayAnimation,The method has 5 parameters. Parameters: name' startFrame' endFrame' loop' backwards
Long Parameter List,WaveEngine.Components.Animation,AnimationBase,C:\repos\WaveEngine_Components\Shared\Animation\AnimationBase.cs,PlayAnimation,The method has 5 parameters. Parameters: name' startFrame' endFrame' loop' backwards
Long Parameter List,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,FloatAnimationGameAction,The method has 5 parameters. Parameters: entity' from' to' time' ease
Long Parameter List,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,FloatAnimationGameAction,The method has 6 parameters. Parameters: entity' from' to' time' ease' updateAction
Long Parameter List,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,DeltaFunction,The method has 5 parameters. Parameters: function' from' to' time' totalTime
Long Parameter List,WaveEngine.Components.GameActions,MoveTo2DGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\MoveTo2DGameAction.cs,MoveTo2DGameAction,The method has 5 parameters. Parameters: entity' to' time' ease' local
Long Parameter List,WaveEngine.Components.GameActions,MoveTo3DGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\MoveTo3DGameAction.cs,MoveTo3DGameAction,The method has 5 parameters. Parameters: entity' to' time' ease' local
Long Parameter List,WaveEngine.Components.GameActions,RotateTo2DGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\RotateTo2DGameAction.cs,RotateTo2DGameAction,The method has 5 parameters. Parameters: entity' to' time' ease' local
Long Parameter List,WaveEngine.Components.GameActions,RotateTo3DGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\RotateTo3DGameAction.cs,RotateTo3DGameAction,The method has 6 parameters. Parameters: entity' to' time' ease' local' shorterPath
Long Parameter List,WaveEngine.Components.GameActions,ScaleTo2DGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\ScaleTo2DGameAction.cs,ScaleTo2DGameAction,The method has 5 parameters. Parameters: entity' to' time' ease' local
Long Parameter List,WaveEngine.Components.GameActions,ScaleTo3DGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\ScaleTo3DGameAction.cs,ScaleTo3DGameAction,The method has 5 parameters. Parameters: entity' to' time' ease' local
Long Parameter List,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,Vector2AnimationGameAction,The method has 5 parameters. Parameters: entity' from' to' time' ease
Long Parameter List,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,Vector2AnimationGameAction,The method has 6 parameters. Parameters: entity' from' to' time' ease' updateAction
Long Parameter List,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,DeltaFunction,The method has 5 parameters. Parameters: function' from' to' time' totalTime
Long Parameter List,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,QuaternionAnimationGameAction,The method has 5 parameters. Parameters: entity' from' to' time' ease
Long Parameter List,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,QuaternionAnimationGameAction,The method has 6 parameters. Parameters: entity' from' to' time' ease' updateAction
Long Parameter List,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,DeltaFunction,The method has 5 parameters. Parameters: function' from' to' time' totalTime
Long Parameter List,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,Vector3AnimationGameAction,The method has 5 parameters. Parameters: entity' from' to' time' ease
Long Parameter List,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,Vector3AnimationGameAction,The method has 6 parameters. Parameters: entity' from' to' time' ease' updateAction
Long Parameter List,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,DeltaFunction,The method has 5 parameters. Parameters: function' from' to' time' totalTime
Long Parameter List,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The method has 6 parameters. Parameters: normal' width' height' twoSides' uvHorizontalFlip' uvVerticalFlip
Long Parameter List,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,Bezier,The method has 5 parameters. Parameters: p1' p2' p3' p4' t
Long Parameter List,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,Bezier,The method has 5 parameters. Parameters: p1' p2' p3' p4' t
Long Parameter List,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,BezierTangent,The method has 5 parameters. Parameters: p1' p2' p3' p4' t
Long Parameter List,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,BezierTangent,The method has 5 parameters. Parameters: p1' p2' p3' p4' t
Long Statement,WaveEngine.Components.Animation,Animation2D,C:\repos\WaveEngine_Components\Shared\Animation\Animation2D.cs,Update,The length of the statement  "                        this.currentAnimationFrame = this.startFrame + (((int)(this.currentAnimationTime * this.framesPerSecond) + this.frameLength) % this.frameLength); " is 145.
Long Statement,WaveEngine.Components.Animation,Animation2D,C:\repos\WaveEngine_Components\Shared\Animation\Animation2D.cs,Update,The length of the statement  "                        this.currentAnimationFrame = this.startFrame + (((int)(this.currentAnimationTime * this.framesPerSecond) + this.frameLength) % this.frameLength); " is 145.
Long Statement,WaveEngine.Components.Animation,Animation3D,C:\repos\WaveEngine_Components\Shared\Animation\Animation3D.cs,UpdateNumFrames,The length of the statement  "            if (this.internalAnimation != null && this.internalAnimation.Animations.Count > 0 && this.internalAnimation.Animations.ContainsKey(this.CurrentAnimation)) " is 154.
Long Statement,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,Update,The length of the statement  "                var value = this.DeltaFunction(this.easeFunction' this.from' this.to - this.from' (float)this.ellapsedTime.TotalSeconds' (float)this.totalTime.TotalSeconds); " is 157.
Long Statement,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInOutEase,The length of the statement  "                return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b; " is 120.
Long Statement,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInOutEase,The length of the statement  "            return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b; " is 122.
Long Statement,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,Update,The length of the statement  "                var value = this.DeltaFunction(this.easeFunction' this.from' this.to - this.from' (float)this.ellapsedTime.TotalSeconds' (float)this.totalTime.TotalSeconds); " is 157.
Long Statement,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInOutEase,The length of the statement  "                return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b; " is 120.
Long Statement,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInOutEase,The length of the statement  "            return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b; " is 122.
Long Statement,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,Update,The length of the statement  "                var value = this.DeltaFunction(this.easeFunction' this.from' this.to - this.from' (float)this.ellapsedTime.TotalSeconds' (float)this.totalTime.TotalSeconds); " is 157.
Long Statement,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInOutEase,The length of the statement  "                return ((a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) * -0.5f) + b; " is 121.
Long Statement,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInOutEase,The length of the statement  "            return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b; " is 122.
Long Statement,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,Update,The length of the statement  "                var value = this.DeltaFunction(this.easeFunction' this.from' this.to - this.from' (float)this.ellapsedTime.TotalSeconds' (float)this.totalTime.TotalSeconds); " is 157.
Long Statement,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInOutEase,The length of the statement  "                return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b; " is 120.
Long Statement,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInOutEase,The length of the statement  "            return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b; " is 122.
Long Statement,WaveEngine.Components.GameActions,GameAction,C:\repos\WaveEngine_Components\Shared\GameActions\GameAction.cs,Run,The length of the statement  "                throw new NotSupportedException(string.Format("The GameAction cannot be runned because its state ({0}) does not allow it"' this.State.ToString())); " is 147.
Long Statement,WaveEngine.Components.GameActions,GameAction,C:\repos\WaveEngine_Components\Shared\GameActions\GameAction.cs,TrySkip,The length of the statement  "            else if (this.Parent != null && (this.Parent.State == GameActionState.Waiting || this.Parent.State == GameActionState.Running)) " is 127.
Long Statement,WaveEngine.Components.GameActions,GameAction,C:\repos\WaveEngine_Components\Shared\GameActions\GameAction.cs,TrySkip,The length of the statement  "            else if (this.State == GameActionState.None || this.State == GameActionState.Aborted || this.State == GameActionState.Finished) " is 127.
Long Statement,WaveEngine.Components.GameActions,GameAction,C:\repos\WaveEngine_Components\Shared\GameActions\GameAction.cs,Cancel,The length of the statement  "                throw new NotSupportedException("It cannot be canncelled because it has not been started or already has been cancelled"); " is 121.
Long Statement,WaveEngine.Components.GameActions,GameActionFactory,C:\repos\WaveEngine_Components\Shared\GameActions\GameActionFactory.cs,ContinueWith,The length of the statement  "                throw new NotSupportedException("It is not possible to continue with' aborted or finised task. Defer the run command to a posterior stage."); " is 141.
Long Statement,WaveEngine.Components.GameActions,WaitGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\WaitGameAction.cs,TimerCompleted,The length of the statement  "                throw new NotSupportedException("This point should be not executed because if it has been skiped or aborted the timer (of the TimerTask)should have been removed"); " is 163.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                            if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Bottom) && (p.Position.Y > this.settings.CollisionBottom)) " is 138.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                                            p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                                            p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1))); " is 126.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                            else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Top) && (p.Position.Y < this.settings.CollisionTop)) " is 137.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                                            p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                                            p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1))); " is 126.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                            if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Right) && (p.Position.X > this.settings.CollisionRight)) " is 136.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                                            p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1))); " is 126.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                                            p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                            else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Left) && (p.Position.X < this.settings.CollisionLeft)) " is 139.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                                            p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1))); " is 126.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                                            p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The length of the statement  "                        if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1) " is 148.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The length of the statement  "                double life = (this.settings.EmitRate > 0) ? -1 : TimeSpan.FromSeconds(this.random.NextDouble() * (this.numParticles * InitTimeMultipler)).TotalSeconds; " is 152.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The length of the statement  "            this.mesh = new Mesh(0' vertexBuffer.VertexCount' 0' indexBuffer.IndexCount / 3' vertexBuffer' indexBuffer' PrimitiveType.TriangleList) " is 135.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The length of the statement  "                p.Velocity.X = this.settings.LocalVelocity.X + (this.settings.RandomVelocity.X * (((float)this.random.NextDouble() * 2) - 1)); " is 126.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The length of the statement  "                p.Velocity.Y = this.settings.LocalVelocity.Y + (this.settings.RandomVelocity.Y * (((float)this.random.NextDouble() * 2) - 1)); " is 126.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The length of the statement  "                            float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2); " is 145.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The length of the statement  "                            float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2); " is 145.
Long Statement,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The length of the statement  "                p.VelocityRotation = MathHelper.Lerp(this.settings.MinRotateSpeed' this.settings.MaxRotateSpeed' (float)this.random.NextDouble()); " is 130.
Long Statement,WaveEngine.Components.Graphics2D,SpriteRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\SpriteRenderer.cs,RefreshSliceCache,The length of the statement  "            var horizontalScalableAnchors = hasHorizontalAnchors ? texture2D.HorizontalScalableAnchors : new Point[] { new Point(0' texture2D.Width) }; " is 139.
Long Statement,WaveEngine.Components.Graphics2D,SpriteRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\SpriteRenderer.cs,RefreshSliceCache,The length of the statement  "            var verticalScalableAnchors = hasVerticalAnchors ? texture2D.VerticalScalableAnchors : new Point[] { new Point(0' texture2D.Height) }; " is 134.
Long Statement,WaveEngine.Components.Graphics2D,SpriteRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\SpriteRenderer.cs,RefreshSliceCache,The length of the statement  "            flippedOrigin.X = this.Transform2D.Effect.HasFlag(SpriteEffects.FlipHorizontally) ? 1 - flippedOrigin.X : flippedOrigin.X; " is 122.
Long Statement,WaveEngine.Components.Graphics2D,SpriteRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\SpriteRenderer.cs,RefreshSliceCache,The length of the statement  "            flippedOrigin.Y = this.Transform2D.Effect.HasFlag(SpriteEffects.FlipVertically) ? 1 - flippedOrigin.Y : flippedOrigin.Y; " is 120.
Long Statement,WaveEngine.Components.Graphics2D,SpriteRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\SpriteRenderer.cs,RefreshSliceCache,The length of the statement  "                    var scolor = vStretchActive ? (hStretchActive ? Color.Pink : Color.LightGreen) : (hStretchActive ? Color.LightGreen : Color.White); " is 131.
Long Statement,WaveEngine.Components.Graphics3D,CapsuleMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\CapsuleMesh.cs,GenerateCapsule,The length of the statement  "            this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Capsule(this.Height' this.Radius' this.Tessellation * 2)); " is 124.
Long Statement,WaveEngine.Components.Graphics3D,CubeMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\CubeMesh.cs,GenerateCube,The length of the statement  "            this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cube(this.Size' this.UVHorizontalFlip' this.UVVerticalFlip)); " is 127.
Long Statement,WaveEngine.Components.Graphics3D,CylinderMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\CylinderMesh.cs,GenerateCylinder,The length of the statement  "            this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cylinder(this.Height' this.Diameter' this.Tessellation)); " is 123.
Long Statement,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The length of the statement  "                var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID); " is 142.
Long Statement,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,GenerateCollisionInfo,The length of the statement  "                mesh.VertexBuffer.GetVertexProperties(ref vertexPositions' VertexElementUsage.Position' 0' mesh.NumVertices' mesh.VertexOffset); " is 128.
Long Statement,WaveEngine.Components.Graphics3D,MeshRenderer,C:\repos\WaveEngine_Components\Shared\Graphics3D\MeshRenderer.cs,Draw,The length of the statement  "                        this.ModelMesh.InternalModel.Materials != null && this.ModelMesh.InternalModel.Materials.Count > currentMesh.MaterialIndex) " is 123.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                            if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y)) " is 135.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1))); " is 126.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                            else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y)) " is 140.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1))); " is 126.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                            if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X)) " is 135.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1))); " is 126.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                            else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X)) " is 140.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1))); " is 126.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                            if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z)) " is 135.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1))); " is 126.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                            else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z)) " is 140.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1))); " is 125.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                                            p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1))); " is 126.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The length of the statement  "                        if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1) " is 148.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The length of the statement  "                double life = (this.settings.EmitRate > 0) ? -1 : TimeSpan.FromSeconds(this.random.NextDouble() * (this.numParticles * InitTimeMultipler)).TotalSeconds; " is 152.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The length of the statement  "            this.mesh = new Mesh(0' vertexBuffer.VertexCount' 0' indexBuffer.IndexCount / 3' vertexBuffer' indexBuffer' PrimitiveType.TriangleList) " is 135.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The length of the statement  "                            float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2); " is 145.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The length of the statement  "                            float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2); " is 145.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The length of the statement  "                p.VelocityRotation = MathHelper.Lerp(this.settings.MinRotateSpeed' this.settings.MaxRotateSpeed' (float)this.random.NextDouble()); " is 130.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The length of the statement  "            if (this.settings.LinearColorEnabled && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count >= 1) " is 130.
Long Statement,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The length of the statement  "            Matrix.CreateFromYawPitchRoll(this.Transform.Rotation.Y' this.Transform.Rotation.X' this.Transform.Rotation.Z' out this.rotationMatrix); " is 136.
Long Statement,WaveEngine.Components.Graphics3D,PlaneMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\PlaneMesh.cs,GeneratePlane,The length of the statement  "            this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Primitives.Plane(this.Normal' this.Width' this.Height' this.TwoSides' this.UVHorizontalFlip' this.UVVerticalFlip)); " is 181.
Long Statement,WaveEngine.Components.Graphics3D,SkinnedModelRenderer,C:\repos\WaveEngine_Components\Shared\Graphics3D\SkinnedModelRenderer.cs,Draw,The length of the statement  "            bool needsUpdate = (!LowPerformance && this.lastKeyFrame != this.Animation.Frame && this.updateLod) && this.lastAnimTime != this.Animation.TotalAnimTime; " is 153.
Long Statement,WaveEngine.Components.Graphics3D,SkinnedModelRenderer,C:\repos\WaveEngine_Components\Shared\Graphics3D\SkinnedModelRenderer.cs,UpdateTransforms,The length of the statement  "            this.Animation.InternalAnimation.Animations[this.Animation.CurrentAnimation].Frames[this.Animation.Frame].CopyTo(this.boneTransforms' 0); " is 137.
Long Statement,WaveEngine.Components.Graphics3D,SkinnedModelRenderer,C:\repos\WaveEngine_Components\Shared\Graphics3D\SkinnedModelRenderer.cs,UpdateTransforms,The length of the statement  "                ////this.Model.BoundingBox.Min = Vector3.Transform(this.Animation.InternalAnimation.Animations[this.Animation.CurrentAnimation].BoundingBox.Min' this.skinTransforms[bbIndex]); " is 175.
Long Statement,WaveEngine.Components.Graphics3D,SkinnedModelRenderer,C:\repos\WaveEngine_Components\Shared\Graphics3D\SkinnedModelRenderer.cs,UpdateTransforms,The length of the statement  "                ////this.Model.BoundingBox.Max = Vector3.Transform(this.Animation.InternalAnimation.Animations[this.Animation.CurrentAnimation].BoundingBox.Max' this.skinTransforms[bbIndex]); " is 175.
Long Statement,WaveEngine.Components.Graphics3D,SphereMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\SphereMesh.cs,GenerateSphere,The length of the statement  "            this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Sphere(this.Diameter' this.Tessellation' this.UVHorizontalFlip' this.UVVerticalFlip)); " is 152.
Long Statement,WaveEngine.Components.Graphics3D,TorusMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\TorusMesh.cs,GenerateTorus,The length of the statement  "            this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Torus(this.Diameter' this.Thickness' this.Tessellation)); " is 123.
Long Statement,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,AddVertex,The length of the statement  "            this.vertices.Add(new VertexPositionNormalTangentColorDualTexture(position' normal' Vector3.Zero' Vector3.Zero' Color.Black' Vector2.Zero' Vector2.Zero)); " is 154.
Long Statement,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,AddVertex,The length of the statement  "            this.vertices.Add(new VertexPositionNormalTangentColorDualTexture(position' normal' Vector3.Zero' Vector3.Zero' Color.Black' texcoord' texcoord)); " is 146.
Long Statement,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,AddVertex,The length of the statement  "            this.vertices.Add(new VertexPositionNormalTangentColorDualTexture(position' normal' tangent' binormal' Color.Black' texcoord' texcoord)); " is 137.
Long Statement,WaveEngine.Components.Toolkit,TextRenderer2D,C:\repos\WaveEngine_Components\Shared\Toolkit\TextRenderer2D.cs,Initialize,The length of the statement  "            this.material = new StandardMaterial() { DiffuseColor = Color.White' LightingEnabled = false' LayerType = this.LayerType' SamplerMode = AddressMode.LinearClamp }; " is 162.
Long Statement,WaveEngine.Components.Toolkit,TextRenderer3D,C:\repos\WaveEngine_Components\Shared\Toolkit\TextRenderer3D.cs,Initialize,The length of the statement  "            this.material = new StandardMaterial() { DiffuseColor = Color.White' LightingEnabled = false' LayerType = this.LayerType' SamplerMode = AddressMode.LinearClamp }; " is 162.
Long Statement,WaveEngine.Components.Transitions,ChequeredAppearTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ChequeredAppearTransition.cs,Draw,The length of the statement  "            this.sourceRenderTarget = this.graphicsDevice.RenderTargets.GetTemporalRenderTarget(this.platform.ScreenWidth' this.platform.ScreenHeight); " is 139.
Long Statement,WaveEngine.Components.Transitions,ChequeredAppearTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ChequeredAppearTransition.cs,Draw,The length of the statement  "            this.targetRenderTarget = this.graphicsDevice.RenderTargets.GetTemporalRenderTarget(this.platform.ScreenWidth' this.platform.ScreenHeight); " is 139.
Long Statement,WaveEngine.Components.Transitions,ChequeredAppearTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ChequeredAppearTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.targetRenderTarget' Vector2.Zero' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0.5f); " is 137.
Long Statement,WaveEngine.Components.Transitions,ColorFadeTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ColorFadeTransition.cs,Draw,The length of the statement  "            this.sourceRenderTarget = this.graphicsDevice.RenderTargets.GetTemporalRenderTarget(this.platform.ScreenWidth' this.platform.ScreenHeight); " is 139.
Long Statement,WaveEngine.Components.Transitions,ColorFadeTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ColorFadeTransition.cs,Draw,The length of the statement  "            this.targetRenderTarget = this.graphicsDevice.RenderTargets.GetTemporalRenderTarget(this.platform.ScreenWidth' this.platform.ScreenHeight); " is 139.
Long Statement,WaveEngine.Components.Transitions,ColorFadeTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ColorFadeTransition.cs,Draw,The length of the statement  "                this.spriteBatch.Draw(this.sourceRenderTarget' new Rectangle(0' 0' this.sourceRenderTarget.Width' this.sourceRenderTarget.Height)' null' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f); " is 193.
Long Statement,WaveEngine.Components.Transitions,ColorFadeTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ColorFadeTransition.cs,Draw,The length of the statement  "                this.spriteBatch.Draw(this.targetRenderTarget' new Rectangle(0' 0' this.sourceRenderTarget.Width' this.sourceRenderTarget.Height)' null' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f); " is 193.
Long Statement,WaveEngine.Components.Transitions,ColorFadeTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ColorFadeTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(StaticResources.WhitePixel' new Rectangle(0' 0' this.platform.ScreenWidth' this.platform.ScreenHeight)' null' blendColor' 0' Vector2.Zero' SpriteEffects.None' 0); " is 184.
Long Statement,WaveEngine.Components.Transitions,CombTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CombTransition.cs,Draw,The length of the statement  "                        this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f); " is 122.
Long Statement,WaveEngine.Components.Transitions,CombTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CombTransition.cs,Draw,The length of the statement  "                        this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f); " is 122.
Long Statement,WaveEngine.Components.Transitions,CombTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CombTransition.cs,Draw,The length of the statement  "                        this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f); " is 122.
Long Statement,WaveEngine.Components.Transitions,CombTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CombTransition.cs,Draw,The length of the statement  "                        this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f); " is 122.
Long Statement,WaveEngine.Components.Transitions,CoverTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CoverTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.sourceRenderTarget' Vector2.Zero' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0.5f); " is 137.
Long Statement,WaveEngine.Components.Transitions,CoverTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CoverTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.targetRenderTarget' this.position' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0f); " is 136.
Long Statement,WaveEngine.Components.Transitions,CrossFadeTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CrossFadeTransition.cs,Draw,The length of the statement  "            RenderTarget sourceRenderTarget = this.graphicsDevice.RenderTargets.GetTemporalRenderTarget(this.platform.ScreenWidth' this.platform.ScreenHeight); " is 147.
Long Statement,WaveEngine.Components.Transitions,CrossFadeTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CrossFadeTransition.cs,Draw,The length of the statement  "            RenderTarget targetRenderTarget = this.graphicsDevice.RenderTargets.GetTemporalRenderTarget(this.platform.ScreenWidth' this.platform.ScreenHeight); " is 147.
Long Statement,WaveEngine.Components.Transitions,CrossFadeTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CrossFadeTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(sourceRenderTarget' new Rectangle(0' 0' sourceRenderTarget.Width' sourceRenderTarget.Height)' null' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f); " is 178.
Long Statement,WaveEngine.Components.Transitions,CrossFadeTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CrossFadeTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(targetRenderTarget' new Rectangle(0' 0' sourceRenderTarget.Width' sourceRenderTarget.Height)' null' blendColor' 0' Vector2.Zero' SpriteEffects.None' 0); " is 174.
Long Statement,WaveEngine.Components.Transitions,CurtainsTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CurtainsTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.targetRenderTarget' Vector2.Zero' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0.5f); " is 137.
Long Statement,WaveEngine.Components.Transitions,FallingLinesTransition,C:\repos\WaveEngine_Components\Shared\Transitions\FallingLinesTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.targetRenderTarget' Vector2.Zero' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0.5f); " is 137.
Long Statement,WaveEngine.Components.Transitions,FallingLinesTransition,C:\repos\WaveEngine_Components\Shared\Transitions\FallingLinesTransition.cs,Draw,The length of the statement  "                this.spriteBatch.Draw(this.sourceRenderTarget' pos' rect' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0f); " is 126.
Long Statement,WaveEngine.Components.Transitions,PushTransition,C:\repos\WaveEngine_Components\Shared\Transitions\PushTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.sourceRenderTarget' this.position2' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0.5f); " is 139.
Long Statement,WaveEngine.Components.Transitions,PushTransition,C:\repos\WaveEngine_Components\Shared\Transitions\PushTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.targetRenderTarget' this.position1' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0f); " is 137.
Long Statement,WaveEngine.Components.Transitions,ScaleTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ScaleTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.sourceRenderTarget' Vector2.Zero' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0.5f); " is 137.
Long Statement,WaveEngine.Components.Transitions,ShrinkAndSpinTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ShrinkAndSpinTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.targetRenderTarget' Vector2.Zero' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0.5f); " is 137.
Long Statement,WaveEngine.Components.Transitions,ShrinkAndSpinTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ShrinkAndSpinTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.sourceRenderTarget' center + translate' null' tint' rotation' center' scale' SpriteEffects.None' 0); " is 127.
Long Statement,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.targetRenderTarget' Vector2.Zero' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0.5f); " is 137.
Long Statement,WaveEngine.Components.Transitions,UncoverTransition,C:\repos\WaveEngine_Components\Shared\Transitions\UncoverTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.targetRenderTarget' Vector2.Zero' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0.5f); " is 137.
Long Statement,WaveEngine.Components.Transitions,UncoverTransition,C:\repos\WaveEngine_Components\Shared\Transitions\UncoverTransition.cs,Draw,The length of the statement  "            this.spriteBatch.Draw(this.sourceRenderTarget' this.position' null' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0f); " is 136.
Long Statement,WaveEngine.Components.UI,GridRenderer,C:\repos\WaveEngine_Components\Shared\UI\Grid\GridRenderer.cs,DrawDebugLines,The length of the statement  "            this.RenderManager.LineBatch2D.DrawPoint(this.Transform2D.Rectangle.Location + this.Transform2D.Origin' 10f' Color.Red' this.Transform2D.DrawOrder); " is 148.
Long Statement,WaveEngine.Components.UI,ImageAtlasRenderer,C:\repos\WaveEngine_Components\Shared\UI\ImageAtlasRenderer.cs,DrawDebugLines,The length of the statement  "            this.RenderManager.LineBatch2D.DrawPoint(this.Transform2D.Rectangle.Location + this.Transform2D.Origin' 10f' Color.Red' this.Transform2D.DrawOrder); " is 148.
Long Statement,WaveEngine.Components.UI,ImageControlRenderer,C:\repos\WaveEngine_Components\Shared\UI\Image\ImageControlRenderer.cs,DrawDebugLines,The length of the statement  "            this.RenderManager.LineBatch2D.DrawPoint(this.Transform2D.Rectangle.Location + this.Transform2D.Origin' 10f' Color.Red' this.Transform2D.DrawOrder); " is 148.
Long Statement,WaveEngine.Components.UI,PanelControlRenderer,C:\repos\WaveEngine_Components\Shared\UI\Panel\PanelControlRenderer.cs,DrawDebugLines,The length of the statement  "            this.RenderManager.LineBatch2D.DrawPoint(this.Transform2D.Rectangle.Location + this.Transform2D.Origin' 10f' Color.Red' this.Transform2D.DrawOrder); " is 148.
Long Statement,WaveEngine.Components.UI,ProgressBarBehavior,C:\repos\WaveEngine_Components\Shared\UI\ProgressBar\ProgressBarBehavior.cs,UpdateDifference,The length of the statement  "                throw new ArgumentException(string.Format("Minimum: {0} can not be greather than Maximum: {1}"' this.minimum' this.maximum)); " is 125.
Long Statement,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,UpdateOrientation,The length of the statement  "                        this.textControl.Margin = new Thickness(-DefaultTextOffset' this.Panel.Height - (this.bulletImage.Height * 1.5f)' 0' 0); " is 120.
Long Statement,WaveEngine.Components.UI,StackPanelRenderer,C:\repos\WaveEngine_Components\Shared\UI\Stack\StackPanelRenderer.cs,DrawDebugLines,The length of the statement  "            this.RenderManager.LineBatch2D.DrawPoint(this.Transform2D.Rectangle.Location + this.Transform2D.Origin' 10f' Color.Red' this.Transform2D.DrawOrder); " is 148.
Long Statement,WaveEngine.Components.UI,TextControlRenderer,C:\repos\WaveEngine_Components\Shared\UI\TextBlock\TextControlRenderer.cs,DrawDebugLines,The length of the statement  "            this.RenderManager.LineBatch2D.DrawPoint(this.Transform2D.Rectangle.Location + this.Transform2D.Origin' 10f' Color.Red' this.Transform2D.DrawOrder); " is 148.
Long Statement,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The length of the statement  "                    ((this.inputService.KeyboardState.Enter == ButtonState.Pressed && this.beforeKeyboardState.Enter != ButtonState.Pressed) || " is 123.
Long Statement,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The length of the statement  "                    (this.inputService.KeyboardState.Execute == ButtonState.Pressed && this.beforeKeyboardState.Execute != ButtonState.Pressed))) " is 125.
Long Statement,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The length of the statement  "                if (this.inputService.KeyboardState.Delete == ButtonState.Pressed && this.beforeKeyboardState.Delete != ButtonState.Pressed) " is 124.
Long Statement,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The length of the statement  "                if ((this.inputService.KeyboardState.LeftShift == ButtonState.Pressed && this.beforeKeyboardState.LeftShift != ButtonState.Pressed) || " is 134.
Long Statement,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The length of the statement  "                     (this.inputService.KeyboardState.RightShift == ButtonState.Pressed && this.beforeKeyboardState.RightShift != ButtonState.Pressed) || " is 132.
Long Statement,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The length of the statement  "                     (this.inputService.KeyboardState.CapitalLock == ButtonState.Pressed && this.beforeKeyboardState.CapitalLock != ButtonState.Pressed && !this.uppercase)) " is 151.
Long Statement,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The length of the statement  "                else if ((this.inputService.KeyboardState.LeftShift == ButtonState.Released && this.beforeKeyboardState.LeftShift != ButtonState.Released) || " is 141.
Long Statement,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The length of the statement  "                     (this.inputService.KeyboardState.RightShift == ButtonState.Released && this.beforeKeyboardState.RightShift != ButtonState.Released) || " is 134.
Long Statement,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The length of the statement  "                     (this.inputService.KeyboardState.CapitalLock == ButtonState.Pressed && this.beforeKeyboardState.CapitalLock != ButtonState.Pressed && this.uppercase)) " is 150.
Long Statement,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The length of the statement  "                if (this.inputService.KeyboardState.RightAlt == ButtonState.Pressed && this.beforeKeyboardState.RightAlt != ButtonState.Pressed) " is 128.
Long Statement,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,ShowScreenKeyboard,The length of the statement  "            var newText = await WaveServices.Platform.ShowTextDialogBoxAsync(this.MessageBoxTitle' this.MessageBoxDescription' this.textControl.Text); " is 138.
Long Statement,WaveEngine.Components.UI,WrapPanelRenderer,C:\repos\WaveEngine_Components\Shared\UI\Wrap\WrapPanelRenderer.cs,DrawDebugLines,The length of the statement  "            this.RenderManager.LineBatch2D.DrawPoint(this.Transform2D.Rectangle.Location + this.Transform2D.Origin' 10f' Color.Red' this.Transform2D.DrawOrder); " is 148.
Long Statement,WaveEngine.Components.VR,VRCameraRig,C:\repos\WaveEngine_Components\Shared\VR\VRCameraRig.cs,RefreshCameraProperties,The length of the statement  "            this.AttachedCamera.BackgroundColor = this.LeftEyeCamera.BackgroundColor = this.RightEyeCamera.BackgroundColor = this.backgroundColor; " is 134.
Long Statement,WaveEngine.Components.VR,VRCameraRig,C:\repos\WaveEngine_Components\Shared\VR\VRCameraRig.cs,UpdateCamera,The length of the statement  "            camera.Transform.LocalOrientation = this.Monoscopic ? this.CenterEyeAnchorTransform.LocalOrientation : eyePose.Orientation; " is 123.
Complex Conditional,WaveEngine.Components.Gestures,TouchGestures,C:\repos\WaveEngine_Components\Shared\Gestures\TouchGestures.cs,FreeState,The conditional expression  "scale != 1 && !float.IsNaN(scale) && !float.IsInfinity(scale) && scale > 0.01f"  is complex.
Complex Conditional,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The conditional expression  "this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1"  is complex.
Complex Conditional,WaveEngine.Components.Graphics3D,FileMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\FileMesh.cs,LoadModel,The conditional expression  "this.ModelMeshName == null &&                      this.InternalModel != null &&                      this.InternalModel.Meshes != null &&                      this.InternalModel.Meshes.Count > 0"  is complex.
Complex Conditional,WaveEngine.Components.Graphics3D,MeshRenderer,C:\repos\WaveEngine_Components\Shared\Graphics3D\MeshRenderer.cs,Draw,The conditional expression  "this.Materials != null && this.Materials.Length > 0 &&                          this.ModelMesh.InternalModel.Materials != null && this.ModelMesh.InternalModel.Materials.Count > currentMesh.MaterialIndex"  is complex.
Complex Conditional,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The conditional expression  "this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1"  is complex.
Complex Conditional,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,UpdateOrientation,The conditional expression  "this.backgroundImage != null && this.foregroundImage != null && this.foregroundTransform != null                          && this.bulletImage != null && this.bulletTransform != null && this.textControl != null &&                          this.textTransform != null && this.Panel != null"  is complex.
Complex Conditional,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,UpdateOrientation,The conditional expression  "this.backgroundImage != null && this.foregroundImage != null && this.foregroundTransform != null                          && this.bulletImage != null && this.bulletTransform != null && this.textControl != null &&                          this.textTransform != null && this.Panel != null"  is complex.
Complex Conditional,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The conditional expression  "this.acceptsReturn &&                      ((this.inputService.KeyboardState.Enter == ButtonState.Pressed && this.beforeKeyboardState.Enter != ButtonState.Pressed) ||                      (this.inputService.KeyboardState.Execute == ButtonState.Pressed && this.beforeKeyboardState.Execute != ButtonState.Pressed))"  is complex.
Complex Conditional,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The conditional expression  "(this.inputService.KeyboardState.LeftShift == ButtonState.Pressed && this.beforeKeyboardState.LeftShift != ButtonState.Pressed) ||                       (this.inputService.KeyboardState.RightShift == ButtonState.Pressed && this.beforeKeyboardState.RightShift != ButtonState.Pressed) ||                       (this.inputService.KeyboardState.CapitalLock == ButtonState.Pressed && this.beforeKeyboardState.CapitalLock != ButtonState.Pressed && !this.uppercase)"  is complex.
Complex Conditional,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Update,The conditional expression  "(this.inputService.KeyboardState.LeftShift == ButtonState.Released && this.beforeKeyboardState.LeftShift != ButtonState.Released) ||                       (this.inputService.KeyboardState.RightShift == ButtonState.Released && this.beforeKeyboardState.RightShift != ButtonState.Released) ||                       (this.inputService.KeyboardState.CapitalLock == ButtonState.Pressed && this.beforeKeyboardState.CapitalLock != ButtonState.Pressed && this.uppercase)"  is complex.
Magic Number,WaveEngine.Components.Animation,Animation2D,C:\repos\WaveEngine_Components\Shared\Animation\Animation2D.cs,PlayAnimation,The following statement contains a magic number: if (this.currentSpriteSheetAnimation != null)              {                  this.keyFrameEvents.TryGetValue(name' out this.currentKeyFrameEvents);                    // Check start frame                  if (startFrame.HasValue)                  {                      if (startFrame.Value < 0)                      {                          this.startFrame = 0;                      }                      else if (startFrame.Value >= this.currentSpriteSheetAnimation.Length - 1)                      {                          this.startFrame = this.currentSpriteSheetAnimation.Length - 2;                      }                      else                      {                          this.startFrame = startFrame.Value;                      }                  }                  else                  {                      this.startFrame = 0;                  }                    // Check end frame                  if (endFrame.HasValue)                  {                      if (endFrame.Value < this.startFrame)                      {                          this.endFrame = this.startFrame + 1;                      }                      else if (endFrame.Value >= this.currentSpriteSheetAnimation.Length)                      {                          this.endFrame = this.currentSpriteSheetAnimation.Length - 1;                      }                      else                      {                          this.endFrame = endFrame.Value;                      }                  }                  else                  {                      this.endFrame = this.currentSpriteSheetAnimation.Length - 1;                  }                    if (framesPerSecond.HasValue)                  {                      this.framesPerSecond = framesPerSecond.Value;                  }                  else                  {                      this.framesPerSecond = this.currentSpriteSheetAnimation.FramesPerSecond;                  }                    if (this.startFrame < 0)                  {                      this.startFrame = 0;                  }                    if (this.endFrame < 0)                  {                      this.endFrame = 0;                  }                    this.frameLength = this.endFrame - this.startFrame + 1;                    this.SetFrame(0);                  this.Loop = loop;                  this.State = AnimationState.Playing;                  this.Backwards = backwards;                    this.currentAnimationTime = 0;                  this.currentAnimationEndTime = this.frameLength / (double)this.framesPerSecond;              }
Magic Number,WaveEngine.Components.Animation,Animation3D,C:\repos\WaveEngine_Components\Shared\Animation\Animation3D.cs,DefaultValues,The following statement contains a magic number: this.FramesPerSecond = 30;
Magic Number,WaveEngine.Components.Cameras,FixedCamera2D,C:\repos\WaveEngine_Components\Shared\Cameras\FixedCamera2D.cs,FixedCamera2D,The following statement contains a magic number: Vector3 position3D = position.ToVector3(-10);
Magic Number,WaveEngine.Components.Cameras,FreeCamera2DBehavior,C:\repos\WaveEngine_Components\Shared\Cameras\FreeCamera2DBehavior.cs,HandleTouch,The following statement contains a magic number: if (touchState.Count >= 2)              {                  Vector2 touch1 = touchState[0].Position;                  Vector2 touch2 = touchState[1].Position;                  Vector2 dragPosition;                  Vector2.Lerp(ref touch1' ref touch2' 0.5f' out dragPosition);                    if (this.isDragging)                  {                      float deltaX = dragPosition.X - this.lastDragPosition.X;                      float deltaY = dragPosition.Y - this.lastDragPosition.Y;                        Vector2 zoom = this.transform2D.Scale;                        // Up                      this.positionDelta.X = this.positionDelta.X - (deltaY * zoom.X * this.up.X);                      this.positionDelta.Y = this.positionDelta.Y - (deltaY * zoom.Y * this.up.Y);                        // Right                      this.positionDelta.X = this.positionDelta.X - (deltaX * zoom.X * this.right.X);                      this.positionDelta.Y = this.positionDelta.Y - (deltaX * zoom.Y * this.right.Y);                  }                    this.lastDragPosition = dragPosition;                  this.isDragging = true;              }              else              {                  this.isDragging = false;              }
Magic Number,WaveEngine.Components.Cameras,FreeCamera3DBehavior,C:\repos\WaveEngine_Components\Shared\Cameras\FreeCamera3DBehavior.cs,DefaultValues,The following statement contains a magic number: this.speed = 20;
Magic Number,WaveEngine.Components.Cameras,FreeCamera3DBehavior,C:\repos\WaveEngine_Components\Shared\Cameras\FreeCamera3DBehavior.cs,HandleInput,The following statement contains a magic number: if (this.input.KeyboardState.IsConnected || this.isTouchPanelConnected)              {                  this.keyboardState = this.input.KeyboardState;                    // If the touch panel is connected and it has two points' we can go forward                  if (this.isTouchPanelConnected)                  {                      if (this.input.TouchPanelState.Count == 2)                      {                          this.moveWithTouchPanel = true;                      }                  }                    this.moveForward = this.keyboardState.W == ButtonState.Pressed || this.moveWithTouchPanel;                  this.moveBack = this.keyboardState.S == ButtonState.Pressed;                  this.moveLeft = this.keyboardState.A == ButtonState.Pressed;                  this.moveRight = this.keyboardState.D == ButtonState.Pressed;                  this.UpdateCameraPosition(amount);                    this.moveWithTouchPanel = false;              }
Magic Number,WaveEngine.Components.Cameras,ViewCamera3DBehavior,C:\repos\WaveEngine_Components\Shared\Cameras\ViewCamera3DBehavior.cs,Update,The following statement contains a magic number: if (this.touchState.Count > 0)              {                  var currentState = this.touchState[0].State;                    if (currentState == TouchLocationState.Pressed)                  {                      this.prevPosition = this.touchState[0].Position;                  }                  else if (currentState == TouchLocationState.Moved)                  {                      this.currentPosition = this.touchState[0].Position;                      this.delta = (this.currentPosition - this.prevPosition) * ((float)Math.PI / 180);                      this.prevPosition = this.currentPosition;                      this.phi -= this.delta.X * this.RotationSpeed;                      this.theta += this.delta.Y * this.RotationSpeed;                        if (this.theta <= -MathHelper.TwoPi)                      {                          this.theta += MathHelper.TwoPi;                      }                        if (this.theta > MathHelper.TwoPi)                      {                          this.theta -= MathHelper.TwoPi;                      }                        if (this.phi <= -MathHelper.TwoPi)                      {                          this.phi += MathHelper.TwoPi;                      }                        if (this.phi > MathHelper.TwoPi)                      {                          this.phi -= MathHelper.TwoPi;                      }                        this.UpdateCameraPosition();                  }              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (t * t * ((((s *= 1.525f) + 1) * t) - s))) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (t * t * ((((s *= 1.525f) + 1) * t) - s))) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * ((((s *= 1.525f) + 1) * t) + s)) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * ((((s *= 1.525f) + 1) * t) + s)) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * ((((s *= 1.525f) + 1) * t) + s)) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' 0' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' 0' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' 0' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' 0' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' 0' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' 0' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (-c / 2 * ((float)Math.Sqrt(1 - (t * t)) - 1)) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (-c / 2 * ((float)Math.Sqrt(1 - (t * t)) - 1)) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: return (c / 2 * ((float)Math.Sqrt(1 - ((t -= 2) * t)) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: return (c / 2 * ((float)Math.Sqrt(1 - ((t -= 2) * t)) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if ((t /= d / 2) == 2)              {                  return b + c;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if ((t /= d / 2) == 2)              {                  return b + c;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialInEase,The following statement contains a magic number: return (t == 0) ? b : (c * (float)Math.Pow(2' 10 * ((t / d) - 1))) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialInEase,The following statement contains a magic number: return (t == 0) ? b : (c * (float)Math.Pow(2' 10 * ((t / d) - 1))) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialOutEase,The following statement contains a magic number: return (t == d) ? b + c : (c * (-(float)Math.Pow(2' -10 * t / d) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialOutEase,The following statement contains a magic number: return (t == d) ? b + c : (c * (-(float)Math.Pow(2' -10 * t / d) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuadraticOutEase,The following statement contains a magic number: return (-c * (t /= d) * (t - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: return (-c / 2 * (((--t) * (t - 2)) - 1)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: return (-c / 2 * (((--t) * (t - 2)) - 1)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: return (-c / 2 * (((t -= 2) * t * t * t) - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: return (-c / 2 * (((t -= 2) * t * t * t) - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: return (-c / 2 * (((t -= 2) * t * t * t) - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,SineInEase,The following statement contains a magic number: return (-c * (float)Math.Cos(t / d * (Math.PI / 2))) + c + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,SineOutEase,The following statement contains a magic number: return (c * (float)Math.Sin(t / d * (Math.PI / 2))) + b;
Magic Number,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,SineInOutEase,The following statement contains a magic number: return (-c / 2 * ((float)Math.Cos(Math.PI * t / d) - 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (t * t * ((((s *= 1.525f) + 1) * t) - s))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (t * t * ((((s *= 1.525f) + 1) * t) - s))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * ((((s *= 1.525f) + 1) * t) + s)) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * ((((s *= 1.525f) + 1) * t) + s)) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * ((((s *= 1.525f) + 1) * t) + s)) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' Vector2.Zero' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' Vector2.Zero' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' Vector2.Zero' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' Vector2.Zero' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' Vector2.Zero' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' Vector2.Zero' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (-c / 2 * ((float)Math.Sqrt(1 - (t * t)) - 1)) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (-c / 2 * ((float)Math.Sqrt(1 - (t * t)) - 1)) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: return (c / 2 * ((float)Math.Sqrt(1 - ((t -= 2) * t)) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: return (c / 2 * ((float)Math.Sqrt(1 - ((t -= 2) * t)) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if ((t /= d / 2) == 2)              {                  return b + c;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if ((t /= d / 2) == 2)              {                  return b + c;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialInEase,The following statement contains a magic number: return (t == 0) ? b : (c * (float)Math.Pow(2' 10 * ((t / d) - 1))) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialInEase,The following statement contains a magic number: return (t == 0) ? b : (c * (float)Math.Pow(2' 10 * ((t / d) - 1))) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialOutEase,The following statement contains a magic number: return (t == d) ? b + c : (c * (-(float)Math.Pow(2' -10 * t / d) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialOutEase,The following statement contains a magic number: return (t == d) ? b + c : (c * (-(float)Math.Pow(2' -10 * t / d) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuadraticOutEase,The following statement contains a magic number: return (-c * (t /= d) * (t - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: return (-c / 2 * (((--t) * (t - 2)) - 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: return (-c / 2 * (((--t) * (t - 2)) - 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: return (-c / 2 * (((t -= 2) * t * t * t) - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: return (-c / 2 * (((t -= 2) * t * t * t) - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: return (-c / 2 * (((t -= 2) * t * t * t) - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,SineInEase,The following statement contains a magic number: return (-c * (float)Math.Cos(t / d * (Math.PI / 2))) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,SineOutEase,The following statement contains a magic number: return (c * (float)Math.Sin(t / d * (Math.PI / 2))) + b;
Magic Number,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,SineInOutEase,The following statement contains a magic number: return (-c / 2 * ((float)Math.Cos(Math.PI * t / d) - 1)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c * 0.5f * (t * t * ((((s *= 1.525f) + 1) * t) - s))) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: return (c * 0.5f * (((t -= 2) * t * ((((s *= 1.525f) + 1) * t) + s)) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: return (c * 0.5f * (((t -= 2) * t * ((((s *= 1.525f) + 1) * t) + s)) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' Quaternion.Identity' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' Quaternion.Identity' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' Quaternion.Identity' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' Quaternion.Identity' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' Quaternion.Identity' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' Quaternion.Identity' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (-c * 0.5f * ((float)Math.Sqrt(1 - (t * t)) - 1)) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: return (c * 0.5f * ((float)Math.Sqrt(1 - ((t -= 2) * t)) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c * 0.5f * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: return (c * 0.5f * (((t -= 2) * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: return (c * 0.5f * (((t -= 2) * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if ((t /= d / 2) == 2)              {                  return b + c;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if ((t /= d / 2) == 2)              {                  return b + c;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return ((a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) * -0.5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return ((a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) * -0.5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return ((a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) * -0.5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ExponentialInEase,The following statement contains a magic number: return (t == 0) ? b : (c * (float)Math.Pow(2' 10 * ((t / d) - 1))) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ExponentialInEase,The following statement contains a magic number: return (t == 0) ? b : (c * (float)Math.Pow(2' 10 * ((t / d) - 1))) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ExponentialOutEase,The following statement contains a magic number: return (t == d) ? b + c : (c * (-(float)Math.Pow(2' -10 * t / d) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ExponentialOutEase,The following statement contains a magic number: return (t == d) ? b + c : (c * (-(float)Math.Pow(2' -10 * t / d) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c * 0.5f * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c * 0.5f * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c * 0.5f * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c * 0.5f * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c * 0.5f * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c * 0.5f * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,QuadraticOutEase,The following statement contains a magic number: return (-c * (t /= d) * (t - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c * 0.5f * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: return (-c * 0.5f * (((--t) * (t - 2)) - 1)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c * 0.5f * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: return (-c * 0.5f * (((t -= 2) * t * t * t) - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: return (-c * 0.5f * (((t -= 2) * t * t * t) - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c * 0.5f * t * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: return (c * 0.5f * (((t -= 2) * t * t * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: return (c * 0.5f * (((t -= 2) * t * t * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,SineInEase,The following statement contains a magic number: return (-c * (float)Math.Cos(t / d * (Math.PI / 2))) + c + b;
Magic Number,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,SineOutEase,The following statement contains a magic number: return (c * (float)Math.Sin(t / d * (Math.PI / 2))) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (t * t * ((((s *= 1.525f) + 1) * t) - s))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (t * t * ((((s *= 1.525f) + 1) * t) - s))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * ((((s *= 1.525f) + 1) * t) + s)) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * ((((s *= 1.525f) + 1) * t) + s)) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,BackInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * ((((s *= 1.525f) + 1) * t) + s)) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,BounceOutEase,The following statement contains a magic number: if ((t /= d) < (1 / 2.75f))              {                  return (c * (7.5625f * t * t)) + b;              }              else if (t < (2 / 2.75f))              {                  return (c * ((7.5625f * (t -= 1.5f / 2.75f) * t) + .75f)) + b;              }              else if (t < (2.5 / 2.75))              {                  return (c * ((7.5625f * (t -= 2.25f / 2.75f) * t) + .9375f)) + b;              }              else              {                  return (c * ((7.5625f * (t -= 2.625f / 2.75f) * t) + .984375f)) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' Vector3.Zero' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' Vector3.Zero' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' Vector3.Zero' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' Vector3.Zero' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,BounceInOutEase,The following statement contains a magic number: if (t < d / 2)              {                  return (this.BounceInEase(t * 2' Vector3.Zero' c' d) * .5f) + b;              }              else              {                  return (this.BounceOutEase((t * 2) - d' Vector3.Zero' c' d) * .5f) + (c * .5f) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (-c / 2 * ((float)Math.Sqrt(1 - (t * t)) - 1)) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (-c / 2 * ((float)Math.Sqrt(1 - (t * t)) - 1)) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: return (c / 2 * ((float)Math.Sqrt(1 - ((t -= 2) * t)) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,CircleInOutEase,The following statement contains a magic number: return (c / 2 * ((float)Math.Sqrt(1 - ((t -= 2) * t)) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,CubicInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInEase,The following statement contains a magic number: return -(a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * t) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p)) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if ((t /= d / 2) == 2)              {                  return b + c;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if ((t /= d / 2) == 2)              {                  return b + c;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: float s = p / 4;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: if (t < 1)              {                  return (-.5f * (a * (float)Math.Pow(2' 10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ElasticInOutEase,The following statement contains a magic number: return (a * (float)Math.Pow(2' -10 * (t -= 1)) * (float)Math.Sin(((t * d) - s) * (2 * (float)Math.PI) / p) * .5f) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialInEase,The following statement contains a magic number: return (t == 0) ? b : (c * (float)Math.Pow(2' 10 * ((t / d) - 1))) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialInEase,The following statement contains a magic number: return (t == 0) ? b : (c * (float)Math.Pow(2' 10 * ((t / d) - 1))) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialOutEase,The following statement contains a magic number: return (t == d) ? b + c : (c * (-(float)Math.Pow(2' -10 * t / d) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialOutEase,The following statement contains a magic number: return (t == d) ? b + c : (c * (-(float)Math.Pow(2' -10 * t / d) + 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * (float)Math.Pow(2' 10 * (t - 1))) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,ExponentialInOutEase,The following statement contains a magic number: return (c / 2 * (-(float)Math.Pow(2' -10 * --t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuadraticOutEase,The following statement contains a magic number: return (-c * (t /= d) * (t - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: return (-c / 2 * (((--t) * (t - 2)) - 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuadraticInOutEase,The following statement contains a magic number: return (-c / 2 * (((--t) * (t - 2)) - 1)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: return (-c / 2 * (((t -= 2) * t * t * t) - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: return (-c / 2 * (((t -= 2) * t * t * t) - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuarticInOutEase,The following statement contains a magic number: return (-c / 2 * (((t -= 2) * t * t * t) - 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: if ((t /= d / 2) < 1)              {                  return (c / 2 * t * t * t * t * t) + b;              }
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,QuinticInOutEase,The following statement contains a magic number: return (c / 2 * (((t -= 2) * t * t * t * t) + 2)) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,SineInEase,The following statement contains a magic number: return (-c * (float)Math.Cos(t / d * (Math.PI / 2))) + c + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,SineOutEase,The following statement contains a magic number: return (c * (float)Math.Sin(t / d * (Math.PI / 2))) + b;
Magic Number,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,SineInOutEase,The following statement contains a magic number: return (-c / 2 * ((float)Math.Cos(Math.PI * t / d) - 1)) + b;
Magic Number,WaveEngine.Components.Gestures,TouchGestures,C:\repos\WaveEngine_Components\Shared\Gestures\TouchGestures.cs,UpdateTouchOrder,The following statement contains a magic number: if (!this.ManualTouchOrder && this.Owner != null)              {                  int order = 0;                  int numberOfLevels = 100;                    Drawable2D drawable2D = this.Owner.FindComponent<Drawable2D>(false);                  if (drawable2D != null)                  {                      Type layer = drawable2D.LayerType;                      int index = this.RenderManager.GetLayerIndex(layer);                        if (index != -1)                      {                          order = index * numberOfLevels;                      }                  }                    if (this.Transform2D != null)                  {                      order += (int)((1 - this.Transform2D.DrawOrder) * numberOfLevels);                  }                    this.TouchOrder = order;              }
Magic Number,WaveEngine.Components.Gestures,TouchGestures,C:\repos\WaveEngine_Components\Shared\Gestures\TouchGestures.cs,FreeState,The following statement contains a magic number: if (this.currentTouches.Count < 2)              {                  if (this.currentTouches.Count == 1)                  {                      this.currentCentroid = this.currentTouches[0].Position;                      this.previousCentroid = this.currentCentroid;                  }                    this.numTouches = 0;                  this.gestureSample.Type = GestureType.Drag;                  this.state = GestureType.Drag;              }              else              {                  // Calculamos el centroid                  this.currentCentroid = this.ComputeCentroid(this.currentTouches);                    // Calculamos los puntos más lejanos                  if (this.currentTouches.Count == 2)                  {                      this.currentFarthers1 = this.currentTouches[0].Position;                      this.currentFarthers2 = this.currentTouches[1].Position;                  }                  else                  {                      this.FindTwoFarthestTouches(this.currentTouches' ref this.currentFarthers1' ref this.currentFarthers2);                  }                    // Comprobar si se ha producido un cambio en el número de touches                  if (this.numTouches != this.currentTouches.Count)                  {                      this.numTouches = this.currentTouches.Count;                  }                  else                  {                      // Actualizamos el centroid                      this.gestureSample.Position = this.currentCentroid;                        // Calcula el delta translation                      if (this.IsGestureSupported(SupportedGesture.Translation))                      {                          this.gestureSample.DeltaTranslation = this.currentCentroid - this.previousCentroid;                            // Update entity translation                          this.Transform2D.X += this.gestureSample.DeltaTranslation.X;                          this.Transform2D.Y += this.gestureSample.DeltaTranslation.Y;                      }                        // (Común a Rotation & Scale) Calcular los dos puntos más alejados                      if (this.IsGestureSupported(SupportedGesture.Rotation) || this.IsGestureSupported(SupportedGesture.Scale))                      {                          Vector2 currentVector = this.currentFarthers2 - this.currentFarthers1;                          Vector2 previousVector = this.previousFarthers2 - this.previourFarthers1;                            // Calcula el deta Scale                          if (this.IsGestureSupported(SupportedGesture.Scale))                          {                              float currentLength = currentVector.Length();                              float previousLength = previousVector.Length();                              this.gestureSample.DiffScale = currentLength - previousLength;                                float scale = currentLength / previousLength;                                if (scale != 1 && !float.IsNaN(scale) && !float.IsInfinity(scale) && scale > 0.01f)                              {                                  this.gestureSample.DeltaScale = scale;                                    // Update entity scale                                  float newScale = this.Transform2D.XScale + (this.gestureSample.DeltaScale - 1);                                  if (newScale > this.minScale && newScale < this.maxScale)                                  {                                      this.Transform2D.XScale += this.gestureSample.DeltaScale - 1;                                      this.Transform2D.YScale += this.gestureSample.DeltaScale - 1;                                  }                              }                              else                              {                                  this.gestureSample.DeltaScale = 1;                              }                          }                            // Calcula el delta rotation                          if (this.IsGestureSupported(SupportedGesture.Rotation))                          {                              float angle = Vector2.Angle(ref currentVector' ref previousVector);                                if (angle != 0 && !float.IsNaN(angle) && !float.IsInfinity(angle))                              {                                  this.gestureSample.DeltaAngle = angle;                                    // Update entity rotation                                  this.Transform2D.Rotation += this.gestureSample.DeltaAngle;                              }                              else                              {                                  this.gestureSample.DeltaAngle = 0;                              }                          }                      }                  }              }
Magic Number,WaveEngine.Components.Gestures,TouchGestures,C:\repos\WaveEngine_Components\Shared\Gestures\TouchGestures.cs,FreeState,The following statement contains a magic number: if (this.currentTouches.Count < 2)              {                  if (this.currentTouches.Count == 1)                  {                      this.currentCentroid = this.currentTouches[0].Position;                      this.previousCentroid = this.currentCentroid;                  }                    this.numTouches = 0;                  this.gestureSample.Type = GestureType.Drag;                  this.state = GestureType.Drag;              }              else              {                  // Calculamos el centroid                  this.currentCentroid = this.ComputeCentroid(this.currentTouches);                    // Calculamos los puntos más lejanos                  if (this.currentTouches.Count == 2)                  {                      this.currentFarthers1 = this.currentTouches[0].Position;                      this.currentFarthers2 = this.currentTouches[1].Position;                  }                  else                  {                      this.FindTwoFarthestTouches(this.currentTouches' ref this.currentFarthers1' ref this.currentFarthers2);                  }                    // Comprobar si se ha producido un cambio en el número de touches                  if (this.numTouches != this.currentTouches.Count)                  {                      this.numTouches = this.currentTouches.Count;                  }                  else                  {                      // Actualizamos el centroid                      this.gestureSample.Position = this.currentCentroid;                        // Calcula el delta translation                      if (this.IsGestureSupported(SupportedGesture.Translation))                      {                          this.gestureSample.DeltaTranslation = this.currentCentroid - this.previousCentroid;                            // Update entity translation                          this.Transform2D.X += this.gestureSample.DeltaTranslation.X;                          this.Transform2D.Y += this.gestureSample.DeltaTranslation.Y;                      }                        // (Común a Rotation & Scale) Calcular los dos puntos más alejados                      if (this.IsGestureSupported(SupportedGesture.Rotation) || this.IsGestureSupported(SupportedGesture.Scale))                      {                          Vector2 currentVector = this.currentFarthers2 - this.currentFarthers1;                          Vector2 previousVector = this.previousFarthers2 - this.previourFarthers1;                            // Calcula el deta Scale                          if (this.IsGestureSupported(SupportedGesture.Scale))                          {                              float currentLength = currentVector.Length();                              float previousLength = previousVector.Length();                              this.gestureSample.DiffScale = currentLength - previousLength;                                float scale = currentLength / previousLength;                                if (scale != 1 && !float.IsNaN(scale) && !float.IsInfinity(scale) && scale > 0.01f)                              {                                  this.gestureSample.DeltaScale = scale;                                    // Update entity scale                                  float newScale = this.Transform2D.XScale + (this.gestureSample.DeltaScale - 1);                                  if (newScale > this.minScale && newScale < this.maxScale)                                  {                                      this.Transform2D.XScale += this.gestureSample.DeltaScale - 1;                                      this.Transform2D.YScale += this.gestureSample.DeltaScale - 1;                                  }                              }                              else                              {                                  this.gestureSample.DeltaScale = 1;                              }                          }                            // Calcula el delta rotation                          if (this.IsGestureSupported(SupportedGesture.Rotation))                          {                              float angle = Vector2.Angle(ref currentVector' ref previousVector);                                if (angle != 0 && !float.IsNaN(angle) && !float.IsInfinity(angle))                              {                                  this.gestureSample.DeltaAngle = angle;                                    // Update entity rotation                                  this.Transform2D.Rotation += this.gestureSample.DeltaAngle;                              }                              else                              {                                  this.gestureSample.DeltaAngle = 0;                              }                          }                      }                  }              }
Magic Number,WaveEngine.Components.Gestures,TouchGestures,C:\repos\WaveEngine_Components\Shared\Gestures\TouchGestures.cs,FindTwoFarthestTouches,The following statement contains a magic number: for (int i = 0; i < touches.Count; i++)              {                  Vector2 iTouch = touches[i].Position;                    for (int j = 0; j < touches.Count; j++)                  {                      Vector2 jTouch = touches[j].Position;                        float dis = (float)Math.Sqrt(Math.Pow(jTouch.X - iTouch.X' 2) +                                                   Math.Pow(jTouch.Y - iTouch.Y' 2));                        if (maxdist < dis)                      {                          maxdist = dis;                          point1 = iTouch;                          point2 = jTouch;                      }                  }              }
Magic Number,WaveEngine.Components.Gestures,TouchGestures,C:\repos\WaveEngine_Components\Shared\Gestures\TouchGestures.cs,FindTwoFarthestTouches,The following statement contains a magic number: for (int i = 0; i < touches.Count; i++)              {                  Vector2 iTouch = touches[i].Position;                    for (int j = 0; j < touches.Count; j++)                  {                      Vector2 jTouch = touches[j].Position;                        float dis = (float)Math.Sqrt(Math.Pow(jTouch.X - iTouch.X' 2) +                                                   Math.Pow(jTouch.Y - iTouch.Y' 2));                        if (maxdist < dis)                      {                          maxdist = dis;                          point1 = iTouch;                          point2 = jTouch;                      }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sorts the array according age.                  if (this.settings.SortEnabled && this.emitedParticle)                  {                      Array.Sort(                          this.particles'                          delegate(Particle p1' Particle p2)                          {                              if (p1.StartTime != p2.StartTime)                              {                                  return p1.StartTime.CompareTo(p2.StartTime);                              }                              else                              {                                  return p1.Life.CompareTo(p2.Life);                              }                          });                  }                    this.emitedParticle = false;                    bool infiniteCreation = this.settings.EmitRate == 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    int particlesToCreate = 0;                    if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    int nVertices = 0;                    // Recorremos todas las partículas                  for (int i = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                            if (this.settings.CollisionType != ParticleSystem2D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Bottom) && (p.Position.Y > this.settings.CollisionBottom))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionBottom - (bounciness * (p.Position.Y - this.settings.CollisionBottom));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Top) && (p.Position.Y < this.settings.CollisionTop))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionTop + (bounciness * (this.settings.CollisionTop - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Right) && (p.Position.X > this.settings.CollisionRight))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionRight - (bounciness * (p.Position.X - this.settings.CollisionRight));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Left) && (p.Position.X < this.settings.CollisionLeft))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionLeft + (bounciness * (this.settings.CollisionLeft - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                            p.Color *= this.Transform.GlobalOpacity;                            // Update Vertex Buffer                          Matrix world = this.CalculateLocalWorld(ref p);                            Vector3.Transform(ref vertex1' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex2' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex3' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex4' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            // Si la partícula está viva la contamos                          if (p.Alive)                          {                              this.aliveParticles++;                          }                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      this.mesh.NumVertices = nVertices;                      this.mesh.NumPrimitives = nVertices / 2;                      this.mesh.ZOrder = this.Transform.DrawOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sorts the array according age.                  if (this.settings.SortEnabled && this.emitedParticle)                  {                      Array.Sort(                          this.particles'                          delegate(Particle p1' Particle p2)                          {                              if (p1.StartTime != p2.StartTime)                              {                                  return p1.StartTime.CompareTo(p2.StartTime);                              }                              else                              {                                  return p1.Life.CompareTo(p2.Life);                              }                          });                  }                    this.emitedParticle = false;                    bool infiniteCreation = this.settings.EmitRate == 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    int particlesToCreate = 0;                    if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    int nVertices = 0;                    // Recorremos todas las partículas                  for (int i = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                            if (this.settings.CollisionType != ParticleSystem2D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Bottom) && (p.Position.Y > this.settings.CollisionBottom))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionBottom - (bounciness * (p.Position.Y - this.settings.CollisionBottom));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Top) && (p.Position.Y < this.settings.CollisionTop))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionTop + (bounciness * (this.settings.CollisionTop - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Right) && (p.Position.X > this.settings.CollisionRight))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionRight - (bounciness * (p.Position.X - this.settings.CollisionRight));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Left) && (p.Position.X < this.settings.CollisionLeft))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionLeft + (bounciness * (this.settings.CollisionLeft - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                            p.Color *= this.Transform.GlobalOpacity;                            // Update Vertex Buffer                          Matrix world = this.CalculateLocalWorld(ref p);                            Vector3.Transform(ref vertex1' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex2' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex3' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex4' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            // Si la partícula está viva la contamos                          if (p.Alive)                          {                              this.aliveParticles++;                          }                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      this.mesh.NumVertices = nVertices;                      this.mesh.NumPrimitives = nVertices / 2;                      this.mesh.ZOrder = this.Transform.DrawOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sorts the array according age.                  if (this.settings.SortEnabled && this.emitedParticle)                  {                      Array.Sort(                          this.particles'                          delegate(Particle p1' Particle p2)                          {                              if (p1.StartTime != p2.StartTime)                              {                                  return p1.StartTime.CompareTo(p2.StartTime);                              }                              else                              {                                  return p1.Life.CompareTo(p2.Life);                              }                          });                  }                    this.emitedParticle = false;                    bool infiniteCreation = this.settings.EmitRate == 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    int particlesToCreate = 0;                    if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    int nVertices = 0;                    // Recorremos todas las partículas                  for (int i = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                            if (this.settings.CollisionType != ParticleSystem2D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Bottom) && (p.Position.Y > this.settings.CollisionBottom))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionBottom - (bounciness * (p.Position.Y - this.settings.CollisionBottom));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Top) && (p.Position.Y < this.settings.CollisionTop))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionTop + (bounciness * (this.settings.CollisionTop - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Right) && (p.Position.X > this.settings.CollisionRight))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionRight - (bounciness * (p.Position.X - this.settings.CollisionRight));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Left) && (p.Position.X < this.settings.CollisionLeft))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionLeft + (bounciness * (this.settings.CollisionLeft - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                            p.Color *= this.Transform.GlobalOpacity;                            // Update Vertex Buffer                          Matrix world = this.CalculateLocalWorld(ref p);                            Vector3.Transform(ref vertex1' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex2' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex3' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex4' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            // Si la partícula está viva la contamos                          if (p.Alive)                          {                              this.aliveParticles++;                          }                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      this.mesh.NumVertices = nVertices;                      this.mesh.NumPrimitives = nVertices / 2;                      this.mesh.ZOrder = this.Transform.DrawOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sorts the array according age.                  if (this.settings.SortEnabled && this.emitedParticle)                  {                      Array.Sort(                          this.particles'                          delegate(Particle p1' Particle p2)                          {                              if (p1.StartTime != p2.StartTime)                              {                                  return p1.StartTime.CompareTo(p2.StartTime);                              }                              else                              {                                  return p1.Life.CompareTo(p2.Life);                              }                          });                  }                    this.emitedParticle = false;                    bool infiniteCreation = this.settings.EmitRate == 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    int particlesToCreate = 0;                    if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    int nVertices = 0;                    // Recorremos todas las partículas                  for (int i = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                            if (this.settings.CollisionType != ParticleSystem2D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Bottom) && (p.Position.Y > this.settings.CollisionBottom))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionBottom - (bounciness * (p.Position.Y - this.settings.CollisionBottom));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Top) && (p.Position.Y < this.settings.CollisionTop))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionTop + (bounciness * (this.settings.CollisionTop - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Right) && (p.Position.X > this.settings.CollisionRight))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionRight - (bounciness * (p.Position.X - this.settings.CollisionRight));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Left) && (p.Position.X < this.settings.CollisionLeft))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionLeft + (bounciness * (this.settings.CollisionLeft - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                            p.Color *= this.Transform.GlobalOpacity;                            // Update Vertex Buffer                          Matrix world = this.CalculateLocalWorld(ref p);                            Vector3.Transform(ref vertex1' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex2' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex3' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex4' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            // Si la partícula está viva la contamos                          if (p.Alive)                          {                              this.aliveParticles++;                          }                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      this.mesh.NumVertices = nVertices;                      this.mesh.NumPrimitives = nVertices / 2;                      this.mesh.ZOrder = this.Transform.DrawOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sorts the array according age.                  if (this.settings.SortEnabled && this.emitedParticle)                  {                      Array.Sort(                          this.particles'                          delegate(Particle p1' Particle p2)                          {                              if (p1.StartTime != p2.StartTime)                              {                                  return p1.StartTime.CompareTo(p2.StartTime);                              }                              else                              {                                  return p1.Life.CompareTo(p2.Life);                              }                          });                  }                    this.emitedParticle = false;                    bool infiniteCreation = this.settings.EmitRate == 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    int particlesToCreate = 0;                    if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    int nVertices = 0;                    // Recorremos todas las partículas                  for (int i = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                            if (this.settings.CollisionType != ParticleSystem2D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Bottom) && (p.Position.Y > this.settings.CollisionBottom))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionBottom - (bounciness * (p.Position.Y - this.settings.CollisionBottom));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Top) && (p.Position.Y < this.settings.CollisionTop))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionTop + (bounciness * (this.settings.CollisionTop - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Right) && (p.Position.X > this.settings.CollisionRight))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionRight - (bounciness * (p.Position.X - this.settings.CollisionRight));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Left) && (p.Position.X < this.settings.CollisionLeft))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionLeft + (bounciness * (this.settings.CollisionLeft - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                            p.Color *= this.Transform.GlobalOpacity;                            // Update Vertex Buffer                          Matrix world = this.CalculateLocalWorld(ref p);                            Vector3.Transform(ref vertex1' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex2' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex3' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex4' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            // Si la partícula está viva la contamos                          if (p.Alive)                          {                              this.aliveParticles++;                          }                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      this.mesh.NumVertices = nVertices;                      this.mesh.NumPrimitives = nVertices / 2;                      this.mesh.ZOrder = this.Transform.DrawOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sorts the array according age.                  if (this.settings.SortEnabled && this.emitedParticle)                  {                      Array.Sort(                          this.particles'                          delegate(Particle p1' Particle p2)                          {                              if (p1.StartTime != p2.StartTime)                              {                                  return p1.StartTime.CompareTo(p2.StartTime);                              }                              else                              {                                  return p1.Life.CompareTo(p2.Life);                              }                          });                  }                    this.emitedParticle = false;                    bool infiniteCreation = this.settings.EmitRate == 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    int particlesToCreate = 0;                    if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    int nVertices = 0;                    // Recorremos todas las partículas                  for (int i = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                            if (this.settings.CollisionType != ParticleSystem2D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Bottom) && (p.Position.Y > this.settings.CollisionBottom))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionBottom - (bounciness * (p.Position.Y - this.settings.CollisionBottom));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Top) && (p.Position.Y < this.settings.CollisionTop))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionTop + (bounciness * (this.settings.CollisionTop - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Right) && (p.Position.X > this.settings.CollisionRight))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionRight - (bounciness * (p.Position.X - this.settings.CollisionRight));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Left) && (p.Position.X < this.settings.CollisionLeft))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionLeft + (bounciness * (this.settings.CollisionLeft - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                            p.Color *= this.Transform.GlobalOpacity;                            // Update Vertex Buffer                          Matrix world = this.CalculateLocalWorld(ref p);                            Vector3.Transform(ref vertex1' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex2' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex3' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex4' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            // Si la partícula está viva la contamos                          if (p.Alive)                          {                              this.aliveParticles++;                          }                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      this.mesh.NumVertices = nVertices;                      this.mesh.NumPrimitives = nVertices / 2;                      this.mesh.ZOrder = this.Transform.DrawOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sorts the array according age.                  if (this.settings.SortEnabled && this.emitedParticle)                  {                      Array.Sort(                          this.particles'                          delegate(Particle p1' Particle p2)                          {                              if (p1.StartTime != p2.StartTime)                              {                                  return p1.StartTime.CompareTo(p2.StartTime);                              }                              else                              {                                  return p1.Life.CompareTo(p2.Life);                              }                          });                  }                    this.emitedParticle = false;                    bool infiniteCreation = this.settings.EmitRate == 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    int particlesToCreate = 0;                    if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    int nVertices = 0;                    // Recorremos todas las partículas                  for (int i = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                            if (this.settings.CollisionType != ParticleSystem2D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Bottom) && (p.Position.Y > this.settings.CollisionBottom))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionBottom - (bounciness * (p.Position.Y - this.settings.CollisionBottom));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Top) && (p.Position.Y < this.settings.CollisionTop))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionTop + (bounciness * (this.settings.CollisionTop - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Right) && (p.Position.X > this.settings.CollisionRight))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionRight - (bounciness * (p.Position.X - this.settings.CollisionRight));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Left) && (p.Position.X < this.settings.CollisionLeft))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionLeft + (bounciness * (this.settings.CollisionLeft - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                            p.Color *= this.Transform.GlobalOpacity;                            // Update Vertex Buffer                          Matrix world = this.CalculateLocalWorld(ref p);                            Vector3.Transform(ref vertex1' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex2' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex3' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex4' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            // Si la partícula está viva la contamos                          if (p.Alive)                          {                              this.aliveParticles++;                          }                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      this.mesh.NumVertices = nVertices;                      this.mesh.NumPrimitives = nVertices / 2;                      this.mesh.ZOrder = this.Transform.DrawOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sorts the array according age.                  if (this.settings.SortEnabled && this.emitedParticle)                  {                      Array.Sort(                          this.particles'                          delegate(Particle p1' Particle p2)                          {                              if (p1.StartTime != p2.StartTime)                              {                                  return p1.StartTime.CompareTo(p2.StartTime);                              }                              else                              {                                  return p1.Life.CompareTo(p2.Life);                              }                          });                  }                    this.emitedParticle = false;                    bool infiniteCreation = this.settings.EmitRate == 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    int particlesToCreate = 0;                    if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    int nVertices = 0;                    // Recorremos todas las partículas                  for (int i = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                            if (this.settings.CollisionType != ParticleSystem2D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Bottom) && (p.Position.Y > this.settings.CollisionBottom))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionBottom - (bounciness * (p.Position.Y - this.settings.CollisionBottom));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Top) && (p.Position.Y < this.settings.CollisionTop))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionTop + (bounciness * (this.settings.CollisionTop - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Right) && (p.Position.X > this.settings.CollisionRight))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionRight - (bounciness * (p.Position.X - this.settings.CollisionRight));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Left) && (p.Position.X < this.settings.CollisionLeft))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionLeft + (bounciness * (this.settings.CollisionLeft - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                            p.Color *= this.Transform.GlobalOpacity;                            // Update Vertex Buffer                          Matrix world = this.CalculateLocalWorld(ref p);                            Vector3.Transform(ref vertex1' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex2' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex3' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex4' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            // Si la partícula está viva la contamos                          if (p.Alive)                          {                              this.aliveParticles++;                          }                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      this.mesh.NumVertices = nVertices;                      this.mesh.NumPrimitives = nVertices / 2;                      this.mesh.ZOrder = this.Transform.DrawOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sorts the array according age.                  if (this.settings.SortEnabled && this.emitedParticle)                  {                      Array.Sort(                          this.particles'                          delegate(Particle p1' Particle p2)                          {                              if (p1.StartTime != p2.StartTime)                              {                                  return p1.StartTime.CompareTo(p2.StartTime);                              }                              else                              {                                  return p1.Life.CompareTo(p2.Life);                              }                          });                  }                    this.emitedParticle = false;                    bool infiniteCreation = this.settings.EmitRate == 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    int particlesToCreate = 0;                    if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    int nVertices = 0;                    // Recorremos todas las partículas                  for (int i = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                            if (this.settings.CollisionType != ParticleSystem2D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Bottom) && (p.Position.Y > this.settings.CollisionBottom))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionBottom - (bounciness * (p.Position.Y - this.settings.CollisionBottom));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Top) && (p.Position.Y < this.settings.CollisionTop))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionTop + (bounciness * (this.settings.CollisionTop - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Right) && (p.Position.X > this.settings.CollisionRight))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionRight - (bounciness * (p.Position.X - this.settings.CollisionRight));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Left) && (p.Position.X < this.settings.CollisionLeft))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionLeft + (bounciness * (this.settings.CollisionLeft - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                            p.Color *= this.Transform.GlobalOpacity;                            // Update Vertex Buffer                          Matrix world = this.CalculateLocalWorld(ref p);                            Vector3.Transform(ref vertex1' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex2' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex3' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex4' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            // Si la partícula está viva la contamos                          if (p.Alive)                          {                              this.aliveParticles++;                          }                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      this.mesh.NumVertices = nVertices;                      this.mesh.NumPrimitives = nVertices / 2;                      this.mesh.ZOrder = this.Transform.DrawOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sorts the array according age.                  if (this.settings.SortEnabled && this.emitedParticle)                  {                      Array.Sort(                          this.particles'                          delegate(Particle p1' Particle p2)                          {                              if (p1.StartTime != p2.StartTime)                              {                                  return p1.StartTime.CompareTo(p2.StartTime);                              }                              else                              {                                  return p1.Life.CompareTo(p2.Life);                              }                          });                  }                    this.emitedParticle = false;                    bool infiniteCreation = this.settings.EmitRate == 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    int particlesToCreate = 0;                    if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    int nVertices = 0;                    // Recorremos todas las partículas                  for (int i = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                            if (this.settings.CollisionType != ParticleSystem2D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Bottom) && (p.Position.Y > this.settings.CollisionBottom))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionBottom - (bounciness * (p.Position.Y - this.settings.CollisionBottom));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Top) && (p.Position.Y < this.settings.CollisionTop))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionTop + (bounciness * (this.settings.CollisionTop - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Right) && (p.Position.X > this.settings.CollisionRight))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionRight - (bounciness * (p.Position.X - this.settings.CollisionRight));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem2D.ParticleCollisionFlags.Left) && (p.Position.X < this.settings.CollisionLeft))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem2D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem2D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionLeft + (bounciness * (this.settings.CollisionLeft - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector2.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                            p.Color *= this.Transform.GlobalOpacity;                            // Update Vertex Buffer                          Matrix world = this.CalculateLocalWorld(ref p);                            Vector3.Transform(ref vertex1' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex2' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex3' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            Vector3.Transform(ref vertex4' ref world' out this.vertices[nVertices].Position);                          this.vertices[nVertices++].Color = p.Color;                            // Si la partícula está viva la contamos                          if (p.Alive)                          {                              this.aliveParticles++;                          }                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      this.mesh.NumVertices = nVertices;                      this.mesh.NumPrimitives = nVertices / 2;                      this.mesh.ZOrder = this.Transform.DrawOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: this.numPrimitives = this.numParticles * 2;
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: this.numVertices = this.numParticles * 4;
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: this.numIndices = this.numParticles * 6;
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,LoadParticleSystem,The following statement contains a magic number: this.mesh = new Mesh(0' vertexBuffer.VertexCount' 0' indexBuffer.IndexCount / 3' vertexBuffer' indexBuffer' PrimitiveType.TriangleList)                  {                      DisableBatch = true                  };
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.RandomVelocity != Vector2.Zero)              {                  p.Velocity.X = this.settings.LocalVelocity.X + (this.settings.RandomVelocity.X * (((float)this.random.NextDouble() * 2) - 1));                  p.Velocity.Y = this.settings.LocalVelocity.Y + (this.settings.RandomVelocity.Y * (((float)this.random.NextDouble() * 2) - 1));              }              else              {                  p.Velocity.X = this.settings.LocalVelocity.X;                  p.Velocity.Y = this.settings.LocalVelocity.Y;              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.RandomVelocity != Vector2.Zero)              {                  p.Velocity.X = this.settings.LocalVelocity.X + (this.settings.RandomVelocity.X * (((float)this.random.NextDouble() * 2) - 1));                  p.Velocity.Y = this.settings.LocalVelocity.Y + (this.settings.RandomVelocity.Y * (((float)this.random.NextDouble() * 2) - 1));              }              else              {                  p.Velocity.X = this.settings.LocalVelocity.X;                  p.Velocity.Y = this.settings.LocalVelocity.Y;              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector3.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem2D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Y = p.Position.Y + (y * radius);                                break;                          }                        case ParticleSystem2D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Y = p.Position.Y + (y * radius * rnd1);                                break;                          }                        case ParticleSystem2D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Y = p.Position.Y + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Y = p.Position.Y - yside;                                      break;                              }                                break;                          }                        case ParticleSystem2D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        case ParticleSystem2D.Shape.FillBox:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd2 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Y = p.Position.Y + ((this.settings.EmitterSize.Y / 2) * rnd1);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Z / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics2D,ParticleSystemRenderer2D,C:\repos\WaveEngine_Components\Shared\Graphics2D\ParticleSystemRenderer2D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.InitialAngle.Distinct(0) || this.settings.InitialAngleVariation.Distinct(0))              {                  float randomAngle = this.settings.InitialAngleVariation * (((float)this.random.NextDouble() * 2) - 1);                  p.Angle = this.settings.InitialAngle + randomAngle;              }
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: if (this.texcoord1 == null)              {                  this.texcoord1 = new Vector2[4]                  {                      new Vector2(0' 0)'                      new Vector2(1' 0)'                      new Vector2(1' 1)'                      new Vector2(0' 1)'                  };              }
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: if (this.texcoord2 == null)              {                  this.texcoord2 = new Vector2[4]                  {                      new Vector2(0' 0)'                      new Vector2(1' 0)'                      new Vector2(1' 1)'                      new Vector2(0' 1)'                  };              }
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: VertexPositionDualTexture[] vertices = new VertexPositionDualTexture[4];
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: vertices[2].Position = new Vector3(halfWidth - originCorrectionWidth' halfHeight - originCorrectionHeight' 0);
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: vertices[2].TexCoord = this.texcoord1[2];
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: vertices[2].TexCoord = this.texcoord1[2];
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: vertices[2].TexCoord2 = this.texcoord2[2];
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: vertices[2].TexCoord2 = this.texcoord2[2];
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: vertices[3].Position = new Vector3(-originCorrectionWidth' halfHeight - originCorrectionHeight' 0);
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: vertices[3].TexCoord = this.texcoord1[3];
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: vertices[3].TexCoord = this.texcoord1[3];
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: vertices[3].TexCoord2 = this.texcoord2[3];
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: vertices[3].TexCoord2 = this.texcoord2[3];
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: vertexBuffer.SetData(vertices' 4);
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: ushort[] indices = new ushort[6];
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: indices[2] = 2;
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: indices[2] = 2;
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: indices[3] = 2;
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: indices[3] = 2;
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: indices[4] = 3;
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: indices[4] = 3;
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: indices[5] = 0;
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: this.quadMesh = new Mesh(0' 4' 0' 2' vertexBuffer' indexBuffer' PrimitiveType.TriangleList);
Magic Number,WaveEngine.Components.Graphics2D,QuadRenderer,C:\repos\WaveEngine_Components\Shared\Graphics2D\QuadRenderer.cs,RefreshQuadMesh,The following statement contains a magic number: this.quadMesh = new Mesh(0' 4' 0' 2' vertexBuffer' indexBuffer' PrimitiveType.TriangleList);
Magic Number,WaveEngine.Components.Graphics3D,CapsuleMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\CapsuleMesh.cs,DefaultValues,The following statement contains a magic number: this.tessellation = 16;
Magic Number,WaveEngine.Components.Graphics3D,CapsuleMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\CapsuleMesh.cs,GenerateCapsule,The following statement contains a magic number: this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Capsule(this.Height' this.Radius' this.Tessellation * 2));
Magic Number,WaveEngine.Components.Graphics3D,ConeMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\ConeMesh.cs,DefaultValues,The following statement contains a magic number: this.tessellation = 16;
Magic Number,WaveEngine.Components.Graphics3D,CylinderMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\CylinderMesh.cs,DefaultValues,The following statement contains a magic number: this.tessellation = 16;
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,FromPrimitive,The following statement contains a magic number: int primitiveCount = indexCount / 3;
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,Load,The following statement contains a magic number: using (var reader = new BinaryReader(stream))              {                  this.BoundingBox.Min = reader.ReadVector3();                  this.BoundingBox.Max = reader.ReadVector3();                    // Bones                  int numBones = reader.ReadInt32();                  for (int i = 0; i < numBones; i++)                  {                      byte[] dataBones = reader.ReadBytes(8);                      int boneIndex = BitConverter.ToInt32(dataBones' 0);                      int parentIndex = BitConverter.ToInt32(dataBones' 4);                        string boneName = reader.ReadString();                        Matrix matrix;                      reader.ReadMatrix(out matrix);                        this.Bones.Add(new Bone(boneIndex' parentIndex' boneName' matrix));                  }                    // Materials                  int numMaterials = reader.ReadInt32();                    for (int i = 0; i < numMaterials; i++)                  {                      string name = reader.ReadString();                      ////float opacity = reader.ReadSingle();                      ////Color diffuseColor = new Color(reader.ReadUInt32());                      ////Color ambientColor = new Color(reader.ReadUInt32());                      ////Color emissiveColor = new Color(reader.ReadUInt32());                      ////Color specularColor = new Color(reader.ReadUInt32());                      ////string diffuseTextureFile = reader.ReadString();                      ////string ambientTextureFile = reader.ReadString();                      ////string emissiveTextureFile = reader.ReadString();                      ////string specularTextureFile = reader.ReadString();                        ////ModelMaterialModel material = new ModelMaterialModel()                      ////{                      ////    Name = name'                      ////    Opacity = opacity'                      ////    DiffuseColor = diffuseColor'                      ////    AmbientColor = ambientColor'                      ////    EmissiveColor = emissiveColor'                      ////    SpecularColor = specularColor'                      ////    DiffuseTextureFile = diffuseTextureFile'                      ////    AmbientTextureFile = ambientTextureFile'                      ////    EmissiveTextureFile = emissiveTextureFile'                      ////    SpecularTextureFile = specularTextureFile'                      ////};                        this.Materials.Add(name);                  }                    // Meshes                  this.ProcessMeshNodes(reader);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,Load,The following statement contains a magic number: using (var reader = new BinaryReader(stream))              {                  this.BoundingBox.Min = reader.ReadVector3();                  this.BoundingBox.Max = reader.ReadVector3();                    // Bones                  int numBones = reader.ReadInt32();                  for (int i = 0; i < numBones; i++)                  {                      byte[] dataBones = reader.ReadBytes(8);                      int boneIndex = BitConverter.ToInt32(dataBones' 0);                      int parentIndex = BitConverter.ToInt32(dataBones' 4);                        string boneName = reader.ReadString();                        Matrix matrix;                      reader.ReadMatrix(out matrix);                        this.Bones.Add(new Bone(boneIndex' parentIndex' boneName' matrix));                  }                    // Materials                  int numMaterials = reader.ReadInt32();                    for (int i = 0; i < numMaterials; i++)                  {                      string name = reader.ReadString();                      ////float opacity = reader.ReadSingle();                      ////Color diffuseColor = new Color(reader.ReadUInt32());                      ////Color ambientColor = new Color(reader.ReadUInt32());                      ////Color emissiveColor = new Color(reader.ReadUInt32());                      ////Color specularColor = new Color(reader.ReadUInt32());                      ////string diffuseTextureFile = reader.ReadString();                      ////string ambientTextureFile = reader.ReadString();                      ////string emissiveTextureFile = reader.ReadString();                      ////string specularTextureFile = reader.ReadString();                        ////ModelMaterialModel material = new ModelMaterialModel()                      ////{                      ////    Name = name'                      ////    Opacity = opacity'                      ////    DiffuseColor = diffuseColor'                      ////    AmbientColor = ambientColor'                      ////    EmissiveColor = emissiveColor'                      ////    SpecularColor = specularColor'                      ////    DiffuseTextureFile = diffuseTextureFile'                      ////    AmbientTextureFile = ambientTextureFile'                      ////    EmissiveTextureFile = emissiveTextureFile'                      ////    SpecularTextureFile = specularTextureFile'                      ////};                        this.Materials.Add(name);                  }                    // Meshes                  this.ProcessMeshNodes(reader);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: byte[] dataHeader = reader.ReadBytes(8);
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: int meshParts = BitConverter.ToInt32(dataHeader' 4);
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,ReadMesh,The following statement contains a magic number: for (int j = 0; j < meshParts; j++)              {                  byte[] dataPart = reader.ReadBytes(24);                    int vertexOffset = BitConverter.ToInt32(dataPart' 0);                  int numVertices = BitConverter.ToInt32(dataPart' 4);                  int startIndex = BitConverter.ToInt32(dataPart' 8);                  int primitiveCount = BitConverter.ToInt32(dataPart' 12);                  int numVertexElements = BitConverter.ToInt32(dataPart' 20);                    var properties = new VertexElementProperties[numVertexElements];                    byte[] data = reader.ReadBytes(numVertexElements * 16);                  for (int k = 0; k < numVertexElements; k++)                  {                      VertexElementProperties item = properties[k];                        item.Offset = BitConverter.ToInt32(data' 0 + (k * 16));                      item.Format = (VertexElementFormat)BitConverter.ToInt32(data' 4 + (k * 16));                      item.Usage = (VertexElementUsage)BitConverter.ToInt32(data' 8 + (k * 16));                      item.UsageIndex = BitConverter.ToInt32(data' 12 + (k * 16));                        properties[k] = item;                  }                    // Skip collision data (read from file for retrocompatibility)                  bool hasCollision = reader.ReadBoolean();                  if (hasCollision)                  {                      int collisionVerticesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 12);                        int collisionIndicesCount = reader.ReadInt32();                      reader.ReadBytes(collisionVerticesCount * 2);                  }                    int bufferSize = reader.ReadInt32();                  byte[] bufferData = reader.ReadBytes(bufferSize);                    int indexSize = reader.ReadInt32();                  byte[] dataIndices = reader.ReadBytes(indexSize * 2);                    indexSize = (indexSize / 3) * 3;                  var indices = new ushort[indexSize];                    for (int k = 0; k < indexSize; k++)                  {                      indices[k] = BitConverter.ToUInt16(dataIndices' k * 2);                  }                    var vertexBuffer = new VertexBuffer(new VertexBufferFormat(properties));                  vertexBuffer.SetData(bufferData' numVertices);                  var indexBuffer = new IndexBuffer(indices);                  var mesh = new Mesh(vertexOffset' numVertices' startIndex' primitiveCount' vertexBuffer' indexBuffer' PrimitiveType.TriangleList' materialID);                  mesh.Name = meshName;                    this.Meshes.Add(mesh);                  this.MeshBonePairs.Add(this.Meshes.Count - 1' parentBone);              }
Magic Number,WaveEngine.Components.Graphics3D,InternalStaticModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalStaticModel.cs,GenerateCollisionInfo,The following statement contains a magic number: for (int i = 0; i < this.Meshes.Count; i++)              {                  // vertices                  int previousVerticesSize = this.collisionVertices.Length;                  Mesh mesh = this.Meshes[i];                    if (mesh.PrimitiveType != PrimitiveType.TriangleList)                  {                      continue;                  }                    var vertexPositions = new Vector3[mesh.NumVertices];                  mesh.VertexBuffer.GetVertexProperties(ref vertexPositions' VertexElementUsage.Position' 0' mesh.NumVertices' mesh.VertexOffset);                    int meshPreviousVerticesSize = 0;                  int meshPreviousIndicesSize = 0;                  Vector3[] meshVertices;                  int[] meshIndices;                  bool newMesh = !visitedMeshes.Contains(mesh.Name);                    if (newMesh)                  {                      visitedMeshes.Add(mesh.Name);                      meshVertices = vertexPositions;                  }                  else                  {                      meshVertices = this.collisionVerticesPerMesh[mesh.Name];                      meshPreviousVerticesSize = meshVertices.Length;                      Array.Resize(ref meshVertices' meshPreviousVerticesSize + vertexPositions.Length);                  }                    Matrix absoluteTransform = this.Bones[this.MeshBonePairs[i]].AbsoluteTransform;                    Array.Resize(ref this.collisionVertices' previousVerticesSize + vertexPositions.Length);                    if (newMesh)                  {                      for (int j = 0; j < vertexPositions.Length; j++)                      {                          Vector3.Transform(ref vertexPositions[j]' ref absoluteTransform' out this.collisionVertices[previousVerticesSize + j]);                      }                  }                  else                  {                      for (int j = 0; j < vertexPositions.Length; j++)                      {                          meshVertices[meshPreviousVerticesSize + j] = vertexPositions[j];                          Vector3.Transform(ref vertexPositions[j]' ref absoluteTransform' out this.collisionVertices[previousVerticesSize + j]);                      }                  }                    // indices                  int previousIndicesSize = this.collisionIndices.Length;                    var indices = mesh.IndexBuffer.Data;                    int nIndices = mesh.NumPrimitives * 3;                  int startIndex = previousIndicesSize;                    if (newMesh)                  {                      meshIndices = new int[nIndices];                  }                  else                  {                      meshIndices = this.collisionIndicesPerMesh[mesh.Name];                      meshPreviousIndicesSize = meshIndices.Length;                        Array.Resize(ref meshIndices' meshPreviousIndicesSize + nIndices);                  }                    Array.Resize(ref this.collisionIndices' previousIndicesSize + nIndices);                    for (int j = 0; j < nIndices; j++)                  {                      int indice = indices[j + mesh.IndexOffset];                      meshIndices[meshPreviousIndicesSize + j] = meshPreviousVerticesSize + indice;                      this.collisionIndices[startIndex] = previousVerticesSize + indice;                      startIndex++;                  }                    this.collisionVerticesPerMesh[mesh.Name] = meshVertices;                  this.collisionIndicesPerMesh[mesh.Name] = meshIndices;              }
Magic Number,WaveEngine.Components.Graphics3D,Model,C:\repos\WaveEngine_Components\Shared\Graphics3D\Model.cs,RefreshPrimitive,The following statement contains a magic number: switch (this.modelType)              {                  case ModelType.Custom:                      this.isPrimitive = false;                      this.UnloadModel();                      this.LoadModel();                      break;                  case ModelType.Capsule:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Capsule(1.0f' 0.5f' 16));                      break;                  case ModelType.Cone:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cone(1.0f' 1.0f' 16));                      break;                  case ModelType.Cube:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cube(1.0f));                      break;                  case ModelType.Cylinder:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cylinder(1.0f' 1.0f' 16));                      break;                  case ModelType.Plane:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Primitives.Plane(Vector3.UnitY' 1.0f' 1.0f));                      break;                  case ModelType.Pyramid:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Pyramid(1.0f));                      break;                  case ModelType.Sphere:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Sphere(1.0f' 16));                      break;                  case ModelType.Teapot:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Teapot(1.0f' 16));                      break;                  case ModelType.Torus:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Torus(1.0f' 0.333f' 16));                      break;                  default:                      break;              }
Magic Number,WaveEngine.Components.Graphics3D,Model,C:\repos\WaveEngine_Components\Shared\Graphics3D\Model.cs,RefreshPrimitive,The following statement contains a magic number: switch (this.modelType)              {                  case ModelType.Custom:                      this.isPrimitive = false;                      this.UnloadModel();                      this.LoadModel();                      break;                  case ModelType.Capsule:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Capsule(1.0f' 0.5f' 16));                      break;                  case ModelType.Cone:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cone(1.0f' 1.0f' 16));                      break;                  case ModelType.Cube:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cube(1.0f));                      break;                  case ModelType.Cylinder:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cylinder(1.0f' 1.0f' 16));                      break;                  case ModelType.Plane:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Primitives.Plane(Vector3.UnitY' 1.0f' 1.0f));                      break;                  case ModelType.Pyramid:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Pyramid(1.0f));                      break;                  case ModelType.Sphere:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Sphere(1.0f' 16));                      break;                  case ModelType.Teapot:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Teapot(1.0f' 16));                      break;                  case ModelType.Torus:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Torus(1.0f' 0.333f' 16));                      break;                  default:                      break;              }
Magic Number,WaveEngine.Components.Graphics3D,Model,C:\repos\WaveEngine_Components\Shared\Graphics3D\Model.cs,RefreshPrimitive,The following statement contains a magic number: switch (this.modelType)              {                  case ModelType.Custom:                      this.isPrimitive = false;                      this.UnloadModel();                      this.LoadModel();                      break;                  case ModelType.Capsule:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Capsule(1.0f' 0.5f' 16));                      break;                  case ModelType.Cone:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cone(1.0f' 1.0f' 16));                      break;                  case ModelType.Cube:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cube(1.0f));                      break;                  case ModelType.Cylinder:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cylinder(1.0f' 1.0f' 16));                      break;                  case ModelType.Plane:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Primitives.Plane(Vector3.UnitY' 1.0f' 1.0f));                      break;                  case ModelType.Pyramid:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Pyramid(1.0f));                      break;                  case ModelType.Sphere:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Sphere(1.0f' 16));                      break;                  case ModelType.Teapot:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Teapot(1.0f' 16));                      break;                  case ModelType.Torus:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Torus(1.0f' 0.333f' 16));                      break;                  default:                      break;              }
Magic Number,WaveEngine.Components.Graphics3D,Model,C:\repos\WaveEngine_Components\Shared\Graphics3D\Model.cs,RefreshPrimitive,The following statement contains a magic number: switch (this.modelType)              {                  case ModelType.Custom:                      this.isPrimitive = false;                      this.UnloadModel();                      this.LoadModel();                      break;                  case ModelType.Capsule:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Capsule(1.0f' 0.5f' 16));                      break;                  case ModelType.Cone:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cone(1.0f' 1.0f' 16));                      break;                  case ModelType.Cube:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cube(1.0f));                      break;                  case ModelType.Cylinder:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cylinder(1.0f' 1.0f' 16));                      break;                  case ModelType.Plane:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Primitives.Plane(Vector3.UnitY' 1.0f' 1.0f));                      break;                  case ModelType.Pyramid:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Pyramid(1.0f));                      break;                  case ModelType.Sphere:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Sphere(1.0f' 16));                      break;                  case ModelType.Teapot:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Teapot(1.0f' 16));                      break;                  case ModelType.Torus:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Torus(1.0f' 0.333f' 16));                      break;                  default:                      break;              }
Magic Number,WaveEngine.Components.Graphics3D,Model,C:\repos\WaveEngine_Components\Shared\Graphics3D\Model.cs,RefreshPrimitive,The following statement contains a magic number: switch (this.modelType)              {                  case ModelType.Custom:                      this.isPrimitive = false;                      this.UnloadModel();                      this.LoadModel();                      break;                  case ModelType.Capsule:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Capsule(1.0f' 0.5f' 16));                      break;                  case ModelType.Cone:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cone(1.0f' 1.0f' 16));                      break;                  case ModelType.Cube:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cube(1.0f));                      break;                  case ModelType.Cylinder:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cylinder(1.0f' 1.0f' 16));                      break;                  case ModelType.Plane:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Primitives.Plane(Vector3.UnitY' 1.0f' 1.0f));                      break;                  case ModelType.Pyramid:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Pyramid(1.0f));                      break;                  case ModelType.Sphere:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Sphere(1.0f' 16));                      break;                  case ModelType.Teapot:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Teapot(1.0f' 16));                      break;                  case ModelType.Torus:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Torus(1.0f' 0.333f' 16));                      break;                  default:                      break;              }
Magic Number,WaveEngine.Components.Graphics3D,Model,C:\repos\WaveEngine_Components\Shared\Graphics3D\Model.cs,RefreshPrimitive,The following statement contains a magic number: switch (this.modelType)              {                  case ModelType.Custom:                      this.isPrimitive = false;                      this.UnloadModel();                      this.LoadModel();                      break;                  case ModelType.Capsule:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Capsule(1.0f' 0.5f' 16));                      break;                  case ModelType.Cone:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cone(1.0f' 1.0f' 16));                      break;                  case ModelType.Cube:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cube(1.0f));                      break;                  case ModelType.Cylinder:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Cylinder(1.0f' 1.0f' 16));                      break;                  case ModelType.Plane:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Primitives.Plane(Vector3.UnitY' 1.0f' 1.0f));                      break;                  case ModelType.Pyramid:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Pyramid(1.0f));                      break;                  case ModelType.Sphere:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Sphere(1.0f' 16));                      break;                  case ModelType.Teapot:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Teapot(1.0f' 16));                      break;                  case ModelType.Torus:                      this.InternalModel = new InternalStaticModel();                      this.InternalModel.FromPrimitive(WaveServices.GraphicsDevice' new Torus(1.0f' 0.333f' 16));                      break;                  default:                      break;              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The following statement contains a magic number: if (!this.Owner.Scene.IsPaused)              {                  // Sets the timeFactor for updating velocities.                  float timeFactor = VELOCITYFACTOR * (float)gameTime.TotalSeconds;                    this.aliveParticles = 0;                    // Sets the time passed between 2 particles creation.                  this.emitLapse = (this.settings.EmitRate > 0) ? 1 / this.settings.EmitRate : 0;                    bool infiniteCreation = this.settings.EmitRate == 0;                  int particlesToCreate = 0;                  if (!infiniteCreation)                  {                      float particlesToCreateF = ((float)gameTime.TotalSeconds / this.emitLapse) + this.emitRemainder;                      particlesToCreate = (int)particlesToCreateF;                      this.emitRemainder = particlesToCreateF - particlesToCreate;                  }                    // Recorremos todas las partículas                  for (int i = 0' j = 0; i < this.numParticles; i++)                  {                      Particle p = this.particles[i];                        // Update particle                      // Si la partícula está viva seguimos consumiendo su vida                      if (p.Alive)                      {                          p.Life = p.Life - gameTime.TotalSeconds;                      }                        // Si la partícula ha llegado al final de su vida                      if (p.Life < 0)                      {                          // Si permitimos la emisión de nuevas partículas y debe resetear sus valores                          if (this.settings.Emit && (infiniteCreation || (particlesToCreate > 0)))                          {                              this.ResetParticle(ref p);                              particlesToCreate--;                          }                          else                          {                              // Si la particula no está viva                              p.Alive = false;                              p.Size = 0;                          }                      }                      else                      {                          // Si la particula está viva y visible                          // p.Position                          p.Velocity.X = p.Velocity.X + (timeFactor * this.settings.Gravity.X);                          p.Velocity.Y = p.Velocity.Y + (timeFactor * this.settings.Gravity.Y);                          p.Velocity.Z = p.Velocity.Z + (timeFactor * this.settings.Gravity.Z);                            // Calculate the rotation with the transform                          Vector3.TransformNormal(ref p.Velocity' ref this.rotationMatrix' out this.rotationVector);                            p.Position.X = p.Position.X + (timeFactor * this.rotationVector.X);                          p.Position.Y = p.Position.Y + (timeFactor * this.rotationVector.Y);                          p.Position.Z = p.Position.Z + (timeFactor * this.rotationVector.Z);                            if (this.settings.CollisionType != ParticleSystem3D.ParticleCollisionFlags.None)                          {                              // Checks vertical collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxY) && (p.Position.Y > this.settings.CollisionMax.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMax.Y - (bounciness * (p.Position.Y - this.settings.CollisionMax.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinY) && (p.Position.Y < this.settings.CollisionMin.Y))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Y = this.settings.CollisionMin.Y + (bounciness * (this.settings.CollisionMin.Y - p.Position.Y));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = -bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = -bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks horizontal collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxX) && (p.Position.X > this.settings.CollisionMax.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMax.X - (bounciness * (p.Position.X - this.settings.CollisionMax.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinX) && (p.Position.X < this.settings.CollisionMin.X))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.X = this.settings.CollisionMin.X + (bounciness * (this.settings.CollisionMin.X - p.Position.X));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = -bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = -bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                                // Checks depth collisions                              if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MaxZ) && (p.Position.Z > this.settings.CollisionMax.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMax.Z - (bounciness * (p.Position.Z - this.settings.CollisionMax.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                              else if (this.settings.CollisionType.HasFlag(ParticleSystem3D.ParticleCollisionFlags.MinZ) && (p.Position.Z < this.settings.CollisionMin.Z))                              {                                  switch (this.settings.CollisionBehavior)                                  {                                      case ParticleSystem3D.ParticleCollisionBehavior.Die:                                          // Kills the particle                                          p.Alive = false;                                          p.Size = 0;                                          p.Life = -1;                                          break;                                      case ParticleSystem3D.ParticleCollisionBehavior.Bounce:                                          // Mirrors the position and velocity with the bounciness factor.                                          float bounciness = this.settings.Bounciness;                                          p.Position.Z = this.settings.CollisionMin.Z + (bounciness * (this.settings.CollisionMin.Z - p.Position.Z));                                            // Applies the collision spread to the velocity                                          if (this.settings.CollisionSpread != Vector3.Zero)                                          {                                              p.Velocity.X = bounciness * (p.Velocity.X + (this.settings.CollisionSpread.X * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Y = bounciness * (p.Velocity.Y + (this.settings.CollisionSpread.Y * (((float)this.random.NextDouble() * 2) - 1)));                                              p.Velocity.Z = -bounciness * (p.Velocity.Z + (this.settings.CollisionSpread.Z * (((float)this.random.NextDouble() * 2) - 1)));                                          }                                          else                                          {                                              p.Velocity.X = bounciness * p.Velocity.X;                                              p.Velocity.Y = bounciness * p.Velocity.Y;                                              p.Velocity.Z = -bounciness * p.Velocity.Z;                                          }                                            break;                                      default:                                          // Do nothing                                          break;                                  }                              }                          }                            // Rotate                          p.Angle = p.Angle + (timeFactor * p.VelocityRotation);                            // Color                          if (this.settings.LinearColorEnabled && p.TimeLife != 0 && this.settings.InterpolationColors != null && this.settings.InterpolationColors.Count > 1)                          {                              // Num destiny colors                              int count = this.settings.InterpolationColors.Count;                                // Current lerp                              double lerp = 1 - (p.Life / p.TimeLife);                                // Life time of one color                              double colorPeriod = 1 / (count - 1.0);                                // destiny Color                              int sourceIndex = (int)(lerp / colorPeriod);                                sourceIndex = Math.Max(0' Math.Min(count - 2' sourceIndex));                                double currentLerp = (lerp - (sourceIndex * colorPeriod)) / colorPeriod;                                Color sourceColor = this.settings.InterpolationColors[sourceIndex];                              Color destinyColor = this.settings.InterpolationColors[sourceIndex + 1];                                p.Color = Color.Lerp(ref sourceColor' ref destinyColor' (float)currentLerp);                          }                          else                          {                              p.Color = p.CurrentColor;                          }                            if (this.settings.AlphaEnabled && p.TimeLife.Distinct(0))                          {                              double age = p.Life / p.TimeLife;                              p.Color *= (float)age;                          }                      }                        // Update Vertex Buffer                      Matrix world = this.CalculateLocalWorld(ref p);                        Vector3 transformedNormal;                        Vector3.Transform(ref normal' ref world' out transformedNormal);                        Vector3.Transform(ref vertex1' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord1;                        Vector3.Transform(ref vertex2' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord2;                        Vector3.Transform(ref vertex3' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord3;                        Vector3.Transform(ref vertex4' ref world' out this.vertices[j].Position);                      this.vertices[j].Color = p.Color;                      this.vertices[j].Normal = transformedNormal;                      this.vertices[j++].TexCoord = texcoord4;                        ////Vector3 pos1 = this.vertices[j - 4].Position;                      ////Vector3 pos2 = this.vertices[j - 3].Position;                      ////Vector3 pos3 = this.vertices[j - 2].Position;                      ////Vector3 pos4 = this.vertices[j - 1].Position;                        ////this.RenderManager.LineBatch3D.DrawLine(pos1' pos2' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos2' pos3' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos3' pos4' p.Color);                      ////this.RenderManager.LineBatch3D.DrawLine(pos4' pos1' p.Color);                        // Si la partícula está viva la contamos                      if (p.Alive)                      {                          this.aliveParticles++;                      }                  }                    this.internalEnabled = this.aliveParticles > 0;                    if (this.internalEnabled)                  {                      float zOrder = Vector3.DistanceSquared(this.RenderManager.CurrentDrawingCamera3D.Position' this.Transform.Position);                        this.mesh.ZOrder = zOrder;                      this.mesh.VertexBuffer.SetData(this.vertices' this.numVertices);                      this.GraphicsDevice.BindVertexBuffer(this.mesh.VertexBuffer);                        this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);                  }              }              else              {                  // if the scene is paused' draw the previous mesh                  this.RenderManager.DrawMesh(this.mesh' this.material' ref localWorld' false);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: this.numPrimitives = this.numParticles * 2;
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: this.numVertices = this.numParticles * 4;
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: this.numIndices = this.numParticles * 6;
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: for (int i = 0; i < this.numParticles; i++)              {                  indices[(i * 6) + 0] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 1] = (ushort)((i * 4) + 2);                  indices[(i * 6) + 2] = (ushort)((i * 4) + 1);                    indices[(i * 6) + 3] = (ushort)((i * 4) + 0);                  indices[(i * 6) + 4] = (ushort)((i * 4) + 3);                  indices[(i * 6) + 5] = (ushort)((i * 4) + 2);              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,LoadParticleSystem,The following statement contains a magic number: this.mesh = new Mesh(0' vertexBuffer.VertexCount' 0' indexBuffer.IndexCount / 3' vertexBuffer' indexBuffer' PrimitiveType.TriangleList)              {                  DisableBatch = true              };
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.RandomVelocity != Vector3.Zero)              {                  p.Velocity = this.settings.LocalVelocity;                    p.Velocity.X = p.Velocity.X + (this.settings.RandomVelocity.X * (((float)this.random.NextDouble() * 2) - 1));                  p.Velocity.Y = p.Velocity.Y + (this.settings.RandomVelocity.Y * (((float)this.random.NextDouble() * 2) - 1));                  p.Velocity.Z = p.Velocity.Z + (this.settings.RandomVelocity.Z * (((float)this.random.NextDouble() * 2) - 1));              }              else              {                  p.Velocity = this.settings.LocalVelocity;              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.RandomVelocity != Vector3.Zero)              {                  p.Velocity = this.settings.LocalVelocity;                    p.Velocity.X = p.Velocity.X + (this.settings.RandomVelocity.X * (((float)this.random.NextDouble() * 2) - 1));                  p.Velocity.Y = p.Velocity.Y + (this.settings.RandomVelocity.Y * (((float)this.random.NextDouble() * 2) - 1));                  p.Velocity.Z = p.Velocity.Z + (this.settings.RandomVelocity.Z * (((float)this.random.NextDouble() * 2) - 1));              }              else              {                  p.Velocity = this.settings.LocalVelocity;              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.RandomVelocity != Vector3.Zero)              {                  p.Velocity = this.settings.LocalVelocity;                    p.Velocity.X = p.Velocity.X + (this.settings.RandomVelocity.X * (((float)this.random.NextDouble() * 2) - 1));                  p.Velocity.Y = p.Velocity.Y + (this.settings.RandomVelocity.Y * (((float)this.random.NextDouble() * 2) - 1));                  p.Velocity.Z = p.Velocity.Z + (this.settings.RandomVelocity.Z * (((float)this.random.NextDouble() * 2) - 1));              }              else              {                  p.Velocity = this.settings.LocalVelocity;              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.EmitterSize != Vector2.Zero)              {                  switch (this.settings.EmitterShape)                  {                      case ParticleSystem3D.Shape.Circle:                          {                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius);                              p.Position.Z = p.Position.Z + (y * radius);                                break;                          }                        case ParticleSystem3D.Shape.FillCircle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                              float radius = this.settings.EmitterSize.X > this.settings.EmitterSize.Y ? (this.settings.EmitterSize.X / 2) : (this.settings.EmitterSize.Y / 2);                              double angle = this.random.NextDouble() * MathHelper.TwoPi;                              float x = (float)Math.Cos(angle);                              float y = (float)Math.Sin(angle);                                p.Position.X = p.Position.X + (x * radius * rnd0);                              p.Position.Z = p.Position.Z + (y * radius * rnd1);                                break;                          }                        case ParticleSystem3D.Shape.Rectangle:                          {                              int c = this.random.Next(4);                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float xside = this.settings.EmitterSize.X / 2;                              float yside = this.settings.EmitterSize.Y / 2;                                switch (c)                              {                                  case 0:                                      p.Position.X = p.Position.X + xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 1:                                      p.Position.X = p.Position.X - xside;                                      p.Position.Z = p.Position.Z + (yside * rnd0);                                      break;                                  case 2:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z + yside;                                      break;                                  case 3:                                  default:                                      p.Position.X = p.Position.X + (xside * rnd0);                                      p.Position.Z = p.Position.Z - yside;                                      break;                              }                                break;                          }                        case ParticleSystem3D.Shape.FillRectangle:                          {                              float rnd0 = ((float)this.random.NextDouble() * 2) - 1;                              float rnd1 = ((float)this.random.NextDouble() * 2) - 1;                                p.Position.X = p.Position.X + ((this.settings.EmitterSize.X / 2) * rnd0);                              p.Position.Z = p.Position.Z + ((this.settings.EmitterSize.Y / 2) * rnd1);                              break;                          }                        default:                          {                              throw new ArgumentException("Invalid particleSystem shape");                          }                  }              }
Magic Number,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,ResetParticle,The following statement contains a magic number: if (this.settings.InitialAngle.Distinct(0))              {                  float randomAngle = ((float)this.random.NextDouble() * 2) - 1;                  p.Angle = this.settings.InitialAngle * randomAngle;              }
Magic Number,WaveEngine.Components.Graphics3D,SkinnedModelRenderer,C:\repos\WaveEngine_Components\Shared\Graphics3D\SkinnedModelRenderer.cs,DefaultValues,The following statement contains a magic number: this.LODMinDistance = 600;
Magic Number,WaveEngine.Components.Graphics3D,SkinnedModelRenderer,C:\repos\WaveEngine_Components\Shared\Graphics3D\SkinnedModelRenderer.cs,DefaultValues,The following statement contains a magic number: this.LODMaxDistance = 2000;
Magic Number,WaveEngine.Components.Graphics3D,SphereMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\SphereMesh.cs,DefaultValues,The following statement contains a magic number: this.tessellation = 16;
Magic Number,WaveEngine.Components.Graphics3D,TeapotMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\TeapotMesh.cs,DefaultValues,The following statement contains a magic number: this.tessellation = 16;
Magic Number,WaveEngine.Components.Graphics3D,TorusMesh,C:\repos\WaveEngine_Components\Shared\Graphics3D\TorusMesh.cs,DefaultValues,The following statement contains a magic number: this.tessellation = 16;
Magic Number,WaveEngine.Framework.Graphics,Skybox,C:\repos\WaveEngine_Components\Shared\Graphics3D\Skybox.cs,Initialize,The following statement contains a magic number: ushort[] indices = new ushort[36];
Magic Number,WaveEngine.Framework.Graphics,Skybox,C:\repos\WaveEngine_Components\Shared\Graphics3D\Skybox.cs,Initialize,The following statement contains a magic number: VertexPositionTexture[] vertices = new VertexPositionTexture[24];
Magic Number,WaveEngine.Framework.Graphics,Skybox,C:\repos\WaveEngine_Components\Shared\Graphics3D\Skybox.cs,Initialize,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  indices[currentIndice++] = (ushort)(currentVertex + 0);                  indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 2);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    // 1   2                  // 0   3                    // Four vertices per face.                  vertices[currentVertex].Position = (normal - side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 0];                  vertices[currentVertex].Position = (normal - side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 1];                  vertices[currentVertex].Position = (normal + side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 2];                  vertices[currentVertex].Position = (normal + side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 3];              }
Magic Number,WaveEngine.Framework.Graphics,Skybox,C:\repos\WaveEngine_Components\Shared\Graphics3D\Skybox.cs,Initialize,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  indices[currentIndice++] = (ushort)(currentVertex + 0);                  indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 2);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    // 1   2                  // 0   3                    // Four vertices per face.                  vertices[currentVertex].Position = (normal - side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 0];                  vertices[currentVertex].Position = (normal - side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 1];                  vertices[currentVertex].Position = (normal + side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 2];                  vertices[currentVertex].Position = (normal + side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 3];              }
Magic Number,WaveEngine.Framework.Graphics,Skybox,C:\repos\WaveEngine_Components\Shared\Graphics3D\Skybox.cs,Initialize,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  indices[currentIndice++] = (ushort)(currentVertex + 0);                  indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 2);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    // 1   2                  // 0   3                    // Four vertices per face.                  vertices[currentVertex].Position = (normal - side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 0];                  vertices[currentVertex].Position = (normal - side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 1];                  vertices[currentVertex].Position = (normal + side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 2];                  vertices[currentVertex].Position = (normal + side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 3];              }
Magic Number,WaveEngine.Framework.Graphics,Skybox,C:\repos\WaveEngine_Components\Shared\Graphics3D\Skybox.cs,Initialize,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  indices[currentIndice++] = (ushort)(currentVertex + 0);                  indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 2);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    // 1   2                  // 0   3                    // Four vertices per face.                  vertices[currentVertex].Position = (normal - side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 0];                  vertices[currentVertex].Position = (normal - side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 1];                  vertices[currentVertex].Position = (normal + side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 2];                  vertices[currentVertex].Position = (normal + side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 3];              }
Magic Number,WaveEngine.Framework.Graphics,Skybox,C:\repos\WaveEngine_Components\Shared\Graphics3D\Skybox.cs,Initialize,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  indices[currentIndice++] = (ushort)(currentVertex + 0);                  indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 2);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    // 1   2                  // 0   3                    // Four vertices per face.                  vertices[currentVertex].Position = (normal - side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 0];                  vertices[currentVertex].Position = (normal - side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 1];                  vertices[currentVertex].Position = (normal + side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 2];                  vertices[currentVertex].Position = (normal + side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 3];              }
Magic Number,WaveEngine.Framework.Graphics,Skybox,C:\repos\WaveEngine_Components\Shared\Graphics3D\Skybox.cs,Initialize,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  indices[currentIndice++] = (ushort)(currentVertex + 0);                  indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    indices[currentIndice++] = (ushort)(currentVertex + 1);                  indices[currentIndice++] = (ushort)(currentVertex + 2);                  indices[currentIndice++] = (ushort)(currentVertex + 3);                    // 1   2                  // 0   3                    // Four vertices per face.                  vertices[currentVertex].Position = (normal - side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 0];                  vertices[currentVertex].Position = (normal - side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 1];                  vertices[currentVertex].Position = (normal + side1 + side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 2];                  vertices[currentVertex].Position = (normal + side1 - side2) * sizeOverTwo;                  vertices[currentVertex++].TexCoord = texCoord[j + 3];              }
Magic Number,WaveEngine.Framework.Graphics,Skybox,C:\repos\WaveEngine_Components\Shared\Graphics3D\Skybox.cs,Initialize,The following statement contains a magic number: vertexBuffer.SetData(vertices' 24);
Magic Number,WaveEngine.Framework.Graphics,Skybox,C:\repos\WaveEngine_Components\Shared\Graphics3D\Skybox.cs,Initialize,The following statement contains a magic number: this.cubeMesh = new Mesh(0' 24' 0' 12' vertexBuffer' indexBuffer' PrimitiveType.TriangleList)              {                  DisableBatch = true              };
Magic Number,WaveEngine.Framework.Graphics,Skybox,C:\repos\WaveEngine_Components\Shared\Graphics3D\Skybox.cs,Initialize,The following statement contains a magic number: this.cubeMesh = new Mesh(0' 24' 0' 12' vertexBuffer' indexBuffer' PrimitiveType.TriangleList)              {                  DisableBatch = true              };
Magic Number,WaveEngine.Components.Particles,ParticleSystem2D,C:\repos\WaveEngine_Components\Shared\Particles\ParticleSystem2D.cs,DefaultValues,The following statement contains a magic number: this.MinSize = 20;
Magic Number,WaveEngine.Components.Particles,ParticleSystem2D,C:\repos\WaveEngine_Components\Shared\Particles\ParticleSystem2D.cs,DefaultValues,The following statement contains a magic number: this.MaxSize = 50;
Magic Number,WaveEngine.Components.Particles,ParticleSystem2D,C:\repos\WaveEngine_Components\Shared\Particles\ParticleSystem2D.cs,DefaultValues,The following statement contains a magic number: this.MaxLife = 2;
Magic Number,WaveEngine.Components.Particles,ParticleSystem3D,C:\repos\WaveEngine_Components\Shared\Particles\ParticleSystem3D.cs,DefaultValues,The following statement contains a magic number: this.NumParticles = 100;
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: if (tessellation % 2 != 0)              {                  throw new ArgumentOutOfRangeException("tessellation should be even");              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: int halfTessellation = tessellation / 2;
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Capsule,C:\repos\WaveEngine_Components\Shared\Primitives\Capsule.cs,Capsule,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * cylinderHeight)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * cylinderHeight)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(stride + (i * 2));                      this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                        this.AddIndex(stride + ((i * 2) + 1));                      this.AddIndex(stride + (((i * 2) + 3) % ((tessellation + 1) * 2)));                      this.AddIndex(stride + (((i * 2) + 2) % ((tessellation + 1) * 2)));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: if (tessellation < 3)              {                  throw new ArgumentOutOfRangeException("tessellation");              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: height /= 2;
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: float radius = diameter / 2;
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,Cone,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                  Vector3 basePos = (normal * radius) + (Vector3.Down * height);                  Vector3 upPos = Vector3.Up * height;                    normal = Vector3.Cross(upPos' basePos);                  normal = Vector3.Cross(basePos' normal);                  normal.Normalize();                    this.AddVertex(upPos' normal' new Vector2(1 - percent' 0));                  this.AddVertex(basePos' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,CreateCap,The following statement contains a magic number: for (int i = 0; i < tessellation - 2; i++)              {                  if (normal.Y > 0)                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                  }                  else                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,CreateCap,The following statement contains a magic number: for (int i = 0; i < tessellation - 2; i++)              {                  if (normal.Y > 0)                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                  }                  else                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cone,C:\repos\WaveEngine_Components\Shared\Primitives\Cone.cs,CreateCap,The following statement contains a magic number: for (int i = 0; i < tessellation - 2; i++)              {                  if (normal.Y > 0)                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                  }                  else                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cube,C:\repos\WaveEngine_Components\Shared\Primitives\Cube.cs,Cube,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                  Vector3 tangent = tangents[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  this.AddIndex(this.VerticesCount + 0);                  this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 3);                    this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 2);                  this.AddIndex(this.VerticesCount + 3);                    //// 0   3                  //// 1   2                    float sideOverTwo = size * 0.5f;                    // Four vertices per face.                  this.AddVertex((normal - side1 - side2) * sideOverTwo' normal' tangent' texCoord[j]);                  this.AddVertex((normal - side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 1]);                  this.AddVertex((normal + side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 2]);                  this.AddVertex((normal + side1 - side2) * sideOverTwo' normal' tangent' texCoord[j + 3]);              }
Magic Number,WaveEngine.Components.Primitives,Cube,C:\repos\WaveEngine_Components\Shared\Primitives\Cube.cs,Cube,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                  Vector3 tangent = tangents[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  this.AddIndex(this.VerticesCount + 0);                  this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 3);                    this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 2);                  this.AddIndex(this.VerticesCount + 3);                    //// 0   3                  //// 1   2                    float sideOverTwo = size * 0.5f;                    // Four vertices per face.                  this.AddVertex((normal - side1 - side2) * sideOverTwo' normal' tangent' texCoord[j]);                  this.AddVertex((normal - side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 1]);                  this.AddVertex((normal + side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 2]);                  this.AddVertex((normal + side1 - side2) * sideOverTwo' normal' tangent' texCoord[j + 3]);              }
Magic Number,WaveEngine.Components.Primitives,Cube,C:\repos\WaveEngine_Components\Shared\Primitives\Cube.cs,Cube,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                  Vector3 tangent = tangents[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  this.AddIndex(this.VerticesCount + 0);                  this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 3);                    this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 2);                  this.AddIndex(this.VerticesCount + 3);                    //// 0   3                  //// 1   2                    float sideOverTwo = size * 0.5f;                    // Four vertices per face.                  this.AddVertex((normal - side1 - side2) * sideOverTwo' normal' tangent' texCoord[j]);                  this.AddVertex((normal - side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 1]);                  this.AddVertex((normal + side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 2]);                  this.AddVertex((normal + side1 - side2) * sideOverTwo' normal' tangent' texCoord[j + 3]);              }
Magic Number,WaveEngine.Components.Primitives,Cube,C:\repos\WaveEngine_Components\Shared\Primitives\Cube.cs,Cube,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                  Vector3 tangent = tangents[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  this.AddIndex(this.VerticesCount + 0);                  this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 3);                    this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 2);                  this.AddIndex(this.VerticesCount + 3);                    //// 0   3                  //// 1   2                    float sideOverTwo = size * 0.5f;                    // Four vertices per face.                  this.AddVertex((normal - side1 - side2) * sideOverTwo' normal' tangent' texCoord[j]);                  this.AddVertex((normal - side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 1]);                  this.AddVertex((normal + side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 2]);                  this.AddVertex((normal + side1 - side2) * sideOverTwo' normal' tangent' texCoord[j + 3]);              }
Magic Number,WaveEngine.Components.Primitives,Cube,C:\repos\WaveEngine_Components\Shared\Primitives\Cube.cs,Cube,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                  Vector3 tangent = tangents[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  this.AddIndex(this.VerticesCount + 0);                  this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 3);                    this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 2);                  this.AddIndex(this.VerticesCount + 3);                    //// 0   3                  //// 1   2                    float sideOverTwo = size * 0.5f;                    // Four vertices per face.                  this.AddVertex((normal - side1 - side2) * sideOverTwo' normal' tangent' texCoord[j]);                  this.AddVertex((normal - side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 1]);                  this.AddVertex((normal + side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 2]);                  this.AddVertex((normal + side1 - side2) * sideOverTwo' normal' tangent' texCoord[j + 3]);              }
Magic Number,WaveEngine.Components.Primitives,Cube,C:\repos\WaveEngine_Components\Shared\Primitives\Cube.cs,Cube,The following statement contains a magic number: for (int i = 0' j = 0; i < normals.Length; i++' j += 4)              {                  Vector3 normal = normals[i];                  Vector3 tangent = tangents[i];                    // Get two vectors perpendicular to the face normal and to each other.                  Vector3 side1 = new Vector3(normal.Y' normal.Z' normal.X);                  Vector3 side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  this.AddIndex(this.VerticesCount + 0);                  this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 3);                    this.AddIndex(this.VerticesCount + 1);                  this.AddIndex(this.VerticesCount + 2);                  this.AddIndex(this.VerticesCount + 3);                    //// 0   3                  //// 1   2                    float sideOverTwo = size * 0.5f;                    // Four vertices per face.                  this.AddVertex((normal - side1 - side2) * sideOverTwo' normal' tangent' texCoord[j]);                  this.AddVertex((normal - side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 1]);                  this.AddVertex((normal + side1 + side2) * sideOverTwo' normal' tangent' texCoord[j + 2]);                  this.AddVertex((normal + side1 - side2) * sideOverTwo' normal' tangent' texCoord[j + 3]);              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: if (tessellation < 3)              {                  throw new ArgumentOutOfRangeException("tessellation");              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: height /= 2;
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: float radius = diameter / 2;
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,Cylinder,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float percent = i / (float)tessellation;                  float angle = percent * MathHelper.TwoPi;                    float dx = (float)Math.Cos(angle);                  float dz = (float)Math.Sin(angle);                    Vector3 normal = new Vector3(dx' 0' dz);                    this.AddVertex((normal * radius) + (Vector3.Up * height)' normal' new Vector2(1 - percent' 0));                  this.AddVertex((normal * radius) + (Vector3.Down * height)' normal' new Vector2(1 - percent' 1));                    if (i < tessellation)                  {                      this.AddIndex(i * 2);                      this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                        this.AddIndex((i * 2) + 1);                      this.AddIndex(((i * 2) + 3) % ((tessellation + 1) * 2));                      this.AddIndex(((i * 2) + 2) % ((tessellation + 1) * 2));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,CreateCap,The following statement contains a magic number: for (int i = 0; i < tessellation - 2; i++)              {                  if (normal.Y > 0)                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                  }                  else                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,CreateCap,The following statement contains a magic number: for (int i = 0; i < tessellation - 2; i++)              {                  if (normal.Y > 0)                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                  }                  else                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                  }              }
Magic Number,WaveEngine.Components.Primitives,Cylinder,C:\repos\WaveEngine_Components\Shared\Primitives\Cylinder.cs,CreateCap,The following statement contains a magic number: for (int i = 0; i < tessellation - 2; i++)              {                  if (normal.Y > 0)                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                  }                  else                  {                      this.AddIndex(this.VerticesCount);                      this.AddIndex(this.VerticesCount + ((i + 2) % tessellation));                      this.AddIndex(this.VerticesCount + ((i + 1) % tessellation));                  }              }
Magic Number,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,CalculateTangentSpace,The following statement contains a magic number: int triangleCount = this.indices.Count / 3;
Magic Number,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,CalculateTangentSpace,The following statement contains a magic number: Vector3* tan1 = stackalloc Vector3[vertexCount * 2];
Magic Number,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,CalculateTangentSpace,The following statement contains a magic number: for (int a = 0; a < triangleCount; a++)              {                  ushort i1 = this.indices[(a * 3) + 0];                  ushort i2 = this.indices[(a * 3) + 1];                  ushort i3 = this.indices[(a * 3) + 2];                    a1 = this.vertices[i1];                  a2 = this.vertices[i2];                  a3 = this.vertices[i3];                    v1 = a1.Position;                  v2 = a2.Position;                  v3 = a3.Position;                    w1 = a1.TexCoord;                  w2 = a2.TexCoord;                  w3 = a3.TexCoord;                    float x1 = v2.X - v1.X;                  float x2 = v3.X - v1.X;                  float y1 = v2.Y - v1.Y;                  float y2 = v3.Y - v1.Y;                  float z1 = v2.Z - v1.Z;                  float z2 = v3.Z - v1.Z;                    float s1 = w2.X - w1.X;                  float s2 = w3.X - w1.X;                  float t1 = w2.Y - w1.Y;                  float t2 = w3.Y - w1.Y;                    float r = 1.0F / ((s1 * t2) - (s2 * t1));                  Vector3 sdir = new Vector3(((t2 * x1) - (t1 * x2)) * r' ((t2 * y1) - (t1 * y2)) * r' ((t2 * z1) - (t1 * z2)) * r);                  Vector3 tdir = new Vector3(((s1 * x2) - (s2 * x1)) * r' ((s1 * y2) - (s2 * y1)) * r' ((s1 * z2) - (s2 * z1)) * r);                    tan1[i1] += sdir;                  tan1[i2] += sdir;                  tan1[i3] += sdir;                    tan2[i1] += tdir;                  tan2[i2] += tdir;                  tan2[i3] += tdir;              }
Magic Number,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,CalculateTangentSpace,The following statement contains a magic number: for (int a = 0; a < triangleCount; a++)              {                  ushort i1 = this.indices[(a * 3) + 0];                  ushort i2 = this.indices[(a * 3) + 1];                  ushort i3 = this.indices[(a * 3) + 2];                    a1 = this.vertices[i1];                  a2 = this.vertices[i2];                  a3 = this.vertices[i3];                    v1 = a1.Position;                  v2 = a2.Position;                  v3 = a3.Position;                    w1 = a1.TexCoord;                  w2 = a2.TexCoord;                  w3 = a3.TexCoord;                    float x1 = v2.X - v1.X;                  float x2 = v3.X - v1.X;                  float y1 = v2.Y - v1.Y;                  float y2 = v3.Y - v1.Y;                  float z1 = v2.Z - v1.Z;                  float z2 = v3.Z - v1.Z;                    float s1 = w2.X - w1.X;                  float s2 = w3.X - w1.X;                  float t1 = w2.Y - w1.Y;                  float t2 = w3.Y - w1.Y;                    float r = 1.0F / ((s1 * t2) - (s2 * t1));                  Vector3 sdir = new Vector3(((t2 * x1) - (t1 * x2)) * r' ((t2 * y1) - (t1 * y2)) * r' ((t2 * z1) - (t1 * z2)) * r);                  Vector3 tdir = new Vector3(((s1 * x2) - (s2 * x1)) * r' ((s1 * y2) - (s2 * y1)) * r' ((s1 * z2) - (s2 * z1)) * r);                    tan1[i1] += sdir;                  tan1[i2] += sdir;                  tan1[i3] += sdir;                    tan2[i1] += tdir;                  tan2[i2] += tdir;                  tan2[i3] += tdir;              }
Magic Number,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,CalculateTangentSpace,The following statement contains a magic number: for (int a = 0; a < triangleCount; a++)              {                  ushort i1 = this.indices[(a * 3) + 0];                  ushort i2 = this.indices[(a * 3) + 1];                  ushort i3 = this.indices[(a * 3) + 2];                    a1 = this.vertices[i1];                  a2 = this.vertices[i2];                  a3 = this.vertices[i3];                    v1 = a1.Position;                  v2 = a2.Position;                  v3 = a3.Position;                    w1 = a1.TexCoord;                  w2 = a2.TexCoord;                  w3 = a3.TexCoord;                    float x1 = v2.X - v1.X;                  float x2 = v3.X - v1.X;                  float y1 = v2.Y - v1.Y;                  float y2 = v3.Y - v1.Y;                  float z1 = v2.Z - v1.Z;                  float z2 = v3.Z - v1.Z;                    float s1 = w2.X - w1.X;                  float s2 = w3.X - w1.X;                  float t1 = w2.Y - w1.Y;                  float t2 = w3.Y - w1.Y;                    float r = 1.0F / ((s1 * t2) - (s2 * t1));                  Vector3 sdir = new Vector3(((t2 * x1) - (t1 * x2)) * r' ((t2 * y1) - (t1 * y2)) * r' ((t2 * z1) - (t1 * z2)) * r);                  Vector3 tdir = new Vector3(((s1 * x2) - (s2 * x1)) * r' ((s1 * y2) - (s2 * y1)) * r' ((s1 * z2) - (s2 * z1)) * r);                    tan1[i1] += sdir;                  tan1[i2] += sdir;                  tan1[i3] += sdir;                    tan2[i1] += tdir;                  tan2[i2] += tdir;                  tan2[i3] += tdir;              }
Magic Number,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,CalculateTangentSpace,The following statement contains a magic number: for (int a = 0; a < triangleCount; a++)              {                  ushort i1 = this.indices[(a * 3) + 0];                  ushort i2 = this.indices[(a * 3) + 1];                  ushort i3 = this.indices[(a * 3) + 2];                    a1 = this.vertices[i1];                  a2 = this.vertices[i2];                  a3 = this.vertices[i3];                    v1 = a1.Position;                  v2 = a2.Position;                  v3 = a3.Position;                    w1 = a1.TexCoord;                  w2 = a2.TexCoord;                  w3 = a3.TexCoord;                    float x1 = v2.X - v1.X;                  float x2 = v3.X - v1.X;                  float y1 = v2.Y - v1.Y;                  float y2 = v3.Y - v1.Y;                  float z1 = v2.Z - v1.Z;                  float z2 = v3.Z - v1.Z;                    float s1 = w2.X - w1.X;                  float s2 = w3.X - w1.X;                  float t1 = w2.Y - w1.Y;                  float t2 = w3.Y - w1.Y;                    float r = 1.0F / ((s1 * t2) - (s2 * t1));                  Vector3 sdir = new Vector3(((t2 * x1) - (t1 * x2)) * r' ((t2 * y1) - (t1 * y2)) * r' ((t2 * z1) - (t1 * z2)) * r);                  Vector3 tdir = new Vector3(((s1 * x2) - (s2 * x1)) * r' ((s1 * y2) - (s2 * y1)) * r' ((s1 * z2) - (s2 * z1)) * r);                    tan1[i1] += sdir;                  tan1[i2] += sdir;                  tan1[i3] += sdir;                    tan2[i1] += tdir;                  tan2[i2] += tdir;                  tan2[i3] += tdir;              }
Magic Number,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,GetSphericalTexCoord,The following statement contains a magic number: double tx = (Math.Atan2(normal.X' normal.Z) / (Math.PI * 2)) + 0.25;
Magic Number,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,GetSphericalTexCoord,The following statement contains a magic number: double tx = (Math.Atan2(normal.X' normal.Z) / (Math.PI * 2)) + 0.25;
Magic Number,WaveEngine.Components.Primitives,Geometric,C:\repos\WaveEngine_Components\Shared\Primitives\Geometric.cs,GetSphericalTexCoord,The following statement contains a magic number: double ty = (Math.Asin(normal.Y) / MathHelper.Pi) + 0.5;
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: this.AddIndex(2);
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: this.AddIndex(2);
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: this.AddIndex(3);
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: Vector2[] uv = new Vector2[4];
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: uv[2] = new Vector2(1' 0);
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: uv[3] = new Vector2(1' 1);
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (uvHorizontalFlip)              {                  aux = uv[0];                  uv[0] = uv[3];                  uv[3] = aux;                    aux = uv[1];                  uv[1] = uv[2];                  uv[2] = aux;              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (uvHorizontalFlip)              {                  aux = uv[0];                  uv[0] = uv[3];                  uv[3] = aux;                    aux = uv[1];                  uv[1] = uv[2];                  uv[2] = aux;              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (uvHorizontalFlip)              {                  aux = uv[0];                  uv[0] = uv[3];                  uv[3] = aux;                    aux = uv[1];                  uv[1] = uv[2];                  uv[2] = aux;              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (uvHorizontalFlip)              {                  aux = uv[0];                  uv[0] = uv[3];                  uv[3] = aux;                    aux = uv[1];                  uv[1] = uv[2];                  uv[2] = aux;              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (uvVerticalFlip)              {                  aux = uv[0];                  uv[0] = uv[1];                  uv[1] = aux;                    aux = uv[3];                  uv[3] = uv[2];                  uv[2] = aux;              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (uvVerticalFlip)              {                  aux = uv[0];                  uv[0] = uv[1];                  uv[1] = aux;                    aux = uv[3];                  uv[3] = uv[2];                  uv[2] = aux;              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (uvVerticalFlip)              {                  aux = uv[0];                  uv[0] = uv[1];                  uv[1] = aux;                    aux = uv[3];                  uv[3] = uv[2];                  uv[2] = aux;              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (uvVerticalFlip)              {                  aux = uv[0];                  uv[0] = uv[1];                  uv[1] = aux;                    aux = uv[3];                  uv[3] = uv[2];                  uv[2] = aux;              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: this.AddVertex(v3' normal' uv[2]);
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: this.AddVertex(v4' normal' uv[3]);
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (twoSides)              {                  this.AddIndex(4);                  this.AddIndex(6);                  this.AddIndex(5);                    this.AddIndex(4);                  this.AddIndex(7);                  this.AddIndex(6);                    this.AddVertex(v1' normal' uv[3]);                  this.AddVertex(v2' normal' uv[2]);                  this.AddVertex(v3' normal' uv[1]);                  this.AddVertex(v4' normal' uv[0]);              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (twoSides)              {                  this.AddIndex(4);                  this.AddIndex(6);                  this.AddIndex(5);                    this.AddIndex(4);                  this.AddIndex(7);                  this.AddIndex(6);                    this.AddVertex(v1' normal' uv[3]);                  this.AddVertex(v2' normal' uv[2]);                  this.AddVertex(v3' normal' uv[1]);                  this.AddVertex(v4' normal' uv[0]);              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (twoSides)              {                  this.AddIndex(4);                  this.AddIndex(6);                  this.AddIndex(5);                    this.AddIndex(4);                  this.AddIndex(7);                  this.AddIndex(6);                    this.AddVertex(v1' normal' uv[3]);                  this.AddVertex(v2' normal' uv[2]);                  this.AddVertex(v3' normal' uv[1]);                  this.AddVertex(v4' normal' uv[0]);              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (twoSides)              {                  this.AddIndex(4);                  this.AddIndex(6);                  this.AddIndex(5);                    this.AddIndex(4);                  this.AddIndex(7);                  this.AddIndex(6);                    this.AddVertex(v1' normal' uv[3]);                  this.AddVertex(v2' normal' uv[2]);                  this.AddVertex(v3' normal' uv[1]);                  this.AddVertex(v4' normal' uv[0]);              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (twoSides)              {                  this.AddIndex(4);                  this.AddIndex(6);                  this.AddIndex(5);                    this.AddIndex(4);                  this.AddIndex(7);                  this.AddIndex(6);                    this.AddVertex(v1' normal' uv[3]);                  this.AddVertex(v2' normal' uv[2]);                  this.AddVertex(v3' normal' uv[1]);                  this.AddVertex(v4' normal' uv[0]);              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (twoSides)              {                  this.AddIndex(4);                  this.AddIndex(6);                  this.AddIndex(5);                    this.AddIndex(4);                  this.AddIndex(7);                  this.AddIndex(6);                    this.AddVertex(v1' normal' uv[3]);                  this.AddVertex(v2' normal' uv[2]);                  this.AddVertex(v3' normal' uv[1]);                  this.AddVertex(v4' normal' uv[0]);              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (twoSides)              {                  this.AddIndex(4);                  this.AddIndex(6);                  this.AddIndex(5);                    this.AddIndex(4);                  this.AddIndex(7);                  this.AddIndex(6);                    this.AddVertex(v1' normal' uv[3]);                  this.AddVertex(v2' normal' uv[2]);                  this.AddVertex(v3' normal' uv[1]);                  this.AddVertex(v4' normal' uv[0]);              }
Magic Number,WaveEngine.Components.Primitives,Plane,C:\repos\WaveEngine_Components\Shared\Primitives\Plane.cs,Plane,The following statement contains a magic number: if (twoSides)              {                  this.AddIndex(4);                  this.AddIndex(6);                  this.AddIndex(5);                    this.AddIndex(4);                  this.AddIndex(7);                  this.AddIndex(6);                    this.AddVertex(v1' normal' uv[3]);                  this.AddVertex(v2' normal' uv[2]);                  this.AddVertex(v3' normal' uv[1]);                  this.AddVertex(v4' normal' uv[0]);              }
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: float sizeOverTwo = size / 2;
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(2);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(2);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(3);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(4);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(5);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(6);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(7);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(8);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(9);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(10);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(11);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(12);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(13);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(14);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddIndex(15);
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddVertex(basePos * -(size / 2)' normal' new Vector2(0.5f' 0));
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddVertex(basePos * -(size / 2)' normal' new Vector2(0.5f' 0));
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddVertex(basePos * -(size / 2)' normal' new Vector2(0.5f' 0));
Magic Number,WaveEngine.Components.Primitives,Pyramid,C:\repos\WaveEngine_Components\Shared\Primitives\Pyramid.cs,Pyramid,The following statement contains a magic number: this.AddVertex(basePos * -(size / 2)' normal' new Vector2(0.5f' 0));
Magic Number,WaveEngine.Components.Primitives,Sphere,C:\repos\WaveEngine_Components\Shared\Primitives\Sphere.cs,Sphere,The following statement contains a magic number: if (tessellation < 3)              {                  throw new ArgumentOutOfRangeException("tessellation");              }
Magic Number,WaveEngine.Components.Primitives,Sphere,C:\repos\WaveEngine_Components\Shared\Primitives\Sphere.cs,Sphere,The following statement contains a magic number: int horizontalSegments = tessellation * 2;
Magic Number,WaveEngine.Components.Primitives,Sphere,C:\repos\WaveEngine_Components\Shared\Primitives\Sphere.cs,Sphere,The following statement contains a magic number: float radius = diameter / 2;
Magic Number,WaveEngine.Components.Primitives,Sphere,C:\repos\WaveEngine_Components\Shared\Primitives\Sphere.cs,Sphere,The following statement contains a magic number: for (int i = 0; i < verticalSegments - 2; i++)              {                  for (int j = 0; j < horizontalSegments; j++)                  {                      int nextI = i + 1;                      int nextJ = j + 1;                      int num = horizontalSegments + 1;                        int i1 = horizontalSegments + (i * num) + j;                      int i2 = horizontalSegments + (i * num) + nextJ;                      int i3 = horizontalSegments + (nextI * num) + j;                      int i4 = i3 + 1;                        this.AddIndex(i1);                      this.AddIndex(i2);                      this.AddIndex(i3);                        this.AddIndex(i2);                      this.AddIndex(i4);                      this.AddIndex(i3);                  }              }
Magic Number,WaveEngine.Components.Primitives,Sphere,C:\repos\WaveEngine_Components\Shared\Primitives\Sphere.cs,Sphere,The following statement contains a magic number: for (int i = 0; i < horizontalSegments; i++)              {                  this.AddIndex(this.VerticesCount - 1 - i);                  this.AddIndex(this.VerticesCount - horizontalSegments - 2 - i);                  this.AddIndex(this.VerticesCount - horizontalSegments - 1 - i);              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,TessellatePatch,The following statement contains a magic number: Vector3[] controlPoints = new Vector3[16];
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,TessellatePatch,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  int index = patch.Indices[i];                  controlPoints[i] = teapotControlPoints[index] * scale;              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,CreatePatchVertices,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float ti = (float)i / tessellation;                  float uCoord = ti;                    for (int j = 0; j <= tessellation; j++)                  {                      float tj = (float)j / tessellation;                      float vCoord = tj;                        // Perform four horizontal bezier interpolations                      // between the control points of this patch.                      Vector3 p1 = this.Bezier(patch[0]' patch[1]' patch[2]' patch[3]' ti);                      Vector3 p2 = this.Bezier(patch[4]' patch[5]' patch[6]' patch[7]' ti);                      Vector3 p3 = this.Bezier(patch[8]' patch[9]' patch[10]' patch[11]' ti);                      Vector3 p4 = this.Bezier(patch[12]' patch[13]' patch[14]' patch[15]' ti);                        // Perform a vertical interpolation between the results of the                      // previous horizontal interpolations' to compute the position.                      Vector3 position = this.Bezier(p1' p2' p3' p4' tj);                        // Perform another four bezier interpolations between the control                      // points' but this time vertically rather than horizontally.                      Vector3 q1 = this.Bezier(patch[0]' patch[4]' patch[8]' patch[12]' tj);                      Vector3 q2 = this.Bezier(patch[1]' patch[5]' patch[9]' patch[13]' tj);                      Vector3 q3 = this.Bezier(patch[2]' patch[6]' patch[10]' patch[14]' tj);                      Vector3 q4 = this.Bezier(patch[3]' patch[7]' patch[11]' patch[15]' tj);                        // Compute vertical and horizontal tangent vectors.                      Vector3 tangentA = this.BezierTangent(p1' p2' p3' p4' tj);                      Vector3 tangentB = this.BezierTangent(q1' q2' q3' q4' ti);                        // Cross the two tangent vectors to compute the normal.                      Vector3 normal = Vector3.Cross(tangentA' tangentB);                        if (normal.Length() > 0.0001f)                      {                          normal.Normalize();                            // If this patch is mirrored' we must invert the normal.                          if (isMirrored)                          {                              normal = -normal;                          }                      }                      else                      {                          if (position.Y > 0)                          {                              normal = Vector3.Up;                          }                          else                          {                              normal = Vector3.Down;                          }                      }                        if (isMirrored)                      {                          vCoord = -vCoord;                      }                        // Create the vertex.                      this.AddVertex(position' normal' new Vector2(uCoord' vCoord));                  }              }
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,Bezier,The following statement contains a magic number: return (p1 * (1 - t) * (1 - t) * (1 - t)) +                     (p2 * 3 * t * (1 - t) * (1 - t)) +                     (p3 * 3 * t * t * (1 - t)) +                     (p4 * t * t * t);
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,Bezier,The following statement contains a magic number: return (p1 * (1 - t) * (1 - t) * (1 - t)) +                     (p2 * 3 * t * (1 - t) * (1 - t)) +                     (p3 * 3 * t * t * (1 - t)) +                     (p4 * t * t * t);
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,BezierTangent,The following statement contains a magic number: return (p1 * (-1 + (2 * t) - (t * t))) +                     (p2 * (1 - (4 * t) + (3 * t * t))) +                     (p3 * ((2 * t) - (3 * t * t))) +                     (p4 * (t * t));
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,BezierTangent,The following statement contains a magic number: return (p1 * (-1 + (2 * t) - (t * t))) +                     (p2 * (1 - (4 * t) + (3 * t * t))) +                     (p3 * ((2 * t) - (3 * t * t))) +                     (p4 * (t * t));
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,BezierTangent,The following statement contains a magic number: return (p1 * (-1 + (2 * t) - (t * t))) +                     (p2 * (1 - (4 * t) + (3 * t * t))) +                     (p3 * ((2 * t) - (3 * t * t))) +                     (p4 * (t * t));
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,BezierTangent,The following statement contains a magic number: return (p1 * (-1 + (2 * t) - (t * t))) +                     (p2 * (1 - (4 * t) + (3 * t * t))) +                     (p3 * ((2 * t) - (3 * t * t))) +                     (p4 * (t * t));
Magic Number,WaveEngine.Components.Primitives,Teapot,C:\repos\WaveEngine_Components\Shared\Primitives\Teapot.cs,BezierTangent,The following statement contains a magic number: return (p1 * (-1 + (2 * t) - (t * t))) +                     (p2 * (1 - (4 * t) + (3 * t * t))) +                     (p3 * ((2 * t) - (3 * t * t))) +                     (p4 * (t * t));
Magic Number,WaveEngine.Components.Primitives,Torus,C:\repos\WaveEngine_Components\Shared\Primitives\Torus.cs,Torus,The following statement contains a magic number: if (tessellation < 3)              {                  throw new ArgumentOutOfRangeException("tessellation");              }
Magic Number,WaveEngine.Components.Primitives,Torus,C:\repos\WaveEngine_Components\Shared\Primitives\Torus.cs,Torus,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float outerPercent = i / (float)tessellation;                  float outerAngle = outerPercent * MathHelper.TwoPi;                    // Create a transform matrix that will align geometry to                  // slice perpendicularly though the current ring position.                  Matrix transform = Matrix.CreateTranslation(diameter / 2' 0' 0) *                                     Matrix.CreateRotationY(outerAngle);                    // Now we loop along the other axis' around the side of the tube.                  for (int j = 0; j <= tessellation; j++)                  {                      float innerPercent = j / (float)tessellation;                      float innerAngle = MathHelper.TwoPi * innerPercent;                        float dx = (float)Math.Cos(innerAngle);                      float dy = (float)Math.Sin(innerAngle);                        // Create a vertex.                      Vector3 normal = new Vector3(dx' dy' 0);                      Vector3 position = normal * thickness / 2;                        position = Vector3.Transform(position' transform);                      normal = Vector3.TransformNormal(normal' transform);                        this.AddVertex(position' normal' new Vector2(outerPercent' 0.5f - innerPercent));                        // And create indices for two triangles.                      int nextI = (i + 1) % tessellationPlus;                      int nextJ = (j + 1) % tessellationPlus;                        if ((j < tessellation) && (i < tessellation))                      {                          this.AddIndex((i * tessellationPlus) + j);                          this.AddIndex((i * tessellationPlus) + nextJ);                          this.AddIndex((nextI * tessellationPlus) + j);                            this.AddIndex((i * tessellationPlus) + nextJ);                          this.AddIndex((nextI * tessellationPlus) + nextJ);                          this.AddIndex((nextI * tessellationPlus) + j);                      }                  }              }
Magic Number,WaveEngine.Components.Primitives,Torus,C:\repos\WaveEngine_Components\Shared\Primitives\Torus.cs,Torus,The following statement contains a magic number: for (int i = 0; i <= tessellation; i++)              {                  float outerPercent = i / (float)tessellation;                  float outerAngle = outerPercent * MathHelper.TwoPi;                    // Create a transform matrix that will align geometry to                  // slice perpendicularly though the current ring position.                  Matrix transform = Matrix.CreateTranslation(diameter / 2' 0' 0) *                                     Matrix.CreateRotationY(outerAngle);                    // Now we loop along the other axis' around the side of the tube.                  for (int j = 0; j <= tessellation; j++)                  {                      float innerPercent = j / (float)tessellation;                      float innerAngle = MathHelper.TwoPi * innerPercent;                        float dx = (float)Math.Cos(innerAngle);                      float dy = (float)Math.Sin(innerAngle);                        // Create a vertex.                      Vector3 normal = new Vector3(dx' dy' 0);                      Vector3 position = normal * thickness / 2;                        position = Vector3.Transform(position' transform);                      normal = Vector3.TransformNormal(normal' transform);                        this.AddVertex(position' normal' new Vector2(outerPercent' 0.5f - innerPercent));                        // And create indices for two triangles.                      int nextI = (i + 1) % tessellationPlus;                      int nextJ = (j + 1) % tessellationPlus;                        if ((j < tessellation) && (i < tessellation))                      {                          this.AddIndex((i * tessellationPlus) + j);                          this.AddIndex((i * tessellationPlus) + nextJ);                          this.AddIndex((nextI * tessellationPlus) + j);                            this.AddIndex((i * tessellationPlus) + nextJ);                          this.AddIndex((nextI * tessellationPlus) + nextJ);                          this.AddIndex((nextI * tessellationPlus) + j);                      }                  }              }
Magic Number,WaveEngine.Components.Toolkit,Tagalong,C:\repos\WaveEngine_Components\Shared\Toolkit\Tagalong.cs,DefaultValues,The following statement contains a magic number: this.MaxAngle = MathHelper.ToRadians(13);
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,DefaultValues,The following statement contains a magic number: this.width = 300;
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,CreateInfexBuffer,The following statement contains a magic number: for (int j = 0' v = 0; j < indices.Length; j += CHARINDICES' v += CHARVERTICES)              {                  indices[j + 0] = (ushort)v; // 0                  indices[j + 1] = (ushort)(v + 2); // 2                  indices[j + 2] = (ushort)(v + 1); // 1                  indices[j + 3] = (ushort)(v + 1); // 1                  indices[j + 4] = (ushort)(v + 2); // 2                  indices[j + 5] = (ushort)(v + 3); // 3              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,CreateInfexBuffer,The following statement contains a magic number: for (int j = 0' v = 0; j < indices.Length; j += CHARINDICES' v += CHARVERTICES)              {                  indices[j + 0] = (ushort)v; // 0                  indices[j + 1] = (ushort)(v + 2); // 2                  indices[j + 2] = (ushort)(v + 1); // 1                  indices[j + 3] = (ushort)(v + 1); // 1                  indices[j + 4] = (ushort)(v + 2); // 2                  indices[j + 5] = (ushort)(v + 3); // 3              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,CreateInfexBuffer,The following statement contains a magic number: for (int j = 0' v = 0; j < indices.Length; j += CHARINDICES' v += CHARVERTICES)              {                  indices[j + 0] = (ushort)v; // 0                  indices[j + 1] = (ushort)(v + 2); // 2                  indices[j + 2] = (ushort)(v + 1); // 1                  indices[j + 3] = (ushort)(v + 1); // 1                  indices[j + 4] = (ushort)(v + 2); // 2                  indices[j + 5] = (ushort)(v + 3); // 3              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,CreateInfexBuffer,The following statement contains a magic number: for (int j = 0' v = 0; j < indices.Length; j += CHARINDICES' v += CHARVERTICES)              {                  indices[j + 0] = (ushort)v; // 0                  indices[j + 1] = (ushort)(v + 2); // 2                  indices[j + 2] = (ushort)(v + 1); // 1                  indices[j + 3] = (ushort)(v + 1); // 1                  indices[j + 4] = (ushort)(v + 2); // 2                  indices[j + 5] = (ushort)(v + 3); // 3              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,CreateInfexBuffer,The following statement contains a magic number: for (int j = 0' v = 0; j < indices.Length; j += CHARINDICES' v += CHARVERTICES)              {                  indices[j + 0] = (ushort)v; // 0                  indices[j + 1] = (ushort)(v + 2); // 2                  indices[j + 2] = (ushort)(v + 1); // 1                  indices[j + 3] = (ushort)(v + 1); // 1                  indices[j + 4] = (ushort)(v + 2); // 2                  indices[j + 5] = (ushort)(v + 3); // 3              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,CreateInfexBuffer,The following statement contains a magic number: for (int j = 0' v = 0; j < indices.Length; j += CHARINDICES' v += CHARVERTICES)              {                  indices[j + 0] = (ushort)v; // 0                  indices[j + 1] = (ushort)(v + 2); // 2                  indices[j + 2] = (ushort)(v + 1); // 1                  indices[j + 3] = (ushort)(v + 1); // 1                  indices[j + 4] = (ushort)(v + 2); // 2                  indices[j + 5] = (ushort)(v + 3); // 3              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,CreateInfexBuffer,The following statement contains a magic number: for (int j = 0' v = 0; j < indices.Length; j += CHARINDICES' v += CHARVERTICES)              {                  indices[j + 0] = (ushort)v; // 0                  indices[j + 1] = (ushort)(v + 2); // 2                  indices[j + 2] = (ushort)(v + 1); // 1                  indices[j + 3] = (ushort)(v + 1); // 1                  indices[j + 4] = (ushort)(v + 2); // 2                  indices[j + 5] = (ushort)(v + 3); // 3              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,RefreshMeshes,The following statement contains a magic number: for (int charNum = 0; charNum < totalChars; charNum++)              {                  var charInfo = this.charInfoList[charNum];                  var p = charInfo.Position;                  var s = charInfo.SourceRectangle;                    // Builds the vertex information.                  // Front Vertex                  this.vertexBufferData[index].Position = new Vector3(p.Left' p.Top' 0);                  this.vertexBufferData[index].Normal = normal;                  this.vertexBufferData[index].TexCoord = new Vector2(s.Left / tW' s.Bottom / tH);                    this.vertexBufferData[index + 1].Position = new Vector3(p.Right' p.Top' 0);                  this.vertexBufferData[index + 1].Normal = normal;                  this.vertexBufferData[index + 1].TexCoord = new Vector2(s.Right / tW' s.Bottom / tH);                    this.vertexBufferData[index + 2].Position = new Vector3(p.Left' p.Bottom' 0);                  this.vertexBufferData[index + 2].Normal = normal;                  this.vertexBufferData[index + 2].TexCoord = new Vector2(s.Left / tW' s.Top / tH);                    this.vertexBufferData[index + 3].Position = new Vector3(p.Right' p.Bottom' 0);                  this.vertexBufferData[index + 3].Normal = normal;                  this.vertexBufferData[index + 3].TexCoord = new Vector2(s.Right / tW' s.Top / tH);                    index += CHARVERTICES;                  remainingVertices -= CHARVERTICES;                  bufferLength += CHARVERTICES;                    if ((index >= BUFFERLENGTH) || (remainingVertices <= 0))                  {                      Mesh mesh = this.CreateMesh();                      mesh.VertexBuffer.SetData(this.vertexBufferData' BUFFERLENGTH' 0);                      mesh.NumVertices = bufferLength;                      mesh.NumPrimitives = (bufferLength * CHARTRIANGLES) / CHARVERTICES;                        this.RenderManager.GraphicsDevice.BindVertexBuffer(mesh.VertexBuffer);                        this.meshes.Add(mesh);                        mesh.VertexBuffer.FreePointer();                        index = 0;                      bufferLength = 0;                  }              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,RefreshMeshes,The following statement contains a magic number: for (int charNum = 0; charNum < totalChars; charNum++)              {                  var charInfo = this.charInfoList[charNum];                  var p = charInfo.Position;                  var s = charInfo.SourceRectangle;                    // Builds the vertex information.                  // Front Vertex                  this.vertexBufferData[index].Position = new Vector3(p.Left' p.Top' 0);                  this.vertexBufferData[index].Normal = normal;                  this.vertexBufferData[index].TexCoord = new Vector2(s.Left / tW' s.Bottom / tH);                    this.vertexBufferData[index + 1].Position = new Vector3(p.Right' p.Top' 0);                  this.vertexBufferData[index + 1].Normal = normal;                  this.vertexBufferData[index + 1].TexCoord = new Vector2(s.Right / tW' s.Bottom / tH);                    this.vertexBufferData[index + 2].Position = new Vector3(p.Left' p.Bottom' 0);                  this.vertexBufferData[index + 2].Normal = normal;                  this.vertexBufferData[index + 2].TexCoord = new Vector2(s.Left / tW' s.Top / tH);                    this.vertexBufferData[index + 3].Position = new Vector3(p.Right' p.Bottom' 0);                  this.vertexBufferData[index + 3].Normal = normal;                  this.vertexBufferData[index + 3].TexCoord = new Vector2(s.Right / tW' s.Top / tH);                    index += CHARVERTICES;                  remainingVertices -= CHARVERTICES;                  bufferLength += CHARVERTICES;                    if ((index >= BUFFERLENGTH) || (remainingVertices <= 0))                  {                      Mesh mesh = this.CreateMesh();                      mesh.VertexBuffer.SetData(this.vertexBufferData' BUFFERLENGTH' 0);                      mesh.NumVertices = bufferLength;                      mesh.NumPrimitives = (bufferLength * CHARTRIANGLES) / CHARVERTICES;                        this.RenderManager.GraphicsDevice.BindVertexBuffer(mesh.VertexBuffer);                        this.meshes.Add(mesh);                        mesh.VertexBuffer.FreePointer();                        index = 0;                      bufferLength = 0;                  }              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,RefreshMeshes,The following statement contains a magic number: for (int charNum = 0; charNum < totalChars; charNum++)              {                  var charInfo = this.charInfoList[charNum];                  var p = charInfo.Position;                  var s = charInfo.SourceRectangle;                    // Builds the vertex information.                  // Front Vertex                  this.vertexBufferData[index].Position = new Vector3(p.Left' p.Top' 0);                  this.vertexBufferData[index].Normal = normal;                  this.vertexBufferData[index].TexCoord = new Vector2(s.Left / tW' s.Bottom / tH);                    this.vertexBufferData[index + 1].Position = new Vector3(p.Right' p.Top' 0);                  this.vertexBufferData[index + 1].Normal = normal;                  this.vertexBufferData[index + 1].TexCoord = new Vector2(s.Right / tW' s.Bottom / tH);                    this.vertexBufferData[index + 2].Position = new Vector3(p.Left' p.Bottom' 0);                  this.vertexBufferData[index + 2].Normal = normal;                  this.vertexBufferData[index + 2].TexCoord = new Vector2(s.Left / tW' s.Top / tH);                    this.vertexBufferData[index + 3].Position = new Vector3(p.Right' p.Bottom' 0);                  this.vertexBufferData[index + 3].Normal = normal;                  this.vertexBufferData[index + 3].TexCoord = new Vector2(s.Right / tW' s.Top / tH);                    index += CHARVERTICES;                  remainingVertices -= CHARVERTICES;                  bufferLength += CHARVERTICES;                    if ((index >= BUFFERLENGTH) || (remainingVertices <= 0))                  {                      Mesh mesh = this.CreateMesh();                      mesh.VertexBuffer.SetData(this.vertexBufferData' BUFFERLENGTH' 0);                      mesh.NumVertices = bufferLength;                      mesh.NumPrimitives = (bufferLength * CHARTRIANGLES) / CHARVERTICES;                        this.RenderManager.GraphicsDevice.BindVertexBuffer(mesh.VertexBuffer);                        this.meshes.Add(mesh);                        mesh.VertexBuffer.FreePointer();                        index = 0;                      bufferLength = 0;                  }              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,RefreshMeshes,The following statement contains a magic number: for (int charNum = 0; charNum < totalChars; charNum++)              {                  var charInfo = this.charInfoList[charNum];                  var p = charInfo.Position;                  var s = charInfo.SourceRectangle;                    // Builds the vertex information.                  // Front Vertex                  this.vertexBufferData[index].Position = new Vector3(p.Left' p.Top' 0);                  this.vertexBufferData[index].Normal = normal;                  this.vertexBufferData[index].TexCoord = new Vector2(s.Left / tW' s.Bottom / tH);                    this.vertexBufferData[index + 1].Position = new Vector3(p.Right' p.Top' 0);                  this.vertexBufferData[index + 1].Normal = normal;                  this.vertexBufferData[index + 1].TexCoord = new Vector2(s.Right / tW' s.Bottom / tH);                    this.vertexBufferData[index + 2].Position = new Vector3(p.Left' p.Bottom' 0);                  this.vertexBufferData[index + 2].Normal = normal;                  this.vertexBufferData[index + 2].TexCoord = new Vector2(s.Left / tW' s.Top / tH);                    this.vertexBufferData[index + 3].Position = new Vector3(p.Right' p.Bottom' 0);                  this.vertexBufferData[index + 3].Normal = normal;                  this.vertexBufferData[index + 3].TexCoord = new Vector2(s.Right / tW' s.Top / tH);                    index += CHARVERTICES;                  remainingVertices -= CHARVERTICES;                  bufferLength += CHARVERTICES;                    if ((index >= BUFFERLENGTH) || (remainingVertices <= 0))                  {                      Mesh mesh = this.CreateMesh();                      mesh.VertexBuffer.SetData(this.vertexBufferData' BUFFERLENGTH' 0);                      mesh.NumVertices = bufferLength;                      mesh.NumPrimitives = (bufferLength * CHARTRIANGLES) / CHARVERTICES;                        this.RenderManager.GraphicsDevice.BindVertexBuffer(mesh.VertexBuffer);                        this.meshes.Add(mesh);                        mesh.VertexBuffer.FreePointer();                        index = 0;                      bufferLength = 0;                  }              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,RefreshMeshes,The following statement contains a magic number: for (int charNum = 0; charNum < totalChars; charNum++)              {                  var charInfo = this.charInfoList[charNum];                  var p = charInfo.Position;                  var s = charInfo.SourceRectangle;                    // Builds the vertex information.                  // Front Vertex                  this.vertexBufferData[index].Position = new Vector3(p.Left' p.Top' 0);                  this.vertexBufferData[index].Normal = normal;                  this.vertexBufferData[index].TexCoord = new Vector2(s.Left / tW' s.Bottom / tH);                    this.vertexBufferData[index + 1].Position = new Vector3(p.Right' p.Top' 0);                  this.vertexBufferData[index + 1].Normal = normal;                  this.vertexBufferData[index + 1].TexCoord = new Vector2(s.Right / tW' s.Bottom / tH);                    this.vertexBufferData[index + 2].Position = new Vector3(p.Left' p.Bottom' 0);                  this.vertexBufferData[index + 2].Normal = normal;                  this.vertexBufferData[index + 2].TexCoord = new Vector2(s.Left / tW' s.Top / tH);                    this.vertexBufferData[index + 3].Position = new Vector3(p.Right' p.Bottom' 0);                  this.vertexBufferData[index + 3].Normal = normal;                  this.vertexBufferData[index + 3].TexCoord = new Vector2(s.Right / tW' s.Top / tH);                    index += CHARVERTICES;                  remainingVertices -= CHARVERTICES;                  bufferLength += CHARVERTICES;                    if ((index >= BUFFERLENGTH) || (remainingVertices <= 0))                  {                      Mesh mesh = this.CreateMesh();                      mesh.VertexBuffer.SetData(this.vertexBufferData' BUFFERLENGTH' 0);                      mesh.NumVertices = bufferLength;                      mesh.NumPrimitives = (bufferLength * CHARTRIANGLES) / CHARVERTICES;                        this.RenderManager.GraphicsDevice.BindVertexBuffer(mesh.VertexBuffer);                        this.meshes.Add(mesh);                        mesh.VertexBuffer.FreePointer();                        index = 0;                      bufferLength = 0;                  }              }
Magic Number,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,RefreshMeshes,The following statement contains a magic number: for (int charNum = 0; charNum < totalChars; charNum++)              {                  var charInfo = this.charInfoList[charNum];                  var p = charInfo.Position;                  var s = charInfo.SourceRectangle;                    // Builds the vertex information.                  // Front Vertex                  this.vertexBufferData[index].Position = new Vector3(p.Left' p.Top' 0);                  this.vertexBufferData[index].Normal = normal;                  this.vertexBufferData[index].TexCoord = new Vector2(s.Left / tW' s.Bottom / tH);                    this.vertexBufferData[index + 1].Position = new Vector3(p.Right' p.Top' 0);                  this.vertexBufferData[index + 1].Normal = normal;                  this.vertexBufferData[index + 1].TexCoord = new Vector2(s.Right / tW' s.Bottom / tH);                    this.vertexBufferData[index + 2].Position = new Vector3(p.Left' p.Bottom' 0);                  this.vertexBufferData[index + 2].Normal = normal;                  this.vertexBufferData[index + 2].TexCoord = new Vector2(s.Left / tW' s.Top / tH);                    this.vertexBufferData[index + 3].Position = new Vector3(p.Right' p.Bottom' 0);                  this.vertexBufferData[index + 3].Normal = normal;                  this.vertexBufferData[index + 3].TexCoord = new Vector2(s.Right / tW' s.Top / tH);                    index += CHARVERTICES;                  remainingVertices -= CHARVERTICES;                  bufferLength += CHARVERTICES;                    if ((index >= BUFFERLENGTH) || (remainingVertices <= 0))                  {                      Mesh mesh = this.CreateMesh();                      mesh.VertexBuffer.SetData(this.vertexBufferData' BUFFERLENGTH' 0);                      mesh.NumVertices = bufferLength;                      mesh.NumPrimitives = (bufferLength * CHARTRIANGLES) / CHARVERTICES;                        this.RenderManager.GraphicsDevice.BindVertexBuffer(mesh.VertexBuffer);                        this.meshes.Add(mesh);                        mesh.VertexBuffer.FreePointer();                        index = 0;                      bufferLength = 0;                  }              }
Magic Number,WaveEngine.Components.Transitions,ChequeredAppearTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ChequeredAppearTransition.cs,ChequeredAppearTransition,The following statement contains a magic number: this.segments = 8;
Magic Number,WaveEngine.Components.Transitions,ChequeredAppearTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ChequeredAppearTransition.cs,Draw,The following statement contains a magic number: System.Random random = new System.Random(23);
Magic Number,WaveEngine.Components.Transitions,ColorFadeTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ColorFadeTransition.cs,Draw,The following statement contains a magic number: float factor = (this.Lerp <= 0.5f) ? 2 * this.Lerp : 1 - (2 * (this.Lerp - 0.5f));
Magic Number,WaveEngine.Components.Transitions,ColorFadeTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ColorFadeTransition.cs,Draw,The following statement contains a magic number: float factor = (this.Lerp <= 0.5f) ? 2 * this.Lerp : 1 - (2 * (this.Lerp - 0.5f));
Magic Number,WaveEngine.Components.Transitions,CombTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CombTransition.cs,CombTransition,The following statement contains a magic number: this.segments = 5;
Magic Number,WaveEngine.Components.Transitions,CombTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CombTransition.cs,Draw,The following statement contains a magic number: for (int i = 0; i < this.segments; i++)              {                  Rectangle rect;                  if (this.effectOption == EffectOptions.Horizontal)                  {                      rect = new Rectangle(0' hSegment * i' this.targetRenderTarget.Width' hSegment);                        Rectangle destination = rect;                        if ((i % 2) == 0)                      {                          destination.X = (int)this.position1.X;                          this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f);                            destination.X = (int)this.position1.X + (int)this.initialPosition.X;                          this.spriteBatch.Draw(this.targetRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0);                      }                      else                      {                          destination.X = (int)this.position2.X;                          this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f);                            destination.X = (int)this.position2.X - (int)this.initialPosition.X;                          this.spriteBatch.Draw(this.targetRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0);                      }                  }                  else                  {                      rect = new Rectangle(wSegment * i' 0' wSegment' this.targetRenderTarget.Height);                        Rectangle destination = rect;                        if ((i % 2) == 0)                      {                          destination.Y = (int)this.position1.Y;                          this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f);                            destination.Y = (int)this.position1.Y + (int)this.initialPosition.Y;                          this.spriteBatch.Draw(this.targetRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0);                      }                      else                      {                          destination.Y = (int)this.position2.Y;                          this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f);                            destination.Y = (int)this.position2.Y - (int)this.initialPosition.Y;                          this.spriteBatch.Draw(this.targetRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0);                      }                  }              }
Magic Number,WaveEngine.Components.Transitions,CombTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CombTransition.cs,Draw,The following statement contains a magic number: for (int i = 0; i < this.segments; i++)              {                  Rectangle rect;                  if (this.effectOption == EffectOptions.Horizontal)                  {                      rect = new Rectangle(0' hSegment * i' this.targetRenderTarget.Width' hSegment);                        Rectangle destination = rect;                        if ((i % 2) == 0)                      {                          destination.X = (int)this.position1.X;                          this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f);                            destination.X = (int)this.position1.X + (int)this.initialPosition.X;                          this.spriteBatch.Draw(this.targetRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0);                      }                      else                      {                          destination.X = (int)this.position2.X;                          this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f);                            destination.X = (int)this.position2.X - (int)this.initialPosition.X;                          this.spriteBatch.Draw(this.targetRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0);                      }                  }                  else                  {                      rect = new Rectangle(wSegment * i' 0' wSegment' this.targetRenderTarget.Height);                        Rectangle destination = rect;                        if ((i % 2) == 0)                      {                          destination.Y = (int)this.position1.Y;                          this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f);                            destination.Y = (int)this.position1.Y + (int)this.initialPosition.Y;                          this.spriteBatch.Draw(this.targetRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0);                      }                      else                      {                          destination.Y = (int)this.position2.Y;                          this.spriteBatch.Draw(this.sourceRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0.5f);                            destination.Y = (int)this.position2.Y - (int)this.initialPosition.Y;                          this.spriteBatch.Draw(this.targetRenderTarget' destination' rect' Color.White' 0' Vector2.Zero' SpriteEffects.None' 0);                      }                  }              }
Magic Number,WaveEngine.Components.Transitions,CurtainsTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CurtainsTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,CurtainsTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CurtainsTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,DoorwayTransition,C:\repos\WaveEngine_Components\Shared\Transitions\DoorwayTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,DoorwayTransition,C:\repos\WaveEngine_Components\Shared\Transitions\DoorwayTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,DoorwayTransition,C:\repos\WaveEngine_Components\Shared\Transitions\DoorwayTransition.cs,Draw,The following statement contains a magic number: int middle = width / 2;
Magic Number,WaveEngine.Components.Transitions,FallingLinesTransition,C:\repos\WaveEngine_Components\Shared\Transitions\FallingLinesTransition.cs,FallingLinesTransition,The following statement contains a magic number: this.segments = 60;
Magic Number,WaveEngine.Components.Transitions,FallingLinesTransition,C:\repos\WaveEngine_Components\Shared\Transitions\FallingLinesTransition.cs,Draw,The following statement contains a magic number: System.Random random = new System.Random(23);
Magic Number,WaveEngine.Components.Transitions,FallingLinesTransition,C:\repos\WaveEngine_Components\Shared\Transitions\FallingLinesTransition.cs,Draw,The following statement contains a magic number: for (int x = 0; x < this.segments; x++)              {                  int wsize = (width / this.segments) + 1;                  Rectangle rect = new Rectangle(wsize * x' 0' wsize' height);                    Vector2 pos = new Vector2(rect.X' 0);                    pos.Y += height * (float)Math.Pow(this.Lerp' random.NextDouble() * 10);                    this.spriteBatch.Draw(this.sourceRenderTarget' pos' rect' Color.White' 0f' Vector2.Zero' Vector2.One' SpriteEffects.None' 0f);              }
Magic Number,WaveEngine.Components.Transitions,RotateTransition,C:\repos\WaveEngine_Components\Shared\Transitions\RotateTransition.cs,Draw,The following statement contains a magic number: System.Random random = new System.Random(23);
Magic Number,WaveEngine.Components.Transitions,RotateTransition,C:\repos\WaveEngine_Components\Shared\Transitions\RotateTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,RotateTransition,C:\repos\WaveEngine_Components\Shared\Transitions\RotateTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,ScaleTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ScaleTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,ScaleTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ScaleTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,ShrinkAndSpinTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ShrinkAndSpinTransition.cs,Draw,The following statement contains a magic number: System.Random random = new System.Random(23);
Magic Number,WaveEngine.Components.Transitions,ShrinkAndSpinTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ShrinkAndSpinTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,ShrinkAndSpinTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ShrinkAndSpinTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,ShrinkAndSpinTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ShrinkAndSpinTransition.cs,Draw,The following statement contains a magic number: Vector2 translate = (new Vector2(32' this.sourceRenderTarget.Height - 32) - center) * this.Lerp;
Magic Number,WaveEngine.Components.Transitions,ShrinkAndSpinTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ShrinkAndSpinTransition.cs,Draw,The following statement contains a magic number: Vector2 translate = (new Vector2(32' this.sourceRenderTarget.Height - 32) - center) * this.Lerp;
Magic Number,WaveEngine.Components.Transitions,ShrinkAndSpinTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ShrinkAndSpinTransition.cs,Draw,The following statement contains a magic number: float rotation = this.Lerp * -2;
Magic Number,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,SpinningSquaresTransition,The following statement contains a magic number: this.segments = 8;
Magic Number,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,Draw,The following statement contains a magic number: System.Random random = new System.Random(23);
Magic Number,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,Draw,The following statement contains a magic number: for (int x = 0; x < this.segments; x++)              {                  for (int y = 0; y < this.segments; y++)                  {                      Rectangle rect = new Rectangle(                          this.targetRenderTarget.Width * x / this.segments'                          this.targetRenderTarget.Height * y / this.segments'                          this.targetRenderTarget.Width / this.segments'                          this.targetRenderTarget.Height / this.segments);                        Vector2 origin = new Vector2(rect.Width' rect.Height) / 2;                      float inverse = 1 - this.Lerp;                        float rotation = (float)(random.NextDouble() - 0.5) * this.Lerp * 2;                      Vector2 scale = new Vector2(1 + (float)((random.NextDouble() - 0.5f) * this.Lerp));                        Vector2 pos = new Vector2(rect.Center.X' rect.Center.Y);                        pos.X += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Width / 2);                      pos.Y += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Height / 2);                        this.spriteBatch.Draw(this.sourceRenderTarget' pos' rect' Color.White * inverse' rotation' origin' scale' 0' 0);                  }              }
Magic Number,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,Draw,The following statement contains a magic number: for (int x = 0; x < this.segments; x++)              {                  for (int y = 0; y < this.segments; y++)                  {                      Rectangle rect = new Rectangle(                          this.targetRenderTarget.Width * x / this.segments'                          this.targetRenderTarget.Height * y / this.segments'                          this.targetRenderTarget.Width / this.segments'                          this.targetRenderTarget.Height / this.segments);                        Vector2 origin = new Vector2(rect.Width' rect.Height) / 2;                      float inverse = 1 - this.Lerp;                        float rotation = (float)(random.NextDouble() - 0.5) * this.Lerp * 2;                      Vector2 scale = new Vector2(1 + (float)((random.NextDouble() - 0.5f) * this.Lerp));                        Vector2 pos = new Vector2(rect.Center.X' rect.Center.Y);                        pos.X += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Width / 2);                      pos.Y += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Height / 2);                        this.spriteBatch.Draw(this.sourceRenderTarget' pos' rect' Color.White * inverse' rotation' origin' scale' 0' 0);                  }              }
Magic Number,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,Draw,The following statement contains a magic number: for (int x = 0; x < this.segments; x++)              {                  for (int y = 0; y < this.segments; y++)                  {                      Rectangle rect = new Rectangle(                          this.targetRenderTarget.Width * x / this.segments'                          this.targetRenderTarget.Height * y / this.segments'                          this.targetRenderTarget.Width / this.segments'                          this.targetRenderTarget.Height / this.segments);                        Vector2 origin = new Vector2(rect.Width' rect.Height) / 2;                      float inverse = 1 - this.Lerp;                        float rotation = (float)(random.NextDouble() - 0.5) * this.Lerp * 2;                      Vector2 scale = new Vector2(1 + (float)((random.NextDouble() - 0.5f) * this.Lerp));                        Vector2 pos = new Vector2(rect.Center.X' rect.Center.Y);                        pos.X += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Width / 2);                      pos.Y += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Height / 2);                        this.spriteBatch.Draw(this.sourceRenderTarget' pos' rect' Color.White * inverse' rotation' origin' scale' 0' 0);                  }              }
Magic Number,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,Draw,The following statement contains a magic number: for (int x = 0; x < this.segments; x++)              {                  for (int y = 0; y < this.segments; y++)                  {                      Rectangle rect = new Rectangle(                          this.targetRenderTarget.Width * x / this.segments'                          this.targetRenderTarget.Height * y / this.segments'                          this.targetRenderTarget.Width / this.segments'                          this.targetRenderTarget.Height / this.segments);                        Vector2 origin = new Vector2(rect.Width' rect.Height) / 2;                      float inverse = 1 - this.Lerp;                        float rotation = (float)(random.NextDouble() - 0.5) * this.Lerp * 2;                      Vector2 scale = new Vector2(1 + (float)((random.NextDouble() - 0.5f) * this.Lerp));                        Vector2 pos = new Vector2(rect.Center.X' rect.Center.Y);                        pos.X += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Width / 2);                      pos.Y += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Height / 2);                        this.spriteBatch.Draw(this.sourceRenderTarget' pos' rect' Color.White * inverse' rotation' origin' scale' 0' 0);                  }              }
Magic Number,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,Draw,The following statement contains a magic number: for (int x = 0; x < this.segments; x++)              {                  for (int y = 0; y < this.segments; y++)                  {                      Rectangle rect = new Rectangle(                          this.targetRenderTarget.Width * x / this.segments'                          this.targetRenderTarget.Height * y / this.segments'                          this.targetRenderTarget.Width / this.segments'                          this.targetRenderTarget.Height / this.segments);                        Vector2 origin = new Vector2(rect.Width' rect.Height) / 2;                      float inverse = 1 - this.Lerp;                        float rotation = (float)(random.NextDouble() - 0.5) * this.Lerp * 2;                      Vector2 scale = new Vector2(1 + (float)((random.NextDouble() - 0.5f) * this.Lerp));                        Vector2 pos = new Vector2(rect.Center.X' rect.Center.Y);                        pos.X += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Width / 2);                      pos.Y += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Height / 2);                        this.spriteBatch.Draw(this.sourceRenderTarget' pos' rect' Color.White * inverse' rotation' origin' scale' 0' 0);                  }              }
Magic Number,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,Draw,The following statement contains a magic number: for (int x = 0; x < this.segments; x++)              {                  for (int y = 0; y < this.segments; y++)                  {                      Rectangle rect = new Rectangle(                          this.targetRenderTarget.Width * x / this.segments'                          this.targetRenderTarget.Height * y / this.segments'                          this.targetRenderTarget.Width / this.segments'                          this.targetRenderTarget.Height / this.segments);                        Vector2 origin = new Vector2(rect.Width' rect.Height) / 2;                      float inverse = 1 - this.Lerp;                        float rotation = (float)(random.NextDouble() - 0.5) * this.Lerp * 2;                      Vector2 scale = new Vector2(1 + (float)((random.NextDouble() - 0.5f) * this.Lerp));                        Vector2 pos = new Vector2(rect.Center.X' rect.Center.Y);                        pos.X += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Width / 2);                      pos.Y += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Height / 2);                        this.spriteBatch.Draw(this.sourceRenderTarget' pos' rect' Color.White * inverse' rotation' origin' scale' 0' 0);                  }              }
Magic Number,WaveEngine.Components.Transitions,SpinningSquaresTransition,C:\repos\WaveEngine_Components\Shared\Transitions\SpinningSquaresTransition.cs,Draw,The following statement contains a magic number: for (int x = 0; x < this.segments; x++)              {                  for (int y = 0; y < this.segments; y++)                  {                      Rectangle rect = new Rectangle(                          this.targetRenderTarget.Width * x / this.segments'                          this.targetRenderTarget.Height * y / this.segments'                          this.targetRenderTarget.Width / this.segments'                          this.targetRenderTarget.Height / this.segments);                        Vector2 origin = new Vector2(rect.Width' rect.Height) / 2;                      float inverse = 1 - this.Lerp;                        float rotation = (float)(random.NextDouble() - 0.5) * this.Lerp * 2;                      Vector2 scale = new Vector2(1 + (float)((random.NextDouble() - 0.5f) * this.Lerp));                        Vector2 pos = new Vector2(rect.Center.X' rect.Center.Y);                        pos.X += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Width / 2);                      pos.Y += (float)(random.NextDouble() - 0.5) * this.Lerp * (this.targetRenderTarget.Height / 2);                        this.spriteBatch.Draw(this.sourceRenderTarget' pos' rect' Color.White * inverse' rotation' origin' scale' 0' 0);                  }              }
Magic Number,WaveEngine.Components.Transitions,ZoomTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ZoomTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.Transitions,ZoomTransition,C:\repos\WaveEngine_Components\Shared\Transitions\ZoomTransition.cs,Draw,The following statement contains a magic number: Vector2 center = new Vector2(this.sourceRenderTarget.Width / 2' this.sourceRenderTarget.Height / 2);
Magic Number,WaveEngine.Components.UI,CheckBox,C:\repos\WaveEngine_Components\Shared\UI\CheckBox\CheckBox.cs,CheckBox,The following statement contains a magic number: this.entity = new Entity(name)                             .AddComponent(new Transform2D())                             .AddComponent(new RectangleCollider2D())                             .AddComponent(new TouchGestures(false))                             .AddComponent(new CheckBoxBehavior())                             .AddComponent(new GridControl(150' 42))                             .AddComponent(new GridRenderer());
Magic Number,WaveEngine.Components.UI,CheckBox,C:\repos\WaveEngine_Components\Shared\UI\CheckBox\CheckBox.cs,CheckBox,The following statement contains a magic number: this.entity = new Entity(name)                             .AddComponent(new Transform2D())                             .AddComponent(new RectangleCollider2D())                             .AddComponent(new TouchGestures(false))                             .AddComponent(new CheckBoxBehavior())                             .AddComponent(new GridControl(150' 42))                             .AddComponent(new GridRenderer());
Magic Number,WaveEngine.Components.UI,ImageControl,C:\repos\WaveEngine_Components\Shared\UI\Image\ImageControl.cs,Arrange,The following statement contains a magic number: switch (this.HorizontalAlignment)              {                  case HorizontalAlignment.Left:                      currentRect.X = finalSize.X + this.Margin.Left;                      break;                  case HorizontalAlignment.Center:                      currentRect.X = finalSize.X + (finalSize.Width / 2) - (rect.Width / 2) - this.Margin.Right + this.Margin.Left;                      break;                  case HorizontalAlignment.Right:                      currentRect.X = finalSize.X + finalSize.Width - this.Margin.Right - rect.Width;                      break;                  case HorizontalAlignment.Stretch:                      break;              }
Magic Number,WaveEngine.Components.UI,ImageControl,C:\repos\WaveEngine_Components\Shared\UI\Image\ImageControl.cs,Arrange,The following statement contains a magic number: switch (this.HorizontalAlignment)              {                  case HorizontalAlignment.Left:                      currentRect.X = finalSize.X + this.Margin.Left;                      break;                  case HorizontalAlignment.Center:                      currentRect.X = finalSize.X + (finalSize.Width / 2) - (rect.Width / 2) - this.Margin.Right + this.Margin.Left;                      break;                  case HorizontalAlignment.Right:                      currentRect.X = finalSize.X + finalSize.Width - this.Margin.Right - rect.Width;                      break;                  case HorizontalAlignment.Stretch:                      break;              }
Magic Number,WaveEngine.Components.UI,ImageControl,C:\repos\WaveEngine_Components\Shared\UI\Image\ImageControl.cs,Arrange,The following statement contains a magic number: switch (this.VerticalAlignment)              {                  case VerticalAlignment.Top:                      currentRect.Y = finalSize.Y + this.Margin.Top;                      break;                  case VerticalAlignment.Center:                      currentRect.Y = finalSize.Y + (finalSize.Height / 2) - (rect.Height / 2) - this.Margin.Bottom + this.Margin.Top;                      break;                  case VerticalAlignment.Bottom:                      currentRect.Y = finalSize.Y + finalSize.Height - this.Margin.Bottom - rect.Height;                      break;                  case VerticalAlignment.Stretch:                      break;              }
Magic Number,WaveEngine.Components.UI,ImageControl,C:\repos\WaveEngine_Components\Shared\UI\Image\ImageControl.cs,Arrange,The following statement contains a magic number: switch (this.VerticalAlignment)              {                  case VerticalAlignment.Top:                      currentRect.Y = finalSize.Y + this.Margin.Top;                      break;                  case VerticalAlignment.Center:                      currentRect.Y = finalSize.Y + (finalSize.Height / 2) - (rect.Height / 2) - this.Margin.Bottom + this.Margin.Top;                      break;                  case VerticalAlignment.Bottom:                      currentRect.Y = finalSize.Y + finalSize.Height - this.Margin.Bottom - rect.Height;                      break;                  case VerticalAlignment.Stretch:                      break;              }
Magic Number,WaveEngine.Components.UI,ProgressBar,C:\repos\WaveEngine_Components\Shared\UI\ProgressBar\ProgressBar.cs,ProgressBar,The following statement contains a magic number: this.entity = new Entity(name)                             .AddComponent(new Transform2D())                             .AddComponent(new RectangleCollider2D())                             .AddComponent(new TouchGestures(false))                             .AddComponent(new PanelControl(100' 20))                             .AddComponent(new PanelControlRenderer())                             .AddComponent(new ProgressBarBehavior())                             .AddChild(new Entity("BackgroundEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.5f                                  })                                  .AddComponent(new ImageControl(Color.Blue' 1' 1))                                  .AddComponent(new ImageControlRenderer()))                              .AddChild(new Entity("ForegroundEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.45f                                  })                                  .AddComponent(new AnimationUI())                                  .AddComponent(new ImageControl(Color.LightBlue' 1' 1))                                  .AddComponent(new ImageControlRenderer()));
Magic Number,WaveEngine.Components.UI,ProgressBar,C:\repos\WaveEngine_Components\Shared\UI\ProgressBar\ProgressBar.cs,ProgressBar,The following statement contains a magic number: this.entity = new Entity(name)                             .AddComponent(new Transform2D())                             .AddComponent(new RectangleCollider2D())                             .AddComponent(new TouchGestures(false))                             .AddComponent(new PanelControl(100' 20))                             .AddComponent(new PanelControlRenderer())                             .AddComponent(new ProgressBarBehavior())                             .AddChild(new Entity("BackgroundEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.5f                                  })                                  .AddComponent(new ImageControl(Color.Blue' 1' 1))                                  .AddComponent(new ImageControlRenderer()))                              .AddChild(new Entity("ForegroundEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.45f                                  })                                  .AddComponent(new AnimationUI())                                  .AddComponent(new ImageControl(Color.LightBlue' 1' 1))                                  .AddComponent(new ImageControlRenderer()));
Magic Number,WaveEngine.Components.UI,ProgressBarBehavior,C:\repos\WaveEngine_Components\Shared\UI\ProgressBar\ProgressBarBehavior.cs,ProgressBarBehavior,The following statement contains a magic number: this.maximum = 100;
Magic Number,WaveEngine.Components.UI,RadioButton,C:\repos\WaveEngine_Components\Shared\UI\RadioButton\RadioButton.cs,RadioButton,The following statement contains a magic number: this.entity = new Entity(name)                             .AddComponent(new Transform2D())                             .AddComponent(new RectangleCollider2D())                             .AddComponent(new TouchGestures(false))                             .AddComponent(new RadioButtonBehavior())                             .AddComponent(new GridControl(170' 42))                             .AddComponent(new GridRenderer());
Magic Number,WaveEngine.Components.UI,RadioButton,C:\repos\WaveEngine_Components\Shared\UI\RadioButton\RadioButton.cs,RadioButton,The following statement contains a magic number: this.entity = new Entity(name)                             .AddComponent(new Transform2D())                             .AddComponent(new RectangleCollider2D())                             .AddComponent(new TouchGestures(false))                             .AddComponent(new RadioButtonBehavior())                             .AddComponent(new GridControl(170' 42))                             .AddComponent(new GridRenderer());
Magic Number,WaveEngine.Components.UI,Slider,C:\repos\WaveEngine_Components\Shared\UI\Slider\Slider.cs,Slider,The following statement contains a magic number: this.entity = new Entity(name)                             .AddComponent(new Transform2D())                             .AddComponent(new RectangleCollider2D())                             .AddComponent(new TouchGestures(false))                             .AddComponent(new PanelControl(100' 20))                             .AddComponent(new PanelControlRenderer())                             .AddComponent(new SliderBehavior())                             .AddChild(new Entity("BackgroundEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.5f                                  })                                  .AddComponent(new ImageControl(Color.Blue' 1' 1))                                  .AddComponent(new ImageControlRenderer()))                              .AddChild(new Entity("ForegroundEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.45f                                  })                                  .AddComponent(new ImageControl(Color.LightBlue' 1' 1))                                  .AddComponent(new ImageControlRenderer()))                              .AddChild(new Entity("BulletEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.4f                                  })                                  .AddComponent(new ImageControl(Color.White' 1' 1))                                  .AddComponent(new ImageControlRenderer()))                              .AddChild(new Entity("TextEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.4f'                                      Opacity = 0                                  })                                  .AddComponent(new AnimationUI())                                  .AddComponent(new TextControl())                                  .AddComponent(new TextControlRenderer()));
Magic Number,WaveEngine.Components.UI,Slider,C:\repos\WaveEngine_Components\Shared\UI\Slider\Slider.cs,Slider,The following statement contains a magic number: this.entity = new Entity(name)                             .AddComponent(new Transform2D())                             .AddComponent(new RectangleCollider2D())                             .AddComponent(new TouchGestures(false))                             .AddComponent(new PanelControl(100' 20))                             .AddComponent(new PanelControlRenderer())                             .AddComponent(new SliderBehavior())                             .AddChild(new Entity("BackgroundEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.5f                                  })                                  .AddComponent(new ImageControl(Color.Blue' 1' 1))                                  .AddComponent(new ImageControlRenderer()))                              .AddChild(new Entity("ForegroundEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.45f                                  })                                  .AddComponent(new ImageControl(Color.LightBlue' 1' 1))                                  .AddComponent(new ImageControlRenderer()))                              .AddChild(new Entity("BulletEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.4f                                  })                                  .AddComponent(new ImageControl(Color.White' 1' 1))                                  .AddComponent(new ImageControlRenderer()))                              .AddChild(new Entity("TextEntity")                                  .AddComponent(new Transform2D()                                  {                                      DrawOrder = 0.4f'                                      Opacity = 0                                  })                                  .AddComponent(new AnimationUI())                                  .AddComponent(new TextControl())                                  .AddComponent(new TextControlRenderer()));
Magic Number,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,SliderBehavior,The following statement contains a magic number: this.maximum = 100;
Magic Number,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,UpdateOrientation,The following statement contains a magic number: switch (this.orientation)              {                  case Orientation.Vertical:                        if (this.backgroundImage != null && this.foregroundImage != null && this.foregroundTransform != null                          && this.bulletImage != null && this.bulletTransform != null && this.textControl != null &&                          this.textTransform != null && this.Panel != null)                      {                          this.maximunOffset = this.Panel.Height - this.bulletImage.Height;                          this.bulletWeightOver2 = this.bulletImage.Height / 2;                          this.maximunOffsetOver2 = this.Panel.Height - this.bulletImage.Height - this.bulletWeightOver2;                            this.backgroundImage.Width = DefaultSliderWeight;                          this.backgroundImage.Height = this.Panel.Height;                            this.foregroundImage.Width = DefaultSliderWeight;                          this.foregroundImage.Height = 1;                          this.foregroundImage.Margin = new Thickness(0' this.Panel.Height' 0' 0);                            this.foregroundTransform.Origin = Vector2.UnitX / 2;                          this.foregroundTransform.Rotation = MathHelper.Pi;                          this.foregroundTransform.XScale = 1;                            this.bulletImage.Margin = new Thickness(0' this.Panel.Height - this.bulletImage.Height' 0' 0);                            this.bulletTransform.X = 0;                            this.bulletTransform.Y = 0;                            this.textControl.Margin = new Thickness(-DefaultTextOffset' this.Panel.Height - (this.bulletImage.Height * 1.5f)' 0' 0);                            this.textTransform.X = 0;                      }                        break;                  case Orientation.Horizontal:                        if (this.backgroundImage != null && this.foregroundImage != null && this.foregroundTransform != null                          && this.bulletImage != null && this.bulletTransform != null && this.textControl != null &&                          this.textTransform != null && this.Panel != null)                      {                          this.maximunOffset = this.Panel.Width - this.bulletImage.Width;                          this.bulletWeightOver2 = this.bulletImage.Width / 2;                          this.maximunOffsetOver2 = this.Panel.Width - this.bulletWeightOver2;                            this.backgroundImage.Width = this.Panel.Width;                          this.backgroundImage.Height = DefaultSliderWeight;                            this.foregroundImage.Height = DefaultSliderWeight;                          this.foregroundImage.Width = 1;                          this.foregroundImage.Margin = Thickness.Zero;                            this.foregroundTransform.Origin = Vector2.Zero;                          this.foregroundTransform.Rotation = 0;                          this.foregroundTransform.YScale = 1;                            this.bulletImage.Margin = Thickness.Zero;                            this.bulletTransform.X = 0;                            this.bulletTransform.Y = 0;                            this.textControl.Margin = new Thickness(0' -DefaultTextOffset' 0' 0);                            this.textTransform.Y = 0;                      }                        break;              }
Magic Number,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,UpdateOrientation,The following statement contains a magic number: switch (this.orientation)              {                  case Orientation.Vertical:                        if (this.backgroundImage != null && this.foregroundImage != null && this.foregroundTransform != null                          && this.bulletImage != null && this.bulletTransform != null && this.textControl != null &&                          this.textTransform != null && this.Panel != null)                      {                          this.maximunOffset = this.Panel.Height - this.bulletImage.Height;                          this.bulletWeightOver2 = this.bulletImage.Height / 2;                          this.maximunOffsetOver2 = this.Panel.Height - this.bulletImage.Height - this.bulletWeightOver2;                            this.backgroundImage.Width = DefaultSliderWeight;                          this.backgroundImage.Height = this.Panel.Height;                            this.foregroundImage.Width = DefaultSliderWeight;                          this.foregroundImage.Height = 1;                          this.foregroundImage.Margin = new Thickness(0' this.Panel.Height' 0' 0);                            this.foregroundTransform.Origin = Vector2.UnitX / 2;                          this.foregroundTransform.Rotation = MathHelper.Pi;                          this.foregroundTransform.XScale = 1;                            this.bulletImage.Margin = new Thickness(0' this.Panel.Height - this.bulletImage.Height' 0' 0);                            this.bulletTransform.X = 0;                            this.bulletTransform.Y = 0;                            this.textControl.Margin = new Thickness(-DefaultTextOffset' this.Panel.Height - (this.bulletImage.Height * 1.5f)' 0' 0);                            this.textTransform.X = 0;                      }                        break;                  case Orientation.Horizontal:                        if (this.backgroundImage != null && this.foregroundImage != null && this.foregroundTransform != null                          && this.bulletImage != null && this.bulletTransform != null && this.textControl != null &&                          this.textTransform != null && this.Panel != null)                      {                          this.maximunOffset = this.Panel.Width - this.bulletImage.Width;                          this.bulletWeightOver2 = this.bulletImage.Width / 2;                          this.maximunOffsetOver2 = this.Panel.Width - this.bulletWeightOver2;                            this.backgroundImage.Width = this.Panel.Width;                          this.backgroundImage.Height = DefaultSliderWeight;                            this.foregroundImage.Height = DefaultSliderWeight;                          this.foregroundImage.Width = 1;                          this.foregroundImage.Margin = Thickness.Zero;                            this.foregroundTransform.Origin = Vector2.Zero;                          this.foregroundTransform.Rotation = 0;                          this.foregroundTransform.YScale = 1;                            this.bulletImage.Margin = Thickness.Zero;                            this.bulletTransform.X = 0;                            this.bulletTransform.Y = 0;                            this.textControl.Margin = new Thickness(0' -DefaultTextOffset' 0' 0);                            this.textTransform.Y = 0;                      }                        break;              }
Magic Number,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,UpdateOrientation,The following statement contains a magic number: switch (this.orientation)              {                  case Orientation.Vertical:                        if (this.backgroundImage != null && this.foregroundImage != null && this.foregroundTransform != null                          && this.bulletImage != null && this.bulletTransform != null && this.textControl != null &&                          this.textTransform != null && this.Panel != null)                      {                          this.maximunOffset = this.Panel.Height - this.bulletImage.Height;                          this.bulletWeightOver2 = this.bulletImage.Height / 2;                          this.maximunOffsetOver2 = this.Panel.Height - this.bulletImage.Height - this.bulletWeightOver2;                            this.backgroundImage.Width = DefaultSliderWeight;                          this.backgroundImage.Height = this.Panel.Height;                            this.foregroundImage.Width = DefaultSliderWeight;                          this.foregroundImage.Height = 1;                          this.foregroundImage.Margin = new Thickness(0' this.Panel.Height' 0' 0);                            this.foregroundTransform.Origin = Vector2.UnitX / 2;                          this.foregroundTransform.Rotation = MathHelper.Pi;                          this.foregroundTransform.XScale = 1;                            this.bulletImage.Margin = new Thickness(0' this.Panel.Height - this.bulletImage.Height' 0' 0);                            this.bulletTransform.X = 0;                            this.bulletTransform.Y = 0;                            this.textControl.Margin = new Thickness(-DefaultTextOffset' this.Panel.Height - (this.bulletImage.Height * 1.5f)' 0' 0);                            this.textTransform.X = 0;                      }                        break;                  case Orientation.Horizontal:                        if (this.backgroundImage != null && this.foregroundImage != null && this.foregroundTransform != null                          && this.bulletImage != null && this.bulletTransform != null && this.textControl != null &&                          this.textTransform != null && this.Panel != null)                      {                          this.maximunOffset = this.Panel.Width - this.bulletImage.Width;                          this.bulletWeightOver2 = this.bulletImage.Width / 2;                          this.maximunOffsetOver2 = this.Panel.Width - this.bulletWeightOver2;                            this.backgroundImage.Width = this.Panel.Width;                          this.backgroundImage.Height = DefaultSliderWeight;                            this.foregroundImage.Height = DefaultSliderWeight;                          this.foregroundImage.Width = 1;                          this.foregroundImage.Margin = Thickness.Zero;                            this.foregroundTransform.Origin = Vector2.Zero;                          this.foregroundTransform.Rotation = 0;                          this.foregroundTransform.YScale = 1;                            this.bulletImage.Margin = Thickness.Zero;                            this.bulletTransform.X = 0;                            this.bulletTransform.Y = 0;                            this.textControl.Margin = new Thickness(0' -DefaultTextOffset' 0' 0);                            this.textTransform.Y = 0;                      }                        break;              }
Magic Number,WaveEngine.Components.UI,TextBlock,C:\repos\WaveEngine_Components\Shared\UI\TextBlock\TextBlock.cs,TextBlock,The following statement contains a magic number: this.entity = new Entity(name)                                  .AddComponent(new Transform2D())                                  .AddComponent(new PanelControl(100' 30))                                  .AddComponent(new PanelControlRenderer())                                  .AddChild(new Entity("TextEntity")                                      .AddComponent(new Transform2D())                                      .AddComponent(new TextControl()                                      {                                          Text = "TextBlock"                                      })                                      .AddComponent(new TextControlRenderer(layer)));
Magic Number,WaveEngine.Components.UI,TextBlock,C:\repos\WaveEngine_Components\Shared\UI\TextBlock\TextBlock.cs,TextBlock,The following statement contains a magic number: this.entity = new Entity(name)                                  .AddComponent(new Transform2D())                                  .AddComponent(new PanelControl(100' 30))                                  .AddComponent(new PanelControlRenderer())                                  .AddChild(new Entity("TextEntity")                                      .AddComponent(new Transform2D())                                      .AddComponent(new TextControl()                                      {                                          Text = "TextBlock"                                      })                                      .AddComponent(new TextControlRenderer(layer)));
Magic Number,WaveEngine.Components.UI,TextControl,C:\repos\WaveEngine_Components\Shared\UI\TextBlock\TextControl.cs,CalculateAlignmentOffset,The following statement contains a magic number: switch (this.textAlignment)              {                  case TextAlignment.Left:                      break;                  case TextAlignment.Right:                        if (size.X < this.width)                      {                          offsetX = this.width - size.X;                      }                        break;                  case TextAlignment.Center:                        if (size.X < this.width)                      {                          offsetX = (this.width - size.X) / 2;                      }                        break;              }
Magic Number,WaveEngine.Components.UI,TextBox,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBox.cs,TextBox,The following statement contains a magic number: this.entity = new Entity(name)                                  .AddComponent(new Transform2D())                                  .AddComponent(new TextBoxBehavior())                                  .AddComponent(new RectangleCollider2D())                                  .AddComponent(new TouchGestures(false))                                  .AddComponent(new PanelControl(100' 30))                                  .AddComponent(new PanelControlRenderer())                                  .AddChild(new Entity("ImageEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.55f                                      })                                      .AddComponent(new ImageControl(Color.White' 100' 30))                                      .AddComponent(new ImageControlRenderer()))                                  .AddChild(new Entity("TextEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.4f                                      })                                      .AddComponent(new TextControl()                                      {                                          Text = "TextBox"'                                          Foreground = Color.Black                                      })                                      .AddComponent(new TextControlRenderer()))                                  .AddChild(new Entity("CursorEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.35f'                                          Opacity = 0f                                      })                                      .AddComponent(new AnimationUI())                                      .AddComponent(new ImageControl(Color.Black' 2' 30))                                      .AddComponent(new ImageControlRenderer()));
Magic Number,WaveEngine.Components.UI,TextBox,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBox.cs,TextBox,The following statement contains a magic number: this.entity = new Entity(name)                                  .AddComponent(new Transform2D())                                  .AddComponent(new TextBoxBehavior())                                  .AddComponent(new RectangleCollider2D())                                  .AddComponent(new TouchGestures(false))                                  .AddComponent(new PanelControl(100' 30))                                  .AddComponent(new PanelControlRenderer())                                  .AddChild(new Entity("ImageEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.55f                                      })                                      .AddComponent(new ImageControl(Color.White' 100' 30))                                      .AddComponent(new ImageControlRenderer()))                                  .AddChild(new Entity("TextEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.4f                                      })                                      .AddComponent(new TextControl()                                      {                                          Text = "TextBox"'                                          Foreground = Color.Black                                      })                                      .AddComponent(new TextControlRenderer()))                                  .AddChild(new Entity("CursorEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.35f'                                          Opacity = 0f                                      })                                      .AddComponent(new AnimationUI())                                      .AddComponent(new ImageControl(Color.Black' 2' 30))                                      .AddComponent(new ImageControlRenderer()));
Magic Number,WaveEngine.Components.UI,TextBox,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBox.cs,TextBox,The following statement contains a magic number: this.entity = new Entity(name)                                  .AddComponent(new Transform2D())                                  .AddComponent(new TextBoxBehavior())                                  .AddComponent(new RectangleCollider2D())                                  .AddComponent(new TouchGestures(false))                                  .AddComponent(new PanelControl(100' 30))                                  .AddComponent(new PanelControlRenderer())                                  .AddChild(new Entity("ImageEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.55f                                      })                                      .AddComponent(new ImageControl(Color.White' 100' 30))                                      .AddComponent(new ImageControlRenderer()))                                  .AddChild(new Entity("TextEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.4f                                      })                                      .AddComponent(new TextControl()                                      {                                          Text = "TextBox"'                                          Foreground = Color.Black                                      })                                      .AddComponent(new TextControlRenderer()))                                  .AddChild(new Entity("CursorEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.35f'                                          Opacity = 0f                                      })                                      .AddComponent(new AnimationUI())                                      .AddComponent(new ImageControl(Color.Black' 2' 30))                                      .AddComponent(new ImageControlRenderer()));
Magic Number,WaveEngine.Components.UI,TextBox,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBox.cs,TextBox,The following statement contains a magic number: this.entity = new Entity(name)                                  .AddComponent(new Transform2D())                                  .AddComponent(new TextBoxBehavior())                                  .AddComponent(new RectangleCollider2D())                                  .AddComponent(new TouchGestures(false))                                  .AddComponent(new PanelControl(100' 30))                                  .AddComponent(new PanelControlRenderer())                                  .AddChild(new Entity("ImageEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.55f                                      })                                      .AddComponent(new ImageControl(Color.White' 100' 30))                                      .AddComponent(new ImageControlRenderer()))                                  .AddChild(new Entity("TextEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.4f                                      })                                      .AddComponent(new TextControl()                                      {                                          Text = "TextBox"'                                          Foreground = Color.Black                                      })                                      .AddComponent(new TextControlRenderer()))                                  .AddChild(new Entity("CursorEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.35f'                                          Opacity = 0f                                      })                                      .AddComponent(new AnimationUI())                                      .AddComponent(new ImageControl(Color.Black' 2' 30))                                      .AddComponent(new ImageControlRenderer()));
Magic Number,WaveEngine.Components.UI,TextBox,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBox.cs,TextBox,The following statement contains a magic number: this.entity = new Entity(name)                                  .AddComponent(new Transform2D())                                  .AddComponent(new TextBoxBehavior())                                  .AddComponent(new RectangleCollider2D())                                  .AddComponent(new TouchGestures(false))                                  .AddComponent(new PanelControl(100' 30))                                  .AddComponent(new PanelControlRenderer())                                  .AddChild(new Entity("ImageEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.55f                                      })                                      .AddComponent(new ImageControl(Color.White' 100' 30))                                      .AddComponent(new ImageControlRenderer()))                                  .AddChild(new Entity("TextEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.4f                                      })                                      .AddComponent(new TextControl()                                      {                                          Text = "TextBox"'                                          Foreground = Color.Black                                      })                                      .AddComponent(new TextControlRenderer()))                                  .AddChild(new Entity("CursorEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.35f'                                          Opacity = 0f                                      })                                      .AddComponent(new AnimationUI())                                      .AddComponent(new ImageControl(Color.Black' 2' 30))                                      .AddComponent(new ImageControlRenderer()));
Magic Number,WaveEngine.Components.UI,TextBox,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBox.cs,TextBox,The following statement contains a magic number: this.entity = new Entity(name)                                  .AddComponent(new Transform2D())                                  .AddComponent(new TextBoxBehavior())                                  .AddComponent(new RectangleCollider2D())                                  .AddComponent(new TouchGestures(false))                                  .AddComponent(new PanelControl(100' 30))                                  .AddComponent(new PanelControlRenderer())                                  .AddChild(new Entity("ImageEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.55f                                      })                                      .AddComponent(new ImageControl(Color.White' 100' 30))                                      .AddComponent(new ImageControlRenderer()))                                  .AddChild(new Entity("TextEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.4f                                      })                                      .AddComponent(new TextControl()                                      {                                          Text = "TextBox"'                                          Foreground = Color.Black                                      })                                      .AddComponent(new TextControlRenderer()))                                  .AddChild(new Entity("CursorEntity")                                      .AddComponent(new Transform2D()                                      {                                          DrawOrder = 0.35f'                                          Opacity = 0f                                      })                                      .AddComponent(new AnimationUI())                                      .AddComponent(new ImageControl(Color.Black' 2' 30))                                      .AddComponent(new ImageControlRenderer()));
Magic Number,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,Gestures_TouchPressed,The following statement contains a magic number: if (this.inputService.KeyboardState.IsConnected)              {                  float clickX = e.GestureSample.Position.X - this.Transform.Rectangle.X;                  float clickY = e.GestureSample.Position.Y - this.Transform.Rectangle.Y;                    // Cursor position Y                  float posY = this.textControl.LineSpacing;                  int lineIndex = 0;                  while (lineIndex < this.textControl.LinesInfo.Count - 1 &&                         posY + this.textControl.FontHeight < clickY)                  {                      posY += this.textControl.FontHeight + this.textControl.LineSpacing;                      lineIndex++;                  }                    // Cursor position X                  float posX = 0;                  if (this.textControl.LinesInfo.Count > 0)                  {                      LineInfo lineInfo = this.textControl.LinesInfo[lineIndex];                      if (posY + this.textControl.FontHeight < clickY)                      {                          // Outside of textControl                          posX = lineInfo.AlignmentOffsetX + lineInfo.Size.X;                          this.textBeforeCursor = this.textControl.Text;                          this.textAfterCursor = string.Empty;                      }                      else                      {                          // Search X position                          posX = lineInfo.AlignmentOffsetX;                          float maxOffsetX = lineInfo.AlignmentOffsetX + lineInfo.Size.X;                          int characterIndex = 0;                          string currentLineText = lineInfo.SubTextList[0].Text;                          float characterOffset = this.textControl.SpriteFont.MeasureString(currentLineText[characterIndex].ToString()).X;                          while (posX <= maxOffsetX &&                                 posX + (characterOffset / 2) < clickX)                          {                              posX += characterOffset;                              if (characterIndex < currentLineText.Length - 1)                              {                                  characterIndex++;                                  characterOffset = this.textControl.SpriteFont.MeasureString(currentLineText[characterIndex].ToString()).X;                              }                              else                              {                                  break;                              }                          }                            // Text before cursor                          List<LineInfo> linesInfo = this.textControl.LinesInfo;                          this.textBeforeCursor = string.Empty;                          for (int i = 0; i < lineIndex; i++)                          {                              this.textBeforeCursor += this.textControl.LinesInfo[i].SubTextList[0].Text;                          }                            this.textBeforeCursor += currentLineText.Substring(0' characterIndex);                            // Text After cursor                          this.textAfterCursor = currentLineText.Substring(characterIndex);                          for (int i = lineIndex + 1; i < this.textControl.LinesInfo.Count; i++)                          {                              this.textAfterCursor += this.textControl.LinesInfo[i].SubTextList[0].Text;                          }                      }                  }                    // Final positions                  this.cursorTransform.X = posX;                  this.cursorTransform.Y = posY;                  this.cursorAnimation.BeginAnimation(Transform2D.OpacityProperty' this.flicker);              }              else              {                  this.ShowScreenKeyboard();              }
Magic Number,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,RemoveBackCharacter,The following statement contains a magic number: if (text.Length < 2)              {                  this.textBeforeCursor = string.Empty;              }              else if (text.Length > 4)              {                  string fourLast = text.Substring(text.Length - 4);                  if (fourLast.Equals(" /n "))                  {                      this.textBeforeCursor = text.Substring(0' text.Length - 4);                  }                  else                  {                      this.textBeforeCursor = text.Substring(0' text.Length - 1);                  }              }              else              {                  this.textBeforeCursor = text.Substring(0' text.Length - 1);              }
Magic Number,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,RemoveBackCharacter,The following statement contains a magic number: if (text.Length < 2)              {                  this.textBeforeCursor = string.Empty;              }              else if (text.Length > 4)              {                  string fourLast = text.Substring(text.Length - 4);                  if (fourLast.Equals(" /n "))                  {                      this.textBeforeCursor = text.Substring(0' text.Length - 4);                  }                  else                  {                      this.textBeforeCursor = text.Substring(0' text.Length - 1);                  }              }              else              {                  this.textBeforeCursor = text.Substring(0' text.Length - 1);              }
Magic Number,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,RemoveBackCharacter,The following statement contains a magic number: if (text.Length < 2)              {                  this.textBeforeCursor = string.Empty;              }              else if (text.Length > 4)              {                  string fourLast = text.Substring(text.Length - 4);                  if (fourLast.Equals(" /n "))                  {                      this.textBeforeCursor = text.Substring(0' text.Length - 4);                  }                  else                  {                      this.textBeforeCursor = text.Substring(0' text.Length - 1);                  }              }              else              {                  this.textBeforeCursor = text.Substring(0' text.Length - 1);              }
Magic Number,WaveEngine.Components.UI,TextBoxBehavior,C:\repos\WaveEngine_Components\Shared\UI\TextBox\TextBoxBehavior.cs,RemoveBackCharacter,The following statement contains a magic number: if (text.Length < 2)              {                  this.textBeforeCursor = string.Empty;              }              else if (text.Length > 4)              {                  string fourLast = text.Substring(text.Length - 4);                  if (fourLast.Equals(" /n "))                  {                      this.textBeforeCursor = text.Substring(0' text.Length - 4);                  }                  else                  {                      this.textBeforeCursor = text.Substring(0' text.Length - 1);                  }              }              else              {                  this.textBeforeCursor = text.Substring(0' text.Length - 1);              }
Magic Number,WaveEngine.Components.UI,ToggleSwitch,C:\repos\WaveEngine_Components\Shared\UI\ToggleSwitch\ToggleSwitch.cs,ToggleSwitch,The following statement contains a magic number: this.entity = new Entity(name)                             .AddComponent(new Transform2D())                             .AddComponent(new RectangleCollider2D())                             .AddComponent(new TouchGestures(false))                             .AddComponent(new GridControl(100' 42))                             .AddComponent(new GridRenderer())                             .AddComponent(new ToggleSwitchBehavior());
Magic Number,WaveEngine.Components.UI,ToggleSwitch,C:\repos\WaveEngine_Components\Shared\UI\ToggleSwitch\ToggleSwitch.cs,ToggleSwitch,The following statement contains a magic number: this.entity = new Entity(name)                             .AddComponent(new Transform2D())                             .AddComponent(new RectangleCollider2D())                             .AddComponent(new TouchGestures(false))                             .AddComponent(new GridControl(100' 42))                             .AddComponent(new GridRenderer())                             .AddComponent(new ToggleSwitchBehavior());
Duplicate Code,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The method contains a code clone-set at the following line numbers (starting from the method definition): ((167' 187)' (202' 222))
Duplicate Code,WaveEngine.Components.Graphics3D,ParticleSystemRenderer3D,C:\repos\WaveEngine_Components\Shared\Graphics3D\ParticleSystemRenderer3D.cs,Draw,The method contains a code clone-set at the following line numbers (starting from the method definition): ((239' 259)' (274' 294))
Missing Default,WaveEngine.Components.GameActions,FloatAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\FloatAnimationGameAction.cs,DeltaFunction,The following switch statement is missing a default case: switch (this.easeFunction)              {                  case EaseFunction.BackInEase:                      delta = this.BackInEase(time' from' to' totalTime);                      break;                  case EaseFunction.BackInOutEase:                      delta = this.BackInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BackOutEase:                      delta = this.BackOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceInEase:                      delta = this.BounceInEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceOutEase:                      delta = this.BounceOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceInOutEase:                      delta = this.BounceInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleInEase:                      delta = this.CircleInEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleOutEase:                      delta = this.CircleOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleInOutEase:                      delta = this.CircleInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicInEase:                      delta = this.CubicInEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicOutEase:                      delta = this.CubicOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicInOutEase:                      delta = this.CubicInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticInEase:                      delta = this.ElasticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticOutEase:                      delta = this.ElasticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticInOutEase:                      delta = this.ElasticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialInEase:                      delta = this.ExponentialInEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialOutEase:                      delta = this.ExponentialOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialInOutEase:                      delta = this.ExponentialInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticInEase:                      delta = this.QuadraticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticOutEase:                      delta = this.QuadraticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticInOutEase:                      delta = this.QuadraticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticInEase:                      delta = this.QuarticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticOutEase:                      delta = this.QuarticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticInOutEase:                      delta = this.QuarticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticInEase:                      delta = this.QuinticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticOutEase:                      delta = this.QuinticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticInOutEase:                      delta = this.QuinticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineInEase:                      delta = this.SineInEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineOutEase:                      delta = this.SineOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineInOutEase:                      delta = this.SineInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.None:                      delta = this.LinearStep(from' to' lerp);                      break;              }
Missing Default,WaveEngine.Components.GameActions,Vector2AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector2AnimationGameAction.cs,DeltaFunction,The following switch statement is missing a default case: switch (this.easeFunction)              {                  case EaseFunction.BackInEase:                      delta = this.BackInEase(time' from' to' totalTime);                      break;                  case EaseFunction.BackInOutEase:                      delta = this.BackInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BackOutEase:                      delta = this.BackOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceInEase:                      delta = this.BounceInEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceOutEase:                      delta = this.BounceOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceInOutEase:                      delta = this.BounceInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleInEase:                      delta = this.CircleInEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleOutEase:                      delta = this.CircleOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleInOutEase:                      delta = this.CircleInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicInEase:                      delta = this.CubicInEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicOutEase:                      delta = this.CubicOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicInOutEase:                      delta = this.CubicInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticInEase:                      delta = this.ElasticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticOutEase:                      delta = this.ElasticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticInOutEase:                      delta = this.ElasticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialInEase:                      delta = this.ExponentialInEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialOutEase:                      delta = this.ExponentialOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialInOutEase:                      delta = this.ExponentialInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticInEase:                      delta = this.QuadraticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticOutEase:                      delta = this.QuadraticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticInOutEase:                      delta = this.QuadraticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticInEase:                      delta = this.QuarticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticOutEase:                      delta = this.QuarticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticInOutEase:                      delta = this.QuarticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticInEase:                      delta = this.QuinticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticOutEase:                      delta = this.QuinticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticInOutEase:                      delta = this.QuinticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineInEase:                      delta = this.SineInEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineOutEase:                      delta = this.SineOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineInOutEase:                      delta = this.SineInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.None:                      delta = this.LinearStep(time' from' to' totalTime);                      break;              }
Missing Default,WaveEngine.Components.GameActions,QuaternionAnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\QuaternionAnimationGameAction.cs,DeltaFunction,The following switch statement is missing a default case: switch (this.easeFunction)              {                  case EaseFunction.BackInEase:                      delta = this.BackInEase(time' from' to' totalTime);                      break;                  case EaseFunction.BackInOutEase:                      delta = this.BackInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BackOutEase:                      delta = this.BackOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceInEase:                      delta = this.BounceInEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceOutEase:                      delta = this.BounceOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceInOutEase:                      delta = this.BounceInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleInEase:                      delta = this.CircleInEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleOutEase:                      delta = this.CircleOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleInOutEase:                      delta = this.CircleInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicInEase:                      delta = this.CubicInEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicOutEase:                      delta = this.CubitOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicInOutEase:                      delta = this.CubicInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticInEase:                      delta = this.ElasticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticOutEase:                      delta = this.ElasticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticInOutEase:                      delta = this.ElasticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialInEase:                      delta = this.ExponentialInEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialOutEase:                      delta = this.ExponentialOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialInOutEase:                      delta = this.ExponentialInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticInEase:                      delta = this.QuadraticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticOutEase:                      delta = this.QuadraticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticInOutEase:                      delta = this.QuadraticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticInEase:                      delta = this.QuarticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticOutEase:                      delta = this.QuarticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticInOutEase:                      delta = this.QuarticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticInEase:                      delta = this.QuinticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticOutEase:                      delta = this.QuinticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticInOutEase:                      delta = this.QuinticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineInEase:                      delta = this.SineInEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineOutEase:                      delta = this.SineOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineInOutEase:                      delta = this.SineInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.None:                      delta = this.LinearStep(time' from' to' totalTime);                      break;              }
Missing Default,WaveEngine.Components.GameActions,Vector3AnimationGameAction,C:\repos\WaveEngine_Components\Shared\GameActions\Animations\Vector3AnimationGameAction.cs,DeltaFunction,The following switch statement is missing a default case: switch (this.easeFunction)              {                  case EaseFunction.BackInEase:                      delta = this.BackInEase(time' from' to' totalTime);                      break;                  case EaseFunction.BackInOutEase:                      delta = this.BackInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BackOutEase:                      delta = this.BackOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceInEase:                      delta = this.BounceInEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceOutEase:                      delta = this.BounceOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.BounceInOutEase:                      delta = this.BounceInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleInEase:                      delta = this.CircleInEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleOutEase:                      delta = this.CircleOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CircleInOutEase:                      delta = this.CircleInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicInEase:                      delta = this.CubicInEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicOutEase:                      delta = this.CubitOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.CubicInOutEase:                      delta = this.CubicInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticInEase:                      delta = this.ElasticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticOutEase:                      delta = this.ElasticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ElasticInOutEase:                      delta = this.ElasticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialInEase:                      delta = this.ExponentialInEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialOutEase:                      delta = this.ExponentialOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.ExponentialInOutEase:                      delta = this.ExponentialInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticInEase:                      delta = this.QuadraticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticOutEase:                      delta = this.QuadraticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuadraticInOutEase:                      delta = this.QuadraticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticInEase:                      delta = this.QuarticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticOutEase:                      delta = this.QuarticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuarticInOutEase:                      delta = this.QuarticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticInEase:                      delta = this.QuinticInEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticOutEase:                      delta = this.QuinticOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.QuinticInOutEase:                      delta = this.QuinticInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineInEase:                      delta = this.SineInEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineOutEase:                      delta = this.SineOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.SineInOutEase:                      delta = this.SineInOutEase(time' from' to' totalTime);                      break;                  case EaseFunction.None:                      delta = this.LinearStep(time' from' to' totalTime);                      break;              }
Missing Default,WaveEngine.Components.Gestures,TouchGestures,C:\repos\WaveEngine_Components\Shared\Gestures\TouchGestures.cs,Update,The following switch statement is missing a default case: switch (this.state)              {                  case GestureType.None:                      this.NoneState();                      break;                    case GestureType.Pressed:                      this.PressedState();                      break;                    case GestureType.Tap:                      this.TapState();                      break;                    case GestureType.Stopped:                  case GestureType.Drag:                      this.StoppedAndDragState();                      break;                    case GestureType.Free:                      this.FreeState();                      break;              }
Missing Default,WaveEngine.Components.Graphics3D,InternalSkinnedModel,C:\repos\WaveEngine_Components\Shared\Graphics3D\InternalSkinnedModel.cs,Load,The following switch statement is missing a default case: switch (property.Usage)                                  {                                      case VertexElementUsage.Position:                                          bufferData[k].Position = reader.ReadVector3();                                          break;                                      case VertexElementUsage.TextureCoordinate:                                          bufferData[k].TexCoord = reader.ReadVector2();                                          break;                                      case VertexElementUsage.Normal:                                          bufferData[k].Normal = reader.ReadVector3();                                          break;                                      case VertexElementUsage.BlendIndices:                                          bufferData[k].BlendIndices = reader.ReadByte4();                                          break;                                      case VertexElementUsage.BlendWeight:                                          bufferData[k].BlendWeights = reader.ReadVector2();                                          break;                                        case VertexElementUsage.Tangent:                                          bufferData[k].Tangent = reader.ReadVector3();                                          break;                                      case VertexElementUsage.Binormal:                                          bufferData[k].Binormal = reader.ReadVector3();                                          break;                                  }
Missing Default,WaveEngine.Components.Toolkit,TextComponent,C:\repos\WaveEngine_Components\Shared\Toolkit\TextComponent.cs,CalculateAlignmentOffset,The following switch statement is missing a default case: switch (this.textAlignment)              {                  case TextAlignment.Left:                      break;                  case TextAlignment.Right:                        if (size.X < width)                      {                          offsetX = width - size.X;                      }                        break;                  case TextAlignment.Center:                        if (size.X < width)                      {                          offsetX = (width - size.X) * 0.5f;                      }                        break;              }
Missing Default,WaveEngine.Components.Transitions,CombTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CombTransition.cs,Initialize,The following switch statement is missing a default case: switch (this.effectOption)              {                  case EffectOptions.Horizontal:                      this.initialPosition = new Vector2(this.platform.ScreenWidth' 0);                      break;                  case EffectOptions.Vertical:                      this.initialPosition = new Vector2(0' -this.platform.ScreenHeight);                      break;              }
Missing Default,WaveEngine.Components.Transitions,CoverTransition,C:\repos\WaveEngine_Components\Shared\Transitions\CoverTransition.cs,Initialize,The following switch statement is missing a default case: switch (this.effectOption)              {                  case EffectOptions.FromRight:                      this.initialPosition = new Vector2(this.platform.ScreenWidth' 0);                      break;                  case EffectOptions.FromTop:                      this.initialPosition = new Vector2(0' -this.platform.ScreenHeight);                      break;                  case EffectOptions.FromLeft:                      this.initialPosition = new Vector2(-this.platform.ScreenWidth' 0);                      break;                  case EffectOptions.FromBotton:                      this.initialPosition = new Vector2(0' this.platform.ScreenHeight);                      break;                  case EffectOptions.FromTopRight:                      this.initialPosition = new Vector2(this.platform.ScreenWidth' -this.platform.ScreenHeight);                      break;                  case EffectOptions.FromBottomRight:                      this.initialPosition = new Vector2(this.platform.ScreenWidth' this.platform.ScreenHeight);                      break;                  case EffectOptions.FromTopLeft:                      this.initialPosition = new Vector2(-this.platform.ScreenWidth' -this.platform.ScreenHeight);                      break;                  case EffectOptions.FromBottonLeft:                      this.initialPosition = new Vector2(-this.platform.ScreenWidth' this.platform.ScreenHeight);                      break;              }
Missing Default,WaveEngine.Components.Transitions,PushTransition,C:\repos\WaveEngine_Components\Shared\Transitions\PushTransition.cs,Initialize,The following switch statement is missing a default case: switch (this.effectOption)              {                  case EffectOptions.FromRight:                      this.initialPosition = new Vector2(this.platform.ScreenWidth' 0);                      break;                  case EffectOptions.FromTop:                      this.initialPosition = new Vector2(0' -this.platform.ScreenHeight);                      break;                  case EffectOptions.FromLeft:                      this.initialPosition = new Vector2(-this.platform.ScreenWidth' 0);                      break;                  case EffectOptions.FromBotton:                      this.initialPosition = new Vector2(0' this.platform.ScreenHeight);                      break;              }
Missing Default,WaveEngine.Components.Transitions,UncoverTransition,C:\repos\WaveEngine_Components\Shared\Transitions\UncoverTransition.cs,Initialize,The following switch statement is missing a default case: switch (this.effectOption)              {                  case EffectOptions.FromRight:                      this.targetPosition = new Vector2(-this.platform.ScreenWidth' 0);                      break;                  case EffectOptions.FromTop:                      this.targetPosition = new Vector2(0' this.platform.ScreenHeight);                      break;                  case EffectOptions.FromLeft:                      this.targetPosition = new Vector2(this.platform.ScreenWidth' 0);                      break;                  case EffectOptions.FromBotton:                      this.targetPosition = new Vector2(0' -this.platform.ScreenHeight);                      break;                  case EffectOptions.FromTopRight:                      this.targetPosition = new Vector2(-this.platform.ScreenWidth' this.platform.ScreenHeight);                      break;                  case EffectOptions.FromBottomRight:                      this.targetPosition = new Vector2(-this.platform.ScreenWidth' -this.platform.ScreenHeight);                      break;                  case EffectOptions.FromTopLeft:                      this.targetPosition = new Vector2(this.platform.ScreenWidth' this.platform.ScreenHeight);                      break;                  case EffectOptions.FromBottonLeft:                      this.targetPosition = new Vector2(this.platform.ScreenWidth' -this.platform.ScreenHeight);                      break;              }
Missing Default,WaveEngine.Components.UI,ImageControl,C:\repos\WaveEngine_Components\Shared\UI\Image\ImageControl.cs,Arrange,The following switch statement is missing a default case: switch (this.Stretch)              {                  case Stretch.None:                      break;                  case Stretch.Fill:                      currentRect.Width = finalSize.Width - this.Margin.Left - this.Margin.Right;                      currentRect.Height = finalSize.Height - this.Margin.Top - this.Margin.Bottom;                      break;                  case Stretch.Uniform:                        if (this.width >= this.height)                      {                          float finalProportionalHeight = (this.height * finalSize.Width) / this.width;                            if (finalSize.Height < finalProportionalHeight)                          {                              currentRect.Width = ((this.width * finalSize.Height) / this.height) - this.Margin.Left - this.Margin.Right;                              currentRect.Height = finalSize.Height - this.Margin.Top - this.Margin.Bottom;                          }                          else                          {                              currentRect.Width = finalSize.Width - this.Margin.Left - this.Margin.Right;                              currentRect.Height = finalProportionalHeight - this.Margin.Top - this.Margin.Bottom;                          }                      }                      else                      {                          float finalProportionalWidth = (this.width * finalSize.Height) / this.height;                            if (finalSize.Width < finalProportionalWidth)                          {                              currentRect.Width = finalSize.Width - this.Margin.Left - this.Margin.Right;                              currentRect.Height = ((this.height * finalSize.Width) / this.width) - this.Margin.Top - this.Margin.Bottom;                          }                          else                          {                              currentRect.Width = finalProportionalWidth - this.Margin.Left - this.Margin.Right;                              currentRect.Height = finalSize.Height - this.Margin.Top - this.Margin.Bottom;                          }                      }                        break;                  case Stretch.UniformToFill:                        if (this.width >= this.height)                      {                          float finalProportionalWidth = (this.width * finalSize.Height) / this.height;                            if (finalSize.Width > finalProportionalWidth)                          {                              currentRect.Width = finalSize.Width - this.Margin.Left - this.Margin.Right;                              currentRect.Height = ((this.height * finalSize.Width) / this.width) - this.Margin.Top - this.Margin.Bottom;                          }                          else                          {                              currentRect.Width = finalProportionalWidth - this.Margin.Left - this.Margin.Right;                              currentRect.Height = finalSize.Height - this.Margin.Top - this.Margin.Bottom;                          }                      }                      else                      {                          float finalProportionalHeight = (this.height * finalSize.Width) / this.width;                            if (finalSize.Height > finalProportionalHeight)                          {                              currentRect.Width = ((this.width * finalSize.Height) / this.height) - this.Margin.Left - this.Margin.Right;                              currentRect.Height = finalSize.Height - this.Margin.Top - this.Margin.Bottom;                          }                          else                          {                              currentRect.Width = finalSize.Width - this.Margin.Left - this.Margin.Right;                              currentRect.Height = finalProportionalHeight - this.Margin.Top - this.Margin.Bottom;                          }                      }                        break;              }
Missing Default,WaveEngine.Components.UI,ImageControl,C:\repos\WaveEngine_Components\Shared\UI\Image\ImageControl.cs,Arrange,The following switch statement is missing a default case: switch (this.HorizontalAlignment)              {                  case HorizontalAlignment.Left:                      currentRect.X = finalSize.X + this.Margin.Left;                      break;                  case HorizontalAlignment.Center:                      currentRect.X = finalSize.X + (finalSize.Width / 2) - (rect.Width / 2) - this.Margin.Right + this.Margin.Left;                      break;                  case HorizontalAlignment.Right:                      currentRect.X = finalSize.X + finalSize.Width - this.Margin.Right - rect.Width;                      break;                  case HorizontalAlignment.Stretch:                      break;              }
Missing Default,WaveEngine.Components.UI,ImageControl,C:\repos\WaveEngine_Components\Shared\UI\Image\ImageControl.cs,Arrange,The following switch statement is missing a default case: switch (this.VerticalAlignment)              {                  case VerticalAlignment.Top:                      currentRect.Y = finalSize.Y + this.Margin.Top;                      break;                  case VerticalAlignment.Center:                      currentRect.Y = finalSize.Y + (finalSize.Height / 2) - (rect.Height / 2) - this.Margin.Bottom + this.Margin.Top;                      break;                  case VerticalAlignment.Bottom:                      currentRect.Y = finalSize.Y + finalSize.Height - this.Margin.Bottom - rect.Height;                      break;                  case VerticalAlignment.Stretch:                      break;              }
Missing Default,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,ResolveDependencies,The following switch statement is missing a default case: switch (this.orientation)              {                  case Orientation.Vertical:                      float result = this.maximunOffset * (this.value - this.minimum) / this.difference;                      this.bulletTransform.Y = -result;                      this.foregroundTransform.YScale = result;                      break;                  case Orientation.Horizontal:                      this.bulletTransform.X = this.maximunOffset * (this.value - this.minimum) / this.difference;                      this.foregroundTransform.XScale = this.bulletTransform.X;                      break;              }
Missing Default,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,Gestures_TouchPressed,The following switch statement is missing a default case: switch (this.orientation)              {                  case Orientation.Vertical:                      float offsetY = e.GestureSample.Position.Y - this.bulletTransform.Rectangle.Y;                      this.UpdateWidthVerticalOffset(offsetY);                        break;                  case Orientation.Horizontal:                      float offsetX = e.GestureSample.Position.X - this.bulletTransform.Rectangle.X;                      this.UpdateWidthHorizontalOffset(offsetX);                        break;              }
Missing Default,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,Gestures_TouchMoved,The following switch statement is missing a default case: switch (this.orientation)              {                  case Orientation.Vertical:                      float offsetY = e.GestureSample.Position.Y - this.bulletTransform.Rectangle.Y;                      this.UpdateWidthVerticalOffset(offsetY);                        break;                  case Orientation.Horizontal:                      float offsetX = e.GestureSample.Position.X - this.bulletTransform.Rectangle.X;                      this.UpdateWidthHorizontalOffset(offsetX);                        break;              }
Missing Default,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,UpdateValue,The following switch statement is missing a default case: switch (this.orientation)                  {                      case Orientation.Vertical:                          this.value = (int)(this.minimum + ((-this.bulletTransform.Y * this.difference) / this.maximunOffset));                          break;                      case Orientation.Horizontal:                          this.value = (int)(this.minimum + ((this.bulletTransform.X * this.difference) / this.maximunOffset));                          break;                  }
Missing Default,WaveEngine.Components.UI,SliderBehavior,C:\repos\WaveEngine_Components\Shared\UI\Slider\SliderBehavior.cs,UpdateOrientation,The following switch statement is missing a default case: switch (this.orientation)              {                  case Orientation.Vertical:                        if (this.backgroundImage != null && this.foregroundImage != null && this.foregroundTransform != null                          && this.bulletImage != null && this.bulletTransform != null && this.textControl != null &&                          this.textTransform != null && this.Panel != null)                      {                          this.maximunOffset = this.Panel.Height - this.bulletImage.Height;                          this.bulletWeightOver2 = this.bulletImage.Height / 2;                          this.maximunOffsetOver2 = this.Panel.Height - this.bulletImage.Height - this.bulletWeightOver2;                            this.backgroundImage.Width = DefaultSliderWeight;                          this.backgroundImage.Height = this.Panel.Height;                            this.foregroundImage.Width = DefaultSliderWeight;                          this.foregroundImage.Height = 1;                          this.foregroundImage.Margin = new Thickness(0' this.Panel.Height' 0' 0);                            this.foregroundTransform.Origin = Vector2.UnitX / 2;                          this.foregroundTransform.Rotation = MathHelper.Pi;                          this.foregroundTransform.XScale = 1;                            this.bulletImage.Margin = new Thickness(0' this.Panel.Height - this.bulletImage.Height' 0' 0);                            this.bulletTransform.X = 0;                            this.bulletTransform.Y = 0;                            this.textControl.Margin = new Thickness(-DefaultTextOffset' this.Panel.Height - (this.bulletImage.Height * 1.5f)' 0' 0);                            this.textTransform.X = 0;                      }                        break;                  case Orientation.Horizontal:                        if (this.backgroundImage != null && this.foregroundImage != null && this.foregroundTransform != null                          && this.bulletImage != null && this.bulletTransform != null && this.textControl != null &&                          this.textTransform != null && this.Panel != null)                      {                          this.maximunOffset = this.Panel.Width - this.bulletImage.Width;                          this.bulletWeightOver2 = this.bulletImage.Width / 2;                          this.maximunOffsetOver2 = this.Panel.Width - this.bulletWeightOver2;                            this.backgroundImage.Width = this.Panel.Width;                          this.backgroundImage.Height = DefaultSliderWeight;                            this.foregroundImage.Height = DefaultSliderWeight;                          this.foregroundImage.Width = 1;                          this.foregroundImage.Margin = Thickness.Zero;                            this.foregroundTransform.Origin = Vector2.Zero;                          this.foregroundTransform.Rotation = 0;                          this.foregroundTransform.YScale = 1;                            this.bulletImage.Margin = Thickness.Zero;                            this.bulletTransform.X = 0;                            this.bulletTransform.Y = 0;                            this.textControl.Margin = new Thickness(0' -DefaultTextOffset' 0' 0);                            this.textTransform.Y = 0;                      }                        break;              }
Missing Default,WaveEngine.Components.UI,TextControl,C:\repos\WaveEngine_Components\Shared\UI\TextBlock\TextControl.cs,CalculateAlignmentOffset,The following switch statement is missing a default case: switch (this.textAlignment)              {                  case TextAlignment.Left:                      break;                  case TextAlignment.Right:                        if (size.X < this.width)                      {                          offsetX = this.width - size.X;                      }                        break;                  case TextAlignment.Center:                        if (size.X < this.width)                      {                          offsetX = (this.width - size.X) / 2;                      }                        break;              }
