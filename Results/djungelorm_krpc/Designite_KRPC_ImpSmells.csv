Implementation smell,Namespace,Class,File,Method,Description
Long Method,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The method has 154 lines of code.
Long Method,KRPC.Service.Scanner,Scanner,C:\repos\djungelorm_krpc\server\src\Service\Scanner\Scanner.cs,GetServices,The method has 110 lines of code.
Complex Method,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,RPCServerUpdate,Cyclomatic complexity of the method is 14
Complex Method,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,StreamServerUpdate,Cyclomatic complexity of the method is 18
Complex Method,KRPC.Server.Message,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\Message\RPCStream.cs,Poll,Cyclomatic complexity of the method is 8
Complex Method,KRPC.Server.WebSockets,ConnectionRequest,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\ConnectionRequest.cs,CheckValid,Cyclomatic complexity of the method is 10
Complex Method,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,ToBytes,Cyclomatic complexity of the method is 8
Complex Method,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,Cyclomatic complexity of the method is 9
Complex Method,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,Cyclomatic complexity of the method is 16
Complex Method,KRPC.Service,TypeUtils,C:\repos\djungelorm_krpc\server\src\Service\TypeUtils.cs,ValidateKRPCEnum,Cyclomatic complexity of the method is 8
Complex Method,KRPC.Service.KRPC,KRPC,C:\repos\djungelorm_krpc\server\src\Service\KRPC\KRPC.cs,GetServices,Cyclomatic complexity of the method is 16
Complex Method,KRPC.Service.Scanner,Scanner,C:\repos\djungelorm_krpc\server\src\Service\Scanner\Scanner.cs,GetServices,Cyclomatic complexity of the method is 16
Complex Method,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawServer,Cyclomatic complexity of the method is 11
Complex Method,KRPC.UI,Window,C:\repos\djungelorm_krpc\server\src\UI\Window.cs,OnGUI,Cyclomatic complexity of the method is 8
Complex Method,KRPC.Utils,APILoader,C:\repos\djungelorm_krpc\server\src\Utils\APILoader.cs,Load,Cyclomatic complexity of the method is 9
Complex Method,KRPC.Utils,DocumentationExtensions,C:\repos\djungelorm_krpc\server\src\Utils\DocumentationExtensions.cs,Dedent,Cyclomatic complexity of the method is 8
Complex Method,KRPC.Utils,Text,C:\repos\djungelorm_krpc\server\src\Utils\Text.cs,IsValidTruncatedUTF8,Cyclomatic complexity of the method is 14
Long Parameter List,KRPC.Continuations,ParameterizedContinuation<TReturn;TArg0;TArg1;TArg2;TArg3>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuation,The method has 5 parameters. Parameters: fn' arg0' arg1' arg2' arg3
Long Parameter List,KRPC.Continuations,ParameterizedContinuationVoid<TArg0;TArg1;TArg2;TArg3>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuationVoid,The method has 5 parameters. Parameters: fn' arg0' arg1' arg2' arg3
Long Parameter List,KRPC.Continuations,ParameterizedContinuation<TReturn;TArg0;TArg1;TArg2;TArg3;TArg4>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuation,The method has 6 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4
Long Parameter List,KRPC.Continuations,ParameterizedContinuationVoid<TArg0;TArg1;TArg2;TArg3;TArg4>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuationVoid,The method has 6 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4
Long Parameter List,KRPC.Continuations,ParameterizedContinuation<TReturn;TArg0;TArg1;TArg2;TArg3;TArg4;TArg5>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuation,The method has 7 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4' arg5
Long Parameter List,KRPC.Continuations,ParameterizedContinuationVoid<TArg0;TArg1;TArg2;TArg3;TArg4;TArg5>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuationVoid,The method has 7 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4' arg5
Long Parameter List,KRPC.Continuations,ParameterizedContinuation<TReturn;TArg0;TArg1;TArg2;TArg3;TArg4;TArg5;TArg6>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuation,The method has 8 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,KRPC.Continuations,ParameterizedContinuationVoid<TArg0;TArg1;TArg2;TArg3;TArg4;TArg5;TArg6>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuationVoid,The method has 8 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,KRPC.Continuations,ParameterizedContinuation<TReturn;TArg0;TArg1;TArg2;TArg3;TArg4;TArg5;TArg6;TArg7>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuation,The method has 9 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,KRPC.Continuations,ParameterizedContinuationVoid<TArg0;TArg1;TArg2;TArg3;TArg4;TArg5;TArg6;TArg7>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuationVoid,The method has 9 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,KRPC.Continuations,ParameterizedContinuation<TReturn;TArg0;TArg1;TArg2;TArg3;TArg4;TArg5;TArg6;TArg7;TArg8>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuation,The method has 10 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,KRPC.Continuations,ParameterizedContinuationVoid<TArg0;TArg1;TArg2;TArg3;TArg4;TArg5;TArg6;TArg7;TArg8>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuationVoid,The method has 10 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,KRPC.Continuations,ParameterizedContinuation<TReturn;TArg0;TArg1;TArg2;TArg3;TArg4;TArg5;TArg6;TArg7;TArg8;TArg9>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuation,The method has 11 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,KRPC.Continuations,ParameterizedContinuationVoid<TArg0;TArg1;TArg2;TArg3;TArg4;TArg5;TArg6;TArg7;TArg8;TArg9>,C:\repos\djungelorm_krpc\server\src\Continuations\ParameterizedContinuation.cs,ParameterizedContinuationVoid,The method has 11 parameters. Parameters: fn' arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,KRPC.Server,Server,C:\repos\djungelorm_krpc\server\src\Server\Server.cs,Server,The method has 5 parameters. Parameters: id' protocol' name' rpcServer' streamServer
Long Parameter List,KRPC.Server.ProtocolBuffers,Utils,C:\repos\djungelorm_krpc\server\src\Server\ProtocolBuffers\Utils.cs,ReadMessage,The method has 5 parameters. Parameters: message' parser' data' offset' length
Long Parameter List,KRPC.Server.SerialIO,ByteServer,C:\repos\djungelorm_krpc\server\src\Server\SerialIO\ByteServer.cs,ByteServer,The method has 5 parameters. Parameters: address' baudRate' dataBits' parity' stopBits
Long Parameter List,KRPC.Service.Scanner,EnumerationValueSignature,C:\repos\djungelorm_krpc\server\src\Service\Scanner\EnumerationValueSignature.cs,EnumerationValueSignature,The method has 5 parameters. Parameters: serviceName' enumName' valueName' value' documentation
Long Parameter List,KRPC.Service.Scanner,ProcedureSignature,C:\repos\djungelorm_krpc\server\src\Service\Scanner\ProcedureSignature.cs,ProcedureSignature,The method has 6 parameters. Parameters: serviceName' procedureName' id' documentation' handler' gameScene
Long Parameter List,KRPC.Service.Scanner,ServiceSignature,C:\repos\djungelorm_krpc\server\src\Service\Scanner\ServiceSignature.cs,AddClassPropertyMethod,The method has 5 parameters. Parameters: cls' classType' property' method' nullable
Long Parameter List,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,ComboBox,The method has 6 parameters. Parameters: caller' selectedItem' entries' buttonStyle' optionsStyle' optionStyle
Long Parameter List,KRPC.Utils,Compatibility,C:\repos\djungelorm_krpc\server\src\Utils\Compatibility.cs,SpawnPopupDialog,The method has 10 parameters. Parameters: anchorMin' anchorMax' dialogName' title' message' buttonMessage' persistAcrossScenes' skin' isModal' titleExtra
Long Parameter List,KRPC.Utils,Compatibility,C:\repos\djungelorm_krpc\server\src\Utils\Compatibility.cs,NewMultiOptionDialog,The method has 5 parameters. Parameters: name' msg' windowTitle' skin' options
Long Parameter List,KRPC.Utils,Tuple<T1;T2;T3;T4;T5>,C:\repos\djungelorm_krpc\server\src\Utils\Tuple.cs,Tuple,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,KRPC.Utils,Tuple<T1;T2;T3;T4;T5;T6>,C:\repos\djungelorm_krpc\server\src\Utils\Tuple.cs,Tuple,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,KRPC.Utils,Tuple<T1;T2;T3;T4;T5;T6;T7>,C:\repos\djungelorm_krpc\server\src\Utils\Tuple.cs,Tuple,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,KRPC.Utils,Tuple<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\djungelorm_krpc\server\src\Utils\Tuple.cs,Tuple,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,KRPC.Utils,Tuple<T1;T2;T3;T4;T5;T6;T7;T8;T9>,C:\repos\djungelorm_krpc\server\src\Utils\Tuple.cs,Tuple,The method has 9 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' item8' item9
Long Parameter List,KRPC.Utils,Tuple,C:\repos\djungelorm_krpc\server\src\Utils\Tuple.cs,Create,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,KRPC.Utils,Tuple,C:\repos\djungelorm_krpc\server\src\Utils\Tuple.cs,Create,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,KRPC.Utils,Tuple,C:\repos\djungelorm_krpc\server\src\Utils\Tuple.cs,Create,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,KRPC.Utils,Tuple,C:\repos\djungelorm_krpc\server\src\Utils\Tuple.cs,Create,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,KRPC.Utils,Tuple,C:\repos\djungelorm_krpc\server\src\Utils\Tuple.cs,Create,The method has 9 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' item8' item9
Long Identifier,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,,The length of the parameter lastActivityMillisecondsInterval is 32.
Long Statement,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,IsCompatible,The length of the statement  "            var version = (AssemblyKSPVersionAttribute)(Assembly.GetExecutingAssembly ().GetCustomAttributes (typeof(AssemblyKSPVersionAttribute)' false).First ()); " is 152.
Long Statement,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,Start,The length of the statement  "            Debug.Log (String.Format ("[CompatibilityChecker] Running checker version {0} from '{1}'"' _version' Assembly.GetExecutingAssembly ().GetName ().Name)); " is 152.
Long Statement,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,Start,The length of the statement  "                        Debug.LogWarning (String.Format ("[CompatibilityChecker] Exception while invoking IsCompatible() from '{0}':\n\n{1}"' m.DeclaringType.Assembly.GetName ().Name' e)); " is 164.
Long Statement,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,Start,The length of the statement  "                        Debug.LogWarning (String.Format ("[CompatibilityChecker] Exception while invoking IsUnityCompatible() from '{0}':\n\n{1}"' m.DeclaringType.Assembly.GetName ().Name' e)); " is 169.
Long Statement,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,Start,The length of the statement  "            String message = "Some installed mods may be incompatible with this version of Kerbal Space Program. Features may be broken or disabled. Please check for updates to the listed mods."; " is 183.
Long Statement,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,Start,The length of the statement  "                message += String.Format ("\n\nThese mods are incompatible with KSP {0}.{1}.{2}:\n\n"' Versioning.version_major' Versioning.version_minor' Versioning.Revision); " is 160.
Long Statement,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,Start,The length of the statement  "                Debug.LogWarning ("[CompatibilityChecker] Incompatible mods (Unity) detected: " + String.Join ("' "' incompatibleUnity)); " is 121.
Long Statement,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,StreamServerUpdate,The length of the statement  "                            Logger.WriteLine ("Failed to send stream update to client " + streamClientAddress + Environment.NewLine + exn' Logger.Severity.Error); " is 134.
Long Statement,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,PollRequests,The length of the statement  "                        Logger.WriteLine ("Sent error response to client " + client.Address + " (" + response.Error + ")"' Logger.Severity.Debug); " is 122.
Long Statement,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,PollRequests,The length of the statement  "                        Logger.WriteLine ("Failed to send error response to client " + client.Address + Environment.NewLine + exn' Logger.Severity.Error); " is 130.
Long Statement,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,ExecuteContinuation,The length of the statement  "                        Logger.WriteLine ("Sent error response to client " + client.Address + " (" + response.Error + ")"' Logger.Severity.Debug); " is 122.
Long Statement,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,ExecuteContinuation,The length of the statement  "                Logger.WriteLine ("Failed to send response to client " + client.Address + Environment.NewLine + exn' Logger.Severity.Error); " is 124.
Long Statement,KRPC,ServicesChecker,C:\repos\djungelorm_krpc\server\src\ServicesChecker.cs,Start,The length of the statement  "                Utils.Logger.WriteLine("Service errors encountered' plugin has been disabled. Errors were:"' Utils.Logger.Severity.Error); " is 122.
Long Statement,KRPC.Server.Message,StreamServer,C:\repos\djungelorm_krpc\server\src\Server\Message\StreamServer.cs,HandleClientDisconnected,The length of the statement  "            EventHandlerExtensions.Invoke (OnClientDisconnected' this' new ClientDisconnectedEventArgs<NoMessage'StreamUpdate> (client)); " is 125.
Long Statement,KRPC.Server.ProtocolBuffers,RPCServer,C:\repos\djungelorm_krpc\server\src\Server\ProtocolBuffers\RPCServer.cs,CreateClient,The length of the statement  "                    WriteErrorConnectionResponse (client' Status.Timeout' "Connection request message not received after waiting 3 seconds"); " is 121.
Long Statement,KRPC.Server.ProtocolBuffers,StreamServer,C:\repos\djungelorm_krpc\server\src\Server\ProtocolBuffers\StreamServer.cs,CreateClient,The length of the statement  "                    WriteErrorConnectionResponse (Status.Timeout' "Connection request message not received after waiting 3 seconds"' stream); " is 121.
Long Statement,KRPC.Server.SerialIO,RPCServer,C:\repos\djungelorm_krpc\server\src\Server\SerialIO\RPCServer.cs,CreateClient,The length of the statement  "                    WriteErrorConnectionResponse (client' Status.Timeout' "Connection request message not received after waiting 3 seconds"); " is 121.
Long Statement,KRPC.Server.TCP,TCPServer,C:\repos\djungelorm_krpc\server\src\Server\TCP\TCPServer.cs,Start,The length of the statement  "                Logger.WriteLine ("TCPServer: failed to start server' timed out waiting for TcpListener to start"' Logger.Severity.Error); " is 122.
Long Statement,KRPC.Server.TCP,TCPServer,C:\repos\djungelorm_krpc\server\src\Server\TCP\TCPServer.cs,Stop,The length of the statement  "                Logger.WriteLine ("TCPServer: cancelling pending connection to client (" + client.Address + ")"' Logger.Severity.Debug); " is 120.
Long Statement,KRPC.Server.TCP,TCPServer,C:\repos\djungelorm_krpc\server\src\Server\TCP\TCPServer.cs,ListenerThread,The length of the statement  "                        Logger.WriteLine ("TCPServer.Listener: client requesting connection (" + client.Client.RemoteEndPoint + ")"' Logger.Severity.Debug); " is 132.
Long Statement,KRPC.Server.WebSockets,ConnectionRequest,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\ConnectionRequest.cs,CheckValid,The length of the statement  "            if (!request.Headers.ContainsKey ("upgrade") || request.Headers ["upgrade"].SingleOrDefault ().ToLower () != "websocket") " is 121.
Long Statement,KRPC.Server.WebSockets,ConnectionRequest,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\ConnectionRequest.cs,CheckValid,The length of the statement  "            if (!request.Headers.ContainsKey ("connection") || !request.Headers ["connection"].Contains ("upgrade"' StringComparer.CurrentCultureIgnoreCase)) " is 145.
Long Statement,KRPC.Server.WebSockets,ConnectionRequest,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\ConnectionRequest.cs,CheckValid,The length of the statement  "                    throw new HandshakeException (Response.CreateBadRequest ("Failed to decode Sec-WebSocket-Key\nExpected 16 bytes' got " + key.Length + " bytes.")); " is 146.
Long Statement,KRPC.Server.WebSockets,ConnectionRequest,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\ConnectionRequest.cs,CheckValid,The length of the statement  "            if (!request.Headers.ContainsKey ("sec-websocket-version") || request.Headers ["sec-websocket-version"].SingleOrDefault () != "13") { " is 133.
Long Statement,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The length of the statement  "                        if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) { " is 170.
Long Statement,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The length of the statement  "                        if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) { " is 170.
Long Statement,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The length of the statement  "                        if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) { " is 130.
Long Statement,KRPC.Server.WebSockets,StreamServer,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\StreamServer.cs,GetGuid,The length of the statement  "                    Logger.WriteLine ("Invalid WebSockets URI: id is not 16 bytes' got " + length + " bytes: " + id' Logger.Severity.Error); " is 120.
Long Statement,KRPC.Service,ClassMethodHandler,C:\repos\djungelorm_krpc\server\src\Service\ClassMethodHandler.cs,Invoke,The length of the statement  "            // TODO: should be able to invoke default arguments using Type.Missing' but get "System.ArgumentException : failed to convert parameters" " is 137.
Long Statement,KRPC.Service,ClassStaticMethodHandler,C:\repos\djungelorm_krpc\server\src\Service\ClassStaticMethodHandler.cs,Invoke,The length of the statement  "            // TODO: should be able to invoke default arguments using Type.Missing' but get "System.ArgumentException : failed to convert parameters" " is 137.
Long Statement,KRPC.Service,ProcedureHandler,C:\repos\djungelorm_krpc\server\src\Service\ProcedureHandler.cs,Invoke,The length of the statement  "            // TODO: should be able to invoke default arguments using Type.Missing' but get "System.ArgumentException : failed to convert parameters" " is 137.
Long Statement,KRPC.Service,Services,C:\repos\djungelorm_krpc\server\src\Service\Services.cs,GetArguments,The length of the statement  "                        throw new RPCException ("Argument not specified for parameter " + parameter.Name + " in " + procedure.FullyQualifiedName + ". "); " is 129.
Long Statement,KRPC.Service,TypeUtils,C:\repos\djungelorm_krpc\server\src\Service\TypeUtils.cs,IsAValidType,The length of the statement  "            return IsAValueType (type) || IsAMessageType (type) || IsAClassType (type) || IsAnEnumType (type) || IsACollectionType (type); " is 126.
Long Statement,KRPC.Service,TypeUtils,C:\repos\djungelorm_krpc\server\src\Service\TypeUtils.cs,IsACollectionType,The length of the statement  "            return IsATupleCollectionType (type) || IsAListCollectionType (type) || IsASetCollectionType (type) || IsADictionaryCollectionType (type); " is 138.
Long Statement,KRPC.Service,TypeUtils,C:\repos\djungelorm_krpc\server\src\Service\TypeUtils.cs,ValidateKRPCClass,The length of the statement  "            if (attribute.Service == null && (declaringType == null || !Reflection.HasAttribute<KRPCServiceAttribute> (declaringType))) " is 123.
Long Statement,KRPC.Service,TypeUtils,C:\repos\djungelorm_krpc\server\src\Service\TypeUtils.cs,ValidateKRPCClass,The length of the statement  "                        throw new ServiceException ("KRPCClass " + type + " is declared inside a KRPCService' but has the service name explicitly set"); " is 128.
Long Statement,KRPC.Service,TypeUtils,C:\repos\djungelorm_krpc\server\src\Service\TypeUtils.cs,ValidateKRPCEnum,The length of the statement  "                throw new ServiceException ("KRPCEnum " + type + " has underlying type " + Enum.GetUnderlyingType (type) + "; but only int is supported"); " is 138.
Long Statement,KRPC.Service,TypeUtils,C:\repos\djungelorm_krpc\server\src\Service\TypeUtils.cs,ValidateKRPCEnum,The length of the statement  "            if (attribute.Service == null && (declaringType == null || !Reflection.HasAttribute<KRPCServiceAttribute> (declaringType))) " is 123.
Long Statement,KRPC.Service,TypeUtils,C:\repos\djungelorm_krpc\server\src\Service\TypeUtils.cs,ValidateKRPCEnum,The length of the statement  "                        throw new ServiceException ("KRPCClass " + type + " is declared inside a KRPCService' but has the service name explicitly set"); " is 128.
Long Statement,KRPC.Service,TypeUtils,C:\repos\djungelorm_krpc\server\src\Service\TypeUtils.cs,ValidateKRPCException,The length of the statement  "            if (attribute.Service == null && (declaringType == null || !Reflection.HasAttribute<KRPCServiceAttribute> (declaringType))) " is 123.
Long Statement,KRPC.Service,TypeUtils,C:\repos\djungelorm_krpc\server\src\Service\TypeUtils.cs,ValidateKRPCException,The length of the statement  "                        throw new ServiceException ("KRPCException " + type + " is declared inside a KRPCService' but has the service name explicitly set"); " is 132.
Long Statement,KRPC.Service.Scanner,ServiceSignature,C:\repos\djungelorm_krpc\server\src\Service\Scanner\ServiceSignature.cs,AddPropertyProcedure,The length of the statement  "            AddProcedure (new ProcedureSignature (Name' method.Name' NextProcedureId' property.GetDocumentation ()' handler' GameScene)); " is 125.
Long Statement,KRPC.Service.Scanner,ServiceSignature,C:\repos\djungelorm_krpc\server\src\Service\Scanner\ServiceSignature.cs,AddEnum,The length of the statement  "                values.Add (new EnumerationValueSignature (Name' name' field.Name' (int)field.GetRawConstantValue ()' field.GetDocumentation ())); " is 130.
Long Statement,KRPC.Service.Scanner,ServiceSignature,C:\repos\djungelorm_krpc\server\src\Service\Scanner\ServiceSignature.cs,AddClassMethod,The length of the statement  "                AddProcedure (new ProcedureSignature (Name' cls + "_static_" + name' id' method.GetDocumentation ()' handler' GameScene)); " is 122.
Long Statement,KRPC.Service.Scanner,ServiceSignature,C:\repos\djungelorm_krpc\server\src\Service\Scanner\ServiceSignature.cs,AddClassPropertyMethod,The length of the statement  "            AddProcedure (new ProcedureSignature (Name' cls + '_' + method.Name' NextProcedureId' property.GetDocumentation ()' handler' GameScene)); " is 137.
Long Statement,KRPC.UI,ClientConnectingDialog,C:\repos\djungelorm_krpc\server\src\UI\ClientConnectingDialog.cs,Opened,The length of the statement  "            Message = (clientName.Length == 0 ? "A client" : "'" + clientName + "'") + " is attempting to connect from " + clientAddress; " is 125.
Long Statement,KRPC.UI,EditServer,C:\repos\djungelorm_krpc\server\src\UI\EditServer.cs,Draw,The length of the statement  "            protocol = (Protocol)GUILayoutExtensions.ComboBox ("protocol"' (int)protocol' availableProtocols' window.buttonStyle' window.comboOptionsStyle' window.comboOptionStyle); " is 169.
Long Statement,KRPC.UI,EditServer,C:\repos\djungelorm_krpc\server\src\UI\EditServer.cs,Draw,The length of the statement  "                addressSelected = GUILayoutExtensions.ComboBox("address"' addressSelected' availableAddresses' window.buttonStyle' window.comboOptionsStyle' window.comboOptionStyle); " is 166.
Long Statement,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,ComboBox,The length of the statement  "            if (ComboBoxWindow.Instance.Caller == caller && ComboBoxWindow.Instance.Visible && comboButtonPositions.ContainsKey (caller)) { " is 127.
Long Statement,KRPC.UI,InfoWindow,C:\repos\djungelorm_krpc\server\src\UI\InfoWindow.cs,Draw,The length of the statement  "            DrawInfo (rpcExecutionMode' config.OneRPCPerUpdate ? singleRPCModeText : (config.AdaptiveRateControl ? adaptiveModeText : staticModeText)); " is 139.
Long Statement,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawServer,The length of the statement  "                if (GUILayout.Button(new GUIContent(expanded ? icons.ButtonCollapse : icons.ButtonExpand' expanded ? "Collapse" : "Expand")' " is 124.
Long Statement,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawAdvancedServerOptionsToggle,The length of the statement  "            bool value = GUILayout.Toggle (showAdvancedServerOptions' advancedServerOptionsText' toggleStyle' new GUILayoutOption[] { }); " is 125.
Long Statement,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawAutoStartServerToggle,The length of the statement  "            bool autoStartServers = GUILayout.Toggle (config.Configuration.AutoStartServers' autoStartServerText' toggleStyle' new GUILayoutOption[] { }); " is 142.
Long Statement,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawAutoAcceptConnectionsToggle,The length of the statement  "            bool autoAcceptConnections = GUILayout.Toggle (config.Configuration.AutoAcceptConnections' autoAcceptConnectionsText' toggleStyle' new GUILayoutOption [] { }); " is 159.
Long Statement,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawPauseServerWithGameToggle,The length of the statement  "            bool pauseServerWithGame = GUILayout.Toggle (config.Configuration.PauseServerWithGame' pauseServerWithGameText' toggleStyle' new GUILayoutOption [] { }); " is 153.
Long Statement,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawConfirmRemoveClientToggle,The length of the statement  "            bool confirmRemoveClient = GUILayout.Toggle (config.Configuration.ConfirmRemoveClient' confirmRemoveClientText' toggleStyle' new GUILayoutOption[] { }); " is 152.
Long Statement,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawOneRPCPerUpdateToggle,The length of the statement  "            bool oneRPCPerUpdate = GUILayout.Toggle (config.Configuration.OneRPCPerUpdate' oneRPCPerUpdateText' toggleStyle' new GUILayoutOption[] { }); " is 140.
Long Statement,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawAdaptiveRateControlToggle,The length of the statement  "            bool adaptiveRateControl = GUILayout.Toggle (config.Configuration.AdaptiveRateControl' adaptiveRateControlText' toggleStyle' new GUILayoutOption[] { }); " is 152.
Long Statement,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawBlockingRecvToggle,The length of the statement  "            bool blockingRecv = GUILayout.Toggle (config.Configuration.BlockingRecv' blockingRecvText' toggleStyle' new GUILayoutOption[] { }); " is 131.
Long Statement,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawDebugLogging,The length of the statement  "            bool debugLogging = GUILayout.Toggle (config.Configuration.DebugLogging' debugLoggingText' toggleStyle' new GUILayoutOption[] { }); " is 131.
Long Statement,KRPC.UI,OptionDialog,C:\repos\djungelorm_krpc\server\src\UI\OptionDialog.cs,Open,The length of the statement  "                popup = PopupDialog.SpawnPopupDialog (new Vector2 (0.5f' 0.5f)' new Vector2 (0.5f' 0.5f)' dialog' false' HighLogic.UISkin); " is 123.
Long Statement,KRPC.UI,Window,C:\repos\djungelorm_krpc\server\src\UI\Window.cs,DrawWindow,The length of the statement  "                if (GUI.Button (new Rect (Position.width - (2 + closeButtonStyle.fixedWidth)' 2' closeButtonStyle.fixedWidth' closeButtonStyle.fixedHeight)' " is 140.
Long Statement,KRPC.Utils,APILoader,C:\repos\djungelorm_krpc\server\src\Utils\APILoader.cs,Load,The length of the statement  "                    Error ("Failed to load " + assemblyName + "; found version " + version + " but version >= " + requiredVersion + " is required"); " is 128.
Long Statement,KRPC.Utils,DocumentationExtensions,C:\repos\djungelorm_krpc\server\src\Utils\DocumentationExtensions.cs,GetDocumentation,The length of the statement  "            var path = Path.GetDirectoryName (assemblyPath) + Path.DirectorySeparatorChar + Path.GetFileNameWithoutExtension (assemblyPath) + ".xml"; " is 137.
Long Statement,KRPC.Utils,Reflection,C:\repos\djungelorm_krpc\server\src\Utils\Reflection.cs,IsStatic,The length of the statement  "            return (property.GetGetMethod () == null || property.GetGetMethod ().IsStatic) && (property.GetSetMethod () == null || property.GetSetMethod ().IsStatic); " is 154.
Long Statement,KRPC.Utils,Reflection,C:\repos\djungelorm_krpc\server\src\Utils\Reflection.cs,IsPublic,The length of the statement  "            return (property.GetGetMethod () == null || property.GetGetMethod ().IsPublic) && (property.GetSetMethod () == null || property.GetSetMethod ().IsPublic); " is 154.
Complex Conditional,KRPC,Addon,C:\repos\djungelorm_krpc\server\src\Addon.cs,Awake,The conditional expression  "HighLogic.LoadedScene != GameScenes.EDITOR &&                  HighLogic.LoadedScene != GameScenes.FLIGHT &&                  HighLogic.LoadedScene != GameScenes.SPACECENTER &&                  HighLogic.LoadedScene != GameScenes.TRACKSTATION"  is complex.
Complex Conditional,KRPC.Server.SerialIO,ByteServer,C:\repos\djungelorm_krpc\server\src\Server\SerialIO\ByteServer.cs,Update,The conditional expression  "client == null && pendingClient == null && port.IsOpen && port.BytesToRead > 0"  is complex.
Complex Conditional,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The conditional expression  "status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)"  is complex.
Complex Conditional,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,ComboOptionsStyle,The conditional expression  "x < border || x > texture.width - border || y < border || y > texture.height - border"  is complex.
Empty Catch Block,KRPC.Server.ProtocolBuffers,MessageExtensions,C:\repos\djungelorm_krpc\server\src\Server\ProtocolBuffers\MessageExtensions.cs,ToMessage,The method has an empty catch block.
Empty Catch Block,KRPC.Server.SerialIO,ByteServer,C:\repos\djungelorm_krpc\server\src\Server\SerialIO\ByteServer.cs,DisconnectClient,The method has an empty catch block.
Empty Catch Block,KRPC.Server.TCP,TCPClient,C:\repos\djungelorm_krpc\server\src\Server\TCP\TCPClient.cs,TCPClient,The method has an empty catch block.
Empty Catch Block,KRPC.Server.TCP,TCPClient,C:\repos\djungelorm_krpc\server\src\Server\TCP\TCPClient.cs,TCPClient,The method has an empty catch block.
Empty Catch Block,KRPC.Server.TCP,TCPServer,C:\repos\djungelorm_krpc\server\src\Server\TCP\TCPServer.cs,DisconnectClient,The method has an empty catch block.
Empty Catch Block,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawClients,The method has an empty catch block.
Empty Catch Block,KRPC.UI,OptionDialog,C:\repos\djungelorm_krpc\server\src\UI\OptionDialog.cs,Close,The method has an empty catch block.
Magic Number,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,IsCompatible,The following statement contains a magic number: var kspVersion = Versioning.version_major * 10000 + Versioning.version_minor * 100 + Versioning.Revision;
Magic Number,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,IsCompatible,The following statement contains a magic number: var kspVersion = Versioning.version_major * 10000 + Versioning.version_minor * 100 + Versioning.Revision;
Magic Number,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,IsCompatible,The following statement contains a magic number: var maxVersion = version.MaxMajor * 10000 + version.MaxMinor * 100 + version.MaxPatch;
Magic Number,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,IsCompatible,The following statement contains a magic number: var maxVersion = version.MaxMajor * 10000 + version.MaxMinor * 100 + version.MaxPatch;
Magic Number,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,IsCompatible,The following statement contains a magic number: var minVersion = version.MinMajor * 10000 + version.MinMinor * 100 + version.MinPatch;
Magic Number,KRPC,CompatibilityChecker,C:\repos\djungelorm_krpc\server\src\CompatibilityChecker.cs,IsCompatible,The following statement contains a magic number: var minVersion = version.MinMajor * 10000 + version.MinMinor * 100 + version.MinPatch;
Magic Number,KRPC,Configuration,C:\repos\djungelorm_krpc\server\src\Configuration.cs,Configuration,The following statement contains a magic number: MaxTimePerUpdate = 5000;
Magic Number,KRPC,Configuration,C:\repos\djungelorm_krpc\server\src\Configuration.cs,Configuration,The following statement contains a magic number: RecvTimeout = 1000;
Magic Number,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,Update,The following statement contains a magic number: if (config.AdaptiveRateControl) {                  var targetTicks = Stopwatch.Frequency / 59;                  if (ticksElapsed > targetTicks) {                      if (config.MaxTimePerUpdate > 1000)                          config.MaxTimePerUpdate -= 100;                  } else {                      if (ExecTimePerRPCUpdate < 0.001) {                          config.MaxTimePerUpdate = 10000;                      } else {                          if (config.MaxTimePerUpdate < 25000)                              config.MaxTimePerUpdate += 100;                      }                  }              }
Magic Number,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,Update,The following statement contains a magic number: if (config.AdaptiveRateControl) {                  var targetTicks = Stopwatch.Frequency / 59;                  if (ticksElapsed > targetTicks) {                      if (config.MaxTimePerUpdate > 1000)                          config.MaxTimePerUpdate -= 100;                  } else {                      if (ExecTimePerRPCUpdate < 0.001) {                          config.MaxTimePerUpdate = 10000;                      } else {                          if (config.MaxTimePerUpdate < 25000)                              config.MaxTimePerUpdate += 100;                      }                  }              }
Magic Number,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,Update,The following statement contains a magic number: if (config.AdaptiveRateControl) {                  var targetTicks = Stopwatch.Frequency / 59;                  if (ticksElapsed > targetTicks) {                      if (config.MaxTimePerUpdate > 1000)                          config.MaxTimePerUpdate -= 100;                  } else {                      if (ExecTimePerRPCUpdate < 0.001) {                          config.MaxTimePerUpdate = 10000;                      } else {                          if (config.MaxTimePerUpdate < 25000)                              config.MaxTimePerUpdate += 100;                      }                  }              }
Magic Number,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,Update,The following statement contains a magic number: if (config.AdaptiveRateControl) {                  var targetTicks = Stopwatch.Frequency / 59;                  if (ticksElapsed > targetTicks) {                      if (config.MaxTimePerUpdate > 1000)                          config.MaxTimePerUpdate -= 100;                  } else {                      if (ExecTimePerRPCUpdate < 0.001) {                          config.MaxTimePerUpdate = 10000;                      } else {                          if (config.MaxTimePerUpdate < 25000)                              config.MaxTimePerUpdate += 100;                      }                  }              }
Magic Number,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,Update,The following statement contains a magic number: if (config.AdaptiveRateControl) {                  var targetTicks = Stopwatch.Frequency / 59;                  if (ticksElapsed > targetTicks) {                      if (config.MaxTimePerUpdate > 1000)                          config.MaxTimePerUpdate -= 100;                  } else {                      if (ExecTimePerRPCUpdate < 0.001) {                          config.MaxTimePerUpdate = 10000;                      } else {                          if (config.MaxTimePerUpdate < 25000)                              config.MaxTimePerUpdate += 100;                      }                  }              }
Magic Number,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,Update,The following statement contains a magic number: if (config.AdaptiveRateControl) {                  var targetTicks = Stopwatch.Frequency / 59;                  if (ticksElapsed > targetTicks) {                      if (config.MaxTimePerUpdate > 1000)                          config.MaxTimePerUpdate -= 100;                  } else {                      if (ExecTimePerRPCUpdate < 0.001) {                          config.MaxTimePerUpdate = 10000;                      } else {                          if (config.MaxTimePerUpdate < 25000)                              config.MaxTimePerUpdate += 100;                      }                  }              }
Magic Number,KRPC,Core,C:\repos\djungelorm_krpc\server\src\Core.cs,Update,The following statement contains a magic number: if (config.AdaptiveRateControl) {                  var targetTicks = Stopwatch.Frequency / 59;                  if (ticksElapsed > targetTicks) {                      if (config.MaxTimePerUpdate > 1000)                          config.MaxTimePerUpdate -= 100;                  } else {                      if (ExecTimePerRPCUpdate < 0.001) {                          config.MaxTimePerUpdate = 10000;                      } else {                          if (config.MaxTimePerUpdate < 25000)                              config.MaxTimePerUpdate += 100;                      }                  }              }
Magic Number,KRPC,ServicesChecker,C:\repos\djungelorm_krpc\server\src\ServicesChecker.cs,CheckDocumentation,The following statement contains a magic number: if (notDocumented.Count > 0) {                  var n = notDocumented.Count;                  var msg = n + " item" + (n != 1 ? "s are" : " is") + " not documented.";                  for (int i = 0; i < 10 && i < n; i++)                      msg += Environment.NewLine + notDocumented [i];                  if (n > 10)                      msg += Environment.NewLine + "...";                  Utils.Compatibility.SpawnPopupDialog(                      new Vector2 (0.5f' 0.5f)' new Vector2 (0.5f' 0.5f)' "krpc-service-warning"'                      "kRPC service warning"' msg' "OK"' true' HighLogic.UISkin);              }
Magic Number,KRPC,ServicesChecker,C:\repos\djungelorm_krpc\server\src\ServicesChecker.cs,CheckDocumentation,The following statement contains a magic number: if (notDocumented.Count > 0) {                  var n = notDocumented.Count;                  var msg = n + " item" + (n != 1 ? "s are" : " is") + " not documented.";                  for (int i = 0; i < 10 && i < n; i++)                      msg += Environment.NewLine + notDocumented [i];                  if (n > 10)                      msg += Environment.NewLine + "...";                  Utils.Compatibility.SpawnPopupDialog(                      new Vector2 (0.5f' 0.5f)' new Vector2 (0.5f' 0.5f)' "krpc-service-warning"'                      "kRPC service warning"' msg' "OK"' true' HighLogic.UISkin);              }
Magic Number,KRPC.Server.HTTP,Request,C:\repos\djungelorm_krpc\server\src\Server\HTTP\Request.cs,FromString,The following statement contains a magic number: using (var line = content.Split (new [] { NEWLINE }' StringSplitOptions.None).AsEnumerable ().GetEnumerator ()) {                  // Parse request line                  if (!line.MoveNext ())                      throw new MalformedRequestException ("No request line");                  var requestLineParts = line.Current.Split (' ');                  if (requestLineParts.Length != 3)                      throw new MalformedRequestException ("Request line malformed");                  if (requestLineParts [0].Length == 0)                      throw new MalformedRequestException ("Invalid or unsupported method");                  request.Method = requestLineParts [0].ToLower ();                  try {                      var baseUri = new Uri ("http://localhost/");                      request.URI = new Uri (baseUri' requestLineParts [1]);                  } catch (UriFormatException) {                      throw new MalformedRequestException ("URI is malformed");                  }                  if (requestLineParts [2].Length == 0)                      throw new MalformedRequestException ("Invalid or unsupported protocol");                  request.Protocol = requestLineParts [2].ToLower ();                    // Parse header fields                  if (!line.MoveNext ())                      throw new MalformedRequestException ("Request ended early");                  request.Headers = new Dictionary<string' IList<string>>();                  while (line.Current.Length > 0) {                      var i = line.Current.IndexOf (':');                      if (i == -1)                          throw new MalformedRequestException ("Header field malformed");                      var key = line.Current.Substring (0' i).Trim ().ToLower ();                      var value = line.Current.Substring (i + 1).Trim ();                      if (key.Length == 0)                          throw new MalformedRequestException ("Header field key empty");                      if (value.Length == 0)                          throw new MalformedRequestException ("Header field value empty");                      if (request.Headers.ContainsKey (key))                          throw new MalformedRequestException ("Header field repeated");                      request.Headers[key] = value.Split (''').Select (x => x.Trim ()).ToList ();                      if (!line.MoveNext ())                          throw new MalformedRequestException ("Request ended early");                  }                    // End of request                  if (line.Current.Length > 0 || !line.MoveNext () || line.Current.Length > 0)                      throw new MalformedRequestException ("Request ended early: ");                  if (line.MoveNext ())                      throw new MalformedRequestException ("Request too long");              }
Magic Number,KRPC.Server.HTTP,Request,C:\repos\djungelorm_krpc\server\src\Server\HTTP\Request.cs,FromString,The following statement contains a magic number: using (var line = content.Split (new [] { NEWLINE }' StringSplitOptions.None).AsEnumerable ().GetEnumerator ()) {                  // Parse request line                  if (!line.MoveNext ())                      throw new MalformedRequestException ("No request line");                  var requestLineParts = line.Current.Split (' ');                  if (requestLineParts.Length != 3)                      throw new MalformedRequestException ("Request line malformed");                  if (requestLineParts [0].Length == 0)                      throw new MalformedRequestException ("Invalid or unsupported method");                  request.Method = requestLineParts [0].ToLower ();                  try {                      var baseUri = new Uri ("http://localhost/");                      request.URI = new Uri (baseUri' requestLineParts [1]);                  } catch (UriFormatException) {                      throw new MalformedRequestException ("URI is malformed");                  }                  if (requestLineParts [2].Length == 0)                      throw new MalformedRequestException ("Invalid or unsupported protocol");                  request.Protocol = requestLineParts [2].ToLower ();                    // Parse header fields                  if (!line.MoveNext ())                      throw new MalformedRequestException ("Request ended early");                  request.Headers = new Dictionary<string' IList<string>>();                  while (line.Current.Length > 0) {                      var i = line.Current.IndexOf (':');                      if (i == -1)                          throw new MalformedRequestException ("Header field malformed");                      var key = line.Current.Substring (0' i).Trim ().ToLower ();                      var value = line.Current.Substring (i + 1).Trim ();                      if (key.Length == 0)                          throw new MalformedRequestException ("Header field key empty");                      if (value.Length == 0)                          throw new MalformedRequestException ("Header field value empty");                      if (request.Headers.ContainsKey (key))                          throw new MalformedRequestException ("Header field repeated");                      request.Headers[key] = value.Split (''').Select (x => x.Trim ()).ToList ();                      if (!line.MoveNext ())                          throw new MalformedRequestException ("Request ended early");                  }                    // End of request                  if (line.Current.Length > 0 || !line.MoveNext () || line.Current.Length > 0)                      throw new MalformedRequestException ("Request ended early: ");                  if (line.MoveNext ())                      throw new MalformedRequestException ("Request too long");              }
Magic Number,KRPC.Server.HTTP,Request,C:\repos\djungelorm_krpc\server\src\Server\HTTP\Request.cs,FromString,The following statement contains a magic number: using (var line = content.Split (new [] { NEWLINE }' StringSplitOptions.None).AsEnumerable ().GetEnumerator ()) {                  // Parse request line                  if (!line.MoveNext ())                      throw new MalformedRequestException ("No request line");                  var requestLineParts = line.Current.Split (' ');                  if (requestLineParts.Length != 3)                      throw new MalformedRequestException ("Request line malformed");                  if (requestLineParts [0].Length == 0)                      throw new MalformedRequestException ("Invalid or unsupported method");                  request.Method = requestLineParts [0].ToLower ();                  try {                      var baseUri = new Uri ("http://localhost/");                      request.URI = new Uri (baseUri' requestLineParts [1]);                  } catch (UriFormatException) {                      throw new MalformedRequestException ("URI is malformed");                  }                  if (requestLineParts [2].Length == 0)                      throw new MalformedRequestException ("Invalid or unsupported protocol");                  request.Protocol = requestLineParts [2].ToLower ();                    // Parse header fields                  if (!line.MoveNext ())                      throw new MalformedRequestException ("Request ended early");                  request.Headers = new Dictionary<string' IList<string>>();                  while (line.Current.Length > 0) {                      var i = line.Current.IndexOf (':');                      if (i == -1)                          throw new MalformedRequestException ("Header field malformed");                      var key = line.Current.Substring (0' i).Trim ().ToLower ();                      var value = line.Current.Substring (i + 1).Trim ();                      if (key.Length == 0)                          throw new MalformedRequestException ("Header field key empty");                      if (value.Length == 0)                          throw new MalformedRequestException ("Header field value empty");                      if (request.Headers.ContainsKey (key))                          throw new MalformedRequestException ("Header field repeated");                      request.Headers[key] = value.Split (''').Select (x => x.Trim ()).ToList ();                      if (!line.MoveNext ())                          throw new MalformedRequestException ("Request ended early");                  }                    // End of request                  if (line.Current.Length > 0 || !line.MoveNext () || line.Current.Length > 0)                      throw new MalformedRequestException ("Request ended early: ");                  if (line.MoveNext ())                      throw new MalformedRequestException ("Request too long");              }
Magic Number,KRPC.Server.HTTP,Response,C:\repos\djungelorm_krpc\server\src\Server\HTTP\Response.cs,CreateBadRequest,The following statement contains a magic number: return new Response (400' "Bad Request"' message);
Magic Number,KRPC.Server.HTTP,Response,C:\repos\djungelorm_krpc\server\src\Server\HTTP\Response.cs,CreateNotFound,The following statement contains a magic number: return new Response (404' "Not Found"' message);
Magic Number,KRPC.Server.HTTP,Response,C:\repos\djungelorm_krpc\server\src\Server\HTTP\Response.cs,CreateMethodNotAllowed,The following statement contains a magic number: return new Response (405' "Method Not Allowed"' message);
Magic Number,KRPC.Server.HTTP,Response,C:\repos\djungelorm_krpc\server\src\Server\HTTP\Response.cs,CreateUpgradeRequired,The following statement contains a magic number: return new Response (426' "Upgrade Required"' message);
Magic Number,KRPC.Server.HTTP,Response,C:\repos\djungelorm_krpc\server\src\Server\HTTP\Response.cs,CreateHTTPVersionNotSupported,The following statement contains a magic number: return new Response (505' "HTTP Version Not Supported"' message);
Magic Number,KRPC.Server.ProtocolBuffers,StreamServer,C:\repos\djungelorm_krpc\server\src\Server\ProtocolBuffers\StreamServer.cs,CreateClient,The following statement contains a magic number: try {                  bool timeout;                  var request = Utils.ReadMessage<ConnectionRequest> (client' out timeout);                  if (timeout) {                      WriteErrorConnectionResponse (Status.Timeout' "Connection request message not received after waiting 3 seconds"' stream);                      args.Request.Deny ();                      return null;                  }                  if (request == null)                      return null;                  if (request.Type != Type.Stream) {                      var name = request.Type.ToString ().ToLower ();                      WriteErrorConnectionResponse (Status.WrongType'                          "Connection request was for the " + name + " server' but this is the stream server. " +                          "Did you connect to the wrong port number?"' stream);                  } else if (request.ClientIdentifier.Length != 16) {                      WriteErrorConnectionResponse (Status.MalformedMessage' "Client identifier must be 16 bytes."' stream);                  } else {                      var guid = new Guid (request.ClientIdentifier.ToByteArray ());                      return new StreamClient (guid' args.Client);                  }              } catch (InvalidProtocolBufferException e) {                  WriteErrorConnectionResponse (Status.MalformedMessage' e.Message' stream);              }
Magic Number,KRPC.Server.ProtocolBuffers,Utils,C:\repos\djungelorm_krpc\server\src\Server\ProtocolBuffers\Utils.cs,ReadMessage,The following statement contains a magic number: if (request == null) {                  if (readMessageTimers.ContainsKey (client) && readMessageTimers [client].ElapsedSeconds () > 3) {                      readMessageTimers.Remove (client);                      readMessageBuffers.Remove (client);                      timeout = true;                      return null;                  }                  readMessageBuffers [client] = buffer;                  if (!readMessageTimers.ContainsKey (client)) {                      var timer = new Stopwatch ();                      timer.Start ();                      readMessageTimers [client] = timer;                  }                  return null;              }
Magic Number,KRPC.Server.ProtocolBuffers,Utils,C:\repos\djungelorm_krpc\server\src\Server\ProtocolBuffers\Utils.cs,ReadMessage,The following statement contains a magic number: byte[] buffer = new byte[4096];
Magic Number,KRPC.Server.SerialIO,ByteServer,C:\repos\djungelorm_krpc\server\src\Server\SerialIO\ByteServer.cs,ByteServer,The following statement contains a magic number: if (dataBits < 5 || dataBits > 8)                  throw new ArgumentException ("Data bits must be 5' 6' 7 or 8"' nameof (dataBits));
Magic Number,KRPC.Server.SerialIO,ByteServer,C:\repos\djungelorm_krpc\server\src\Server\SerialIO\ByteServer.cs,ByteServer,The following statement contains a magic number: if (dataBits < 5 || dataBits > 8)                  throw new ArgumentException ("Data bits must be 5' 6' 7 or 8"' nameof (dataBits));
Magic Number,KRPC.Server.TCP,TCPServer,C:\repos\djungelorm_krpc\server\src\Server\TCP\TCPServer.cs,Start,The following statement contains a magic number: startedEvent.WaitOne (500);
Magic Number,KRPC.Server.TCP,TCPServer,C:\repos\djungelorm_krpc\server\src\Server\TCP\TCPServer.cs,Stop,The following statement contains a magic number: if (!listenerThread.Join (3000))                  throw new ServerException ("Failed to stop TCP listener thread (timed out after 3 seconds)");
Magic Number,KRPC.Server.WebSockets,ConnectionRequest,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\ConnectionRequest.cs,WriteResponse,The following statement contains a magic number: var response = new Response (101' "Switching Protocols");
Magic Number,KRPC.Server.WebSockets,ConnectionRequest,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\ConnectionRequest.cs,CheckValid,The following statement contains a magic number: try {                  var key = Convert.FromBase64String (request.Headers ["sec-websocket-key"].SingleOrDefault ());                  if (key.Length != 16)                      throw new HandshakeException (Response.CreateBadRequest ("Failed to decode Sec-WebSocket-Key\nExpected 16 bytes' got " + key.Length + " bytes."));              } catch (FormatException e) {                  throw new HandshakeException (Response.CreateBadRequest ("Failed to decode Sec-WebSocket-Key\n" + e.Message));              }
Magic Number,KRPC.Server.WebSockets,Frame,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Frame.cs,FromBytes,The following statement contains a magic number: if (frame.Header.Length == 0)                  frame.Payload = new byte[0];              else {                  // See if the payload has been partially received                  frame.IsPartial = (count < (int)frame.Header.Length);                  // Payload must be masked                  if (!frame.Header.Masked)                      throw new FramingException (1002' "Payload is not masked");                  // Unmask the payload                  frame.Payload = new byte [count < (int)frame.Header.Length ? count : (int)frame.Header.Length];                  for (int i = 0; i < frame.Payload.Length; i++)                      frame.Payload [i] = (byte)(data [index + i] ^ frame.Header.MaskingKey [i % 4]);              }
Magic Number,KRPC.Server.WebSockets,Frame,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Frame.cs,FromBytes,The following statement contains a magic number: if (frame.Header.Length == 0)                  frame.Payload = new byte[0];              else {                  // See if the payload has been partially received                  frame.IsPartial = (count < (int)frame.Header.Length);                  // Payload must be masked                  if (!frame.Header.Masked)                      throw new FramingException (1002' "Payload is not masked");                  // Unmask the payload                  frame.Payload = new byte [count < (int)frame.Header.Length ? count : (int)frame.Header.Length];                  for (int i = 0; i < frame.Payload.Length; i++)                      frame.Payload [i] = (byte)(data [index + i] ^ frame.Header.MaskingKey [i % 4]);              }
Magic Number,KRPC.Server.WebSockets,Frame,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Frame.cs,Close,The following statement contains a magic number: Array.Copy (messageBytes' 0' payload' 2' messageBytes.Length);
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,ToBytes,The following statement contains a magic number: if (Length <= 125) {                  bytes [1] |= (byte)Length;              } else if (Length <= 0xffff) {                  bytes [1] |= 126;                  byte[] size = BitConverter.GetBytes ((short)Length);                  bytes [2] = size [1];                  bytes [3] = size [0];              } else {                  bytes [1] |= 127;                  byte[] size = BitConverter.GetBytes ((long)Length);                  for (int i = 0; i < 8; i++)                      bytes [2 + i] = size [7 - i];              }
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,ToBytes,The following statement contains a magic number: if (Length <= 125) {                  bytes [1] |= (byte)Length;              } else if (Length <= 0xffff) {                  bytes [1] |= 126;                  byte[] size = BitConverter.GetBytes ((short)Length);                  bytes [2] = size [1];                  bytes [3] = size [0];              } else {                  bytes [1] |= 127;                  byte[] size = BitConverter.GetBytes ((long)Length);                  for (int i = 0; i < 8; i++)                      bytes [2 + i] = size [7 - i];              }
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,ToBytes,The following statement contains a magic number: if (Length <= 125) {                  bytes [1] |= (byte)Length;              } else if (Length <= 0xffff) {                  bytes [1] |= 126;                  byte[] size = BitConverter.GetBytes ((short)Length);                  bytes [2] = size [1];                  bytes [3] = size [0];              } else {                  bytes [1] |= 127;                  byte[] size = BitConverter.GetBytes ((long)Length);                  for (int i = 0; i < 8; i++)                      bytes [2 + i] = size [7 - i];              }
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,ToBytes,The following statement contains a magic number: if (Length <= 125) {                  bytes [1] |= (byte)Length;              } else if (Length <= 0xffff) {                  bytes [1] |= 126;                  byte[] size = BitConverter.GetBytes ((short)Length);                  bytes [2] = size [1];                  bytes [3] = size [0];              } else {                  bytes [1] |= 127;                  byte[] size = BitConverter.GetBytes ((long)Length);                  for (int i = 0; i < 8; i++)                      bytes [2 + i] = size [7 - i];              }
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,ToBytes,The following statement contains a magic number: if (Length <= 125) {                  bytes [1] |= (byte)Length;              } else if (Length <= 0xffff) {                  bytes [1] |= 126;                  byte[] size = BitConverter.GetBytes ((short)Length);                  bytes [2] = size [1];                  bytes [3] = size [0];              } else {                  bytes [1] |= 127;                  byte[] size = BitConverter.GetBytes ((long)Length);                  for (int i = 0; i < 8; i++)                      bytes [2 + i] = size [7 - i];              }
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,ToBytes,The following statement contains a magic number: if (Length <= 125) {                  bytes [1] |= (byte)Length;              } else if (Length <= 0xffff) {                  bytes [1] |= 126;                  byte[] size = BitConverter.GetBytes ((short)Length);                  bytes [2] = size [1];                  bytes [3] = size [0];              } else {                  bytes [1] |= 127;                  byte[] size = BitConverter.GetBytes ((long)Length);                  for (int i = 0; i < 8; i++)                      bytes [2 + i] = size [7 - i];              }
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,ToBytes,The following statement contains a magic number: if (Length <= 125) {                  bytes [1] |= (byte)Length;              } else if (Length <= 0xffff) {                  bytes [1] |= 126;                  byte[] size = BitConverter.GetBytes ((short)Length);                  bytes [2] = size [1];                  bytes [3] = size [0];              } else {                  bytes [1] |= 127;                  byte[] size = BitConverter.GetBytes ((long)Length);                  for (int i = 0; i < 8; i++)                      bytes [2 + i] = size [7 - i];              }
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,ToBytes,The following statement contains a magic number: if (Length <= 125) {                  bytes [1] |= (byte)Length;              } else if (Length <= 0xffff) {                  bytes [1] |= 126;                  byte[] size = BitConverter.GetBytes ((short)Length);                  bytes [2] = size [1];                  bytes [3] = size [0];              } else {                  bytes [1] |= 127;                  byte[] size = BitConverter.GetBytes ((long)Length);                  for (int i = 0; i < 8; i++)                      bytes [2 + i] = size [7 - i];              }
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,ToBytes,The following statement contains a magic number: if (Masked)                  Array.Copy (MaskingKey' 0' bytes' bytes.Length - 4' 4);
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,ToBytes,The following statement contains a magic number: if (Masked)                  Array.Copy (MaskingKey' 0' bytes' bytes.Length - 4' 4);
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: var headerLength = 2;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (!Enum.IsDefined (typeof(OpCode)' firstByte & OP_CODE_MASK))                  throw new FramingException (1002' "Invalid op code");
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (!header.FinalFragment && isControl)                  throw new FramingException (1002' "Control frames must not be fragmented");
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (payloadLength == 126) {                  headerLength += 2;                  if (length < headerLength)                      throw new NoRequestException ();                  var thirdByte = data [index + 2];                  var fourthByte = data [index + 3];                  byte[] lengthBytes = { fourthByte' thirdByte };                  header.Length = BitConverter.ToUInt16 (lengthBytes' 0);                  extPayloadLengthSize = 2;              } else if (payloadLength == 127) {                  headerLength += 8;                  if (length < headerLength)                      throw new NoRequestException ();                  var lengthBytes = new byte[8];                  for (int i = 0; i < 8; i++)                      lengthBytes [i] = data [index + 9 - i];                  header.Length = BitConverter.ToUInt64 (lengthBytes' 0);                  extPayloadLengthSize = 8;              } else                  header.Length = payloadLength;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (payloadLength == 126) {                  headerLength += 2;                  if (length < headerLength)                      throw new NoRequestException ();                  var thirdByte = data [index + 2];                  var fourthByte = data [index + 3];                  byte[] lengthBytes = { fourthByte' thirdByte };                  header.Length = BitConverter.ToUInt16 (lengthBytes' 0);                  extPayloadLengthSize = 2;              } else if (payloadLength == 127) {                  headerLength += 8;                  if (length < headerLength)                      throw new NoRequestException ();                  var lengthBytes = new byte[8];                  for (int i = 0; i < 8; i++)                      lengthBytes [i] = data [index + 9 - i];                  header.Length = BitConverter.ToUInt64 (lengthBytes' 0);                  extPayloadLengthSize = 8;              } else                  header.Length = payloadLength;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (payloadLength == 126) {                  headerLength += 2;                  if (length < headerLength)                      throw new NoRequestException ();                  var thirdByte = data [index + 2];                  var fourthByte = data [index + 3];                  byte[] lengthBytes = { fourthByte' thirdByte };                  header.Length = BitConverter.ToUInt16 (lengthBytes' 0);                  extPayloadLengthSize = 2;              } else if (payloadLength == 127) {                  headerLength += 8;                  if (length < headerLength)                      throw new NoRequestException ();                  var lengthBytes = new byte[8];                  for (int i = 0; i < 8; i++)                      lengthBytes [i] = data [index + 9 - i];                  header.Length = BitConverter.ToUInt64 (lengthBytes' 0);                  extPayloadLengthSize = 8;              } else                  header.Length = payloadLength;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (payloadLength == 126) {                  headerLength += 2;                  if (length < headerLength)                      throw new NoRequestException ();                  var thirdByte = data [index + 2];                  var fourthByte = data [index + 3];                  byte[] lengthBytes = { fourthByte' thirdByte };                  header.Length = BitConverter.ToUInt16 (lengthBytes' 0);                  extPayloadLengthSize = 2;              } else if (payloadLength == 127) {                  headerLength += 8;                  if (length < headerLength)                      throw new NoRequestException ();                  var lengthBytes = new byte[8];                  for (int i = 0; i < 8; i++)                      lengthBytes [i] = data [index + 9 - i];                  header.Length = BitConverter.ToUInt64 (lengthBytes' 0);                  extPayloadLengthSize = 8;              } else                  header.Length = payloadLength;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (payloadLength == 126) {                  headerLength += 2;                  if (length < headerLength)                      throw new NoRequestException ();                  var thirdByte = data [index + 2];                  var fourthByte = data [index + 3];                  byte[] lengthBytes = { fourthByte' thirdByte };                  header.Length = BitConverter.ToUInt16 (lengthBytes' 0);                  extPayloadLengthSize = 2;              } else if (payloadLength == 127) {                  headerLength += 8;                  if (length < headerLength)                      throw new NoRequestException ();                  var lengthBytes = new byte[8];                  for (int i = 0; i < 8; i++)                      lengthBytes [i] = data [index + 9 - i];                  header.Length = BitConverter.ToUInt64 (lengthBytes' 0);                  extPayloadLengthSize = 8;              } else                  header.Length = payloadLength;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (payloadLength == 126) {                  headerLength += 2;                  if (length < headerLength)                      throw new NoRequestException ();                  var thirdByte = data [index + 2];                  var fourthByte = data [index + 3];                  byte[] lengthBytes = { fourthByte' thirdByte };                  header.Length = BitConverter.ToUInt16 (lengthBytes' 0);                  extPayloadLengthSize = 2;              } else if (payloadLength == 127) {                  headerLength += 8;                  if (length < headerLength)                      throw new NoRequestException ();                  var lengthBytes = new byte[8];                  for (int i = 0; i < 8; i++)                      lengthBytes [i] = data [index + 9 - i];                  header.Length = BitConverter.ToUInt64 (lengthBytes' 0);                  extPayloadLengthSize = 8;              } else                  header.Length = payloadLength;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (payloadLength == 126) {                  headerLength += 2;                  if (length < headerLength)                      throw new NoRequestException ();                  var thirdByte = data [index + 2];                  var fourthByte = data [index + 3];                  byte[] lengthBytes = { fourthByte' thirdByte };                  header.Length = BitConverter.ToUInt16 (lengthBytes' 0);                  extPayloadLengthSize = 2;              } else if (payloadLength == 127) {                  headerLength += 8;                  if (length < headerLength)                      throw new NoRequestException ();                  var lengthBytes = new byte[8];                  for (int i = 0; i < 8; i++)                      lengthBytes [i] = data [index + 9 - i];                  header.Length = BitConverter.ToUInt64 (lengthBytes' 0);                  extPayloadLengthSize = 8;              } else                  header.Length = payloadLength;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (payloadLength == 126) {                  headerLength += 2;                  if (length < headerLength)                      throw new NoRequestException ();                  var thirdByte = data [index + 2];                  var fourthByte = data [index + 3];                  byte[] lengthBytes = { fourthByte' thirdByte };                  header.Length = BitConverter.ToUInt16 (lengthBytes' 0);                  extPayloadLengthSize = 2;              } else if (payloadLength == 127) {                  headerLength += 8;                  if (length < headerLength)                      throw new NoRequestException ();                  var lengthBytes = new byte[8];                  for (int i = 0; i < 8; i++)                      lengthBytes [i] = data [index + 9 - i];                  header.Length = BitConverter.ToUInt64 (lengthBytes' 0);                  extPayloadLengthSize = 8;              } else                  header.Length = payloadLength;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (payloadLength == 126) {                  headerLength += 2;                  if (length < headerLength)                      throw new NoRequestException ();                  var thirdByte = data [index + 2];                  var fourthByte = data [index + 3];                  byte[] lengthBytes = { fourthByte' thirdByte };                  header.Length = BitConverter.ToUInt16 (lengthBytes' 0);                  extPayloadLengthSize = 2;              } else if (payloadLength == 127) {                  headerLength += 8;                  if (length < headerLength)                      throw new NoRequestException ();                  var lengthBytes = new byte[8];                  for (int i = 0; i < 8; i++)                      lengthBytes [i] = data [index + 9 - i];                  header.Length = BitConverter.ToUInt64 (lengthBytes' 0);                  extPayloadLengthSize = 8;              } else                  header.Length = payloadLength;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (payloadLength == 126) {                  headerLength += 2;                  if (length < headerLength)                      throw new NoRequestException ();                  var thirdByte = data [index + 2];                  var fourthByte = data [index + 3];                  byte[] lengthBytes = { fourthByte' thirdByte };                  header.Length = BitConverter.ToUInt16 (lengthBytes' 0);                  extPayloadLengthSize = 2;              } else if (payloadLength == 127) {                  headerLength += 8;                  if (length < headerLength)                      throw new NoRequestException ();                  var lengthBytes = new byte[8];                  for (int i = 0; i < 8; i++)                      lengthBytes [i] = data [index + 9 - i];                  header.Length = BitConverter.ToUInt64 (lengthBytes' 0);                  extPayloadLengthSize = 8;              } else                  header.Length = payloadLength;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (payloadLength == 126) {                  headerLength += 2;                  if (length < headerLength)                      throw new NoRequestException ();                  var thirdByte = data [index + 2];                  var fourthByte = data [index + 3];                  byte[] lengthBytes = { fourthByte' thirdByte };                  header.Length = BitConverter.ToUInt16 (lengthBytes' 0);                  extPayloadLengthSize = 2;              } else if (payloadLength == 127) {                  headerLength += 8;                  if (length < headerLength)                      throw new NoRequestException ();                  var lengthBytes = new byte[8];                  for (int i = 0; i < 8; i++)                      lengthBytes [i] = data [index + 9 - i];                  header.Length = BitConverter.ToUInt64 (lengthBytes' 0);                  extPayloadLengthSize = 8;              } else                  header.Length = payloadLength;
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (isControl && header.Length >= 126)                  throw new FramingException (1002' "Control frame payload must not exceed 125 bytes");
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (isControl && header.Length >= 126)                  throw new FramingException (1002' "Control frame payload must not exceed 125 bytes");
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (isMasked) {                  headerLength += 4;                  if (length < headerLength)                      throw new NoRequestException ();                  var mask = new byte[4];                  Array.Copy (data' index + 2 + extPayloadLengthSize' mask' 0' 4);                  header.MaskingKey = mask;              }
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (isMasked) {                  headerLength += 4;                  if (length < headerLength)                      throw new NoRequestException ();                  var mask = new byte[4];                  Array.Copy (data' index + 2 + extPayloadLengthSize' mask' 0' 4);                  header.MaskingKey = mask;              }
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (isMasked) {                  headerLength += 4;                  if (length < headerLength)                      throw new NoRequestException ();                  var mask = new byte[4];                  Array.Copy (data' index + 2 + extPayloadLengthSize' mask' 0' 4);                  header.MaskingKey = mask;              }
Magic Number,KRPC.Server.WebSockets,Header,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\Header.cs,FromBytes,The following statement contains a magic number: if (isMasked) {                  headerLength += 4;                  if (length < headerLength)                      throw new NoRequestException ();                  var mask = new byte[4];                  Array.Copy (data' index + 2 + extPayloadLengthSize' mask' 0' 4);                  header.MaskingKey = mask;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,RPCStream,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\RPCStream.cs,Read,The following statement contains a magic number: while (length > 0) {                  // Read the next frame                  Frame frame;                  try {                      frame = Frame.FromBytes (data' offset' length);                  } catch (FramingException e) {                      Stream.Write (Frame.Close (e.Status' e.Message).ToBytes ());                      Stream.Close ();                      throw new MalformedRequestException (e.ToString ());                  } catch (NoRequestException) {                      return read;                  }                    // Fail if rsv bits are set                  if (frame.Header.Rsv1 || frame.Header.Rsv2 || frame.Header.Rsv3) {                      Logger.WriteLine ("WebSockets invalid message: RSV bit(s) set in frame header"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a continue frame is received before a start frame                  if (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Fail if a start frame is received before the fragmented message ends                  if (frame.Header.OpCode != OpCode.Continue && !frame.Header.IsControl && fragmentsOpCode != OpCode.Close) {                      Logger.WriteLine ("WebSockets invalid message: message start fragment received out of order"' Logger.Severity.Error);                      Stream.Write (Frame.Close (1002).ToBytes ());                      Stream.Close ();                      break;                  }                    // Partial payload received                  if (frame.IsPartial) {                      // Check that partially received text frames are valid UTF8                      if (frame.Header.OpCode == OpCode.Text || (frame.Header.OpCode == OpCode.Continue && fragmentsOpCode == OpCode.Text)) {                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsPayload.Length -= frame.Payload.Length;                      }                      break;                  }                    if (!frame.Header.IsControl && frame.Header.OpCode != OpCode.Continue && !frame.Header.FinalFragment)                      fragmentsOpCode = frame.Header.OpCode;                    // Get the op code for the frame' or Binary if the frame is a fragment of a message                  var opCode = frame.Header.OpCode;                  if (frame.Header.OpCode == OpCode.Continue)                      opCode = fragmentsOpCode;                    // Handle fragmented non-control frames                  byte[] payload = null;                  if (!frame.Header.IsControl) {                      if (!frame.Header.FinalFragment) {                          // We haven't received the entire message yet                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                      } else if (fragmentsPayload.Length > 0) {                          // Payload for the entire message from the fragments                          fragmentsPayload.Append (frame.Payload' 0' frame.Payload.Length);                          payload = fragmentsPayload.ToArray ();                          fragmentsPayload.Length = 0;                          fragmentsVerifiedPosition = 0;                      } else {                          // Unfragmented message                          payload = frame.Payload;                      }                  }                    // Handle the frame                  if (opCode == OpCode.Binary) {                      // Process binary frame                      if (frame.Header.FinalFragment) {                          if (shouldEcho)                              Stream.Write (Frame.Binary (payload).ToBytes ());                          else {                              try {                                  request = Schema.KRPC.Request.Parser.ParseFrom (payload).ToMessage ();                              } catch (InvalidProtocolBufferException) {                                  Logger.WriteLine ("WebSockets invalid message: failed to decode protobuf message"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1007' "Malformed protocol buffer message").ToBytes ());                                  Stream.Close ();                              }                          }                      }                  } else if (opCode == OpCode.Text) {                      // Process text frame                      if (frame.Header.FinalFragment) {                          if (!Text.IsValidUTF8 (payload' 0' payload.Length)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          } else {                              if (shouldEcho) {                                  Stream.Write (new Frame (OpCode.Text' payload).ToBytes ());                              } else {                                  Logger.WriteLine ("WebSockets invalid message: text frames are not permitted"' Logger.Severity.Error);                                  Stream.Write (Frame.Close (1003' "Text frames are not permitted").ToBytes ());                                  Stream.Close ();                              }                          }                      } else if (fragmentsPayload.Length > 0) {                          int truncatedCharLength = 0;                          if (!Text.IsValidTruncatedUTF8 (fragmentsPayload.GetBuffer ()' fragmentsVerifiedPosition' fragmentsPayload.Length - fragmentsVerifiedPosition' ref truncatedCharLength)) {                              Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1007' "Malformed UTF8 string").ToBytes ());                              Stream.Close ();                          }                          fragmentsVerifiedPosition = fragmentsPayload.Length - truncatedCharLength;                      }                  } else if (opCode == OpCode.Ping) {                      // Send pong with copy of ping's payload                      Stream.Write (Frame.Pong (frame.Payload).ToBytes ());                  } else if (opCode == OpCode.Close) {                      if (frame.Header.Length >= 2) {                          // Get status code from frame                          var status = BitConverter.ToUInt16 (new [] { frame.Payload [1]' frame.Payload [0] }' 0);                          if (status < 1000 || status == 1004 || status == 1005 || status == 1006 || status == 1014 || (1015 <= status && status <= 2999)) {                              // Send close if status code is invalid                              Logger.WriteLine ("WebSockets invalid message: invalid close status code"' Logger.Severity.Error);                              Stream.Write (Frame.Close (1002).ToBytes ());                          } else if (status >= 5000) {                              // Close connection if undefined status is used                          } else {                              if (frame.Header.Length > 2) {                                  // Validate the contents as UTF8                                  if (!Text.IsValidUTF8 (frame.Payload' 2' (int)frame.Header.Length - 2)) {                                      Logger.WriteLine ("WebSockets invalid message: malformed UTF8 string"' Logger.Severity.Error);                                      Stream.Write (Frame.Close (1002).ToBytes ());                                      Stream.Close ();                                      break;                                  }                              }                              // Send close with copy of status and optional message                              Stream.Write (Frame.Close (frame.Payload).ToBytes ());                          }                      } else {                          // Send close with no status                          Stream.Write (Frame.Close ().ToBytes ());                      }                      Stream.Close ();                  }                    read += frame.Length;                  offset += frame.Length;                  length -= frame.Length;                  if (request != null)                      return read;              }
Magic Number,KRPC.Server.WebSockets,StreamServer,C:\repos\djungelorm_krpc\server\src\Server\WebSockets\StreamServer.cs,GetGuid,The following statement contains a magic number: try {                  var bytes = Convert.FromBase64String (id);                  var length = bytes.Length;                  if (length != 16) {                      Logger.WriteLine ("Invalid WebSockets URI: id is not 16 bytes' got " + length + " bytes: " + id' Logger.Severity.Error);                      return Guid.Empty;                  }                  return new Guid (bytes);              } catch (FormatException) {                  Logger.WriteLine ("Invalid WebSockets URI: id is not a valid 16 byte Guid"' Logger.Severity.Error);                  return Guid.Empty;              }
Magic Number,KRPC.Service,DocumentationUtils,C:\repos\djungelorm_krpc\server\src\Service\DocumentationUtils.cs,ResolveCref,The following statement contains a magic number: if (cref.Length <= 3 || cref [1] != ':')                  throw new DocumentationException ("Invalid cref '" + cref + "'");
Magic Number,KRPC.Service,DocumentationUtils,C:\repos\djungelorm_krpc\server\src\Service\DocumentationUtils.cs,ResolveCref,The following statement contains a magic number: var reference = cref.Substring (2);
Magic Number,KRPC.Service,TypeUtils,C:\repos\djungelorm_krpc\server\src\Service\TypeUtils.cs,IsADictionaryCollectionType,The following statement contains a magic number: return Reflection.IsGenericType (type' typeof(IDictionary<'>)) &&              type.GetGenericArguments ().Length == 2 &&              IsAValidKeyType (type.GetGenericArguments () [0]) &&              IsAValidType (type.GetGenericArguments () [1]);
Magic Number,KRPC.Service.Scanner,ProcedureSignature,C:\repos\djungelorm_krpc\server\src\Service\Scanner\ProcedureSignature.cs,ProcedureSignature,The following statement contains a magic number: if (parts.Length == 2) {                  if (parts [0] == ("get")) {                      IsPropertyGetter = true;                      PropertyName = parts [1];                  } else if (parts [0] == "set") {                      IsPropertySetter = true;                      PropertyName = parts [1];                  } else {                      IsClassMember = true;                      ClassName = parts [0];                  }              } else if (parts.Length == 3) {                  if (parts [1] == "get") {                      IsClassMember = true;                      IsPropertyGetter = true;                      PropertyName = parts [2];                  } else if (parts [1] == "set") {                      IsClassMember = true;                      ClassName = parts [0];                      IsPropertySetter = true;                      PropertyName = parts [2];                  } else if (parts [1] == "static") {                      IsClassMember = true;                      ClassName = parts [0];                      IsStatic = true;                  }              }
Magic Number,KRPC.Service.Scanner,ProcedureSignature,C:\repos\djungelorm_krpc\server\src\Service\Scanner\ProcedureSignature.cs,ProcedureSignature,The following statement contains a magic number: if (parts.Length == 2) {                  if (parts [0] == ("get")) {                      IsPropertyGetter = true;                      PropertyName = parts [1];                  } else if (parts [0] == "set") {                      IsPropertySetter = true;                      PropertyName = parts [1];                  } else {                      IsClassMember = true;                      ClassName = parts [0];                  }              } else if (parts.Length == 3) {                  if (parts [1] == "get") {                      IsClassMember = true;                      IsPropertyGetter = true;                      PropertyName = parts [2];                  } else if (parts [1] == "set") {                      IsClassMember = true;                      ClassName = parts [0];                      IsPropertySetter = true;                      PropertyName = parts [2];                  } else if (parts [1] == "static") {                      IsClassMember = true;                      ClassName = parts [0];                      IsStatic = true;                  }              }
Magic Number,KRPC.Service.Scanner,ProcedureSignature,C:\repos\djungelorm_krpc\server\src\Service\Scanner\ProcedureSignature.cs,ProcedureSignature,The following statement contains a magic number: if (parts.Length == 2) {                  if (parts [0] == ("get")) {                      IsPropertyGetter = true;                      PropertyName = parts [1];                  } else if (parts [0] == "set") {                      IsPropertySetter = true;                      PropertyName = parts [1];                  } else {                      IsClassMember = true;                      ClassName = parts [0];                  }              } else if (parts.Length == 3) {                  if (parts [1] == "get") {                      IsClassMember = true;                      IsPropertyGetter = true;                      PropertyName = parts [2];                  } else if (parts [1] == "set") {                      IsClassMember = true;                      ClassName = parts [0];                      IsPropertySetter = true;                      PropertyName = parts [2];                  } else if (parts [1] == "static") {                      IsClassMember = true;                      ClassName = parts [0];                      IsStatic = true;                  }              }
Magic Number,KRPC.Service.Scanner,ProcedureSignature,C:\repos\djungelorm_krpc\server\src\Service\Scanner\ProcedureSignature.cs,ProcedureSignature,The following statement contains a magic number: if (parts.Length == 2) {                  if (parts [0] == ("get")) {                      IsPropertyGetter = true;                      PropertyName = parts [1];                  } else if (parts [0] == "set") {                      IsPropertySetter = true;                      PropertyName = parts [1];                  } else {                      IsClassMember = true;                      ClassName = parts [0];                  }              } else if (parts.Length == 3) {                  if (parts [1] == "get") {                      IsClassMember = true;                      IsPropertyGetter = true;                      PropertyName = parts [2];                  } else if (parts [1] == "set") {                      IsClassMember = true;                      ClassName = parts [0];                      IsPropertySetter = true;                      PropertyName = parts [2];                  } else if (parts [1] == "static") {                      IsClassMember = true;                      ClassName = parts [0];                      IsStatic = true;                  }              }
Magic Number,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,SetLightStyleSize,The following statement contains a magic number: var offset = (int)(-0.8 * size);
Magic Number,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,SetLightStyleSize,The following statement contains a magic number: style.border = new RectOffset (offset - 4' offset + 4' offset + 4' offset - 4);
Magic Number,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,SetLightStyleSize,The following statement contains a magic number: style.border = new RectOffset (offset - 4' offset + 4' offset + 4' offset - 4);
Magic Number,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,SetLightStyleSize,The following statement contains a magic number: style.border = new RectOffset (offset - 4' offset + 4' offset + 4' offset - 4);
Magic Number,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,SetLightStyleSize,The following statement contains a magic number: style.border = new RectOffset (offset - 4' offset + 4' offset + 4' offset - 4);
Magic Number,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,SetLightStyleSize,The following statement contains a magic number: style.margin = new RectOffset (4' 0' 0' 0);
Magic Number,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,ComboOptionsStyle,The following statement contains a magic number: var texture = new Texture2D (16' 16' TextureFormat.RGBA32' false);
Magic Number,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,ComboOptionsStyle,The following statement contains a magic number: var texture = new Texture2D (16' 16' TextureFormat.RGBA32' false);
Magic Number,KRPC.UI,GUILayoutExtensions,C:\repos\djungelorm_krpc\server\src\UI\GUILayoutExtensions.cs,ComboOptionsStyle,The following statement contains a magic number: const int border = 2;
Magic Number,KRPC.UI,Icons,C:\repos\djungelorm_krpc\server\src\UI\Icons.cs,LoadTexture,The following statement contains a magic number: filepath = iconsPath + "/" + filepath.Substring (0' filepath.Length - 4);
Magic Number,KRPC.UI,InfoWindow,C:\repos\djungelorm_krpc\server\src\UI\InfoWindow.cs,Init,The following statement contains a magic number: separatorStyle.fixedHeight = 2;
Magic Number,KRPC.UI,InfoWindow,C:\repos\djungelorm_krpc\server\src\UI\InfoWindow.cs,Init,The following statement contains a magic number: separatorStyle.margin = new RectOffset (2' 2' 3' 3);
Magic Number,KRPC.UI,InfoWindow,C:\repos\djungelorm_krpc\server\src\UI\InfoWindow.cs,Init,The following statement contains a magic number: separatorStyle.margin = new RectOffset (2' 2' 3' 3);
Magic Number,KRPC.UI,InfoWindow,C:\repos\djungelorm_krpc\server\src\UI\InfoWindow.cs,Init,The following statement contains a magic number: separatorStyle.margin = new RectOffset (2' 2' 3' 3);
Magic Number,KRPC.UI,InfoWindow,C:\repos\djungelorm_krpc\server\src\UI\InfoWindow.cs,Init,The following statement contains a magic number: separatorStyle.margin = new RectOffset (2' 2' 3' 3);
Magic Number,KRPC.UI,InfoWindow,C:\repos\djungelorm_krpc\server\src\UI\InfoWindow.cs,BytesToString,The following statement contains a magic number: int place = Convert.ToInt32 (Math.Floor (Math.Log (bytes' 1024)));
Magic Number,KRPC.UI,InfoWindow,C:\repos\djungelorm_krpc\server\src\UI\InfoWindow.cs,BytesToString,The following statement contains a magic number: double num = Math.Round (bytes / Math.Pow (1024' place)' 1);
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,Init,The following statement contains a magic number: toggleStyle.contentOffset = new Vector2 (4' 0);
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,Init,The following statement contains a magic number: expandStyle.fixedWidth = 16;
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,Init,The following statement contains a magic number: expandStyle.fixedHeight = 16;
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,Init,The following statement contains a magic number: separatorStyle.fixedHeight = 2;
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,Init,The following statement contains a magic number: separatorStyle.margin = new RectOffset (2' 2' 3' 3);
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,Init,The following statement contains a magic number: separatorStyle.margin = new RectOffset (2' 2' 3' 3);
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,Init,The following statement contains a magic number: separatorStyle.margin = new RectOffset (2' 2' 3' 3);
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,Init,The following statement contains a magic number: separatorStyle.margin = new RectOffset (2' 2' 3' 3);
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawServer,The following statement contains a magic number: if (!forceExpanded) {                  var icons = Icons.Instance;                  if (GUILayout.Button(new GUIContent(expanded ? icons.ButtonCollapse : icons.ButtonExpand' expanded ? "Collapse" : "Expand")'                          expandStyle' GUILayout.MaxWidth(20)' GUILayout.MaxHeight(20))) {                      if (expanded)                          expandServers.Remove(server.Id);                      else                          expandServers.Add(server.Id);                      expanded = !expanded;                      Resized = true;                  }              }
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawServer,The following statement contains a magic number: if (!forceExpanded) {                  var icons = Icons.Instance;                  if (GUILayout.Button(new GUIContent(expanded ? icons.ButtonCollapse : icons.ButtonExpand' expanded ? "Collapse" : "Expand")'                          expandStyle' GUILayout.MaxWidth(20)' GUILayout.MaxHeight(20))) {                      if (expanded)                          expandServers.Remove(server.Id);                      else                          expandServers.Add(server.Id);                      expanded = !expanded;                      Resized = true;                  }              }
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawClients,The following statement contains a magic number: if (clientDescriptions.Any ()) {                  foreach (var entry in clientDescriptions) {                      var client = entry.Key;                      var description = entry.Value;                      GUILayout.BeginHorizontal ();                      GUILayoutExtensions.Light (IsClientActive (client)' lightStyle);                      GUILayout.Label (description' stretchyLabelStyle);                      if (GUILayout.Button (new GUIContent (Icons.Instance.ButtonDisconnectClient' "Disconnect client")'                              buttonStyle' GUILayout.MaxWidth (20)' GUILayout.MaxHeight (20))) {                          if (config.Configuration.ConfirmRemoveClient)                              ClientDisconnectDialog.Show (client);                          else                              client.Close ();                      }                      GUILayout.EndHorizontal ();                  }              } else {                  GUILayout.BeginHorizontal ();                  GUILayout.Label (noClientsConnectedText' labelStyle);                  GUILayout.EndHorizontal ();              }
Magic Number,KRPC.UI,MainWindow,C:\repos\djungelorm_krpc\server\src\UI\MainWindow.cs,DrawClients,The following statement contains a magic number: if (clientDescriptions.Any ()) {                  foreach (var entry in clientDescriptions) {                      var client = entry.Key;                      var description = entry.Value;                      GUILayout.BeginHorizontal ();                      GUILayoutExtensions.Light (IsClientActive (client)' lightStyle);                      GUILayout.Label (description' stretchyLabelStyle);                      if (GUILayout.Button (new GUIContent (Icons.Instance.ButtonDisconnectClient' "Disconnect client")'                              buttonStyle' GUILayout.MaxWidth (20)' GUILayout.MaxHeight (20))) {                          if (config.Configuration.ConfirmRemoveClient)                              ClientDisconnectDialog.Show (client);                          else                              client.Close ();                      }                      GUILayout.EndHorizontal ();                  }              } else {                  GUILayout.BeginHorizontal ();                  GUILayout.Label (noClientsConnectedText' labelStyle);                  GUILayout.EndHorizontal ();              }
Magic Number,KRPC.UI,Window,C:\repos\djungelorm_krpc\server\src\UI\Window.cs,OnGUI,The following statement contains a magic number: if (Visible) {                  var newUiScale = (int)(GameSettings.UI_SCALE * 100);                  if (uiScale != newUiScale) {                      rescale = true;                      uiScale = newUiScale;                      Style.fontSize = (int)(14 * GameSettings.UI_SCALE);                      closeButtonStyle.fixedWidth = 16 * GameSettings.UI_SCALE;                      closeButtonStyle.fixedHeight = 16 * GameSettings.UI_SCALE;                  }                  var newPosition = GUILayout.Window (id' Position' DrawWindow' Title' Style);                  if (newPosition != Position) {                      if (!moving) {                          moving = true;                          EventHandlerExtensions.Invoke(OnStartMoving' this' new MovedEventArgs(Position));                      }                      movingCounter = 0;                  }                  Position = newPosition;              }
Magic Number,KRPC.UI,Window,C:\repos\djungelorm_krpc\server\src\UI\Window.cs,OnGUI,The following statement contains a magic number: if (Visible) {                  var newUiScale = (int)(GameSettings.UI_SCALE * 100);                  if (uiScale != newUiScale) {                      rescale = true;                      uiScale = newUiScale;                      Style.fontSize = (int)(14 * GameSettings.UI_SCALE);                      closeButtonStyle.fixedWidth = 16 * GameSettings.UI_SCALE;                      closeButtonStyle.fixedHeight = 16 * GameSettings.UI_SCALE;                  }                  var newPosition = GUILayout.Window (id' Position' DrawWindow' Title' Style);                  if (newPosition != Position) {                      if (!moving) {                          moving = true;                          EventHandlerExtensions.Invoke(OnStartMoving' this' new MovedEventArgs(Position));                      }                      movingCounter = 0;                  }                  Position = newPosition;              }
Magic Number,KRPC.UI,Window,C:\repos\djungelorm_krpc\server\src\UI\Window.cs,OnGUI,The following statement contains a magic number: if (Visible) {                  var newUiScale = (int)(GameSettings.UI_SCALE * 100);                  if (uiScale != newUiScale) {                      rescale = true;                      uiScale = newUiScale;                      Style.fontSize = (int)(14 * GameSettings.UI_SCALE);                      closeButtonStyle.fixedWidth = 16 * GameSettings.UI_SCALE;                      closeButtonStyle.fixedHeight = 16 * GameSettings.UI_SCALE;                  }                  var newPosition = GUILayout.Window (id' Position' DrawWindow' Title' Style);                  if (newPosition != Position) {                      if (!moving) {                          moving = true;                          EventHandlerExtensions.Invoke(OnStartMoving' this' new MovedEventArgs(Position));                      }                      movingCounter = 0;                  }                  Position = newPosition;              }
Magic Number,KRPC.UI,Window,C:\repos\djungelorm_krpc\server\src\UI\Window.cs,OnGUI,The following statement contains a magic number: if (Visible) {                  var newUiScale = (int)(GameSettings.UI_SCALE * 100);                  if (uiScale != newUiScale) {                      rescale = true;                      uiScale = newUiScale;                      Style.fontSize = (int)(14 * GameSettings.UI_SCALE);                      closeButtonStyle.fixedWidth = 16 * GameSettings.UI_SCALE;                      closeButtonStyle.fixedHeight = 16 * GameSettings.UI_SCALE;                  }                  var newPosition = GUILayout.Window (id' Position' DrawWindow' Title' Style);                  if (newPosition != Position) {                      if (!moving) {                          moving = true;                          EventHandlerExtensions.Invoke(OnStartMoving' this' new MovedEventArgs(Position));                      }                      movingCounter = 0;                  }                  Position = newPosition;              }
Magic Number,KRPC.UI,Window,C:\repos\djungelorm_krpc\server\src\UI\Window.cs,OnGUI,The following statement contains a magic number: if (moving) {                  if (movingCounter > 50) {                      moving = false;                      EventHandlerExtensions.Invoke(OnFinishMoving' this' new MovedEventArgs(Position));                  }                  movingCounter++;              }
Magic Number,KRPC.UI,Window,C:\repos\djungelorm_krpc\server\src\UI\Window.cs,DrawWindow,The following statement contains a magic number: if (Closable) {                  if (GUI.Button (new Rect (Position.width - (2 + closeButtonStyle.fixedWidth)' 2' closeButtonStyle.fixedWidth' closeButtonStyle.fixedHeight)'                          new GUIContent (Icons.Instance.ButtonCloseWindow' "Close window")' closeButtonStyle)) {                      Visible = false;                  }              }
Magic Number,KRPC.UI,Window,C:\repos\djungelorm_krpc\server\src\UI\Window.cs,DrawWindow,The following statement contains a magic number: if (Closable) {                  if (GUI.Button (new Rect (Position.width - (2 + closeButtonStyle.fixedWidth)' 2' closeButtonStyle.fixedWidth' closeButtonStyle.fixedHeight)'                          new GUIContent (Icons.Instance.ButtonCloseWindow' "Close window")' closeButtonStyle)) {                      Visible = false;                  }              }
Magic Number,KRPC.UI,Window,C:\repos\djungelorm_krpc\server\src\UI\Window.cs,DrawWindow,The following statement contains a magic number: GUILayout.Space ((int)(20 * (GameSettings.UI_SCALE - 1)));
Magic Number,KRPC.UI,Window,C:\repos\djungelorm_krpc\server\src\UI\Window.cs,ConstrainToScreen,The following statement contains a magic number: const int border = 10;
Magic Number,KRPC.Utils,Compatibility,C:\repos\djungelorm_krpc\server\src\Utils\Compatibility.cs,SpawnPopupDialog,The following statement contains a magic number: if (Versioning.version_major * 100 + Versioning.version_minor >= 103) {                  // KSP 1.3.0 and up                  var method = typeof(PopupDialog).GetMethod("SpawnPopupDialog"' new Type[] {                      typeof(Vector2)' typeof(Vector2)' typeof(string)' typeof(string)' typeof(string)'                      typeof(string)' typeof(bool)' typeof(UISkinDef)' typeof(bool)' typeof(string)                  });                  return (PopupDialog)method.Invoke(null' new object[] {                      anchorMin' anchorMax' dialogName' title' message' buttonMessage'                      persistAcrossScenes' skin' isModal' titleExtra                  });              } else {                  // KSP 1.2.2 and below                  var method = typeof(PopupDialog).GetMethod("SpawnPopupDialog"' new Type[] {                      typeof(Vector2)' typeof(Vector2)' typeof(string)' typeof(string)'                      typeof(string)' typeof(bool)' typeof(UISkinDef)' typeof(bool)' typeof(string)                  });                  return (PopupDialog)method.Invoke(null' new object[] {                      anchorMin' anchorMax' title' message' buttonMessage'                      persistAcrossScenes' skin' isModal' titleExtra                  });              }
Magic Number,KRPC.Utils,Compatibility,C:\repos\djungelorm_krpc\server\src\Utils\Compatibility.cs,SpawnPopupDialog,The following statement contains a magic number: if (Versioning.version_major * 100 + Versioning.version_minor >= 103) {                  // KSP 1.3.0 and up                  var method = typeof(PopupDialog).GetMethod("SpawnPopupDialog"' new Type[] {                      typeof(Vector2)' typeof(Vector2)' typeof(string)' typeof(string)' typeof(string)'                      typeof(string)' typeof(bool)' typeof(UISkinDef)' typeof(bool)' typeof(string)                  });                  return (PopupDialog)method.Invoke(null' new object[] {                      anchorMin' anchorMax' dialogName' title' message' buttonMessage'                      persistAcrossScenes' skin' isModal' titleExtra                  });              } else {                  // KSP 1.2.2 and below                  var method = typeof(PopupDialog).GetMethod("SpawnPopupDialog"' new Type[] {                      typeof(Vector2)' typeof(Vector2)' typeof(string)' typeof(string)'                      typeof(string)' typeof(bool)' typeof(UISkinDef)' typeof(bool)' typeof(string)                  });                  return (PopupDialog)method.Invoke(null' new object[] {                      anchorMin' anchorMax' title' message' buttonMessage'                      persistAcrossScenes' skin' isModal' titleExtra                  });              }
Magic Number,KRPC.Utils,Compatibility,C:\repos\djungelorm_krpc\server\src\Utils\Compatibility.cs,NewMultiOptionDialog,The following statement contains a magic number: if (Versioning.version_major * 100 + Versioning.version_minor >= 103) {                  // KSP 1.3.0 and up                  var ctor = typeof(MultiOptionDialog).GetConstructor(new Type[] {                      typeof(string)' typeof(string)' typeof(string)'                      typeof(UISkinDef)' typeof(DialogGUIBase[])                  });                  return (MultiOptionDialog)ctor.Invoke(null' new object[] {                      name' msg' windowTitle' skin' options                  });              } else {                  // KSP 1.2.2 and below                  var ctor = typeof(MultiOptionDialog).GetConstructor(new Type[] {                      typeof(string)' typeof(string)'                      typeof(UISkinDef)' typeof(DialogGUIBase[])                  });                  return (MultiOptionDialog)ctor.Invoke(null' new object[] {                      msg' windowTitle' skin' options                  });              }
Magic Number,KRPC.Utils,Compatibility,C:\repos\djungelorm_krpc\server\src\Utils\Compatibility.cs,NewMultiOptionDialog,The following statement contains a magic number: if (Versioning.version_major * 100 + Versioning.version_minor >= 103) {                  // KSP 1.3.0 and up                  var ctor = typeof(MultiOptionDialog).GetConstructor(new Type[] {                      typeof(string)' typeof(string)' typeof(string)'                      typeof(UISkinDef)' typeof(DialogGUIBase[])                  });                  return (MultiOptionDialog)ctor.Invoke(null' new object[] {                      name' msg' windowTitle' skin' options                  });              } else {                  // KSP 1.2.2 and below                  var ctor = typeof(MultiOptionDialog).GetConstructor(new Type[] {                      typeof(string)' typeof(string)'                      typeof(UISkinDef)' typeof(DialogGUIBase[])                  });                  return (MultiOptionDialog)ctor.Invoke(null' new object[] {                      msg' windowTitle' skin' options                  });              }
Magic Number,KRPC.Utils,Text,C:\repos\djungelorm_krpc\server\src\Utils\Text.cs,IsValidTruncatedUTF8,The following statement contains a magic number: if ((startByte & ONE_BYTE_MASK) == ONE_BYTE_HEAD)                  maxContinuationBytes = 0;              else if ((startByte & TWO_BYTE_MASK) == TWO_BYTE_HEAD)                  maxContinuationBytes = 1;              else if ((startByte & THREE_BYTE_MASK) == THREE_BYTE_HEAD)                  maxContinuationBytes = 2;              else if ((startByte & FOUR_BYTE_MASK) == FOUR_BYTE_HEAD)                  maxContinuationBytes = 3;              else                  // Start byte was not valid                  return false;
Magic Number,KRPC.Utils,Text,C:\repos\djungelorm_krpc\server\src\Utils\Text.cs,IsValidTruncatedUTF8,The following statement contains a magic number: if ((startByte & ONE_BYTE_MASK) == ONE_BYTE_HEAD)                  maxContinuationBytes = 0;              else if ((startByte & TWO_BYTE_MASK) == TWO_BYTE_HEAD)                  maxContinuationBytes = 1;              else if ((startByte & THREE_BYTE_MASK) == THREE_BYTE_HEAD)                  maxContinuationBytes = 2;              else if ((startByte & FOUR_BYTE_MASK) == FOUR_BYTE_HEAD)                  maxContinuationBytes = 3;              else                  // Start byte was not valid                  return false;
Magic Number,KRPC.Utils,Text,C:\repos\djungelorm_krpc\server\src\Utils\Text.cs,IsValidTruncatedUTF8,The following statement contains a magic number: if (maxContinuationBytes == 3) {                  if ((startByte & (~FOUR_BYTE_MASK)) > 0x4)                      return false;                  if (continuationBytes > 0 && (data [position + 1] & (~CONTINUATION_MASK)) > 0xf)                      return false;              }
Missing Default,KRPC.Server.ProtocolBuffers,MessageExtensions,C:\repos\djungelorm_krpc\server\src\Server\ProtocolBuffers\MessageExtensions.cs,ToProtobufMessage,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {                  case TypeCode.Single:                      result.Code = Schema.KRPC.Type.Types.TypeCode.Float;                      break;                  case TypeCode.Double:                      result.Code = Schema.KRPC.Type.Types.TypeCode.Double;                      break;                  case TypeCode.Int32:                      result.Code = Schema.KRPC.Type.Types.TypeCode.Sint32;                      break;                  case TypeCode.Int64:                      result.Code = Schema.KRPC.Type.Types.TypeCode.Sint64;                      break;                  case TypeCode.UInt32:                      result.Code = Schema.KRPC.Type.Types.TypeCode.Uint32;                      break;                  case TypeCode.UInt64:                      result.Code = Schema.KRPC.Type.Types.TypeCode.Uint64;                      break;                  case TypeCode.Boolean:                      result.Code = Schema.KRPC.Type.Types.TypeCode.Bool;                      break;                  case TypeCode.String:                      result.Code = Schema.KRPC.Type.Types.TypeCode.String;                      break;                  }
