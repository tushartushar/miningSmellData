Implementation smell,Namespace,Class,File,Method,Description
Long Method,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,Translate,The method has 126 lines of code.
Long Method,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateWay,The method has 168 lines of code.
Long Method,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,BuildRules,The method has 200 lines of code.
Long Method,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseRule,The method has 1153 lines of code.
Long Method,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,RenderPrimitives,The method has 116 lines of code.
Long Method,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,Get,The method has 112 lines of code.
Long Method,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,The method has 264 lines of code.
Long Method,OsmSharp.UI.Renderer.Scene.Storage,Primitive2DRTreeDeserializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\Primitive2DRTreeDeserializer.cs,DeSerialize,The method has 190 lines of code.
Long Method,OsmSharp.UI.Renderer.Scene.Storage,SceneObjectRTreeSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneObjectRTreeSerializer.cs,Serialize,The method has 153 lines of code.
Complex Method,OsmSharp.UI.Animations,CubicBezier,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\CubicBezier.cs,solveCurveX,Cyclomatic complexity of the method is 9
Complex Method,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,Translate,Cyclomatic complexity of the method is 10
Complex Method,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateNode,Cyclomatic complexity of the method is 15
Complex Method,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateWay,Cyclomatic complexity of the method is 30
Complex Method,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateLineairRing,Cyclomatic complexity of the method is 12
Complex Method,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,BuildRules,Cyclomatic complexity of the method is 11
Complex Method,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseRule,Cyclomatic complexity of the method is 20
Complex Method,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,Cyclomatic complexity of the method is 18
Complex Method,OsmSharp.UI.Renderer.Scene.Storage,Primitive2DRTreeDeserializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\Primitive2DRTreeDeserializer.cs,DeSerialize,Cyclomatic complexity of the method is 17
Complex Method,OsmSharp.UI.Renderer.Scene.Styles,StyleLine,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Styles\StyleLine.cs,Equals,Cyclomatic complexity of the method is 8
Long Parameter List,OsmSharp.UI.Map.Layers,Layer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\Layer.cs,ViewChanged,The method has 5 parameters. Parameters: map' zoomFactor' center' view' extraView
Long Parameter List,OsmSharp.UI.Map.Layers,LayerGpx,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerGpx.cs,ViewChanged,The method has 5 parameters. Parameters: map' zoomFactor' center' view' extraView
Long Parameter List,OsmSharp.UI.Map.Layers,LayerMBTile,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerMBTile.cs,ViewChanged,The method has 5 parameters. Parameters: map' zoomFactor' center' view' extraView
Long Parameter List,OsmSharp.UI.Map.Layers,LayerOsm,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerOsm.cs,ViewChanged,The method has 5 parameters. Parameters: map' zoomFactor' center' view' extraView
Long Parameter List,OsmSharp.UI.Map.Layers,LayerPrimitives,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerPrimitives.cs,ViewChanged,The method has 5 parameters. Parameters: map' zoomFactor' center' view' extraView
Long Parameter List,OsmSharp.UI.Map.Layers,LayerScene,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerScene.cs,ViewChanged,The method has 5 parameters. Parameters: map' zoomFactor' center' view' extraView
Long Parameter List,OsmSharp.UI.Map.Layers,LayerTile,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerTile.cs,ViewChanged,The method has 5 parameters. Parameters: map' zoomFactor' center' view' extraView
Long Parameter List,OsmSharp.UI.Map,MapRenderer<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\MapRenderer.cs,Render,The method has 5 parameters. Parameters: target' projection' layers' view' zoomFactor
Long Parameter List,OsmSharp.UI.Map,MapRenderer<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\MapRenderer.cs,Render,The method has 6 parameters. Parameters: target' projection' layers' view' viewRender' zoomFactor
Long Parameter List,OsmSharp.UI.Map,MapRenderer<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\MapRenderer.cs,Render,The method has 5 parameters. Parameters: target' map' view' viewRender' zoomFactor
Long Parameter List,OsmSharp.UI.Map,MapRenderer<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\MapRenderer.cs,Create,The method has 7 parameters. Parameters: width' height' map' zoomFactor' center' xInverted' yInverted
Long Parameter List,OsmSharp.UI.Map,MapRenderer<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\MapRenderer.cs,Create,The method has 8 parameters. Parameters: width' height' map' zoomFactor' center' xInverted' yInverted' angle
Long Parameter List,OsmSharp.UI.Renderer,Matrix2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Matrix2D.cs,FromRectangle,The method has 5 parameters. Parameters: rectangle' width' height' invertX' invertY
Long Parameter List,OsmSharp.UI.Renderer,Matrix2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Matrix2D.cs,ToRectangle,The method has 5 parameters. Parameters: rectangle' width' height' invertX' invertY
Long Parameter List,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,Render,The method has 5 parameters. Parameters: orginalTarget' view' zoomFactor' primitives' backcolor
Long Parameter List,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,DrawPoint,The method has 5 parameters. Parameters: target' x' y' color' size
Long Parameter List,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,DrawLine,The method has 7 parameters. Parameters: target' x' y' color' width' lineJoin' dashes
Long Parameter List,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,DrawPolygon,The method has 6 parameters. Parameters: target' x' y' color' width' fill
Long Parameter List,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,DrawImage,The method has 6 parameters. Parameters: target' left' top' right' bottom' tag
Long Parameter List,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,DrawText,The method has 9 parameters. Parameters: target' x' y' text' color' size' haloColor' haloRadius' fontName
Long Parameter List,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,DrawLineText,The method has 9 parameters. Parameters: target' x' y' text' color' size' haloColor' haloRadius' fontName
Long Parameter List,OsmSharp.UI.Renderer,View2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\View2D.cs,CreateFromCenterAndSize,The method has 6 parameters. Parameters: width' height' centerX' centerY' directionX' directionY
Long Parameter List,OsmSharp.UI.Renderer,View2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\View2D.cs,CreateFromCenterAndSize,The method has 7 parameters. Parameters: width' height' centerX' centerY' xInverted' yInverted' angleY
Long Parameter List,OsmSharp.UI.Renderer,View2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\View2D.cs,CreateFrom,The method has 7 parameters. Parameters: centerX' centerY' pixelsWidth' pixelsHeight' zoomFactor' xInverted' yInverted
Long Parameter List,OsmSharp.UI.Renderer,View2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\View2D.cs,CreateFrom,The method has 8 parameters. Parameters: centerX' centerY' pixelsWidth' pixelsHeight' zoomFactor' xInverted' yInverted' angleY
Long Parameter List,OsmSharp.UI.Renderer,View2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\View2D.cs,ToViewPort,The method has 5 parameters. Parameters: pixelsWidth' pixelsHeight' sceneX' sceneY' transformed
Long Parameter List,OsmSharp.UI.Renderer.Primitives,Icon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Icon2D.cs,Icon2D,The method has 5 parameters. Parameters: x' y' image' minZoom' maxZoom
Long Parameter List,OsmSharp.UI.Renderer.Primitives,Image2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Image2D.cs,Image2D,The method has 5 parameters. Parameters: left' top' bottom' right' nativeImage
Long Parameter List,OsmSharp.UI.Renderer.Primitives,Image2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Image2D.cs,Image2D,The method has 7 parameters. Parameters: left' top' bottom' right' nativeImage' minZoom' maxZoom
Long Parameter List,OsmSharp.UI.Renderer.Primitives,Line2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Line2D.cs,Line2D,The method has 6 parameters. Parameters: x' y' color' width' lineJoin' dashes
Long Parameter List,OsmSharp.UI.Renderer.Primitives,Line2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Line2D.cs,Line2D,The method has 8 parameters. Parameters: x' y' color' width' lineJoin' dashes' minZoom' maxZoom
Long Parameter List,OsmSharp.UI.Renderer.Primitives,Line2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Line2D.cs,Line2D,The method has 10 parameters. Parameters: x' y' color' width' lineJoin' dashes' minX' maxX' minY' maxY
Long Parameter List,OsmSharp.UI.Renderer.Primitives,LineText2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\LineText2D.cs,LineText2D,The method has 5 parameters. Parameters: x' y' color' size' text
Long Parameter List,OsmSharp.UI.Renderer.Primitives,LineText2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\LineText2D.cs,LineText2D,The method has 9 parameters. Parameters: x' y' color' size' text' haloColor' haloRadius' minZoom' maxZoom
Long Parameter List,OsmSharp.UI.Renderer.Primitives,LineText2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\LineText2D.cs,LineText2D,The method has 9 parameters. Parameters: x' y' color' size' text' minX' maxX' minY' maxY
Long Parameter List,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Polygon2D,The method has 5 parameters. Parameters: x' y' color' width' fill
Long Parameter List,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Polygon2D,The method has 7 parameters. Parameters: x' y' color' width' fill' minZoom' maxZoom
Long Parameter List,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Polygon2D,The method has 9 parameters. Parameters: x' y' color' width' fill' minX' maxX' minY' maxY
Long Parameter List,OsmSharp.UI.Renderer.Primitives,Text2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Text2D.cs,Text2D,The method has 5 parameters. Parameters: x' y' text' color' size
Long Parameter List,OsmSharp.UI.Renderer.Primitives,Text2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Text2D.cs,Text2D,The method has 10 parameters. Parameters: x' y' text' color' size' haloColor' haloRadius' font' minZoom' maxZoom
Long Parameter List,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStylePoint,The method has 6 parameters. Parameters: pointId' layer' minZoom' maxZoom' color' size
Long Parameter List,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddIcon,The method has 5 parameters. Parameters: pointId' layer' minZoom' maxZoom' imageId
Long Parameter List,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddText,The method has 10 parameters. Parameters: pointId' layer' minZoom' maxZoom' size' text' color' haloColor' haloRadius' font
Long Parameter List,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStyleLine,The method has 8 parameters. Parameters: pointsId' layer' minZoom' maxZoom' color' width' lineJoin' dashes
Long Parameter List,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,CheckZoomRanges,The method has 6 parameters. Parameters: idx' minZoom' maxZoom' minZoomLimited' maxZoomLimited' simplificationZoom
Long Parameter List,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStyleLineText,The method has 10 parameters. Parameters: pointsId' layer' minZoom' maxZoom' color' size' text' font' haloColor' haloRadius
Long Parameter List,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStylePolygon,The method has 7 parameters. Parameters: pointsId' layer' minZoom' maxZoom' color' width' fill
Long Parameter List,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,FindMatch,The method has 7 parameters. Parameters: linesIndex' lines' x' y' style' epsilon' found
Long Identifier,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseRule,The length of the parameter selectorRuleTagValueComparison is 30.
Long Identifier,OsmSharp.UI.Renderer.Images,NativeImageCacheFactory,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Images\NativeImageCacheFactory.cs,,The length of the parameter _nativeImageCacheCreateDelegate is 31.
Long Statement,OsmSharp.UI.Animations,MapViewAnimator,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\MapViewAnimator.cs,_timer_Elapsed,The length of the statement  "                _currentState.Center = new GeoCoordinate(_animationProgress * (_endState.Center.Latitude - _startState.Center.Latitude) + _startState.Center.Latitude' " is 150.
Long Statement,OsmSharp.UI.Animations.Invalidation.Triggers,DefaultTrigger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\Invalidation\Triggers\DefaultTrigger.cs,NotifyChange,The length of the statement  "                    _timer = new System.Threading.Timer(this.StaticDetectionCallback' null' StaticDetectionTriggerMillis' System.Threading.Timeout.Infinite); " is 137.
Long Statement,OsmSharp.UI.Map.Layers,LayerGpx,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerGpx.cs,AddGpx,The length of the statement  "                        _scene.AddStyleLine(pointsId.Value' 0' float.MinValue' float.MaxValue' transparantBlue.Value' 8' Renderer.Primitives.LineJoin.Round' null); " is 139.
Long Statement,OsmSharp.UI.Map.Layers,LayerMBTile,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerMBTile.cs,ViewChanged,The length of the statement  "                var range = TileRange.CreateAroundBoundingBox(new GeoCoordinateBox(map.Projection.ToGeoCoordinates(viewBox.Min[0]' viewBox.Min[1])' " is 131.
Long Statement,OsmSharp.UI.Map.Layers,LayerMBTile,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerMBTile.cs,ViewChanged,The length of the statement  "				OsmSharp.Logging.Log.TraceEvent ("LayerMBTile"' OsmSharp.Logging.TraceEventType.Verbose' string.Format ("Requesting {0} tiles for view."' range.Count)); " is 152.
Long Statement,OsmSharp.UI.Map.Layers,LayerPrimitives,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerPrimitives.cs,AddLine,The length of the statement  "                _scene.AddStyleLine(pointsId.Value' 0' float.MinValue' float.MaxValue' color' sizePixels' Renderer.Primitives.LineJoin.Round' null); " is 132.
Long Statement,OsmSharp.UI.Map.Layers,LayerPrimitives,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerPrimitives.cs,AddPolyline,The length of the statement  "                _scene.AddStyleLine(pointsId.Value' 0' float.MinValue' float.MaxValue' color' sizePixels' Renderer.Primitives.LineJoin.Round' null); " is 132.
Long Statement,OsmSharp.UI.Map,Map,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Map.cs,EnsureViewWithinBoundingBox,The length of the statement  "            //double[] mapCenterPixels = view.ToViewPort(view.Width' view.Height' mapCenterSceneCoords[0]' mapCenterSceneCoords[1]); " is 120.
Long Statement,OsmSharp.UI.Map,Map,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Map.cs,EnsureViewWithinBoundingBox,The length of the statement  "            fromViewPort.Apply(mapCenterPixelsX - (view.Width) / 2.0' mapCenterPixelsY - (view.Height) / 2.0' out leftScene' out topScene); " is 127.
Long Statement,OsmSharp.UI.Map,Map,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Map.cs,EnsureViewWithinBoundingBox,The length of the statement  "            fromViewPort.Apply(mapCenterPixelsX + (view.Width) / 2.0' mapCenterPixelsY + (view.Height) / 2.0' out rightScene' out bottomScene); " is 131.
Long Statement,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,Translate,The length of the statement  "                    uint pointId = scene.AddPoint(projection.LongitudeToX(node.Coordinate.Longitude)' projection.LatitudeToY(node.Coordinate.Latitude)); " is 132.
Long Statement,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateNode,The length of the statement  "                        scene.AddText(pointId.Value' this.CalculateSceneLayer(OffsetPointText' zIndex)' minZoom' maxZoom' fontSize' value' textColor'  " is 125.
Long Statement,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateWay,The length of the statement  "                                scene.AddStylePolygon(pointsId.Value' this.CalculateSceneLayer(OffsetArea' zIndex)' minZoom' maxZoom' fillColor' 1' true); " is 122.
Long Statement,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateWay,The length of the statement  "                                    scene.AddStylePolygon(pointsId.Value' this.CalculateSceneLayer(OffsetCasing' zIndex)' minZoom' maxZoom' color' 1' false); " is 121.
Long Statement,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateLineairRing,The length of the statement  "                            scene.AddStylePolygon(pointsId.Value' this.CalculateSceneLayer(OffsetArea' zIndex)' minZoom' maxZoom' fillColor' 1' true); " is 122.
Long Statement,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateLineairRing,The length of the statement  "                                scene.AddStylePolygon(pointsId.Value' this.CalculateSceneLayer(OffsetCasing' zIndex)' minZoom' maxZoom' color' 1' false); " is 121.
Long Statement,OsmSharp.UI.Map.Styles.MapCSS.v0_2.Domain,SelectorRuleTagValueComparison,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\Domain\SelectorRule.cs,Selects,The length of the statement  "                        if (double.TryParse(this.Value' NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out valueDouble) && " is 120.
Long Statement,OsmSharp.UI.Map.Styles.MapCSS.v0_2.Domain,SelectorRuleTagValueComparison,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\Domain\SelectorRule.cs,Selects,The length of the statement  "                        if (double.TryParse(this.Value' NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out valueDouble) && " is 120.
Long Statement,OsmSharp.UI.Map.Styles.MapCSS.v0_2.Domain,SelectorRuleTagValueComparison,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\Domain\SelectorRule.cs,Selects,The length of the statement  "                        if (double.TryParse(this.Value' NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out valueDouble) && " is 120.
Long Statement,OsmSharp.UI.Map.Styles.MapCSS.v0_2.Domain,SelectorRuleTagValueComparison,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\Domain\SelectorRule.cs,Selects,The length of the statement  "                        if (double.TryParse(this.Value' NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out valueDouble) && " is 120.
Long Statement,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseColor,The length of the statement  "            else if (int.TryParse(colorTree.Text' NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out valueInt)) " is 121.
Long Statement,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,CalculateSimplificationEpsilon,The length of the statement  "            double xDiff = System.Math.Abs(projection.LongitudeToX(topLeft.Longitude) - projection.LongitudeToX(bottomRight.Longitude)); " is 124.
Long Statement,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,CalculateSimplificationEpsilon,The length of the statement  "            double yDiff = System.Math.Abs(projection.LatitudeToY(topLeft.Latitude) - projection.LatitudeToY(bottomRight.Latitude)); " is 120.
Long Statement,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStylePoint,The length of the statement  "                if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor)) " is 124.
Long Statement,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddIcon,The length of the statement  "                if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor)) " is 124.
Long Statement,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddText,The length of the statement  "                if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor)) " is 124.
Long Statement,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStyleLine,The length of the statement  "                if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor)) " is 124.
Long Statement,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,ConvertToPrimitive,The length of the statement  "            var primitive = new Line2D(geo.X' geo.Y' style.Color' style.Width' style.LineJoin' style.Dashes' style.MinZoom' style.MaxZoom); " is 127.
Long Statement,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStyleLineText,The length of the statement  "                if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor)) " is 124.
Long Statement,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,ConvertToPrimitive,The length of the statement  "            var primitive = new LineText2D(geo.X' geo.Y' style.Color' style.Size' text' style.HaloColor' style.HaloRadius' style.MinZoom' style.MaxZoom); " is 141.
Long Statement,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStylePolygon,The length of the statement  "                if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor)) " is 124.
Long Statement,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,The length of the statement  "                        linesIndex.Add(new PointF2D(scenePoints.X[scenePoints.X.Length - 1]' scenePoints.Y[scenePoints.Y.Length - 1])' scenePoints); " is 124.
Long Statement,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,The length of the statement  "                        linesIndex.Add(new PointF2D(scenePoints.X[scenePoints.X.Length - 1]' scenePoints.Y[scenePoints.Y.Length - 1])' scenePoints); " is 124.
Long Statement,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,The length of the statement  "                    target.AddStylePoint(target.AddPoint(scenePoint.X' scenePoint.Y)' stylePoint.Layer' stylePoint.MinZoom' stylePoint.MaxZoom' " is 123.
Long Statement,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,The length of the statement  "                        //polygonsIndex.Add(new PointF2D(scenePoints.X[scenePoints.X.Length - 1]' scenePoints.Y[scenePoints.Y.Length - 1])' scenePoints); " is 129.
Long Statement,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,The length of the statement  "                        "Merging polygons @z{3}e{4} ({1}/{2})... {0}%"' progress' totalLines - polygons.Count' totalLines' zoomFactor' epsilon); " is 120.
Long Statement,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,The length of the statement  "                //            "Merging lines @z{3}e{4} ({1}/{2})... {0}%"' progress' totalLines - lines.Count' totalLines' zoomFactor' epsilon); " is 128.
Long Statement,OsmSharp.UI.Renderer.Images,NativeImageCacheFactory,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Images\NativeImageCacheFactory.cs,Create,The length of the statement  "                throw new InvalidOperationException("Image creating delegate not initialized' call OsmSharp.{Platform).UI.Native.Initialize() in the native code."); " is 148.
Complex Conditional,OsmSharp.UI.Map,MapRenderer<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\MapRenderer.cs,Render,The conditional expression  "map[layerIdx].IsVisible &&                      (!map[layerIdx].MinZoom.HasValue || map[layerIdx].MinZoom < zoomLevel) &&                      (!map[layerIdx].MaxZoom.HasValue || map[layerIdx].MaxZoom >= zoomLevel)"  is complex.
Complex Conditional,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,Translate,The conditional expression  "_keysForLines == null || osmGeo.Tags.ContainsOneOfKeys(_keysForLines) ||                      _keysForAreas == null || osmGeo.Tags.ContainsOneOfKeys(_keysForAreas)"  is complex.
Complex Conditional,OsmSharp.UI.Map.Styles.MapCSS,MapCSSObject,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSObject.cs,MapCSSObject,The conditional expression  "!(this.Feature.Geometry is LineairRing ||                  this.Feature.Geometry is Polygon ||                  this.Feature.Geometry is MultiPolygon ||                  this.Feature.Geometry is LineString)"  is complex.
Complex Conditional,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,Parse,The conditional expression  "child.ChildCount == 2 &&                              child.Children[0].Text == "SIMPLE_SELECTOR" &&                              child.Children[0].ChildCount == 1 &&                              child.Children[0] is CommonTree &&                              (child.Children[0] as CommonTree).Children[0].Text == "canvas""  is complex.
Complex Conditional,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,Parse,The conditional expression  "child.ChildCount == 2 &&                              child.Children[0].Text == "SIMPLE_SELECTOR" &&                              child.Children[0].ChildCount == 1 &&                              child.Children[0] is CommonTree &&                              (child.Children[0] as CommonTree).Children[0].Text == "meta""  is complex.
Complex Conditional,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseRule,The conditional expression  "attributeSelector.Children[0].Text == "<" ||                                  attributeSelector.Children[0].Text == ">" ||                                  attributeSelector.Children[0].Text == "=" ||                                  attributeSelector.Children[0].Text == "!=""  is complex.
Complex Conditional,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSTypesExtensions,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSTypes.cs,IsOfType,The conditional expression  "way != null &&                              way.Nodes != null &&                              (way.Nodes.Count > 2 && (way.Nodes[0] == way.Nodes[way.Nodes.Count - 1]))"  is complex.
Complex Conditional,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Contains,The conditional expression  "(this.Y[idx] <= coordinate[1] &&                          this.Y[idx + 1] >= coordinate[1]) &&                          !(this.Y[idx] == coordinate[1] &&                          this.Y[idx + 1] == coordinate[1])"  is complex.
Complex Conditional,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Contains,The conditional expression  "(this.Y[idx] >= coordinate[1] &&                          this.Y[idx + 1] <= coordinate[1]) &&                          !(this.Y[idx] == coordinate[1] &&                          this.Y[idx + 1] == coordinate[1])"  is complex.
Complex Conditional,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Contains,The conditional expression  "(Y[idx] <= coordinate[1] &&                          Y[idx + 1] >= coordinate[1]) &&                          !(Y[idx] == coordinate[1] &&                          Y[idx + 1] == coordinate[1])"  is complex.
Complex Conditional,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Contains,The conditional expression  "(Y[idx] >= coordinate[1] &&                          Y[idx + 1] <= coordinate[1]) &&                          !(Y[idx] == coordinate[1] &&                          Y[idx + 1] == coordinate[1])"  is complex.
Complex Conditional,OsmSharp.UI.Renderer.Scene.Styles,StyleLine,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Styles\StyleLine.cs,Equals,The conditional expression  "(obj as StyleLine).Color == this.Color &&                      (obj as StyleLine).Width == this.Width &&                      (obj as StyleLine).LineJoin == this.LineJoin &&                      (obj as StyleLine).Layer == this.Layer &&                      (obj as StyleLine).MinZoom == this.MinZoom &&                      (obj as StyleLine).MaxZoom == this.MaxZoom"  is complex.
Virtual Method Call from Constructor,OsmSharp.UI.Map.Styles,StyleSceneManager,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\StyleSceneManager.cs,StyleSceneManager,The constructor "StyleSceneManager" calls a virtual method "GetCanvasColor".
Magic Number,OsmSharp.UI.Animations,CubicBezier,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\CubicBezier.cs,CubicBezier,The following statement contains a magic number: cx = 3.0 * x1;
Magic Number,OsmSharp.UI.Animations,CubicBezier,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\CubicBezier.cs,CubicBezier,The following statement contains a magic number: bx = 3.0 * (x2 - x1) - cx;
Magic Number,OsmSharp.UI.Animations,CubicBezier,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\CubicBezier.cs,CubicBezier,The following statement contains a magic number: cy = 3.0 * y1;
Magic Number,OsmSharp.UI.Animations,CubicBezier,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\CubicBezier.cs,CubicBezier,The following statement contains a magic number: by = 3.0 * (y2 - y1) - cy;
Magic Number,OsmSharp.UI.Animations,CubicBezier,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\CubicBezier.cs,sampleCurveDerivativeX,The following statement contains a magic number: return (3.0 * ax * t + 2.0 * bx) * t + cx;
Magic Number,OsmSharp.UI.Animations,CubicBezier,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\CubicBezier.cs,sampleCurveDerivativeX,The following statement contains a magic number: return (3.0 * ax * t + 2.0 * bx) * t + cx;
Magic Number,OsmSharp.UI.Animations,CubicBezier,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\CubicBezier.cs,solveCurveX,The following statement contains a magic number: for (t2 = x' i = 0; i < 8; i++)              {                  x2 = sampleCurveX(t2) - x;                  if (System.Math.Abs(x2) < epsilon)                      return t2;                  d2 = sampleCurveDerivativeX(t2);                  if (System.Math.Abs(d2) < 1e-6)                      break;                  t2 = t2 - x2 / d2;              }
Magic Number,OsmSharp.UI.Animations,CubicBezier,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\CubicBezier.cs,solveCurveX,The following statement contains a magic number: for (t2 = x' i = 0; i < 8; i++)              {                  x2 = sampleCurveX(t2) - x;                  if (System.Math.Abs(x2) < epsilon)                      return t2;                  d2 = sampleCurveDerivativeX(t2);                  if (System.Math.Abs(d2) < 1e-6)                      break;                  t2 = t2 - x2 / d2;              }
Magic Number,OsmSharp.UI.Animations,CubicBezier,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\CubicBezier.cs,solveCurveX,The following statement contains a magic number: while (t0 < t1)              {                  x2 = sampleCurveX(t2);                  if (System.Math.Abs(x2 - x) < epsilon)                      return t2;                  if (x > x2)                      t0 = t2;                  else                      t1 = t2;                  t2 = (t1 - t0) * .5 + t0;              }
Magic Number,OsmSharp.UI.Animations,MapViewAnimator,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\MapViewAnimator.cs,_timer_Elapsed,The following statement contains a magic number: if (currentTime >= _endTime)               {                  _currentState = _endState;                  Stop();              }              else              {                  _timeProgress = (double)(currentTime - _startTime) / (double)_duration;                  _animationProgress = _animationFunction.ComputeY(_timeProgress' getEpsilon(_duration/1000));                    _currentState.Zoom = (float)_animationProgress * (_endState.Zoom - _startState.Zoom) + _startState.Zoom;                  _currentState.Tilt = _animationProgress * (_endState.Tilt.SmallestDifference(_startState.Tilt)) + _startState.Tilt;                  _currentState.Center = new GeoCoordinate(_animationProgress * (_endState.Center.Latitude - _startState.Center.Latitude) + _startState.Center.Latitude'                                                           _animationProgress * (_endState.Center.Longitude - _startState.Center.Longitude) + _startState.Center.Longitude);              }
Magic Number,OsmSharp.UI.Animations,MapViewAnimator,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\MapViewAnimator.cs,getEpsilon,The following statement contains a magic number: return 1.0/(200.0*duration);
Magic Number,OsmSharp.UI.Animations.Invalidation.Triggers,DefaultTrigger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\Invalidation\Triggers\DefaultTrigger.cs,NotifyChange,The following statement contains a magic number: lock (this)              {                  _currentView = view;                  _currentZoom = zoom;                    // reset the timer.                  if (_timer == null)                  { // create the timer.                      _timer = new System.Threading.Timer(this.StaticDetectionCallback' null' StaticDetectionTriggerMillis' System.Threading.Timeout.Infinite);                  }                  else                  { // change the timer.                      _timer.Change(StaticDetectionTriggerMillis' System.Threading.Timeout.Infinite);                  }                    // no rendering was successful up until now' only start invalidating after first successful render.                  if (_latestTriggeredView == null)                  {                      return;                  }                    // detect changes by % of view pan.                  var toView = _latestTriggeredView.CreateToViewPort(100' 100);                  double newCenterX' newCenterY;                  toView.Apply(view.Center[0]' view.Center[1]' out newCenterX' out newCenterY);                  //double[] newCenter = _latestTriggeredView.ToViewPort(100' 100' view.Center[0]' view.Center[1]);                  newCenterX = System.Math.Abs(newCenterX - 50.0);                  newCenterY = System.Math.Abs(newCenterY - 50.0);                  if (newCenterX > PanPercentage || newCenterY > PanPercentage)                  { // the pan percentage change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Pan detection.");                          this.Render();                      }                      return;                  }                    // detect changes by angle offset.                  double angleDifference = System.Math.Abs(_latestTriggeredView.Angle.SmallestDifference(view.Angle));                  if (angleDifference > DegreeOffset)                  { // the angle difference change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Angle detection.");                          this.Render();                      }                      return;                  }                    // detect changes by zoom offset.                  double zoomDifference = System.Math.Abs(_latestTriggeredZoom - _currentZoom);                  if (zoomDifference > ZoomOffset)                  { // the zoom difference change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Zoom detection.");                          this.Render();                      }                      return;                  }              }
Magic Number,OsmSharp.UI.Animations.Invalidation.Triggers,DefaultTrigger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\Invalidation\Triggers\DefaultTrigger.cs,NotifyChange,The following statement contains a magic number: lock (this)              {                  _currentView = view;                  _currentZoom = zoom;                    // reset the timer.                  if (_timer == null)                  { // create the timer.                      _timer = new System.Threading.Timer(this.StaticDetectionCallback' null' StaticDetectionTriggerMillis' System.Threading.Timeout.Infinite);                  }                  else                  { // change the timer.                      _timer.Change(StaticDetectionTriggerMillis' System.Threading.Timeout.Infinite);                  }                    // no rendering was successful up until now' only start invalidating after first successful render.                  if (_latestTriggeredView == null)                  {                      return;                  }                    // detect changes by % of view pan.                  var toView = _latestTriggeredView.CreateToViewPort(100' 100);                  double newCenterX' newCenterY;                  toView.Apply(view.Center[0]' view.Center[1]' out newCenterX' out newCenterY);                  //double[] newCenter = _latestTriggeredView.ToViewPort(100' 100' view.Center[0]' view.Center[1]);                  newCenterX = System.Math.Abs(newCenterX - 50.0);                  newCenterY = System.Math.Abs(newCenterY - 50.0);                  if (newCenterX > PanPercentage || newCenterY > PanPercentage)                  { // the pan percentage change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Pan detection.");                          this.Render();                      }                      return;                  }                    // detect changes by angle offset.                  double angleDifference = System.Math.Abs(_latestTriggeredView.Angle.SmallestDifference(view.Angle));                  if (angleDifference > DegreeOffset)                  { // the angle difference change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Angle detection.");                          this.Render();                      }                      return;                  }                    // detect changes by zoom offset.                  double zoomDifference = System.Math.Abs(_latestTriggeredZoom - _currentZoom);                  if (zoomDifference > ZoomOffset)                  { // the zoom difference change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Zoom detection.");                          this.Render();                      }                      return;                  }              }
Magic Number,OsmSharp.UI.Animations.Invalidation.Triggers,DefaultTrigger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\Invalidation\Triggers\DefaultTrigger.cs,NotifyChange,The following statement contains a magic number: lock (this)              {                  _currentView = view;                  _currentZoom = zoom;                    // reset the timer.                  if (_timer == null)                  { // create the timer.                      _timer = new System.Threading.Timer(this.StaticDetectionCallback' null' StaticDetectionTriggerMillis' System.Threading.Timeout.Infinite);                  }                  else                  { // change the timer.                      _timer.Change(StaticDetectionTriggerMillis' System.Threading.Timeout.Infinite);                  }                    // no rendering was successful up until now' only start invalidating after first successful render.                  if (_latestTriggeredView == null)                  {                      return;                  }                    // detect changes by % of view pan.                  var toView = _latestTriggeredView.CreateToViewPort(100' 100);                  double newCenterX' newCenterY;                  toView.Apply(view.Center[0]' view.Center[1]' out newCenterX' out newCenterY);                  //double[] newCenter = _latestTriggeredView.ToViewPort(100' 100' view.Center[0]' view.Center[1]);                  newCenterX = System.Math.Abs(newCenterX - 50.0);                  newCenterY = System.Math.Abs(newCenterY - 50.0);                  if (newCenterX > PanPercentage || newCenterY > PanPercentage)                  { // the pan percentage change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Pan detection.");                          this.Render();                      }                      return;                  }                    // detect changes by angle offset.                  double angleDifference = System.Math.Abs(_latestTriggeredView.Angle.SmallestDifference(view.Angle));                  if (angleDifference > DegreeOffset)                  { // the angle difference change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Angle detection.");                          this.Render();                      }                      return;                  }                    // detect changes by zoom offset.                  double zoomDifference = System.Math.Abs(_latestTriggeredZoom - _currentZoom);                  if (zoomDifference > ZoomOffset)                  { // the zoom difference change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Zoom detection.");                          this.Render();                      }                      return;                  }              }
Magic Number,OsmSharp.UI.Animations.Invalidation.Triggers,DefaultTrigger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Animations\Invalidation\Triggers\DefaultTrigger.cs,NotifyChange,The following statement contains a magic number: lock (this)              {                  _currentView = view;                  _currentZoom = zoom;                    // reset the timer.                  if (_timer == null)                  { // create the timer.                      _timer = new System.Threading.Timer(this.StaticDetectionCallback' null' StaticDetectionTriggerMillis' System.Threading.Timeout.Infinite);                  }                  else                  { // change the timer.                      _timer.Change(StaticDetectionTriggerMillis' System.Threading.Timeout.Infinite);                  }                    // no rendering was successful up until now' only start invalidating after first successful render.                  if (_latestTriggeredView == null)                  {                      return;                  }                    // detect changes by % of view pan.                  var toView = _latestTriggeredView.CreateToViewPort(100' 100);                  double newCenterX' newCenterY;                  toView.Apply(view.Center[0]' view.Center[1]' out newCenterX' out newCenterY);                  //double[] newCenter = _latestTriggeredView.ToViewPort(100' 100' view.Center[0]' view.Center[1]);                  newCenterX = System.Math.Abs(newCenterX - 50.0);                  newCenterY = System.Math.Abs(newCenterY - 50.0);                  if (newCenterX > PanPercentage || newCenterY > PanPercentage)                  { // the pan percentage change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Pan detection.");                          this.Render();                      }                      return;                  }                    // detect changes by angle offset.                  double angleDifference = System.Math.Abs(_latestTriggeredView.Angle.SmallestDifference(view.Angle));                  if (angleDifference > DegreeOffset)                  { // the angle difference change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Angle detection.");                          this.Render();                      }                      return;                  }                    // detect changes by zoom offset.                  double zoomDifference = System.Math.Abs(_latestTriggeredZoom - _currentZoom);                  if (zoomDifference > ZoomOffset)                  { // the zoom difference change was detected.                      if (this.LatestRenderingFinished ||                      !_latestTriggeredView.Rectangle.Overlaps(view.Rectangle))                      { // the last rendering was finished or the latest triggered view does not overlap with the current rendering.                          OsmSharp.Logging.Log.TraceEvent("DefaultTrigger"' Logging.TraceEventType.Information'                              "Rendering triggered: Zoom detection.");                          this.Render();                      }                      return;                  }              }
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromArgb,The following statement contains a magic number: return SimpleColor.FromArgb(255' red' green' blue);
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromArgb,The following statement contains a magic number: if ((alpha > 255) || (alpha < 0))              {                  // alpha out of range!                  throw new ArgumentOutOfRangeException("alpha"' "Value has to be in the range 0-255!");              }
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromArgb,The following statement contains a magic number: if ((red > 255) || (red < 0))              {                  // red out of range!                  throw new ArgumentOutOfRangeException("red"' "Value has to be in the range 0-255!");              }
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromArgb,The following statement contains a magic number: if ((green > 255) || (green < 0))              {                  // green out of range!                  throw new ArgumentOutOfRangeException("green"' "Value has to be in the range 0-255!");              }
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromArgb,The following statement contains a magic number: if ((blue > 255) || (blue < 0))              {                  // red out of range!                  throw new ArgumentOutOfRangeException("blue"' "Value has to be in the range 0-255!");              }
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromArgb,The following statement contains a magic number: return new SimpleColor()                         {                             Value = (int) ((uint) alpha << 24) + (red << 16) + (green << 8) + blue                         };
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromArgb,The following statement contains a magic number: return new SimpleColor()                         {                             Value = (int) ((uint) alpha << 24) + (red << 16) + (green << 8) + blue                         };
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromArgb,The following statement contains a magic number: return new SimpleColor()                         {                             Value = (int) ((uint) alpha << 24) + (red << 16) + (green << 8) + blue                         };
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromHex,The following statement contains a magic number: if (hex.Length < 7) {  				throw new ArgumentOutOfRangeException ("hex"'   					string.Format("The given string can never be a color: {0} too short."' hex));  			}
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromHex,The following statement contains a magic number: if (hex.Length == 7) {                  return SimpleColor.FromArgb(                      Int32.Parse("FF" + hex.Replace("#"' "")' System.Globalization.NumberStyles.HexNumber'                                   System.Globalization.CultureInfo.InvariantCulture));              }   			else if (hex.Length == 9) {  				return SimpleColor.FromArgb (  					Int32.Parse (hex.Replace ("#"' "")' System.Globalization.NumberStyles.HexNumber'   					             System.Globalization.CultureInfo.InvariantCulture));  			} else if (hex.Length == 10) {  				return SimpleColor.FromArgb (  					Int32.Parse (hex.Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber'   					             System.Globalization.CultureInfo.InvariantCulture));  			} else {  				throw new ArgumentOutOfRangeException ("hex"'   				                                       string.Format("The given string can is not a hex-color: {0}."' hex));  			}
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromHex,The following statement contains a magic number: if (hex.Length == 7) {                  return SimpleColor.FromArgb(                      Int32.Parse("FF" + hex.Replace("#"' "")' System.Globalization.NumberStyles.HexNumber'                                   System.Globalization.CultureInfo.InvariantCulture));              }   			else if (hex.Length == 9) {  				return SimpleColor.FromArgb (  					Int32.Parse (hex.Replace ("#"' "")' System.Globalization.NumberStyles.HexNumber'   					             System.Globalization.CultureInfo.InvariantCulture));  			} else if (hex.Length == 10) {  				return SimpleColor.FromArgb (  					Int32.Parse (hex.Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber'   					             System.Globalization.CultureInfo.InvariantCulture));  			} else {  				throw new ArgumentOutOfRangeException ("hex"'   				                                       string.Format("The given string can is not a hex-color: {0}."' hex));  			}
Magic Number,OsmSharp.UI,SimpleColor,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\SimpleColor.cs,FromHex,The following statement contains a magic number: if (hex.Length == 7) {                  return SimpleColor.FromArgb(                      Int32.Parse("FF" + hex.Replace("#"' "")' System.Globalization.NumberStyles.HexNumber'                                   System.Globalization.CultureInfo.InvariantCulture));              }   			else if (hex.Length == 9) {  				return SimpleColor.FromArgb (  					Int32.Parse (hex.Replace ("#"' "")' System.Globalization.NumberStyles.HexNumber'   					             System.Globalization.CultureInfo.InvariantCulture));  			} else if (hex.Length == 10) {  				return SimpleColor.FromArgb (  					Int32.Parse (hex.Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber'   					             System.Globalization.CultureInfo.InvariantCulture));  			} else {  				throw new ArgumentOutOfRangeException ("hex"'   				                                       string.Format("The given string can is not a hex-color: {0}."' hex));  			}
Magic Number,OsmSharp.UI.Map.Layers,LayerGpx,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerGpx.cs,LayerGpx,The following statement contains a magic number: _scene = new Scene2D(projection' 16);
Magic Number,OsmSharp.UI.Map.Layers,LayerGpx,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerGpx.cs,AddGpx,The following statement contains a magic number: foreach (var feature in gpxStream)              {                  if (feature.Geometry is Point)                  { // add the point.                      var point = (feature.Geometry as Point);                        // get x/y.                      var x = _projection.LongitudeToX(point.Coordinate.Longitude);                      var y = _projection.LatitudeToY(point.Coordinate.Latitude);                        // set the default color if none is given.                      var blue = SimpleColor.FromKnownColor(KnownColor.Blue);                      var transparantBlue = SimpleColor.FromArgb(128'                                                        blue.R' blue.G' blue.B);                        uint pointId = _scene.AddPoint(x' y);                      _scene.AddStylePoint(pointId' 0' float.MinValue' float.MaxValue' transparantBlue.Value' 8);                        if (bounds == null)                      { // create box.                          bounds = point.Box;                      }                      else                      { // add to the current box.                          bounds = bounds + point.Box;                      }                  }                  else if (feature.Geometry is LineString)                  { // add the lineString.                      var lineString = (feature.Geometry as LineString);                        // get x/y.                      var x = new double[lineString.Coordinates.Count];                      var y = new double[lineString.Coordinates.Count];                      for (int idx = 0; idx < lineString.Coordinates.Count; idx++)                      {                          x[idx] = _projection.LongitudeToX(                              lineString.Coordinates[idx].Longitude);                          y[idx] = _projection.LatitudeToY(                              lineString.Coordinates[idx].Latitude);                      }                        // set the default color if none is given.                      var blue = SimpleColor.FromKnownColor(KnownColor.Blue);                      var transparantBlue = SimpleColor.FromArgb(128'                                                        blue.R' blue.G' blue.B);                        uint? pointsId = _scene.AddPoints(x' y);                      if (pointsId.HasValue)                      {                          _scene.AddStyleLine(pointsId.Value' 0' float.MinValue' float.MaxValue' transparantBlue.Value' 8' Renderer.Primitives.LineJoin.Round' null);                            if (bounds == null)                          { // create box.                              bounds = lineString.Box;                          }                          else                          { // add to the current box.                              bounds = bounds + lineString.Box;                          }                      }                  }              }
Magic Number,OsmSharp.UI.Map.Layers,LayerGpx,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerGpx.cs,AddGpx,The following statement contains a magic number: foreach (var feature in gpxStream)              {                  if (feature.Geometry is Point)                  { // add the point.                      var point = (feature.Geometry as Point);                        // get x/y.                      var x = _projection.LongitudeToX(point.Coordinate.Longitude);                      var y = _projection.LatitudeToY(point.Coordinate.Latitude);                        // set the default color if none is given.                      var blue = SimpleColor.FromKnownColor(KnownColor.Blue);                      var transparantBlue = SimpleColor.FromArgb(128'                                                        blue.R' blue.G' blue.B);                        uint pointId = _scene.AddPoint(x' y);                      _scene.AddStylePoint(pointId' 0' float.MinValue' float.MaxValue' transparantBlue.Value' 8);                        if (bounds == null)                      { // create box.                          bounds = point.Box;                      }                      else                      { // add to the current box.                          bounds = bounds + point.Box;                      }                  }                  else if (feature.Geometry is LineString)                  { // add the lineString.                      var lineString = (feature.Geometry as LineString);                        // get x/y.                      var x = new double[lineString.Coordinates.Count];                      var y = new double[lineString.Coordinates.Count];                      for (int idx = 0; idx < lineString.Coordinates.Count; idx++)                      {                          x[idx] = _projection.LongitudeToX(                              lineString.Coordinates[idx].Longitude);                          y[idx] = _projection.LatitudeToY(                              lineString.Coordinates[idx].Latitude);                      }                        // set the default color if none is given.                      var blue = SimpleColor.FromKnownColor(KnownColor.Blue);                      var transparantBlue = SimpleColor.FromArgb(128'                                                        blue.R' blue.G' blue.B);                        uint? pointsId = _scene.AddPoints(x' y);                      if (pointsId.HasValue)                      {                          _scene.AddStyleLine(pointsId.Value' 0' float.MinValue' float.MaxValue' transparantBlue.Value' 8' Renderer.Primitives.LineJoin.Round' null);                            if (bounds == null)                          { // create box.                              bounds = lineString.Box;                          }                          else                          { // add to the current box.                              bounds = bounds + lineString.Box;                          }                      }                  }              }
Magic Number,OsmSharp.UI.Map.Layers,LayerGpx,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerGpx.cs,AddGpx,The following statement contains a magic number: foreach (var feature in gpxStream)              {                  if (feature.Geometry is Point)                  { // add the point.                      var point = (feature.Geometry as Point);                        // get x/y.                      var x = _projection.LongitudeToX(point.Coordinate.Longitude);                      var y = _projection.LatitudeToY(point.Coordinate.Latitude);                        // set the default color if none is given.                      var blue = SimpleColor.FromKnownColor(KnownColor.Blue);                      var transparantBlue = SimpleColor.FromArgb(128'                                                        blue.R' blue.G' blue.B);                        uint pointId = _scene.AddPoint(x' y);                      _scene.AddStylePoint(pointId' 0' float.MinValue' float.MaxValue' transparantBlue.Value' 8);                        if (bounds == null)                      { // create box.                          bounds = point.Box;                      }                      else                      { // add to the current box.                          bounds = bounds + point.Box;                      }                  }                  else if (feature.Geometry is LineString)                  { // add the lineString.                      var lineString = (feature.Geometry as LineString);                        // get x/y.                      var x = new double[lineString.Coordinates.Count];                      var y = new double[lineString.Coordinates.Count];                      for (int idx = 0; idx < lineString.Coordinates.Count; idx++)                      {                          x[idx] = _projection.LongitudeToX(                              lineString.Coordinates[idx].Longitude);                          y[idx] = _projection.LatitudeToY(                              lineString.Coordinates[idx].Latitude);                      }                        // set the default color if none is given.                      var blue = SimpleColor.FromKnownColor(KnownColor.Blue);                      var transparantBlue = SimpleColor.FromArgb(128'                                                        blue.R' blue.G' blue.B);                        uint? pointsId = _scene.AddPoints(x' y);                      if (pointsId.HasValue)                      {                          _scene.AddStyleLine(pointsId.Value' 0' float.MinValue' float.MaxValue' transparantBlue.Value' 8' Renderer.Primitives.LineJoin.Round' null);                            if (bounds == null)                          { // create box.                              bounds = lineString.Box;                          }                          else                          { // add to the current box.                              bounds = bounds + lineString.Box;                          }                      }                  }              }
Magic Number,OsmSharp.UI.Map.Layers,LayerGpx,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerGpx.cs,AddGpx,The following statement contains a magic number: foreach (var feature in gpxStream)              {                  if (feature.Geometry is Point)                  { // add the point.                      var point = (feature.Geometry as Point);                        // get x/y.                      var x = _projection.LongitudeToX(point.Coordinate.Longitude);                      var y = _projection.LatitudeToY(point.Coordinate.Latitude);                        // set the default color if none is given.                      var blue = SimpleColor.FromKnownColor(KnownColor.Blue);                      var transparantBlue = SimpleColor.FromArgb(128'                                                        blue.R' blue.G' blue.B);                        uint pointId = _scene.AddPoint(x' y);                      _scene.AddStylePoint(pointId' 0' float.MinValue' float.MaxValue' transparantBlue.Value' 8);                        if (bounds == null)                      { // create box.                          bounds = point.Box;                      }                      else                      { // add to the current box.                          bounds = bounds + point.Box;                      }                  }                  else if (feature.Geometry is LineString)                  { // add the lineString.                      var lineString = (feature.Geometry as LineString);                        // get x/y.                      var x = new double[lineString.Coordinates.Count];                      var y = new double[lineString.Coordinates.Count];                      for (int idx = 0; idx < lineString.Coordinates.Count; idx++)                      {                          x[idx] = _projection.LongitudeToX(                              lineString.Coordinates[idx].Longitude);                          y[idx] = _projection.LatitudeToY(                              lineString.Coordinates[idx].Latitude);                      }                        // set the default color if none is given.                      var blue = SimpleColor.FromKnownColor(KnownColor.Blue);                      var transparantBlue = SimpleColor.FromArgb(128'                                                        blue.R' blue.G' blue.B);                        uint? pointsId = _scene.AddPoints(x' y);                      if (pointsId.HasValue)                      {                          _scene.AddStyleLine(pointsId.Value' 0' float.MinValue' float.MaxValue' transparantBlue.Value' 8' Renderer.Primitives.LineJoin.Round' null);                            if (bounds == null)                          { // create box.                              bounds = lineString.Box;                          }                          else                          { // add to the current box.                              bounds = bounds + lineString.Box;                          }                      }                  }              }
Magic Number,OsmSharp.UI.Map.Layers,LayerOsm,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerOsm.cs,LayerOsm,The following statement contains a magic number: zoomFactors.Add(16);
Magic Number,OsmSharp.UI.Map.Layers,LayerOsm,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerOsm.cs,LayerOsm,The following statement contains a magic number: zoomFactors.Add(14);
Magic Number,OsmSharp.UI.Map.Layers,LayerOsm,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerOsm.cs,LayerOsm,The following statement contains a magic number: zoomFactors.Add(12);
Magic Number,OsmSharp.UI.Map.Layers,LayerOsm,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerOsm.cs,LayerOsm,The following statement contains a magic number: zoomFactors.Add(10);
Magic Number,OsmSharp.UI.Map.Layers,LayerPrimitives,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerPrimitives.cs,LayerPrimitives,The following statement contains a magic number: _scene = new Scene2D(projection' 16);
Magic Number,OsmSharp.UI.Map.Layers,LayerTile,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerTile.cs,LoadTile,The following statement contains a magic number: try              {                  if (_suspended)                  { // stop loading tiles.                      return;                  }                    // a tile was found to load.                  var tile = state as Tile;                    // only load tiles from the same zoom-level.                  if (tile.Zoom != _currentZoom)                  { // zoom is different' don't bother!                      return;                  }                    Image2D image2D;                  if (_cache == null)                  {                      return;                  }                  lock (_cache)                  { // check again for the tile.                      if (_cache.TryGet(tile' out image2D))                      { // tile is already there!                          _cache.Add(tile' image2D); // add again to update status.                          return;                      }                        _loading.Add(tile);                  }                    // load the tile.                  string url = this.FormatURL(tile);                    var request = HttpWebRequest.Create(url);                  request.Accept = "text/html' image/png' image/jpeg' image/gif' */*";                  if(request.IsUserAgentSupported)                  { // set user-agent if possible.                      request.UserAgent = "OsmSharp/4";                  }                    OsmSharp.Logging.Log.TraceEvent("LayerTile"' Logging.TraceEventType.Information' "Request tile@" + url);                        request.BeginGetResponse(new AsyncCallback((iar) =>                      {  						var response = (HttpWebResponse)((HttpWebRequest)iar.AsyncState).EndGetResponse(iar);                          try                          {  							this.Response(response' tile);    							_loading.Remove(tile);                          }                          catch (WebException ex)                          { // catch webexceptions.  							  							OsmSharp.Logging.Log.TraceEvent("LayerTile"' Logging.TraceEventType.Information'   									ex.Message);                                if (ex.Response is HttpWebResponse &&                                  ((ex.Response as HttpWebResponse).StatusCode == HttpStatusCode.NotFound ||                                  (ex.Response as HttpWebResponse).StatusCode == HttpStatusCode.Forbidden))                              { // do not retry loading tile.                                  return;                              }                              else                              { // retry loading tile here.                                  _loading.Remove(tile);                                    lock (_attempts)                                  {                                      int count;                                      if (!_attempts.TryGetValue(tile' out count))                                      { // first attempt.                                          count = 1;                                          _attempts.Add(tile' count);                                      }                                      else                                      { // increase attempt count.                                          _attempts[tile] = count++;                                      }                                      if (count < 3)                                      { // not yet reached maximum.                                           lock (_stack)                                          {                                              _stack.Push(tile);                                              _timer.Change(0' 150);                                          }                                      }                                  }                              }                          }                          catch (Exception ex)                          { // oops' exceptions that are not webexceptions!?                              OsmSharp.Logging.Log.TraceEvent("LayerTile"' Logging.TraceEventType.Error' ex.Message);                          }  						finally   						{  							response.Close();  						}                      })' request);  			}              catch (Exception ex)              { // don't worry about exceptions here.                  OsmSharp.Logging.Log.TraceEvent("LayerTile"' Logging.TraceEventType.Error' ex.Message);              }
Magic Number,OsmSharp.UI.Map.Layers,LayerTile,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerTile.cs,LoadTile,The following statement contains a magic number: try              {                  if (_suspended)                  { // stop loading tiles.                      return;                  }                    // a tile was found to load.                  var tile = state as Tile;                    // only load tiles from the same zoom-level.                  if (tile.Zoom != _currentZoom)                  { // zoom is different' don't bother!                      return;                  }                    Image2D image2D;                  if (_cache == null)                  {                      return;                  }                  lock (_cache)                  { // check again for the tile.                      if (_cache.TryGet(tile' out image2D))                      { // tile is already there!                          _cache.Add(tile' image2D); // add again to update status.                          return;                      }                        _loading.Add(tile);                  }                    // load the tile.                  string url = this.FormatURL(tile);                    var request = HttpWebRequest.Create(url);                  request.Accept = "text/html' image/png' image/jpeg' image/gif' */*";                  if(request.IsUserAgentSupported)                  { // set user-agent if possible.                      request.UserAgent = "OsmSharp/4";                  }                    OsmSharp.Logging.Log.TraceEvent("LayerTile"' Logging.TraceEventType.Information' "Request tile@" + url);                        request.BeginGetResponse(new AsyncCallback((iar) =>                      {  						var response = (HttpWebResponse)((HttpWebRequest)iar.AsyncState).EndGetResponse(iar);                          try                          {  							this.Response(response' tile);    							_loading.Remove(tile);                          }                          catch (WebException ex)                          { // catch webexceptions.  							  							OsmSharp.Logging.Log.TraceEvent("LayerTile"' Logging.TraceEventType.Information'   									ex.Message);                                if (ex.Response is HttpWebResponse &&                                  ((ex.Response as HttpWebResponse).StatusCode == HttpStatusCode.NotFound ||                                  (ex.Response as HttpWebResponse).StatusCode == HttpStatusCode.Forbidden))                              { // do not retry loading tile.                                  return;                              }                              else                              { // retry loading tile here.                                  _loading.Remove(tile);                                    lock (_attempts)                                  {                                      int count;                                      if (!_attempts.TryGetValue(tile' out count))                                      { // first attempt.                                          count = 1;                                          _attempts.Add(tile' count);                                      }                                      else                                      { // increase attempt count.                                          _attempts[tile] = count++;                                      }                                      if (count < 3)                                      { // not yet reached maximum.                                           lock (_stack)                                          {                                              _stack.Push(tile);                                              _timer.Change(0' 150);                                          }                                      }                                  }                              }                          }                          catch (Exception ex)                          { // oops' exceptions that are not webexceptions!?                              OsmSharp.Logging.Log.TraceEvent("LayerTile"' Logging.TraceEventType.Error' ex.Message);                          }  						finally   						{  							response.Close();  						}                      })' request);  			}              catch (Exception ex)              { // don't worry about exceptions here.                  OsmSharp.Logging.Log.TraceEvent("LayerTile"' Logging.TraceEventType.Error' ex.Message);              }
Magic Number,OsmSharp.UI.Map.Layers,LayerTile,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Layers\LayerTile.cs,ViewChanged,The following statement contains a magic number: try              {                  // calculate the current zoom level.                  var zoomLevel = (int)System.Math.Round(map.Projection.ToZoomLevel(zoomFactor)' 0);                    if (zoomLevel >= _minZoomLevel && zoomLevel <= _maxZoomLevel)                  {                      // build the bounding box.                      var viewBox = view.OuterBox;                      var box = new GeoCoordinateBox(map.Projection.ToGeoCoordinates(viewBox.Min[0]' viewBox.Min[1])'                                    map.Projection.ToGeoCoordinates(viewBox.Max[0]' viewBox.Max[1]));                        // build the tile range.                      lock (_stack)                      { // make sure the tile range is not in use.                          _stack.Clear();                            lock (_cache)                          {                              var tileRange = TileRange.CreateAroundBoundingBox(box' zoomLevel);                              _currentZoom = zoomLevel;                              foreach (var tile in tileRange.EnumerateInCenterFirst().Reverse())                              {                                  if (tile.IsValid)                                  { // make sure all tiles are valid.                                      Image2D temp;                                      if (!_cache.TryPeek(tile' out temp) &&                                          !_loading.Contains(tile))                                      { // not cached and not loading.                                          _stack.Push(tile);                                            OsmSharp.Logging.Log.TraceEvent("LayerTile"' Logging.TraceEventType.Information'   											"Queued tile: " + tile.ToString());                                      }                                  }                              }                              _timer.Change(0' 250);                          }                            if (_stack.Count > 0)                          { // reset the attempts.                              lock (_attempts)                              {                                  _attempts.Clear();                              }                          }                      }                  }              }              catch (Exception ex)              { // don't worry about exceptions here.                  OsmSharp.Logging.Log.TraceEvent("LayerTile"' Logging.TraceEventType.Error' ex.Message);              }
Magic Number,OsmSharp.UI.Map,Map,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Map.cs,EnsureViewWithinBoundingBox,The following statement contains a magic number: fromViewPort.Apply(mapCenterPixelsX - (view.Width) / 2.0' mapCenterPixelsY - (view.Height) / 2.0' out leftScene' out topScene);
Magic Number,OsmSharp.UI.Map,Map,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Map.cs,EnsureViewWithinBoundingBox,The following statement contains a magic number: fromViewPort.Apply(mapCenterPixelsX - (view.Width) / 2.0' mapCenterPixelsY - (view.Height) / 2.0' out leftScene' out topScene);
Magic Number,OsmSharp.UI.Map,Map,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Map.cs,EnsureViewWithinBoundingBox,The following statement contains a magic number: fromViewPort.Apply(mapCenterPixelsX + (view.Width) / 2.0' mapCenterPixelsY + (view.Height) / 2.0' out rightScene' out bottomScene);
Magic Number,OsmSharp.UI.Map,Map,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Map.cs,EnsureViewWithinBoundingBox,The following statement contains a magic number: fromViewPort.Apply(mapCenterPixelsX + (view.Width) / 2.0' mapCenterPixelsY + (view.Height) / 2.0' out rightScene' out bottomScene);
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,Translate,The following statement contains a magic number: if (scene.Count <= countBefore)              { // no objects have been added. Apply default styles if needed.                  if (osmGeo.Type == CompleteOsmType.Node &&                      _mapCSSFile != null &&                      _mapCSSFile.DefaultPoints)                  { // apply default points style.                      Node node = (osmGeo as Node);                      uint pointId = scene.AddPoint(projection.LongitudeToX(node.Coordinate.Longitude)' projection.LatitudeToY(node.Coordinate.Latitude));                      scene.AddStylePoint(pointId' this.CalculateSceneLayer(OffsetPoint' 0)' float.MinValue' float.MaxValue'                          SimpleColor.FromKnownColor(KnownColor.Black).Value' 2);                  }                  else if (osmGeo.Type == CompleteOsmType.Way &&                      _mapCSSFile != null &&                      _mapCSSFile.DefaultLines)                  { // apply default lines style.                      CompleteWay way = (osmGeo as CompleteWay);                      // get x/y.                      double[] x = null' y = null;                      if (x == null)                      { // pre-calculate x/y.                          x = new double[way.Nodes.Count];                          y = new double[way.Nodes.Count];                          for (int idx = 0; idx < way.Nodes.Count; idx++)                          {                              x[idx] = projection.LongitudeToX(                                  way.Nodes[idx].Coordinate.Longitude);                              y[idx] = projection.LatitudeToY(                                  way.Nodes[idx].Coordinate.Latitude);                          }                            // simplify.                          if (x.Length > 2)                          {                              double[][] simplified = SimplifyCurve.Simplify(new double[][] { x' y }' 0.0001);                              x = simplified[0];                              y = simplified[1];                          }                      }                      uint? points = scene.AddPoints(x' y);                      if (points.HasValue)                      {                          scene.AddStyleLine(points.Value' this.CalculateSceneLayer(OffsetLine' 0)' float.MinValue' float.MaxValue'                              SimpleColor.FromKnownColor(KnownColor.Red).Value' 1' LineJoin.Round' null);                      }                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,Translate,The following statement contains a magic number: if (scene.Count <= countBefore)              { // no objects have been added. Apply default styles if needed.                  if (osmGeo.Type == CompleteOsmType.Node &&                      _mapCSSFile != null &&                      _mapCSSFile.DefaultPoints)                  { // apply default points style.                      Node node = (osmGeo as Node);                      uint pointId = scene.AddPoint(projection.LongitudeToX(node.Coordinate.Longitude)' projection.LatitudeToY(node.Coordinate.Latitude));                      scene.AddStylePoint(pointId' this.CalculateSceneLayer(OffsetPoint' 0)' float.MinValue' float.MaxValue'                          SimpleColor.FromKnownColor(KnownColor.Black).Value' 2);                  }                  else if (osmGeo.Type == CompleteOsmType.Way &&                      _mapCSSFile != null &&                      _mapCSSFile.DefaultLines)                  { // apply default lines style.                      CompleteWay way = (osmGeo as CompleteWay);                      // get x/y.                      double[] x = null' y = null;                      if (x == null)                      { // pre-calculate x/y.                          x = new double[way.Nodes.Count];                          y = new double[way.Nodes.Count];                          for (int idx = 0; idx < way.Nodes.Count; idx++)                          {                              x[idx] = projection.LongitudeToX(                                  way.Nodes[idx].Coordinate.Longitude);                              y[idx] = projection.LatitudeToY(                                  way.Nodes[idx].Coordinate.Latitude);                          }                            // simplify.                          if (x.Length > 2)                          {                              double[][] simplified = SimplifyCurve.Simplify(new double[][] { x' y }' 0.0001);                              x = simplified[0];                              y = simplified[1];                          }                      }                      uint? points = scene.AddPoints(x' y);                      if (points.HasValue)                      {                          scene.AddStyleLine(points.Value' this.CalculateSceneLayer(OffsetLine' 0)' float.MinValue' float.MaxValue'                              SimpleColor.FromKnownColor(KnownColor.Red).Value' 1' LineJoin.Round' null);                      }                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,Translate,The following statement contains a magic number: if (scene.Count <= countBefore)              { // no objects have been added. Apply default styles if needed.                  if (osmGeo.Type == CompleteOsmType.Node &&                      _mapCSSFile != null &&                      _mapCSSFile.DefaultPoints)                  { // apply default points style.                      Node node = (osmGeo as Node);                      uint pointId = scene.AddPoint(projection.LongitudeToX(node.Coordinate.Longitude)' projection.LatitudeToY(node.Coordinate.Latitude));                      scene.AddStylePoint(pointId' this.CalculateSceneLayer(OffsetPoint' 0)' float.MinValue' float.MaxValue'                          SimpleColor.FromKnownColor(KnownColor.Black).Value' 2);                  }                  else if (osmGeo.Type == CompleteOsmType.Way &&                      _mapCSSFile != null &&                      _mapCSSFile.DefaultLines)                  { // apply default lines style.                      CompleteWay way = (osmGeo as CompleteWay);                      // get x/y.                      double[] x = null' y = null;                      if (x == null)                      { // pre-calculate x/y.                          x = new double[way.Nodes.Count];                          y = new double[way.Nodes.Count];                          for (int idx = 0; idx < way.Nodes.Count; idx++)                          {                              x[idx] = projection.LongitudeToX(                                  way.Nodes[idx].Coordinate.Longitude);                              y[idx] = projection.LatitudeToY(                                  way.Nodes[idx].Coordinate.Latitude);                          }                            // simplify.                          if (x.Length > 2)                          {                              double[][] simplified = SimplifyCurve.Simplify(new double[][] { x' y }' 0.0001);                              x = simplified[0];                              y = simplified[1];                          }                      }                      uint? points = scene.AddPoints(x' y);                      if (points.HasValue)                      {                          scene.AddStyleLine(points.Value' this.CalculateSceneLayer(OffsetLine' 0)' float.MinValue' float.MaxValue'                              SimpleColor.FromKnownColor(KnownColor.Red).Value' 1' LineJoin.Round' null);                      }                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateNode,The following statement contains a magic number: foreach (var rule in rules)              {                  int zIndex;                  if (!rule.TryGetProperty<int>("zIndex"' out zIndex))                  {                      zIndex = 0;                  }                    float minZoom = (float)projection.ToZoomFactor(rule.MinZoom);                  float maxZoom = (float)projection.ToZoomFactor(rule.MaxZoom);                    uint? pointId = null;                  int color;                  if (rule.TryGetProperty<int>("color"' out color))                  {                      float width;                      if (rule.TryGetProperty<float>("width"' out width))                      {                          pointId = scene.AddPoint(projection.LongitudeToX(node.Coordinate.Longitude)'                                         projection.LatitudeToY(node.Coordinate.Latitude));                          scene.AddStylePoint(pointId.Value' this.CalculateSceneLayer(OffsetPoint' zIndex)' minZoom' maxZoom' color' width);                      }                      else                      {                          pointId = scene.AddPoint(projection.LongitudeToX(node.Coordinate.Longitude)'                                         projection.LatitudeToY(node.Coordinate.Latitude));                          scene.AddStylePoint(pointId.Value' this.CalculateSceneLayer(OffsetPoint' zIndex)' minZoom' maxZoom' color' 1);                      }                  }                  byte[] iconImage;                  if (rule.TryGetProperty("iconImage"' out iconImage))                  {                      if (!pointId.HasValue)                      {                          pointId = scene.AddPoint(projection.LongitudeToX(node.Coordinate.Longitude)'                                         projection.LatitudeToY(node.Coordinate.Latitude));                      }                      // an icon is to be drawn!                      ushort imageId = scene.AddImage(iconImage);                      scene.AddIcon(pointId.Value' this.CalculateSceneLayer(OffsetPoint' zIndex)' minZoom' maxZoom' imageId);                  }                    string text;                  if (rule.TryGetProperty("text"' out text))                  {                      int textColor;                      if(!rule.TryGetProperty("textColor"' out textColor))                      {                          textColor = SimpleColor.FromKnownColor(KnownColor.Black).Value;                      }                      int haloColor;                      int? haloColorNullable = null;                      if (rule.TryGetProperty("textHaloColor"' out haloColor))                      {                          haloColorNullable = haloColor;                      }                      int haloRadius;                      int? haloRadiusNullable = null;                      if (rule.TryGetProperty("textHaloRadius"' out haloRadius))                      {                          haloRadiusNullable = haloRadius;                      }                      int fontSize;                      if (!rule.TryGetProperty("fontSize"' out fontSize))                      {                          fontSize = 10;                      }  					string fontFamily;  					if (!rule.TryGetProperty ("fontFamily"' out fontFamily))                      {  						fontFamily = "Arial"; // just some default font.  					}                        // a text is to be drawn.                      string value;                      if (node.Tags.TryGetValue(text' out value))                      {                          if (!pointId.HasValue)                          {                              pointId = scene.AddPoint(projection.LongitudeToX(node.Coordinate.Longitude)'                                             projection.LatitudeToY(node.Coordinate.Latitude));                          }                          scene.AddText(pointId.Value' this.CalculateSceneLayer(OffsetPointText' zIndex)' minZoom' maxZoom' fontSize' value' textColor'   						              haloColorNullable' haloRadiusNullable' fontFamily);                      }                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateWay,The following statement contains a magic number: if (x == null)              { // pre-calculate x/y.  				x = new double[way.Nodes.Count];  				y = new double[way.Nodes.Count];                  for (int idx = 0; idx < way.Nodes.Count; idx++)                  {                      x[idx] = projection.LongitudeToX(                          way.Nodes[idx].Coordinate.Longitude);                      y[idx] = projection.LatitudeToY(                          way.Nodes[idx].Coordinate.Latitude);                  }                    // simplify.                  if (x.Length > 2)                  {                      double[][] simplified = SimplifyCurve.Simplify(new double[][] {x' y}' 0.0001);                      x = simplified[0];                      y = simplified[1];                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateWay,The following statement contains a magic number: if (x == null)              { // pre-calculate x/y.  				x = new double[way.Nodes.Count];  				y = new double[way.Nodes.Count];                  for (int idx = 0; idx < way.Nodes.Count; idx++)                  {                      x[idx] = projection.LongitudeToX(                          way.Nodes[idx].Coordinate.Longitude);                      y[idx] = projection.LatitudeToY(                          way.Nodes[idx].Coordinate.Latitude);                  }                    // simplify.                  if (x.Length > 2)                  {                      double[][] simplified = SimplifyCurve.Simplify(new double[][] {x' y}' 0.0001);                      x = simplified[0];                      y = simplified[1];                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateWay,The following statement contains a magic number: foreach (var rule in rules)              {                  float minZoom = (float)projection.ToZoomFactor(rule.MinZoom);                  float maxZoom = (float)projection.ToZoomFactor(rule.MaxZoom);                    int zIndex ;                  if (!rule.TryGetProperty<int>("zIndex"' out zIndex))                  {                      zIndex = 0;                  }                    // interpret the results.                  if (x != null &&                      x.Length > 1)                  { // there is a valid interpretation of this way.                      int color;                      bool renderAsLine = true;                      if (way.IsOfType(MapCSSTypes.Area))                      { // the way is an area. check if it can be rendered as an area.                          int fillColor;                          if (rule.TryGetProperty("fillColor"' out fillColor))                          { // render as an area.                              uint? pointsId = scene.AddPoints(x' y);                              if (pointsId.HasValue)                              {                                  scene.AddStylePolygon(pointsId.Value' this.CalculateSceneLayer(OffsetArea' zIndex)' minZoom' maxZoom' fillColor' 1' true);                                  success = true;                                  if (rule.TryGetProperty("color"' out color))                                  {                                      scene.AddStylePolygon(pointsId.Value' this.CalculateSceneLayer(OffsetCasing' zIndex)' minZoom' maxZoom' color' 1' false);                                      success = true;                                  }                              }                              renderAsLine = false; // was validly rendered als a line.                          }                      }                        if (renderAsLine)                      { // was not rendered as an area.                          // the way has to rendered as a line.                          LineJoin lineJoin;                          if (!rule.TryGetProperty("lineJoin"' out lineJoin))                          {                              lineJoin = LineJoin.Miter;                          }                          int[] dashes;                          if (!rule.TryGetProperty("dashes"' out dashes))                          {                              dashes = null;                          }                          if (rule.TryGetProperty("color"' out color))                          {                              float casingWidth;                              int casingColor;                              if (!rule.TryGetProperty("casingWidth"' out casingWidth))                              {                                  casingWidth = 0;                              }                              if (!rule.TryGetProperty("casingColor"' out casingColor))                              { // casing: use the casing layer.                                  casingColor = -1;                              }                              float width;                              if (!rule.TryGetProperty("width"' out width))                              {                                  width = 1;                              }                              uint? pointsId = scene.AddPoints(x' y);                              success = true;                              if (pointsId.HasValue)                              {                                  if (casingWidth > 0)                                  { // adds the casing                                      scene.AddStyleLine(pointsId.Value' this.CalculateSceneLayer(OffsetCasing' zIndex)'                                          minZoom' maxZoom' casingColor' width + (casingWidth * 2)' lineJoin' dashes);                                  }                                  if (dashes == null)                                  { // dashes not set' use line offset.                                      scene.AddStyleLine(pointsId.Value' this.CalculateSceneLayer(OffsetLine' zIndex)'                                          minZoom' maxZoom' color' width' lineJoin' dashes);                                  }                                  else                                  { // dashes set' use line pattern offset.                                      scene.AddStyleLine(pointsId.Value' this.CalculateSceneLayer(OffsetLinePattern' zIndex)'                                          minZoom' maxZoom' color' width' lineJoin' dashes);                                  }                                    int textColor;                                  int fontSize;                                  string nameTag;                                  if (!rule.TryGetProperty("fontSize"' out fontSize))                                  {                                      fontSize = 10;                                  }                                  if (rule.TryGetProperty("text"' out nameTag) &&                                      rule.TryGetProperty("textColor"' out textColor))                                  {                                      int haloColor;                                      int? haloColorNullable = null;                                      if (rule.TryGetProperty("textHaloColor"' out haloColor))                                      {                                          haloColorNullable = haloColor;                                      }                                      int haloRadius;                                      int? haloRadiusNullable = null;                                      if (rule.TryGetProperty("textHaloRadius"' out haloRadius))                                      {                                          haloRadiusNullable = haloRadius;                                      }                                      string fontFamily;                                      if (!rule.TryGetProperty("fontFamily"' out fontFamily))                                      {                                          fontFamily = "Arial"; // just some default font.                                      }                                      string name;                                      if (way.Tags.TryGetValue(nameTag' out name))                                      {                                          scene.AddStyleLineText(pointsId.Value' this.CalculateSceneLayer(OffsetLineText' zIndex)'                                              minZoom' maxZoom' textColor' fontSize' name' fontFamily' haloColorNullable' haloRadiusNullable);                                      }                                  }                              }                          }                      }                  }                  else                  { // don't report as an error when no nodes.                      success = true;                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateWay,The following statement contains a magic number: foreach (var rule in rules)              {                  float minZoom = (float)projection.ToZoomFactor(rule.MinZoom);                  float maxZoom = (float)projection.ToZoomFactor(rule.MaxZoom);                    int zIndex ;                  if (!rule.TryGetProperty<int>("zIndex"' out zIndex))                  {                      zIndex = 0;                  }                    // interpret the results.                  if (x != null &&                      x.Length > 1)                  { // there is a valid interpretation of this way.                      int color;                      bool renderAsLine = true;                      if (way.IsOfType(MapCSSTypes.Area))                      { // the way is an area. check if it can be rendered as an area.                          int fillColor;                          if (rule.TryGetProperty("fillColor"' out fillColor))                          { // render as an area.                              uint? pointsId = scene.AddPoints(x' y);                              if (pointsId.HasValue)                              {                                  scene.AddStylePolygon(pointsId.Value' this.CalculateSceneLayer(OffsetArea' zIndex)' minZoom' maxZoom' fillColor' 1' true);                                  success = true;                                  if (rule.TryGetProperty("color"' out color))                                  {                                      scene.AddStylePolygon(pointsId.Value' this.CalculateSceneLayer(OffsetCasing' zIndex)' minZoom' maxZoom' color' 1' false);                                      success = true;                                  }                              }                              renderAsLine = false; // was validly rendered als a line.                          }                      }                        if (renderAsLine)                      { // was not rendered as an area.                          // the way has to rendered as a line.                          LineJoin lineJoin;                          if (!rule.TryGetProperty("lineJoin"' out lineJoin))                          {                              lineJoin = LineJoin.Miter;                          }                          int[] dashes;                          if (!rule.TryGetProperty("dashes"' out dashes))                          {                              dashes = null;                          }                          if (rule.TryGetProperty("color"' out color))                          {                              float casingWidth;                              int casingColor;                              if (!rule.TryGetProperty("casingWidth"' out casingWidth))                              {                                  casingWidth = 0;                              }                              if (!rule.TryGetProperty("casingColor"' out casingColor))                              { // casing: use the casing layer.                                  casingColor = -1;                              }                              float width;                              if (!rule.TryGetProperty("width"' out width))                              {                                  width = 1;                              }                              uint? pointsId = scene.AddPoints(x' y);                              success = true;                              if (pointsId.HasValue)                              {                                  if (casingWidth > 0)                                  { // adds the casing                                      scene.AddStyleLine(pointsId.Value' this.CalculateSceneLayer(OffsetCasing' zIndex)'                                          minZoom' maxZoom' casingColor' width + (casingWidth * 2)' lineJoin' dashes);                                  }                                  if (dashes == null)                                  { // dashes not set' use line offset.                                      scene.AddStyleLine(pointsId.Value' this.CalculateSceneLayer(OffsetLine' zIndex)'                                          minZoom' maxZoom' color' width' lineJoin' dashes);                                  }                                  else                                  { // dashes set' use line pattern offset.                                      scene.AddStyleLine(pointsId.Value' this.CalculateSceneLayer(OffsetLinePattern' zIndex)'                                          minZoom' maxZoom' color' width' lineJoin' dashes);                                  }                                    int textColor;                                  int fontSize;                                  string nameTag;                                  if (!rule.TryGetProperty("fontSize"' out fontSize))                                  {                                      fontSize = 10;                                  }                                  if (rule.TryGetProperty("text"' out nameTag) &&                                      rule.TryGetProperty("textColor"' out textColor))                                  {                                      int haloColor;                                      int? haloColorNullable = null;                                      if (rule.TryGetProperty("textHaloColor"' out haloColor))                                      {                                          haloColorNullable = haloColor;                                      }                                      int haloRadius;                                      int? haloRadiusNullable = null;                                      if (rule.TryGetProperty("textHaloRadius"' out haloRadius))                                      {                                          haloRadiusNullable = haloRadius;                                      }                                      string fontFamily;                                      if (!rule.TryGetProperty("fontFamily"' out fontFamily))                                      {                                          fontFamily = "Arial"; // just some default font.                                      }                                      string name;                                      if (way.Tags.TryGetValue(nameTag' out name))                                      {                                          scene.AddStyleLineText(pointsId.Value' this.CalculateSceneLayer(OffsetLineText' zIndex)'                                              minZoom' maxZoom' textColor' fontSize' name' fontFamily' haloColorNullable' haloRadiusNullable);                                      }                                  }                              }                          }                      }                  }                  else                  { // don't report as an error when no nodes.                      success = true;                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateLineairRing,The following statement contains a magic number: if (lineairRing.Coordinates != null &&                  lineairRing.Coordinates.Count > 0)              { // pre-calculate x/y.                  x = new double[lineairRing.Coordinates.Count];                  y = new double[lineairRing.Coordinates.Count];                  for (int idx = 0; idx < lineairRing.Coordinates.Count; idx++)                  {                      x[idx] = projection.LongitudeToX(                          lineairRing.Coordinates[idx].Longitude);                      y[idx] = projection.LatitudeToY(                          lineairRing.Coordinates[idx].Latitude);                  }                    // simplify.                  if (x.Length > 2)                  {                      double[][] simplified = SimplifyCurve.Simplify(new double[][] { x' y }' 0.0001);                      x = simplified[0];                      y = simplified[1];                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateLineairRing,The following statement contains a magic number: if (lineairRing.Coordinates != null &&                  lineairRing.Coordinates.Count > 0)              { // pre-calculate x/y.                  x = new double[lineairRing.Coordinates.Count];                  y = new double[lineairRing.Coordinates.Count];                  for (int idx = 0; idx < lineairRing.Coordinates.Count; idx++)                  {                      x[idx] = projection.LongitudeToX(                          lineairRing.Coordinates[idx].Longitude);                      y[idx] = projection.LatitudeToY(                          lineairRing.Coordinates[idx].Latitude);                  }                    // simplify.                  if (x.Length > 2)                  {                      double[][] simplified = SimplifyCurve.Simplify(new double[][] { x' y }' 0.0001);                      x = simplified[0];                      y = simplified[1];                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,TranslateLineairRing,The following statement contains a magic number: foreach (var rule in rules)              {                  float minZoom = (float)projection.ToZoomFactor(rule.MinZoom);                  float maxZoom = (float)projection.ToZoomFactor(rule.MaxZoom);                    int zIndex;                  if (!rule.TryGetProperty<int>("zIndex"' out zIndex))                  {                      zIndex = 0;                  }                    // interpret the results.                  if (x != null)                  { // there is a valid interpretation of this way.                      int color;                      int fillColor;                      if (rule.TryGetProperty("fillColor"' out fillColor))                      { // render as an area.                          float fillOpacity;                          if(rule.TryGetProperty("fillOpacity"' out fillOpacity))                          {                              SimpleColor simpleFillColor = new SimpleColor() { Value = fillColor };                              fillColor = SimpleColor.FromArgb((int)(255 * fillOpacity)'                                   simpleFillColor.R' simpleFillColor.G' simpleFillColor.B).Value;                          }                          uint? pointsId = scene.AddPoints(x' y);                          if (pointsId.HasValue)                          {                              scene.AddStylePolygon(pointsId.Value' this.CalculateSceneLayer(OffsetArea' zIndex)' minZoom' maxZoom' fillColor' 1' true);                              if (rule.TryGetProperty("color"' out color))                              {                                  scene.AddStylePolygon(pointsId.Value' this.CalculateSceneLayer(OffsetCasing' zIndex)' minZoom' maxZoom' color' 1' false);                              }                          }                      }                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,CalculateSceneLayer,The following statement contains a magic number: return (uint)(majorZIndex * 1000000 + zIndex * 1000);
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,CalculateSceneLayer,The following statement contains a magic number: return (uint)(majorZIndex * 1000000 + zIndex * 1000);
Magic Number,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,BuildRules,The following statement contains a magic number: foreach (var rule in _mapCSSFile.Rules)              {                  List<SelectorZoom> zooms;                  if (rule.HasToBeAppliedTo(mapCSSObject' out zooms))                  { // the selector was ok.                      // loop over all declarations.                      var properties = new MapCSSRuleProperties();                      foreach (var declaration in rule.Declarations)                      {                          if (declaration is DeclarationInt)                          {                              var declarationInt = (declaration as DeclarationInt);                              switch (declarationInt.Qualifier)                              {                                  case DeclarationIntEnum.FillColor:                                      properties.AddProperty("fillColor"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.ZIndex:                                      properties.AddProperty("zIndex"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.Color:                                      properties.AddProperty("color"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.CasingColor:                                      properties.AddProperty("casingColor"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.Extrude:                                      properties.AddProperty("extrude"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.ExtrudeEdgeColor:                                      properties.AddProperty("extrudeEdgeColor"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.ExtrudeFaceColor:                                      properties.AddProperty("extrudeFaceColor"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.IconWidth:                                      properties.AddProperty("iconWidth"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.IconHeight:                                      properties.AddProperty("iconHeight"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.FontSize:                                      properties.AddProperty("fontSize"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.TextColor:                                      properties.AddProperty("textColor"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.TextOffset:                                      properties.AddProperty("textOffset"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.MaxWidth:                                      properties.AddProperty("maxWidth"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.TextHaloColor:                                      properties.AddProperty("textHaloColor"' declarationInt.Eval(mapCSSObject));                                      break;                                  case DeclarationIntEnum.TextHaloRadius:                                      properties.AddProperty("textHaloRadius"' declarationInt.Eval(mapCSSObject));                                      break;                                  default:                                      throw new ArgumentOutOfRangeException();                              }                          }                          else if (declaration is DeclarationFloat)                          {                              var declarationFloat = (declaration as DeclarationFloat);                              switch (declarationFloat.Qualifier)                              {                                  case DeclarationFloatEnum.Width:                                      properties.AddProperty("width"' declarationFloat.Eval(mapCSSObject));                                      break;                                  case DeclarationFloatEnum.FillOpacity:                                      properties.AddProperty("fillOpacity"' declarationFloat.Eval(mapCSSObject));                                      break;                                  case DeclarationFloatEnum.Opacity:                                      properties.AddProperty("opacity"' declarationFloat.Eval(mapCSSObject));                                      break;                                  case DeclarationFloatEnum.CasingOpacity:                                      properties.AddProperty("casingOpacity"' declarationFloat.Eval(mapCSSObject));                                      break;                                  case DeclarationFloatEnum.ExtrudeEdgeOpacity:                                      properties.AddProperty("extrudeEdgeOpacity"' declarationFloat.Eval(mapCSSObject));                                      break;                                  case DeclarationFloatEnum.ExtrudeFaceOpacity:                                      properties.AddProperty("extrudeFaceOpacity"' declarationFloat.Eval(mapCSSObject));                                      break;                                  case DeclarationFloatEnum.ExtrudeEdgeWidth:                                      properties.AddProperty("extrudeEdgeWidth"' declarationFloat.Eval(mapCSSObject));                                      break;                                  case DeclarationFloatEnum.IconOpacity:                                      properties.AddProperty("iconOpacity"' declarationFloat.Eval(mapCSSObject));                                      break;                                  case DeclarationFloatEnum.TextOpacity:                                      properties.AddProperty("textOpacity"' declarationFloat.Eval(mapCSSObject));                                      break;                                  case DeclarationFloatEnum.CasingWidth:                                      properties.AddProperty("casingWidth"' declarationFloat.Eval(mapCSSObject));                                      break;                                  default:                                      throw new ArgumentOutOfRangeException();                              }                          }                          else if (declaration is DeclarationString)                          {                              var declarationString = declaration as DeclarationString;                              switch (declarationString.Qualifier)                              {                                  case DeclarationStringEnum.FontFamily:                                      properties.AddProperty("fontFamily"' declarationString.Eval(mapCSSObject));                                      break;                                  case DeclarationStringEnum.Text:                                      properties.AddProperty("text"' declarationString.Eval(mapCSSObject));                                      break;                                  default:                                      throw new ArgumentOutOfRangeException();                              }                          }                          else if (declaration is DeclarationURL)                          {                              byte[] image;                              var declarationURL = declaration as DeclarationURL;                              switch (declarationURL.Qualifier)                              {                                  case DeclarationURLEnum.Image:                                      if (_mapCSSImageSource.TryGet(declarationURL.Eval(mapCSSObject)' out image))                                      {                                          properties.AddProperty("image"' image);                                      }                                      break;                                  case DeclarationURLEnum.FillImage:                                      if (_mapCSSImageSource.TryGet(declarationURL.Eval(mapCSSObject)' out image))                                      {                                          properties.AddProperty("fillImage"' image);                                      }                                      break;                                  case DeclarationURLEnum.IconImage:                                      if (_mapCSSImageSource.TryGet(declarationURL.Eval(mapCSSObject)' out image))                                      {                                          properties.AddProperty("iconImage"' image);                                      }                                      break;                                  case DeclarationURLEnum.ShieldImage:                                      if (_mapCSSImageSource.TryGet(declarationURL.Eval(mapCSSObject)' out image))                                      {                                          properties.AddProperty("shieldImage"' image);                                      }                                      break;                                  default:                                      throw new ArgumentOutOfRangeException();                              }                          }                          else if (declaration is DeclarationLineJoin)                          {                              var declarationLineJoin = (declaration as DeclarationLineJoin);                              properties.AddProperty("lineJoin"' declarationLineJoin.Eval(                                  mapCSSObject));                          }                          else if (declaration is DeclarationDashes)                          {                              var declarationDashes = (declaration as DeclarationDashes);                              properties.AddProperty("dashes"' declarationDashes.Eval(                                  mapCSSObject));                          }                      }                        // loop over all zoom levels.                      foreach (var zoom in zooms)                      {                          int minZoom = 0;                          int maxZoom = 25;                          if (zoom != null)                          { // there is a zoom object.                              if (zoom.ZoomMin.HasValue)                              {                                  minZoom = zoom.ZoomMin.Value;                              }                              if (zoom.ZoomMax.HasValue)                              {                                  maxZoom = zoom.ZoomMax.Value;                              }                          }                            // zoom properties;                          var zoomRule = new MapCSSRuleProperties(                              minZoom' maxZoom);                          zoomRule = zoomRule.Merge(properties);                            // add the properties.                          rulesCollection.AddProperties(zoomRule);                      }                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2.Eval,EvalInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\Eval\EvalInterpreter.cs,Interpreter,The following statement contains a magic number: if (expression.StartsWith(TAG_TOKEN))              { // get the tag value.                  string[] args = this.ParseFunction(expression);                  if (args.Length != 1) { throw new EvalInterpreterException("Invalid argument count: {0}"' expression); }                  string tagValue;                  if (!tags.TryGetValue(args[0]' out tagValue))                  { // the tag value.                      tagValue = null;                  }                  return tagValue;              }              else if (expression.StartsWith(PROP_TOKEN))              { // not supported for now: mapcss interpretation code needs to change first to keep a list                  // of current properties.                  return null; // return 'none'.              }              else if (expression.StartsWith(COND_TOKEN))              { // evaluate expression and decide on the next expression.                  string[] args = this.ParseFunction(expression);                  if (args.Length != 3) { throw new EvalInterpreterException("Invalid argument count: {0}"' expression); }                  if (this.ParseBool(this.Interpreter(args[0]' tags)))                  { // evaluate and return the true-part.                      return this.Interpreter(args[1]' tags);                  }                  else                  { // evaluate and return the false-part.                      return this.Interpreter(args[2]' tags);                  }              }              else if (expression.StartsWith(ANY_TOKEN))              { // return the first expression that does not evaluate to 'none'.                  string[] args = this.ParseFunction(expression);                  if (args.Length == 0) { throw new EvalInterpreterException("Invalid argument count: {0}"' expression); }                  for (int idx = 0; idx < args.Length; idx++)                  { // evaluate each expression in the correct order.                      string result = this.Interpreter(args[idx]' tags);                      if (!this.IsNone(result))                      { // expression was found not returning 'none'.                          return result;                      }                  }                  return null;              }              else if (expression.StartsWith(MAX_TOKEN))              { // returns the maximum value of all arguments.                }              else if (expression.StartsWith(MIN_TOKEN))              { // returns the minimum value of all arguments.                }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2.Eval,EvalInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\Eval\EvalInterpreter.cs,Interpreter,The following statement contains a magic number: if (expression.StartsWith(TAG_TOKEN))              { // get the tag value.                  string[] args = this.ParseFunction(expression);                  if (args.Length != 1) { throw new EvalInterpreterException("Invalid argument count: {0}"' expression); }                  string tagValue;                  if (!tags.TryGetValue(args[0]' out tagValue))                  { // the tag value.                      tagValue = null;                  }                  return tagValue;              }              else if (expression.StartsWith(PROP_TOKEN))              { // not supported for now: mapcss interpretation code needs to change first to keep a list                  // of current properties.                  return null; // return 'none'.              }              else if (expression.StartsWith(COND_TOKEN))              { // evaluate expression and decide on the next expression.                  string[] args = this.ParseFunction(expression);                  if (args.Length != 3) { throw new EvalInterpreterException("Invalid argument count: {0}"' expression); }                  if (this.ParseBool(this.Interpreter(args[0]' tags)))                  { // evaluate and return the true-part.                      return this.Interpreter(args[1]' tags);                  }                  else                  { // evaluate and return the false-part.                      return this.Interpreter(args[2]' tags);                  }              }              else if (expression.StartsWith(ANY_TOKEN))              { // return the first expression that does not evaluate to 'none'.                  string[] args = this.ParseFunction(expression);                  if (args.Length == 0) { throw new EvalInterpreterException("Invalid argument count: {0}"' expression); }                  for (int idx = 0; idx < args.Length; idx++)                  { // evaluate each expression in the correct order.                      string result = this.Interpreter(args[idx]' tags);                      if (!this.IsNone(result))                      { // expression was found not returning 'none'.                          return result;                      }                  }                  return null;              }              else if (expression.StartsWith(MAX_TOKEN))              { // returns the maximum value of all arguments.                }              else if (expression.StartsWith(MIN_TOKEN))              { // returns the minimum value of all arguments.                }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,Parse,The following statement contains a magic number: if (tree.ChildCount > 0)              {                  // create the mapcss file.                  var file = new MapCSSFile();                                    // loop over all children.                  foreach (CommonTree child in tree.Children)                  {                      if (child.Text == "RULE")                      {                          if (child.ChildCount == 2 &&                              child.Children[0].Text == "SIMPLE_SELECTOR" &&                              child.Children[0].ChildCount == 1 &&                              child.Children[0] is CommonTree &&                              (child.Children[0] as CommonTree).Children[0].Text == "canvas")                          { // this child represents the canvas rule.                              MapCSSDomainParser.ParseCanvasRule(file' child as CommonTree);                          }                          else if (child.ChildCount == 2 &&                              child.Children[0].Text == "SIMPLE_SELECTOR" &&                              child.Children[0].ChildCount == 1 &&                              child.Children[0] is CommonTree &&                              (child.Children[0] as CommonTree).Children[0].Text == "meta")                          { // this child represents the canvas rule.                              MapCSSDomainParser.ParseMetaRule(file' child as CommonTree);                          }                          else                          { // this child can only be a regular rule.                              Rule rule =                                  MapCSSDomainParser.ParseRule(child as CommonTree);                              file.Rules.Add(rule);                          }                      }                  }                    return file;              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,Parse,The following statement contains a magic number: if (tree.ChildCount > 0)              {                  // create the mapcss file.                  var file = new MapCSSFile();                                    // loop over all children.                  foreach (CommonTree child in tree.Children)                  {                      if (child.Text == "RULE")                      {                          if (child.ChildCount == 2 &&                              child.Children[0].Text == "SIMPLE_SELECTOR" &&                              child.Children[0].ChildCount == 1 &&                              child.Children[0] is CommonTree &&                              (child.Children[0] as CommonTree).Children[0].Text == "canvas")                          { // this child represents the canvas rule.                              MapCSSDomainParser.ParseCanvasRule(file' child as CommonTree);                          }                          else if (child.ChildCount == 2 &&                              child.Children[0].Text == "SIMPLE_SELECTOR" &&                              child.Children[0].ChildCount == 1 &&                              child.Children[0] is CommonTree &&                              (child.Children[0] as CommonTree).Children[0].Text == "meta")                          { // this child represents the canvas rule.                              MapCSSDomainParser.ParseMetaRule(file' child as CommonTree);                          }                          else                          { // this child can only be a regular rule.                              Rule rule =                                  MapCSSDomainParser.ParseRule(child as CommonTree);                              file.Rules.Add(rule);                          }                      }                  }                    return file;              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseCanvasRule,The following statement contains a magic number: if (ruleTree.ChildCount >= 2 &&                  ruleTree.Children[1] != null)              { // loop over all declaration rules in canvas.                  foreach (CommonTree rule in (ruleTree.Children[1] as CommonTree).Children)                  {                      if (rule.Text == "DECLARATION" &&                          rule.Children != null &&                          rule.Children.Count > 0)                      { // parse the decalaration.                          // support both JOSM's background-color and fill-color.                          if (rule.Children[0].Text == "background-color")                          { // parse the background color.                              file.CanvasFillColor = MapCSSDomainParser.ParseColor(rule.Children[1] as CommonTree);                          }                          else if (rule.Children[0].Text == "fill-color")                          { // parse the background color.                              file.CanvasFillColor = MapCSSDomainParser.ParseColor(rule.Children[1] as CommonTree);                          }                          else if (rule.Children[0].Text == "default-points")                          { // parse the default points-setting.                              file.DefaultPoints = false;                              if(rule.Children[1].Text == "true")                              {                                  file.DefaultPoints = true;                              }                          }                          else if (rule.Children[0].Text == "default-lines")                          { // parse the default lines-setting.                              file.DefaultLines = false;                              if (rule.Children[1].Text == "true")                              {                                  file.DefaultLines = true;                              }                          }                      }                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseMetaRule,The following statement contains a magic number: if (ruleTree.ChildCount >= 2 &&                  ruleTree.Children[1] != null)              { // loop over all declaration rules in canvas.                  foreach (CommonTree rule in (ruleTree.Children[1] as CommonTree).Children)                  {                      if (rule.Text == "DECLARATION" &&                          rule.Children != null &&                          rule.Children.Count > 0)                      { // parse the decalaration.                          if (rule.Children[0].Text == "title")                          { // parse the background color.                              file.Title = MapCSSDomainParser.ParseURL(rule.Children[1].Text);                          }                          else if (rule.Children[0].Text == "icon")                          { // parse the default points-setting.                              file.Icon = MapCSSDomainParser.ParseURL(rule.Children[1].Text);                          }                      }                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseRule,The following statement contains a magic number: while (ruleTree.Children[simpleSelectorIdx].Text == "SIMPLE_SELECTOR")              { // see what this SIMPLE_SELECTOR is all about.                  var simpleSelectorTree = ruleTree.Children[simpleSelectorIdx] as CommonTree;                  if (simpleSelectorTree != null)                  { // the simple selector tree exists.                      int childIdx = 0;                      var selector = new Selector();                        if (simpleSelectorTree.Children[0].Text == "way")                      { // the way.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Way;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "node")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Node;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "relation")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Relation;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "area")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Area;                          rule.Selectors.Add(selector);                      }                      else                      {                          // oeps' this is not possible.                          throw new MapCSSDomainParserException(simpleSelectorTree'                                                                "Simple selector type not found!");                      }                        // parse the zoom selector if any.                      if (simpleSelectorTree.ChildCount > 1 &&                          simpleSelectorTree.Children[1].Text == "ZOOM_SELECTOR")                      { // there is a zoom selector.                          childIdx++; // this selector seems ok.                            var zoomSelector =                               simpleSelectorTree.Children[1] as CommonTree;                          if (zoomSelector != null &&                               zoomSelector.Children != null &&                              zoomSelector.Children.Count > 0)                          { // the zoom selector.                              var zooms = new List<string>();                              foreach (var child in zoomSelector.Children)                              {                                  // try and parse the zoom levels.                                  zooms.Add(child.Text);                              }                                if (zooms.Count == 2)                              { // just two zoom selectors.                                  var selectorZoom = new SelectorZoom();                                  int zoom;                                  // parse zoom 1.                                  if (string.IsNullOrWhiteSpace(zooms[0]))                                  { // minzoom is zero.                                      selectorZoom.ZoomMin = null;                                  }                                  else if (int.TryParse(zooms[0]' NumberStyles.Any'                                                        System.Globalization.CultureInfo.InvariantCulture'                                                        out zoom))                                  { // minzoom was set!                                      selectorZoom.ZoomMin = zoom;                                  }                                  else                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(zoomSelector'                                                                            "Zoom selector invalid!");                                  }                                  // parse zoom 2.                                  if (string.IsNullOrWhiteSpace(zooms[1]))                                  { // minzoom is zero.                                      selectorZoom.ZoomMax = null;                                  }                                  else if (int.TryParse(zooms[1]' NumberStyles.Any'                                                        System.Globalization.CultureInfo.InvariantCulture'                                                        out zoom))                                  { // minzoom was set!                                      selectorZoom.ZoomMax = zoom;                                  }                                  else                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(zoomSelector'                                                                            "Zoom selector invalid!");                                  }                                    // add zoom selector.                                  selector.Zoom = selectorZoom;                              }                              else                              {                                  // oeps' this is not possible.                                  throw new MapCSSDomainParserException(zoomSelector'                                                                        "Zoom selector invalid!");                              }                          }                      }                        // parse the rest of the selectors.                      for (int selectorIdx = childIdx; selectorIdx < simpleSelectorTree.ChildCount;                           selectorIdx++)                      {                          var nextSelector =                              simpleSelectorTree.Children[selectorIdx] as CommonTree;                          if (nextSelector != null &&                              nextSelector.Text == "ATTRIBUTE_SELECTOR")                          { // parse attribute selectors.                              var attributeSelector = nextSelector as CommonTree;                                if (attributeSelector.Children[0].Text == "OP_EXIST")                              {                                  // the exists selector.                                  var opExistsRule = new SelectorRuleTag();                                    if (attributeSelector.ChildCount < 2)                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(attributeSelector'                                                                            "OP_EXIST without tag value!");                                  }                                  opExistsRule.Tag = attributeSelector.Children[1].Text;                                    // add the tags.                                  if (selector.SelectorRule == null)                                  {                                      selector.SelectorRule = opExistsRule;                                  }                                  else                                  {                                      selector.SelectorRule = selector.SelectorRule & opExistsRule;                                  }                              }                              else if (attributeSelector.Children[0].Text == "<" ||                                  attributeSelector.Children[0].Text == ">" ||                                  attributeSelector.Children[0].Text == "=" ||                                  attributeSelector.Children[0].Text == "!=")                              {                                  // the exists selector.                                  var selectorRuleTagValueComparison = new SelectorRuleTagValueComparison();                                    if (attributeSelector.ChildCount < 3)                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(attributeSelector'                                                                            "Tag selector without tag/key value!");                                  }                                  switch (attributeSelector.Children[0].Text)                                  {                                      case ">":                                          selectorRuleTagValueComparison.Comparator =                                               SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.GreaterThan;                                          break;                                      case "<":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.GreaterThan;                                          break;                                      case "=":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.Equal;                                          break;                                      case "!=":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.NotEqual;                                          break;                                      default:                                          // oeps' this is not possible.                                          throw new MapCSSDomainParserException(attributeSelector'                                                                                string.Format("{0} not found as comparator"'                                                                                  attributeSelector.Children[0].Text));                                  }                                  selectorRuleTagValueComparison.Tag = attributeSelector.Children[1].Text;                                  selectorRuleTagValueComparison.Value = attributeSelector.Children[2].Text;                                    // add the tags.                                  if (selector.SelectorRule == null)                                  {                                      selector.SelectorRule = selectorRuleTagValueComparison;                                  }                                  else                                  {                                      selector.SelectorRule = selector.SelectorRule & selectorRuleTagValueComparison;                                  }                              }                              else                              {                                  // oeps' this is not possible.                                  throw new MapCSSDomainParserException(attributeSelector'                                                                        "Attibute selector not found!");                              }                          }                      }                  }                    // move to the next selector.                  simpleSelectorIdx++;              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseRule,The following statement contains a magic number: while (ruleTree.Children[simpleSelectorIdx].Text == "SIMPLE_SELECTOR")              { // see what this SIMPLE_SELECTOR is all about.                  var simpleSelectorTree = ruleTree.Children[simpleSelectorIdx] as CommonTree;                  if (simpleSelectorTree != null)                  { // the simple selector tree exists.                      int childIdx = 0;                      var selector = new Selector();                        if (simpleSelectorTree.Children[0].Text == "way")                      { // the way.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Way;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "node")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Node;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "relation")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Relation;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "area")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Area;                          rule.Selectors.Add(selector);                      }                      else                      {                          // oeps' this is not possible.                          throw new MapCSSDomainParserException(simpleSelectorTree'                                                                "Simple selector type not found!");                      }                        // parse the zoom selector if any.                      if (simpleSelectorTree.ChildCount > 1 &&                          simpleSelectorTree.Children[1].Text == "ZOOM_SELECTOR")                      { // there is a zoom selector.                          childIdx++; // this selector seems ok.                            var zoomSelector =                               simpleSelectorTree.Children[1] as CommonTree;                          if (zoomSelector != null &&                               zoomSelector.Children != null &&                              zoomSelector.Children.Count > 0)                          { // the zoom selector.                              var zooms = new List<string>();                              foreach (var child in zoomSelector.Children)                              {                                  // try and parse the zoom levels.                                  zooms.Add(child.Text);                              }                                if (zooms.Count == 2)                              { // just two zoom selectors.                                  var selectorZoom = new SelectorZoom();                                  int zoom;                                  // parse zoom 1.                                  if (string.IsNullOrWhiteSpace(zooms[0]))                                  { // minzoom is zero.                                      selectorZoom.ZoomMin = null;                                  }                                  else if (int.TryParse(zooms[0]' NumberStyles.Any'                                                        System.Globalization.CultureInfo.InvariantCulture'                                                        out zoom))                                  { // minzoom was set!                                      selectorZoom.ZoomMin = zoom;                                  }                                  else                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(zoomSelector'                                                                            "Zoom selector invalid!");                                  }                                  // parse zoom 2.                                  if (string.IsNullOrWhiteSpace(zooms[1]))                                  { // minzoom is zero.                                      selectorZoom.ZoomMax = null;                                  }                                  else if (int.TryParse(zooms[1]' NumberStyles.Any'                                                        System.Globalization.CultureInfo.InvariantCulture'                                                        out zoom))                                  { // minzoom was set!                                      selectorZoom.ZoomMax = zoom;                                  }                                  else                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(zoomSelector'                                                                            "Zoom selector invalid!");                                  }                                    // add zoom selector.                                  selector.Zoom = selectorZoom;                              }                              else                              {                                  // oeps' this is not possible.                                  throw new MapCSSDomainParserException(zoomSelector'                                                                        "Zoom selector invalid!");                              }                          }                      }                        // parse the rest of the selectors.                      for (int selectorIdx = childIdx; selectorIdx < simpleSelectorTree.ChildCount;                           selectorIdx++)                      {                          var nextSelector =                              simpleSelectorTree.Children[selectorIdx] as CommonTree;                          if (nextSelector != null &&                              nextSelector.Text == "ATTRIBUTE_SELECTOR")                          { // parse attribute selectors.                              var attributeSelector = nextSelector as CommonTree;                                if (attributeSelector.Children[0].Text == "OP_EXIST")                              {                                  // the exists selector.                                  var opExistsRule = new SelectorRuleTag();                                    if (attributeSelector.ChildCount < 2)                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(attributeSelector'                                                                            "OP_EXIST without tag value!");                                  }                                  opExistsRule.Tag = attributeSelector.Children[1].Text;                                    // add the tags.                                  if (selector.SelectorRule == null)                                  {                                      selector.SelectorRule = opExistsRule;                                  }                                  else                                  {                                      selector.SelectorRule = selector.SelectorRule & opExistsRule;                                  }                              }                              else if (attributeSelector.Children[0].Text == "<" ||                                  attributeSelector.Children[0].Text == ">" ||                                  attributeSelector.Children[0].Text == "=" ||                                  attributeSelector.Children[0].Text == "!=")                              {                                  // the exists selector.                                  var selectorRuleTagValueComparison = new SelectorRuleTagValueComparison();                                    if (attributeSelector.ChildCount < 3)                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(attributeSelector'                                                                            "Tag selector without tag/key value!");                                  }                                  switch (attributeSelector.Children[0].Text)                                  {                                      case ">":                                          selectorRuleTagValueComparison.Comparator =                                               SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.GreaterThan;                                          break;                                      case "<":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.GreaterThan;                                          break;                                      case "=":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.Equal;                                          break;                                      case "!=":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.NotEqual;                                          break;                                      default:                                          // oeps' this is not possible.                                          throw new MapCSSDomainParserException(attributeSelector'                                                                                string.Format("{0} not found as comparator"'                                                                                  attributeSelector.Children[0].Text));                                  }                                  selectorRuleTagValueComparison.Tag = attributeSelector.Children[1].Text;                                  selectorRuleTagValueComparison.Value = attributeSelector.Children[2].Text;                                    // add the tags.                                  if (selector.SelectorRule == null)                                  {                                      selector.SelectorRule = selectorRuleTagValueComparison;                                  }                                  else                                  {                                      selector.SelectorRule = selector.SelectorRule & selectorRuleTagValueComparison;                                  }                              }                              else                              {                                  // oeps' this is not possible.                                  throw new MapCSSDomainParserException(attributeSelector'                                                                        "Attibute selector not found!");                              }                          }                      }                  }                    // move to the next selector.                  simpleSelectorIdx++;              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseRule,The following statement contains a magic number: while (ruleTree.Children[simpleSelectorIdx].Text == "SIMPLE_SELECTOR")              { // see what this SIMPLE_SELECTOR is all about.                  var simpleSelectorTree = ruleTree.Children[simpleSelectorIdx] as CommonTree;                  if (simpleSelectorTree != null)                  { // the simple selector tree exists.                      int childIdx = 0;                      var selector = new Selector();                        if (simpleSelectorTree.Children[0].Text == "way")                      { // the way.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Way;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "node")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Node;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "relation")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Relation;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "area")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Area;                          rule.Selectors.Add(selector);                      }                      else                      {                          // oeps' this is not possible.                          throw new MapCSSDomainParserException(simpleSelectorTree'                                                                "Simple selector type not found!");                      }                        // parse the zoom selector if any.                      if (simpleSelectorTree.ChildCount > 1 &&                          simpleSelectorTree.Children[1].Text == "ZOOM_SELECTOR")                      { // there is a zoom selector.                          childIdx++; // this selector seems ok.                            var zoomSelector =                               simpleSelectorTree.Children[1] as CommonTree;                          if (zoomSelector != null &&                               zoomSelector.Children != null &&                              zoomSelector.Children.Count > 0)                          { // the zoom selector.                              var zooms = new List<string>();                              foreach (var child in zoomSelector.Children)                              {                                  // try and parse the zoom levels.                                  zooms.Add(child.Text);                              }                                if (zooms.Count == 2)                              { // just two zoom selectors.                                  var selectorZoom = new SelectorZoom();                                  int zoom;                                  // parse zoom 1.                                  if (string.IsNullOrWhiteSpace(zooms[0]))                                  { // minzoom is zero.                                      selectorZoom.ZoomMin = null;                                  }                                  else if (int.TryParse(zooms[0]' NumberStyles.Any'                                                        System.Globalization.CultureInfo.InvariantCulture'                                                        out zoom))                                  { // minzoom was set!                                      selectorZoom.ZoomMin = zoom;                                  }                                  else                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(zoomSelector'                                                                            "Zoom selector invalid!");                                  }                                  // parse zoom 2.                                  if (string.IsNullOrWhiteSpace(zooms[1]))                                  { // minzoom is zero.                                      selectorZoom.ZoomMax = null;                                  }                                  else if (int.TryParse(zooms[1]' NumberStyles.Any'                                                        System.Globalization.CultureInfo.InvariantCulture'                                                        out zoom))                                  { // minzoom was set!                                      selectorZoom.ZoomMax = zoom;                                  }                                  else                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(zoomSelector'                                                                            "Zoom selector invalid!");                                  }                                    // add zoom selector.                                  selector.Zoom = selectorZoom;                              }                              else                              {                                  // oeps' this is not possible.                                  throw new MapCSSDomainParserException(zoomSelector'                                                                        "Zoom selector invalid!");                              }                          }                      }                        // parse the rest of the selectors.                      for (int selectorIdx = childIdx; selectorIdx < simpleSelectorTree.ChildCount;                           selectorIdx++)                      {                          var nextSelector =                              simpleSelectorTree.Children[selectorIdx] as CommonTree;                          if (nextSelector != null &&                              nextSelector.Text == "ATTRIBUTE_SELECTOR")                          { // parse attribute selectors.                              var attributeSelector = nextSelector as CommonTree;                                if (attributeSelector.Children[0].Text == "OP_EXIST")                              {                                  // the exists selector.                                  var opExistsRule = new SelectorRuleTag();                                    if (attributeSelector.ChildCount < 2)                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(attributeSelector'                                                                            "OP_EXIST without tag value!");                                  }                                  opExistsRule.Tag = attributeSelector.Children[1].Text;                                    // add the tags.                                  if (selector.SelectorRule == null)                                  {                                      selector.SelectorRule = opExistsRule;                                  }                                  else                                  {                                      selector.SelectorRule = selector.SelectorRule & opExistsRule;                                  }                              }                              else if (attributeSelector.Children[0].Text == "<" ||                                  attributeSelector.Children[0].Text == ">" ||                                  attributeSelector.Children[0].Text == "=" ||                                  attributeSelector.Children[0].Text == "!=")                              {                                  // the exists selector.                                  var selectorRuleTagValueComparison = new SelectorRuleTagValueComparison();                                    if (attributeSelector.ChildCount < 3)                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(attributeSelector'                                                                            "Tag selector without tag/key value!");                                  }                                  switch (attributeSelector.Children[0].Text)                                  {                                      case ">":                                          selectorRuleTagValueComparison.Comparator =                                               SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.GreaterThan;                                          break;                                      case "<":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.GreaterThan;                                          break;                                      case "=":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.Equal;                                          break;                                      case "!=":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.NotEqual;                                          break;                                      default:                                          // oeps' this is not possible.                                          throw new MapCSSDomainParserException(attributeSelector'                                                                                string.Format("{0} not found as comparator"'                                                                                  attributeSelector.Children[0].Text));                                  }                                  selectorRuleTagValueComparison.Tag = attributeSelector.Children[1].Text;                                  selectorRuleTagValueComparison.Value = attributeSelector.Children[2].Text;                                    // add the tags.                                  if (selector.SelectorRule == null)                                  {                                      selector.SelectorRule = selectorRuleTagValueComparison;                                  }                                  else                                  {                                      selector.SelectorRule = selector.SelectorRule & selectorRuleTagValueComparison;                                  }                              }                              else                              {                                  // oeps' this is not possible.                                  throw new MapCSSDomainParserException(attributeSelector'                                                                        "Attibute selector not found!");                              }                          }                      }                  }                    // move to the next selector.                  simpleSelectorIdx++;              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseRule,The following statement contains a magic number: while (ruleTree.Children[simpleSelectorIdx].Text == "SIMPLE_SELECTOR")              { // see what this SIMPLE_SELECTOR is all about.                  var simpleSelectorTree = ruleTree.Children[simpleSelectorIdx] as CommonTree;                  if (simpleSelectorTree != null)                  { // the simple selector tree exists.                      int childIdx = 0;                      var selector = new Selector();                        if (simpleSelectorTree.Children[0].Text == "way")                      { // the way.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Way;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "node")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Node;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "relation")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Relation;                          rule.Selectors.Add(selector);                      }                      else if (simpleSelectorTree.Children[0].Text == "area")                      { // the node.                          childIdx++; // this selector seems ok.                            selector.Type = SelectorTypeEnum.Area;                          rule.Selectors.Add(selector);                      }                      else                      {                          // oeps' this is not possible.                          throw new MapCSSDomainParserException(simpleSelectorTree'                                                                "Simple selector type not found!");                      }                        // parse the zoom selector if any.                      if (simpleSelectorTree.ChildCount > 1 &&                          simpleSelectorTree.Children[1].Text == "ZOOM_SELECTOR")                      { // there is a zoom selector.                          childIdx++; // this selector seems ok.                            var zoomSelector =                               simpleSelectorTree.Children[1] as CommonTree;                          if (zoomSelector != null &&                               zoomSelector.Children != null &&                              zoomSelector.Children.Count > 0)                          { // the zoom selector.                              var zooms = new List<string>();                              foreach (var child in zoomSelector.Children)                              {                                  // try and parse the zoom levels.                                  zooms.Add(child.Text);                              }                                if (zooms.Count == 2)                              { // just two zoom selectors.                                  var selectorZoom = new SelectorZoom();                                  int zoom;                                  // parse zoom 1.                                  if (string.IsNullOrWhiteSpace(zooms[0]))                                  { // minzoom is zero.                                      selectorZoom.ZoomMin = null;                                  }                                  else if (int.TryParse(zooms[0]' NumberStyles.Any'                                                        System.Globalization.CultureInfo.InvariantCulture'                                                        out zoom))                                  { // minzoom was set!                                      selectorZoom.ZoomMin = zoom;                                  }                                  else                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(zoomSelector'                                                                            "Zoom selector invalid!");                                  }                                  // parse zoom 2.                                  if (string.IsNullOrWhiteSpace(zooms[1]))                                  { // minzoom is zero.                                      selectorZoom.ZoomMax = null;                                  }                                  else if (int.TryParse(zooms[1]' NumberStyles.Any'                                                        System.Globalization.CultureInfo.InvariantCulture'                                                        out zoom))                                  { // minzoom was set!                                      selectorZoom.ZoomMax = zoom;                                  }                                  else                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(zoomSelector'                                                                            "Zoom selector invalid!");                                  }                                    // add zoom selector.                                  selector.Zoom = selectorZoom;                              }                              else                              {                                  // oeps' this is not possible.                                  throw new MapCSSDomainParserException(zoomSelector'                                                                        "Zoom selector invalid!");                              }                          }                      }                        // parse the rest of the selectors.                      for (int selectorIdx = childIdx; selectorIdx < simpleSelectorTree.ChildCount;                           selectorIdx++)                      {                          var nextSelector =                              simpleSelectorTree.Children[selectorIdx] as CommonTree;                          if (nextSelector != null &&                              nextSelector.Text == "ATTRIBUTE_SELECTOR")                          { // parse attribute selectors.                              var attributeSelector = nextSelector as CommonTree;                                if (attributeSelector.Children[0].Text == "OP_EXIST")                              {                                  // the exists selector.                                  var opExistsRule = new SelectorRuleTag();                                    if (attributeSelector.ChildCount < 2)                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(attributeSelector'                                                                            "OP_EXIST without tag value!");                                  }                                  opExistsRule.Tag = attributeSelector.Children[1].Text;                                    // add the tags.                                  if (selector.SelectorRule == null)                                  {                                      selector.SelectorRule = opExistsRule;                                  }                                  else                                  {                                      selector.SelectorRule = selector.SelectorRule & opExistsRule;                                  }                              }                              else if (attributeSelector.Children[0].Text == "<" ||                                  attributeSelector.Children[0].Text == ">" ||                                  attributeSelector.Children[0].Text == "=" ||                                  attributeSelector.Children[0].Text == "!=")                              {                                  // the exists selector.                                  var selectorRuleTagValueComparison = new SelectorRuleTagValueComparison();                                    if (attributeSelector.ChildCount < 3)                                  {                                      // oeps' this is not possible.                                      throw new MapCSSDomainParserException(attributeSelector'                                                                            "Tag selector without tag/key value!");                                  }                                  switch (attributeSelector.Children[0].Text)                                  {                                      case ">":                                          selectorRuleTagValueComparison.Comparator =                                               SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.GreaterThan;                                          break;                                      case "<":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.GreaterThan;                                          break;                                      case "=":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.Equal;                                          break;                                      case "!=":                                          selectorRuleTagValueComparison.Comparator =                                              SelectorRuleTagValueComparison.SelectorRuleTagValueComparisonEnum.NotEqual;                                          break;                                      default:                                          // oeps' this is not possible.                                          throw new MapCSSDomainParserException(attributeSelector'                                                                                string.Format("{0} not found as comparator"'                                                                                  attributeSelector.Children[0].Text));                                  }                                  selectorRuleTagValueComparison.Tag = attributeSelector.Children[1].Text;                                  selectorRuleTagValueComparison.Value = attributeSelector.Children[2].Text;                                    // add the tags.                                  if (selector.SelectorRule == null)                                  {                                      selector.SelectorRule = selectorRuleTagValueComparison;                                  }                                  else                                  {                                      selector.SelectorRule = selector.SelectorRule & selectorRuleTagValueComparison;                                  }                              }                              else                              {                                  // oeps' this is not possible.                                  throw new MapCSSDomainParserException(attributeSelector'                                                                        "Attibute selector not found!");                              }                          }                      }                  }                    // move to the next selector.                  simpleSelectorIdx++;              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseURL,The following statement contains a magic number: if (!string.IsNullOrEmpty(url))              {                  if (url[0] == '"' && url[url.Length - 1] == '"')                  {                      urlBuilder.Append(                          url.Substring(1' url.Length - 2));                  }                  else                  {                      urlBuilder.Append(url);                  }              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSDomainParser,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSDomainParser.cs,ParseColor,The following statement contains a magic number: if (colorTree.Text == "VALUE_RGB")              { // a pre-defined RGB value.                  string rString = colorTree.GetChild(0).Text;                  string gString = colorTree.GetChild(1).Text;                  string bString = colorTree.GetChild(2).Text;                    int r = int.Parse(rString);                  int g = int.Parse(gString);                  int b = int.Parse(bString);                    return SimpleColor.FromArgb(r' g' b).Value;              }              else if (int.TryParse(colorTree.Text' NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out valueInt))              { // the color is defined as an integer? this cannot happen??                  return valueInt;              }  #if!WINDOWS_PHONE              else if (Enum.TryParse<KnownColor>(colorTree.Text' true' out namedColor))  #else              else if (EnumHelper.TryParse<KnownColor>(colorTree.Text' true' out namedColor))  #endif              { // the color was named.                  return SimpleColor.FromKnownColor(namedColor).Value;              }              else              { // value could not be parsed.                  throw new MapCSSDomainParserException(colorTree'                                                              string.Format("Color value cannot be parsed!"));              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSRuleProperties,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSRuleProperties.cs,MapCSSRuleProperties,The following statement contains a magic number: this.MaxZoom = 20;
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSRulePropertiesCollection,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSRulePropertiesCollection.cs,GetRanges,The following statement contains a magic number: int minZoom = 0' maxZoom = 20;
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSRulePropertiesCollection,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSRulePropertiesCollection.cs,GetRanges,The following statement contains a magic number: for (int zoomLevel = 0; zoomLevel < 20; zoomLevel++)              {                  // get the current rule string.                  string currentRuleString = this.GetRuleStringForZoom(zoomLevel);                    if (previousRuleString != currentRuleString)                  { // there is a new rule.                      // store the previous rule.                      if (currentRule != null)                      { // the current rule exists; store it.                          currentRule.MinZoom = minZoom;                          currentRule.MaxZoom = maxZoom + 1;                            rules.Add(currentRule);                          currentRule = null;                      }                        if (!string.IsNullOrWhiteSpace(currentRuleString))                      { // only do this part when string is not empty.                          minZoom = zoomLevel; // set the min zoom.                          MapCSSRuleProperties props = this.GetRulesForZoom(zoomLevel);                          if (props != null)                          {                              currentRule = new MapCSSRuleProperties(minZoom' 20);                              currentRule = currentRule.Merge(props);                          }                      }                      previousRuleString = currentRuleString;                  }                  maxZoom = zoomLevel; // set the max zoom.              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSRulePropertiesCollection,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSRulePropertiesCollection.cs,GetRanges,The following statement contains a magic number: for (int zoomLevel = 0; zoomLevel < 20; zoomLevel++)              {                  // get the current rule string.                  string currentRuleString = this.GetRuleStringForZoom(zoomLevel);                    if (previousRuleString != currentRuleString)                  { // there is a new rule.                      // store the previous rule.                      if (currentRule != null)                      { // the current rule exists; store it.                          currentRule.MinZoom = minZoom;                          currentRule.MaxZoom = maxZoom + 1;                            rules.Add(currentRule);                          currentRule = null;                      }                        if (!string.IsNullOrWhiteSpace(currentRuleString))                      { // only do this part when string is not empty.                          minZoom = zoomLevel; // set the min zoom.                          MapCSSRuleProperties props = this.GetRulesForZoom(zoomLevel);                          if (props != null)                          {                              currentRule = new MapCSSRuleProperties(minZoom' 20);                              currentRule = currentRule.Merge(props);                          }                      }                      previousRuleString = currentRuleString;                  }                  maxZoom = zoomLevel; // set the max zoom.              }
Magic Number,OsmSharp.UI.Map.Styles.MapCSS.v0_2,MapCSSTypesExtensions,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\MapCSSTypes.cs,IsOfType,The following statement contains a magic number: switch (types)              {                  case MapCSSTypes.Node:                      return osmGeo.Type == CompleteOsmType.Node;                  case MapCSSTypes.Way:                      return osmGeo.Type == CompleteOsmType.Way;                  case MapCSSTypes.Relation:                      return osmGeo.Type == CompleteOsmType.Relation;                  case MapCSSTypes.Line:                      if (osmGeo.Type == CompleteOsmType.Way)                      { // the type is way way. now check for a line.                          var way = (osmGeo as CompleteWay);                          if (way != null &&                              way.Nodes[0] == way.Nodes[way.Nodes.Count - 1])                          { // first node is the same as the last one.                              if (way.Tags != null &&                                  way.Tags.TryGetValue("area"' out area) &&                                  area == "yes")                              { // oeps' an area.                                  return false;                              }                              return true;                          }                          else                          { // first node is different from the last one.                              return true; // even if there is an area=yes tag this cannot be an area.                          }                      }  					break;                  case MapCSSTypes.Area:                      if (osmGeo.Type == CompleteOsmType.Way)                      { // the type is way way. now check for a line.                          var way = (osmGeo as CompleteWay);                          if (way != null &&                              way.Nodes != null &&                              (way.Nodes.Count > 2 && (way.Nodes[0] == way.Nodes[way.Nodes.Count - 1])))                          { // first node is the same as the last one.                              return true;                          }                      }                      return false;                  default:                      throw new ArgumentOutOfRangeException("types");              }
Magic Number,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,RenderPrimitives,The following statement contains a magic number: try {                  // calculate current simplification epsilon.                  double epsilon = Scene2D.CalculateSimplificationEpsilon(new WebMercator()' zoomFactor);    	            // loop over all primitives in the scene.                  int simplifiedLines = 0;                  int droppedLines = 0;                  foreach (Primitive2D primitive in primitives)  	            { // the primitive is visible.  					if (_cancelFlag) {  						return false; // stop rendering on cancel and return false for an incomplete rendering.  					}                        if(primitive == null)                      {                          continue;                      }                      double[] x' y;                      switch (primitive.Primitive2DType)                      {                          case Primitive2DType.Line2D:                              Line2D line = (Line2D)primitive;                                x = line.X;                              y = line.Y;                              if (x.Length > 4 && line.MaxZoom > zoomFactor * 2 && line.MaxZoom < 512)                              { // try and simplify.                                  double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                                      epsilon);                                  if (simplified[0].Length < line.X.Length)                                  {                                      simplifiedLines++;                                      x = simplified[0];                                      y = simplified[1];                                  }                                  double distance = epsilon * 2;                                  if (simplified[0].Length == 2)                                  { // check if the simplified version is smaller than epsilon.                                      distance = System.Math.Sqrt(                                          System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                                          System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                                  }                                  if (distance < epsilon)                                  {                                      droppedLines++;                                      continue;                                  }                              }                              this.DrawLine(target' x' y' line.Color'                                  this.FromPixels(target' view' line.Width)' line.LineJoin' line.Dashes);                              break;                          case Primitive2DType.Polygon2D:                              Polygon2D polygon = (Polygon2D)primitive;                                x = polygon.X;                              y = polygon.Y;                              //if (x.Length > 4 && polygon.MaxZoom > zoomFactor * 2 && polygon.MaxZoom < 512)                              //{ // try and simplify.                              //    double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                              //        epsilon);                              //    if (simplified[0].Length < polygon.X.Length)                              //    {                              //        simplifiedLines++;                              //        x = simplified[0];                              //        y = simplified[1];                              //    }                              //    double distance = epsilon * 2;                              //    if (simplified[0].Length == 2)                              //    { // check if the simplified version is smaller than epsilon.                              //        distance = System.Math.Sqrt(                              //            System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                              //            System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                              //    }                              //    //if (distance < epsilon)                              //    //{                              //    //    droppedLines++;                              //    //    continue;                              //    //}                              //}                              this.DrawPolygon(target' x' y' polygon.Color'                                  this.FromPixels(target' view' polygon.Width)' polygon.Fill);                              break;                          case Primitive2DType.LineText2D:                              LineText2D lineText = (LineText2D)primitive;                              this.DrawLineText(target' lineText.X' lineText.Y' lineText.Text' lineText.Color'                                  this.FromPixels(target' view' lineText.Size)' lineText.HaloColor' lineText.HaloRadius' lineText.Font);                              break;                          case Primitive2DType.Point2D:                              Point2D point = (Point2D)primitive;                              this.DrawPoint(target' point.X' point.Y' point.Color'                                  this.FromPixels(target' view' point.Size));                              break;                          case Primitive2DType.Icon2D:                              Icon2D icon = (Icon2D)primitive;                              this.DrawIcon(target' icon.X' icon.Y' icon.Image);                              break;                          case Primitive2DType.ImageTilted2D:                              ImageTilted2D imageTilted = (ImageTilted2D)primitive;                              this.DrawImage(target' imageTilted.Bounds' imageTilted.NativeImage);                              break;                          case Primitive2DType.Image2D:                              Image2D image = (Image2D)primitive;                              this.DrawImage(target' image.Left' image.Top' image.Right' image.Bottom' image.NativeImage);                              break;                          case Primitive2DType.Text2D:                              Text2D text = (Text2D)primitive;                              this.DrawText(target' text.X' text.Y' text.Text' text.Color'                                  this.FromPixels(target' view' text.Size)' text.HaloColor' text.HaloRadius' text.Font);                              break;                      }                  }  				return true;  			}  			catch(Exception ex) {  				OsmSharp.Logging.Log.TraceEvent ("Renderer2D"' OsmSharp.Logging.TraceEventType.Error'   				                                 ex.Message);  				throw ex;  			}
Magic Number,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,RenderPrimitives,The following statement contains a magic number: try {                  // calculate current simplification epsilon.                  double epsilon = Scene2D.CalculateSimplificationEpsilon(new WebMercator()' zoomFactor);    	            // loop over all primitives in the scene.                  int simplifiedLines = 0;                  int droppedLines = 0;                  foreach (Primitive2D primitive in primitives)  	            { // the primitive is visible.  					if (_cancelFlag) {  						return false; // stop rendering on cancel and return false for an incomplete rendering.  					}                        if(primitive == null)                      {                          continue;                      }                      double[] x' y;                      switch (primitive.Primitive2DType)                      {                          case Primitive2DType.Line2D:                              Line2D line = (Line2D)primitive;                                x = line.X;                              y = line.Y;                              if (x.Length > 4 && line.MaxZoom > zoomFactor * 2 && line.MaxZoom < 512)                              { // try and simplify.                                  double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                                      epsilon);                                  if (simplified[0].Length < line.X.Length)                                  {                                      simplifiedLines++;                                      x = simplified[0];                                      y = simplified[1];                                  }                                  double distance = epsilon * 2;                                  if (simplified[0].Length == 2)                                  { // check if the simplified version is smaller than epsilon.                                      distance = System.Math.Sqrt(                                          System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                                          System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                                  }                                  if (distance < epsilon)                                  {                                      droppedLines++;                                      continue;                                  }                              }                              this.DrawLine(target' x' y' line.Color'                                  this.FromPixels(target' view' line.Width)' line.LineJoin' line.Dashes);                              break;                          case Primitive2DType.Polygon2D:                              Polygon2D polygon = (Polygon2D)primitive;                                x = polygon.X;                              y = polygon.Y;                              //if (x.Length > 4 && polygon.MaxZoom > zoomFactor * 2 && polygon.MaxZoom < 512)                              //{ // try and simplify.                              //    double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                              //        epsilon);                              //    if (simplified[0].Length < polygon.X.Length)                              //    {                              //        simplifiedLines++;                              //        x = simplified[0];                              //        y = simplified[1];                              //    }                              //    double distance = epsilon * 2;                              //    if (simplified[0].Length == 2)                              //    { // check if the simplified version is smaller than epsilon.                              //        distance = System.Math.Sqrt(                              //            System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                              //            System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                              //    }                              //    //if (distance < epsilon)                              //    //{                              //    //    droppedLines++;                              //    //    continue;                              //    //}                              //}                              this.DrawPolygon(target' x' y' polygon.Color'                                  this.FromPixels(target' view' polygon.Width)' polygon.Fill);                              break;                          case Primitive2DType.LineText2D:                              LineText2D lineText = (LineText2D)primitive;                              this.DrawLineText(target' lineText.X' lineText.Y' lineText.Text' lineText.Color'                                  this.FromPixels(target' view' lineText.Size)' lineText.HaloColor' lineText.HaloRadius' lineText.Font);                              break;                          case Primitive2DType.Point2D:                              Point2D point = (Point2D)primitive;                              this.DrawPoint(target' point.X' point.Y' point.Color'                                  this.FromPixels(target' view' point.Size));                              break;                          case Primitive2DType.Icon2D:                              Icon2D icon = (Icon2D)primitive;                              this.DrawIcon(target' icon.X' icon.Y' icon.Image);                              break;                          case Primitive2DType.ImageTilted2D:                              ImageTilted2D imageTilted = (ImageTilted2D)primitive;                              this.DrawImage(target' imageTilted.Bounds' imageTilted.NativeImage);                              break;                          case Primitive2DType.Image2D:                              Image2D image = (Image2D)primitive;                              this.DrawImage(target' image.Left' image.Top' image.Right' image.Bottom' image.NativeImage);                              break;                          case Primitive2DType.Text2D:                              Text2D text = (Text2D)primitive;                              this.DrawText(target' text.X' text.Y' text.Text' text.Color'                                  this.FromPixels(target' view' text.Size)' text.HaloColor' text.HaloRadius' text.Font);                              break;                      }                  }  				return true;  			}  			catch(Exception ex) {  				OsmSharp.Logging.Log.TraceEvent ("Renderer2D"' OsmSharp.Logging.TraceEventType.Error'   				                                 ex.Message);  				throw ex;  			}
Magic Number,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,RenderPrimitives,The following statement contains a magic number: try {                  // calculate current simplification epsilon.                  double epsilon = Scene2D.CalculateSimplificationEpsilon(new WebMercator()' zoomFactor);    	            // loop over all primitives in the scene.                  int simplifiedLines = 0;                  int droppedLines = 0;                  foreach (Primitive2D primitive in primitives)  	            { // the primitive is visible.  					if (_cancelFlag) {  						return false; // stop rendering on cancel and return false for an incomplete rendering.  					}                        if(primitive == null)                      {                          continue;                      }                      double[] x' y;                      switch (primitive.Primitive2DType)                      {                          case Primitive2DType.Line2D:                              Line2D line = (Line2D)primitive;                                x = line.X;                              y = line.Y;                              if (x.Length > 4 && line.MaxZoom > zoomFactor * 2 && line.MaxZoom < 512)                              { // try and simplify.                                  double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                                      epsilon);                                  if (simplified[0].Length < line.X.Length)                                  {                                      simplifiedLines++;                                      x = simplified[0];                                      y = simplified[1];                                  }                                  double distance = epsilon * 2;                                  if (simplified[0].Length == 2)                                  { // check if the simplified version is smaller than epsilon.                                      distance = System.Math.Sqrt(                                          System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                                          System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                                  }                                  if (distance < epsilon)                                  {                                      droppedLines++;                                      continue;                                  }                              }                              this.DrawLine(target' x' y' line.Color'                                  this.FromPixels(target' view' line.Width)' line.LineJoin' line.Dashes);                              break;                          case Primitive2DType.Polygon2D:                              Polygon2D polygon = (Polygon2D)primitive;                                x = polygon.X;                              y = polygon.Y;                              //if (x.Length > 4 && polygon.MaxZoom > zoomFactor * 2 && polygon.MaxZoom < 512)                              //{ // try and simplify.                              //    double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                              //        epsilon);                              //    if (simplified[0].Length < polygon.X.Length)                              //    {                              //        simplifiedLines++;                              //        x = simplified[0];                              //        y = simplified[1];                              //    }                              //    double distance = epsilon * 2;                              //    if (simplified[0].Length == 2)                              //    { // check if the simplified version is smaller than epsilon.                              //        distance = System.Math.Sqrt(                              //            System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                              //            System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                              //    }                              //    //if (distance < epsilon)                              //    //{                              //    //    droppedLines++;                              //    //    continue;                              //    //}                              //}                              this.DrawPolygon(target' x' y' polygon.Color'                                  this.FromPixels(target' view' polygon.Width)' polygon.Fill);                              break;                          case Primitive2DType.LineText2D:                              LineText2D lineText = (LineText2D)primitive;                              this.DrawLineText(target' lineText.X' lineText.Y' lineText.Text' lineText.Color'                                  this.FromPixels(target' view' lineText.Size)' lineText.HaloColor' lineText.HaloRadius' lineText.Font);                              break;                          case Primitive2DType.Point2D:                              Point2D point = (Point2D)primitive;                              this.DrawPoint(target' point.X' point.Y' point.Color'                                  this.FromPixels(target' view' point.Size));                              break;                          case Primitive2DType.Icon2D:                              Icon2D icon = (Icon2D)primitive;                              this.DrawIcon(target' icon.X' icon.Y' icon.Image);                              break;                          case Primitive2DType.ImageTilted2D:                              ImageTilted2D imageTilted = (ImageTilted2D)primitive;                              this.DrawImage(target' imageTilted.Bounds' imageTilted.NativeImage);                              break;                          case Primitive2DType.Image2D:                              Image2D image = (Image2D)primitive;                              this.DrawImage(target' image.Left' image.Top' image.Right' image.Bottom' image.NativeImage);                              break;                          case Primitive2DType.Text2D:                              Text2D text = (Text2D)primitive;                              this.DrawText(target' text.X' text.Y' text.Text' text.Color'                                  this.FromPixels(target' view' text.Size)' text.HaloColor' text.HaloRadius' text.Font);                              break;                      }                  }  				return true;  			}  			catch(Exception ex) {  				OsmSharp.Logging.Log.TraceEvent ("Renderer2D"' OsmSharp.Logging.TraceEventType.Error'   				                                 ex.Message);  				throw ex;  			}
Magic Number,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,RenderPrimitives,The following statement contains a magic number: try {                  // calculate current simplification epsilon.                  double epsilon = Scene2D.CalculateSimplificationEpsilon(new WebMercator()' zoomFactor);    	            // loop over all primitives in the scene.                  int simplifiedLines = 0;                  int droppedLines = 0;                  foreach (Primitive2D primitive in primitives)  	            { // the primitive is visible.  					if (_cancelFlag) {  						return false; // stop rendering on cancel and return false for an incomplete rendering.  					}                        if(primitive == null)                      {                          continue;                      }                      double[] x' y;                      switch (primitive.Primitive2DType)                      {                          case Primitive2DType.Line2D:                              Line2D line = (Line2D)primitive;                                x = line.X;                              y = line.Y;                              if (x.Length > 4 && line.MaxZoom > zoomFactor * 2 && line.MaxZoom < 512)                              { // try and simplify.                                  double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                                      epsilon);                                  if (simplified[0].Length < line.X.Length)                                  {                                      simplifiedLines++;                                      x = simplified[0];                                      y = simplified[1];                                  }                                  double distance = epsilon * 2;                                  if (simplified[0].Length == 2)                                  { // check if the simplified version is smaller than epsilon.                                      distance = System.Math.Sqrt(                                          System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                                          System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                                  }                                  if (distance < epsilon)                                  {                                      droppedLines++;                                      continue;                                  }                              }                              this.DrawLine(target' x' y' line.Color'                                  this.FromPixels(target' view' line.Width)' line.LineJoin' line.Dashes);                              break;                          case Primitive2DType.Polygon2D:                              Polygon2D polygon = (Polygon2D)primitive;                                x = polygon.X;                              y = polygon.Y;                              //if (x.Length > 4 && polygon.MaxZoom > zoomFactor * 2 && polygon.MaxZoom < 512)                              //{ // try and simplify.                              //    double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                              //        epsilon);                              //    if (simplified[0].Length < polygon.X.Length)                              //    {                              //        simplifiedLines++;                              //        x = simplified[0];                              //        y = simplified[1];                              //    }                              //    double distance = epsilon * 2;                              //    if (simplified[0].Length == 2)                              //    { // check if the simplified version is smaller than epsilon.                              //        distance = System.Math.Sqrt(                              //            System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                              //            System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                              //    }                              //    //if (distance < epsilon)                              //    //{                              //    //    droppedLines++;                              //    //    continue;                              //    //}                              //}                              this.DrawPolygon(target' x' y' polygon.Color'                                  this.FromPixels(target' view' polygon.Width)' polygon.Fill);                              break;                          case Primitive2DType.LineText2D:                              LineText2D lineText = (LineText2D)primitive;                              this.DrawLineText(target' lineText.X' lineText.Y' lineText.Text' lineText.Color'                                  this.FromPixels(target' view' lineText.Size)' lineText.HaloColor' lineText.HaloRadius' lineText.Font);                              break;                          case Primitive2DType.Point2D:                              Point2D point = (Point2D)primitive;                              this.DrawPoint(target' point.X' point.Y' point.Color'                                  this.FromPixels(target' view' point.Size));                              break;                          case Primitive2DType.Icon2D:                              Icon2D icon = (Icon2D)primitive;                              this.DrawIcon(target' icon.X' icon.Y' icon.Image);                              break;                          case Primitive2DType.ImageTilted2D:                              ImageTilted2D imageTilted = (ImageTilted2D)primitive;                              this.DrawImage(target' imageTilted.Bounds' imageTilted.NativeImage);                              break;                          case Primitive2DType.Image2D:                              Image2D image = (Image2D)primitive;                              this.DrawImage(target' image.Left' image.Top' image.Right' image.Bottom' image.NativeImage);                              break;                          case Primitive2DType.Text2D:                              Text2D text = (Text2D)primitive;                              this.DrawText(target' text.X' text.Y' text.Text' text.Color'                                  this.FromPixels(target' view' text.Size)' text.HaloColor' text.HaloRadius' text.Font);                              break;                      }                  }  				return true;  			}  			catch(Exception ex) {  				OsmSharp.Logging.Log.TraceEvent ("Renderer2D"' OsmSharp.Logging.TraceEventType.Error'   				                                 ex.Message);  				throw ex;  			}
Magic Number,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,RenderPrimitives,The following statement contains a magic number: try {                  // calculate current simplification epsilon.                  double epsilon = Scene2D.CalculateSimplificationEpsilon(new WebMercator()' zoomFactor);    	            // loop over all primitives in the scene.                  int simplifiedLines = 0;                  int droppedLines = 0;                  foreach (Primitive2D primitive in primitives)  	            { // the primitive is visible.  					if (_cancelFlag) {  						return false; // stop rendering on cancel and return false for an incomplete rendering.  					}                        if(primitive == null)                      {                          continue;                      }                      double[] x' y;                      switch (primitive.Primitive2DType)                      {                          case Primitive2DType.Line2D:                              Line2D line = (Line2D)primitive;                                x = line.X;                              y = line.Y;                              if (x.Length > 4 && line.MaxZoom > zoomFactor * 2 && line.MaxZoom < 512)                              { // try and simplify.                                  double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                                      epsilon);                                  if (simplified[0].Length < line.X.Length)                                  {                                      simplifiedLines++;                                      x = simplified[0];                                      y = simplified[1];                                  }                                  double distance = epsilon * 2;                                  if (simplified[0].Length == 2)                                  { // check if the simplified version is smaller than epsilon.                                      distance = System.Math.Sqrt(                                          System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                                          System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                                  }                                  if (distance < epsilon)                                  {                                      droppedLines++;                                      continue;                                  }                              }                              this.DrawLine(target' x' y' line.Color'                                  this.FromPixels(target' view' line.Width)' line.LineJoin' line.Dashes);                              break;                          case Primitive2DType.Polygon2D:                              Polygon2D polygon = (Polygon2D)primitive;                                x = polygon.X;                              y = polygon.Y;                              //if (x.Length > 4 && polygon.MaxZoom > zoomFactor * 2 && polygon.MaxZoom < 512)                              //{ // try and simplify.                              //    double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                              //        epsilon);                              //    if (simplified[0].Length < polygon.X.Length)                              //    {                              //        simplifiedLines++;                              //        x = simplified[0];                              //        y = simplified[1];                              //    }                              //    double distance = epsilon * 2;                              //    if (simplified[0].Length == 2)                              //    { // check if the simplified version is smaller than epsilon.                              //        distance = System.Math.Sqrt(                              //            System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                              //            System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                              //    }                              //    //if (distance < epsilon)                              //    //{                              //    //    droppedLines++;                              //    //    continue;                              //    //}                              //}                              this.DrawPolygon(target' x' y' polygon.Color'                                  this.FromPixels(target' view' polygon.Width)' polygon.Fill);                              break;                          case Primitive2DType.LineText2D:                              LineText2D lineText = (LineText2D)primitive;                              this.DrawLineText(target' lineText.X' lineText.Y' lineText.Text' lineText.Color'                                  this.FromPixels(target' view' lineText.Size)' lineText.HaloColor' lineText.HaloRadius' lineText.Font);                              break;                          case Primitive2DType.Point2D:                              Point2D point = (Point2D)primitive;                              this.DrawPoint(target' point.X' point.Y' point.Color'                                  this.FromPixels(target' view' point.Size));                              break;                          case Primitive2DType.Icon2D:                              Icon2D icon = (Icon2D)primitive;                              this.DrawIcon(target' icon.X' icon.Y' icon.Image);                              break;                          case Primitive2DType.ImageTilted2D:                              ImageTilted2D imageTilted = (ImageTilted2D)primitive;                              this.DrawImage(target' imageTilted.Bounds' imageTilted.NativeImage);                              break;                          case Primitive2DType.Image2D:                              Image2D image = (Image2D)primitive;                              this.DrawImage(target' image.Left' image.Top' image.Right' image.Bottom' image.NativeImage);                              break;                          case Primitive2DType.Text2D:                              Text2D text = (Text2D)primitive;                              this.DrawText(target' text.X' text.Y' text.Text' text.Color'                                  this.FromPixels(target' view' text.Size)' text.HaloColor' text.HaloRadius' text.Font);                              break;                      }                  }  				return true;  			}  			catch(Exception ex) {  				OsmSharp.Logging.Log.TraceEvent ("Renderer2D"' OsmSharp.Logging.TraceEventType.Error'   				                                 ex.Message);  				throw ex;  			}
Magic Number,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,RenderPrimitives,The following statement contains a magic number: try {                  // calculate current simplification epsilon.                  double epsilon = Scene2D.CalculateSimplificationEpsilon(new WebMercator()' zoomFactor);    	            // loop over all primitives in the scene.                  int simplifiedLines = 0;                  int droppedLines = 0;                  foreach (Primitive2D primitive in primitives)  	            { // the primitive is visible.  					if (_cancelFlag) {  						return false; // stop rendering on cancel and return false for an incomplete rendering.  					}                        if(primitive == null)                      {                          continue;                      }                      double[] x' y;                      switch (primitive.Primitive2DType)                      {                          case Primitive2DType.Line2D:                              Line2D line = (Line2D)primitive;                                x = line.X;                              y = line.Y;                              if (x.Length > 4 && line.MaxZoom > zoomFactor * 2 && line.MaxZoom < 512)                              { // try and simplify.                                  double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                                      epsilon);                                  if (simplified[0].Length < line.X.Length)                                  {                                      simplifiedLines++;                                      x = simplified[0];                                      y = simplified[1];                                  }                                  double distance = epsilon * 2;                                  if (simplified[0].Length == 2)                                  { // check if the simplified version is smaller than epsilon.                                      distance = System.Math.Sqrt(                                          System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                                          System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                                  }                                  if (distance < epsilon)                                  {                                      droppedLines++;                                      continue;                                  }                              }                              this.DrawLine(target' x' y' line.Color'                                  this.FromPixels(target' view' line.Width)' line.LineJoin' line.Dashes);                              break;                          case Primitive2DType.Polygon2D:                              Polygon2D polygon = (Polygon2D)primitive;                                x = polygon.X;                              y = polygon.Y;                              //if (x.Length > 4 && polygon.MaxZoom > zoomFactor * 2 && polygon.MaxZoom < 512)                              //{ // try and simplify.                              //    double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                              //        epsilon);                              //    if (simplified[0].Length < polygon.X.Length)                              //    {                              //        simplifiedLines++;                              //        x = simplified[0];                              //        y = simplified[1];                              //    }                              //    double distance = epsilon * 2;                              //    if (simplified[0].Length == 2)                              //    { // check if the simplified version is smaller than epsilon.                              //        distance = System.Math.Sqrt(                              //            System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                              //            System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                              //    }                              //    //if (distance < epsilon)                              //    //{                              //    //    droppedLines++;                              //    //    continue;                              //    //}                              //}                              this.DrawPolygon(target' x' y' polygon.Color'                                  this.FromPixels(target' view' polygon.Width)' polygon.Fill);                              break;                          case Primitive2DType.LineText2D:                              LineText2D lineText = (LineText2D)primitive;                              this.DrawLineText(target' lineText.X' lineText.Y' lineText.Text' lineText.Color'                                  this.FromPixels(target' view' lineText.Size)' lineText.HaloColor' lineText.HaloRadius' lineText.Font);                              break;                          case Primitive2DType.Point2D:                              Point2D point = (Point2D)primitive;                              this.DrawPoint(target' point.X' point.Y' point.Color'                                  this.FromPixels(target' view' point.Size));                              break;                          case Primitive2DType.Icon2D:                              Icon2D icon = (Icon2D)primitive;                              this.DrawIcon(target' icon.X' icon.Y' icon.Image);                              break;                          case Primitive2DType.ImageTilted2D:                              ImageTilted2D imageTilted = (ImageTilted2D)primitive;                              this.DrawImage(target' imageTilted.Bounds' imageTilted.NativeImage);                              break;                          case Primitive2DType.Image2D:                              Image2D image = (Image2D)primitive;                              this.DrawImage(target' image.Left' image.Top' image.Right' image.Bottom' image.NativeImage);                              break;                          case Primitive2DType.Text2D:                              Text2D text = (Text2D)primitive;                              this.DrawText(target' text.X' text.Y' text.Text' text.Color'                                  this.FromPixels(target' view' text.Size)' text.HaloColor' text.HaloRadius' text.Font);                              break;                      }                  }  				return true;  			}  			catch(Exception ex) {  				OsmSharp.Logging.Log.TraceEvent ("Renderer2D"' OsmSharp.Logging.TraceEventType.Error'   				                                 ex.Message);  				throw ex;  			}
Magic Number,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,RenderPrimitives,The following statement contains a magic number: try {                  // calculate current simplification epsilon.                  double epsilon = Scene2D.CalculateSimplificationEpsilon(new WebMercator()' zoomFactor);    	            // loop over all primitives in the scene.                  int simplifiedLines = 0;                  int droppedLines = 0;                  foreach (Primitive2D primitive in primitives)  	            { // the primitive is visible.  					if (_cancelFlag) {  						return false; // stop rendering on cancel and return false for an incomplete rendering.  					}                        if(primitive == null)                      {                          continue;                      }                      double[] x' y;                      switch (primitive.Primitive2DType)                      {                          case Primitive2DType.Line2D:                              Line2D line = (Line2D)primitive;                                x = line.X;                              y = line.Y;                              if (x.Length > 4 && line.MaxZoom > zoomFactor * 2 && line.MaxZoom < 512)                              { // try and simplify.                                  double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                                      epsilon);                                  if (simplified[0].Length < line.X.Length)                                  {                                      simplifiedLines++;                                      x = simplified[0];                                      y = simplified[1];                                  }                                  double distance = epsilon * 2;                                  if (simplified[0].Length == 2)                                  { // check if the simplified version is smaller than epsilon.                                      distance = System.Math.Sqrt(                                          System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                                          System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                                  }                                  if (distance < epsilon)                                  {                                      droppedLines++;                                      continue;                                  }                              }                              this.DrawLine(target' x' y' line.Color'                                  this.FromPixels(target' view' line.Width)' line.LineJoin' line.Dashes);                              break;                          case Primitive2DType.Polygon2D:                              Polygon2D polygon = (Polygon2D)primitive;                                x = polygon.X;                              y = polygon.Y;                              //if (x.Length > 4 && polygon.MaxZoom > zoomFactor * 2 && polygon.MaxZoom < 512)                              //{ // try and simplify.                              //    double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                              //        epsilon);                              //    if (simplified[0].Length < polygon.X.Length)                              //    {                              //        simplifiedLines++;                              //        x = simplified[0];                              //        y = simplified[1];                              //    }                              //    double distance = epsilon * 2;                              //    if (simplified[0].Length == 2)                              //    { // check if the simplified version is smaller than epsilon.                              //        distance = System.Math.Sqrt(                              //            System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                              //            System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                              //    }                              //    //if (distance < epsilon)                              //    //{                              //    //    droppedLines++;                              //    //    continue;                              //    //}                              //}                              this.DrawPolygon(target' x' y' polygon.Color'                                  this.FromPixels(target' view' polygon.Width)' polygon.Fill);                              break;                          case Primitive2DType.LineText2D:                              LineText2D lineText = (LineText2D)primitive;                              this.DrawLineText(target' lineText.X' lineText.Y' lineText.Text' lineText.Color'                                  this.FromPixels(target' view' lineText.Size)' lineText.HaloColor' lineText.HaloRadius' lineText.Font);                              break;                          case Primitive2DType.Point2D:                              Point2D point = (Point2D)primitive;                              this.DrawPoint(target' point.X' point.Y' point.Color'                                  this.FromPixels(target' view' point.Size));                              break;                          case Primitive2DType.Icon2D:                              Icon2D icon = (Icon2D)primitive;                              this.DrawIcon(target' icon.X' icon.Y' icon.Image);                              break;                          case Primitive2DType.ImageTilted2D:                              ImageTilted2D imageTilted = (ImageTilted2D)primitive;                              this.DrawImage(target' imageTilted.Bounds' imageTilted.NativeImage);                              break;                          case Primitive2DType.Image2D:                              Image2D image = (Image2D)primitive;                              this.DrawImage(target' image.Left' image.Top' image.Right' image.Bottom' image.NativeImage);                              break;                          case Primitive2DType.Text2D:                              Text2D text = (Text2D)primitive;                              this.DrawText(target' text.X' text.Y' text.Text' text.Color'                                  this.FromPixels(target' view' text.Size)' text.HaloColor' text.HaloRadius' text.Font);                              break;                      }                  }  				return true;  			}  			catch(Exception ex) {  				OsmSharp.Logging.Log.TraceEvent ("Renderer2D"' OsmSharp.Logging.TraceEventType.Error'   				                                 ex.Message);  				throw ex;  			}
Magic Number,OsmSharp.UI.Renderer,View2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\View2D.cs,CreateFromBounds,The following statement contains a magic number: double centerX = (left + right) / 2.0;
Magic Number,OsmSharp.UI.Renderer,View2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\View2D.cs,CreateFromBounds,The following statement contains a magic number: double centerY = (top + bottom) / 2.0;
Magic Number,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,IsEar,The following statement contains a magic number: return (this.Contains(                  new double[] {                       (this.X[previousIdx] + this.X[nextIdx]) / 2'                       (this.Y[previousIdx] + this.Y[nextIdx]) / 2 }));
Magic Number,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,IsEar,The following statement contains a magic number: return (this.Contains(                  new double[] {                       (this.X[previousIdx] + this.X[nextIdx]) / 2'                       (this.Y[previousIdx] + this.Y[nextIdx]) / 2 }));
Magic Number,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,IsEar,The following statement contains a magic number: return (Polygon2D.Contains(X' Y'                  new double[] {                       (X[previousIdx] + X[nextIdx]) / 2'                       (Y[previousIdx] + Y[nextIdx]) / 2 }));
Magic Number,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,IsEar,The following statement contains a magic number: return (Polygon2D.Contains(X' Y'                  new double[] {                       (X[previousIdx] + X[nextIdx]) / 2'                       (Y[previousIdx] + Y[nextIdx]) / 2 }));
Magic Number,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Tessellate,The following statement contains a magic number: if (X.Count < 3)              {                  return new double[0][];              }
Magic Number,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Tessellate,The following statement contains a magic number: while (X.Count > 3)              { // cut an ear.                  int earIdx = 0;                  while (!Polygon2D.IsEar(X' Y' earIdx))                  {                      earIdx++;                        if (X.Count <= earIdx)                      {                          OsmSharp.Logging.Log.TraceEvent(""' OsmSharp.Logging.TraceEventType.Information' "");                          return triangles.ToArray();                      }                  }                    // ear should be found' cut it!                  double[][] neighbours = Polygon2D.GetNeigbours(X' Y' earIdx);                  triangles.Add(neighbours[0]);                  triangles.Add(neighbours[1]);                  triangles.Add(new double[] { X[earIdx]' Y[earIdx] });                    // remove ear and update workring.                  X.RemoveAt(earIdx);                  Y.RemoveAt(earIdx);              }
Magic Number,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Tessellate,The following statement contains a magic number: if (X.Count == 3)              { // this ring is already a triangle.                  triangles.Add(new double[] { X[0]' Y[0] });                  triangles.Add(new double[] { X[1]' Y[1] });                  triangles.Add(new double[] { X[2]' Y[2] });              }
Magic Number,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Tessellate,The following statement contains a magic number: if (X.Count == 3)              { // this ring is already a triangle.                  triangles.Add(new double[] { X[0]' Y[0] });                  triangles.Add(new double[] { X[1]' Y[1] });                  triangles.Add(new double[] { X[2]' Y[2] });              }
Magic Number,OsmSharp.UI.Renderer.Primitives,Polygon2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Primitives\Polygon2D.cs,Tessellate,The following statement contains a magic number: if (X.Count == 3)              { // this ring is already a triangle.                  triangles.Add(new double[] { X[0]' Y[0] });                  triangles.Add(new double[] { X[1]' Y[1] });                  triangles.Add(new double[] { X[2]' Y[2] });              }
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,CalculateSimplificationEpsilon,The following statement contains a magic number: GeoCoordinate coordinate = new GeoCoordinate(51' 4);
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,CalculateSimplificationEpsilon,The following statement contains a magic number: GeoCoordinate coordinate = new GeoCoordinate(51' 4);
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,CalculateSimplificationEpsilon,The following statement contains a magic number: xDiff = xDiff / 256.0;
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,CalculateSimplificationEpsilon,The following statement contains a magic number: yDiff = yDiff / 256.0;
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddPoints,The following statement contains a magic number: double distance = epsilon * 2;
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddPoints,The following statement contains a magic number: if (simplified[0].Length == 2)              { // check if the simplified version is smaller than epsilon.                  OsmSharp.Math.Primitives.PointF2D point1 = new OsmSharp.Math.Primitives.PointF2D(                      simplified[0][0]' simplified[0][1]);                  OsmSharp.Math.Primitives.PointF2D point2 = new OsmSharp.Math.Primitives.PointF2D(                      simplified[1][0]' simplified[0][1]);                  distance = point1.Distance(point2);              }
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStyleLine,The following statement contains a magic number: for (int idx = 0; idx < _zoomFactors.Count; idx++)              {                  float minimumZoomFactor' maximumZoomFactor' simplificationZoomFactor;                  // check the current object's zoom range against the current min/max zoom factor.                  if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor))                  { // ok this object does existing inside the current range.                      // simplify the algorithm.                      double epsilon = this.CalculateSimplificationEpsilon(simplificationZoomFactor);                      double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(points' epsilon);                      double distance = epsilon * 2;                      if (simplified[0].Length == 2)                      { // check if the simplified version is smaller than epsilon.                          OsmSharp.Math.Primitives.PointF2D point1 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[0][0]' simplified[0][1]);                          OsmSharp.Math.Primitives.PointF2D point2 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[1][0]' simplified[1][1]);                          distance = point1.Distance(point2);                      }                      if (distance >= epsilon)                      { // the object needs to be added for the current zoom range.                          uint geometryId = pointsId;                          // check if there is a need to add a simplified geometry.                          if (simplified[0].Length < points[0].Length)                          { // add a new simplified geometry.                              geometryId = _pointsIndex.Add(new ScenePoints(simplified[0]' simplified[1]));                          }                            // add to the scene.                          // build the style.                          StyleLine style = new StyleLine()                          {                              Color = color'                              Dashes = dashes'                              LineJoin = lineJoin'                              Width = width'                              Layer = layer'                              MinZoom = minimumZoomFactor'                              MaxZoom = maximumZoomFactor                          };                          ushort styleId = (ushort)_lineStyles.Add(style);                            // add the scene object.                          uint id = _nextId;                          _sceneObjects[idx].Add(id'                               new SceneLineObject() { StyleId = styleId' GeoId = pointsId });                          _nextId++;                          newIds.Add(id);                      }                  }              }
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStyleLine,The following statement contains a magic number: for (int idx = 0; idx < _zoomFactors.Count; idx++)              {                  float minimumZoomFactor' maximumZoomFactor' simplificationZoomFactor;                  // check the current object's zoom range against the current min/max zoom factor.                  if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor))                  { // ok this object does existing inside the current range.                      // simplify the algorithm.                      double epsilon = this.CalculateSimplificationEpsilon(simplificationZoomFactor);                      double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(points' epsilon);                      double distance = epsilon * 2;                      if (simplified[0].Length == 2)                      { // check if the simplified version is smaller than epsilon.                          OsmSharp.Math.Primitives.PointF2D point1 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[0][0]' simplified[0][1]);                          OsmSharp.Math.Primitives.PointF2D point2 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[1][0]' simplified[1][1]);                          distance = point1.Distance(point2);                      }                      if (distance >= epsilon)                      { // the object needs to be added for the current zoom range.                          uint geometryId = pointsId;                          // check if there is a need to add a simplified geometry.                          if (simplified[0].Length < points[0].Length)                          { // add a new simplified geometry.                              geometryId = _pointsIndex.Add(new ScenePoints(simplified[0]' simplified[1]));                          }                            // add to the scene.                          // build the style.                          StyleLine style = new StyleLine()                          {                              Color = color'                              Dashes = dashes'                              LineJoin = lineJoin'                              Width = width'                              Layer = layer'                              MinZoom = minimumZoomFactor'                              MaxZoom = maximumZoomFactor                          };                          ushort styleId = (ushort)_lineStyles.Add(style);                            // add the scene object.                          uint id = _nextId;                          _sceneObjects[idx].Add(id'                               new SceneLineObject() { StyleId = styleId' GeoId = pointsId });                          _nextId++;                          newIds.Add(id);                      }                  }              }
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStyleLineText,The following statement contains a magic number: for (int idx = 0; idx < _zoomFactors.Count; idx++)              {                  float minimumZoomFactor' maximumZoomFactor' simplificationZoomFactor;                  // check the current object's zoom range against the current min/max zoom factor.                  if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor))                  { // ok this object does existing inside the current range.                        // simplify the algorithm.                      double epsilon = this.CalculateSimplificationEpsilon(simplificationZoomFactor);                      double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(points'                                                                      epsilon);                      double distance = epsilon * 2;                      if (simplified[0].Length == 2)                      { // check if the simplified version is smaller than epsilon.                          OsmSharp.Math.Primitives.PointF2D point1 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[0][0]' simplified[0][1]);                          OsmSharp.Math.Primitives.PointF2D point2 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[1][0]' simplified[0][1]);                          distance = point1.Distance(point2);                      }                      if (distance >= epsilon)                      { // the object needs to be added for the current zoom range.                          uint geometryId = pointsId;                          // check if there is a need to add a simplified geometry.                          if (simplified[0].Length < points[0].Length)                          { // add a new simplified geometry.                              geometryId = _pointsIndex.Add(new ScenePoints(simplified[0]' simplified[1]));                          }                            // add to the scene.                          // add to stringtable.                          uint textId = _stringTable.Add(text);                            // build the style.                          StyleText style = new StyleText()                          {                              Color = color'                              Size = size'                              Font = font'                              HaloColor = haloColor'                              HaloRadius = haloRadius'                              Layer = layer'                              MinZoom = minimumZoomFactor'                              MaxZoom = maximumZoomFactor                          };                          ushort styleId = (ushort)_textStyles.Add(style);                            // add the scene object.                          uint id = _nextId;                          _sceneObjects[idx].Add(id'                               new SceneLineTextObject() { StyleId = styleId' GeoId = pointsId' TextId = textId });                          _nextId++;                          newIds.Add(id);                      }                  }              }
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStyleLineText,The following statement contains a magic number: for (int idx = 0; idx < _zoomFactors.Count; idx++)              {                  float minimumZoomFactor' maximumZoomFactor' simplificationZoomFactor;                  // check the current object's zoom range against the current min/max zoom factor.                  if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor))                  { // ok this object does existing inside the current range.                        // simplify the algorithm.                      double epsilon = this.CalculateSimplificationEpsilon(simplificationZoomFactor);                      double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(points'                                                                      epsilon);                      double distance = epsilon * 2;                      if (simplified[0].Length == 2)                      { // check if the simplified version is smaller than epsilon.                          OsmSharp.Math.Primitives.PointF2D point1 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[0][0]' simplified[0][1]);                          OsmSharp.Math.Primitives.PointF2D point2 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[1][0]' simplified[0][1]);                          distance = point1.Distance(point2);                      }                      if (distance >= epsilon)                      { // the object needs to be added for the current zoom range.                          uint geometryId = pointsId;                          // check if there is a need to add a simplified geometry.                          if (simplified[0].Length < points[0].Length)                          { // add a new simplified geometry.                              geometryId = _pointsIndex.Add(new ScenePoints(simplified[0]' simplified[1]));                          }                            // add to the scene.                          // add to stringtable.                          uint textId = _stringTable.Add(text);                            // build the style.                          StyleText style = new StyleText()                          {                              Color = color'                              Size = size'                              Font = font'                              HaloColor = haloColor'                              HaloRadius = haloRadius'                              Layer = layer'                              MinZoom = minimumZoomFactor'                              MaxZoom = maximumZoomFactor                          };                          ushort styleId = (ushort)_textStyles.Add(style);                            // add the scene object.                          uint id = _nextId;                          _sceneObjects[idx].Add(id'                               new SceneLineTextObject() { StyleId = styleId' GeoId = pointsId' TextId = textId });                          _nextId++;                          newIds.Add(id);                      }                  }              }
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStylePolygon,The following statement contains a magic number: for (int idx = 0; idx < _zoomFactors.Count; idx++)              {                  float minimumZoomFactor' maximumZoomFactor' simplificationZoomFactor;                  // check the current object's zoom range against the current min/max zoom factor.                  if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor))                  { // ok this object does existing inside the current range.                        // simplify the algorithm.                      double epsilon = this.CalculateSimplificationEpsilon(simplificationZoomFactor);                      double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(points'                                                                      epsilon);                      double distance = epsilon * 2;                      if (simplified[0].Length == 2)                      { // check if the simplified version is smaller than epsilon.                          OsmSharp.Math.Primitives.PointF2D point1 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[0][0]' simplified[0][1]);                          OsmSharp.Math.Primitives.PointF2D point2 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[1][0]' simplified[0][1]);                          distance = point1.Distance(point2);                      }                      if (distance >= epsilon)                      { // the object needs to be added for the current zoom range.                          uint geometryId = pointsId;                          // check if there is a need to add a simplified geometry.                          if (simplified[0].Length < points[0].Length)                          { // add a new simplified geometry.                              geometryId = _pointsIndex.Add(new ScenePoints(simplified[0]' simplified[1]));                          }                            // add to the scene.                          // build the style.                          StylePolygon style = new StylePolygon()                          {                              Color = color'                              Fill = fill'                              Width = width'                              Layer = layer'                              MinZoom = minimumZoomFactor'                              MaxZoom = maximumZoomFactor                          };                          ushort styleId = (ushort)_polygonStyles.Add(style);                            // add the scene object.                          uint id = _nextId;                          _sceneObjects[idx].Add(id'                               new ScenePolygonObject() { StyleId = styleId' GeoId = pointsId });                          _nextId++;                          newIds.Add(id);                      }                  }              }
Magic Number,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,AddStylePolygon,The following statement contains a magic number: for (int idx = 0; idx < _zoomFactors.Count; idx++)              {                  float minimumZoomFactor' maximumZoomFactor' simplificationZoomFactor;                  // check the current object's zoom range against the current min/max zoom factor.                  if (this.CheckZoomRanges(idx' minZoom' maxZoom' out minimumZoomFactor' out maximumZoomFactor' out simplificationZoomFactor))                  { // ok this object does existing inside the current range.                        // simplify the algorithm.                      double epsilon = this.CalculateSimplificationEpsilon(simplificationZoomFactor);                      double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(points'                                                                      epsilon);                      double distance = epsilon * 2;                      if (simplified[0].Length == 2)                      { // check if the simplified version is smaller than epsilon.                          OsmSharp.Math.Primitives.PointF2D point1 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[0][0]' simplified[0][1]);                          OsmSharp.Math.Primitives.PointF2D point2 = new OsmSharp.Math.Primitives.PointF2D(                              simplified[1][0]' simplified[0][1]);                          distance = point1.Distance(point2);                      }                      if (distance >= epsilon)                      { // the object needs to be added for the current zoom range.                          uint geometryId = pointsId;                          // check if there is a need to add a simplified geometry.                          if (simplified[0].Length < points[0].Length)                          { // add a new simplified geometry.                              geometryId = _pointsIndex.Add(new ScenePoints(simplified[0]' simplified[1]));                          }                            // add to the scene.                          // build the style.                          StylePolygon style = new StylePolygon()                          {                              Color = color'                              Fill = fill'                              Width = width'                              Layer = layer'                              MinZoom = minimumZoomFactor'                              MaxZoom = maximumZoomFactor                          };                          ushort styleId = (ushort)_polygonStyles.Add(style);                            // add the scene object.                          uint id = _nextId;                          _sceneObjects[idx].Add(id'                               new ScenePolygonObject() { StyleId = styleId' GeoId = pointsId });                          _nextId++;                          newIds.Add(id);                      }                  }              }
Magic Number,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,The following statement contains a magic number: while (lines.Count > 0)              {                  var line = lines.First();                  lines.Remove(line.Key);                    // report progress.                  float progress = (float)System.Math.Round((((double)(totalLines - lines.Count) / (double)totalLines) * 100));                  if (progress != latestProgress)                  {                      OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                          "Merging lines @z{3}e{4} ({1}/{2})... {0}%"' progress' totalLines - lines.Count' totalLines' zoomFactor' epsilon);                      latestProgress = progress;                  }                    // copy the coordinates to lists.                  double[] x = line.Key.X.Clone() as double[];                  double[] y = line.Key.Y.Clone() as double[];                    // find a matching line.                  int mergeCount = 1;                  Scene2D.ScenePoints found;                  MatchPosition foundPosition = this.FindMatch(linesIndex' lines' x' y' line.Value' epsilon' out found);                  while (found != null)                  { // TODO: keep expanding and duplicating until not possible anymore.                      // remove the found line.                      lines.Remove(found);                        // report progress.                      progress = (float)System.Math.Round((((double)(totalLines - lines.Count) / (double)totalLines) * 100));                      if (progress != latestProgress)                      {                          OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                              "Merging lines @z{3}e{4} ({1}/{2})... {0}%"' progress' totalLines - lines.Count' totalLines' zoomFactor' epsilon);                          latestProgress = progress;                      }                        // add the line.                      int lengthBefore = x.Length;                      Array.Resize(ref x' x.Length + found.X.Length - 1);                      Array.Resize(ref y' y.Length + found.Y.Length - 1);                        switch (foundPosition)                      {                          case MatchPosition.FirstFirst:                              found.X.InsertToReverse(1' x' 0' found.X.Length - 1);                              found.Y.InsertToReverse(1' y' 0' found.Y.Length - 1);                              break;                          case MatchPosition.FirstLast:                              found.X.InsertTo(0' x' 0' found.X.Length - 1);                              found.Y.InsertTo(0' y' 0' found.Y.Length - 1);                              break;                          case MatchPosition.LastFirst:                              found.X.CopyTo(x' lengthBefore - 1);                              found.Y.CopyTo(y' lengthBefore - 1);                              break;                          case MatchPosition.LastLast:                              found.X.CopyToReverse(x' lengthBefore - 1);                              found.Y.CopyToReverse(y' lengthBefore - 1);                              break;                      }                        // select a new line.                      foundPosition = this.FindMatch(linesIndex' lines' x' y' line.Value' epsilon' out found);                      mergeCount++;                  }                    // simplify first.                  double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                                                              epsilon);                    // add the new points.                  uint? pointsId = target.AddPoints(simplified[0]' simplified[1]);                    // add points again with appropriate styles.                  if (pointsId.HasValue)                  {                      foreach (var style in line.Value)                      {                          var scene2DStyleLine = (style as Scene2DStyleLine);                          if (scene2DStyleLine != null)                          {                              StyleLine styleLine = source.GetStyleLine(scene2DStyleLine.StyleLineId);                              target.AddStyleLine(pointsId.Value' styleLine.Layer' styleLine.MinZoom' styleLine.MaxZoom'                                  styleLine.Color' styleLine.Width' styleLine.LineJoin' styleLine.Dashes);                              continue;                          }                          var scene2DStyleLineText = (style as Scene2DStyleLineText);                          if (scene2DStyleLineText != null)                          {                              StyleText styleText = source.GetStyleLineText(scene2DStyleLineText.StyleLineTextId);                              string text = source.GetText(scene2DStyleLineText.TextId);                              target.AddStyleLineText(pointsId.Value' styleText.Layer' styleText.MinZoom' styleText.MaxZoom'                                  styleText.Color' styleText.Size' text' styleText.Font' styleText.HaloColor' styleText.HaloRadius);                              continue;                          }                      }                  }              }
Magic Number,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,The following statement contains a magic number: while (lines.Count > 0)              {                  var line = lines.First();                  lines.Remove(line.Key);                    // report progress.                  float progress = (float)System.Math.Round((((double)(totalLines - lines.Count) / (double)totalLines) * 100));                  if (progress != latestProgress)                  {                      OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                          "Merging lines @z{3}e{4} ({1}/{2})... {0}%"' progress' totalLines - lines.Count' totalLines' zoomFactor' epsilon);                      latestProgress = progress;                  }                    // copy the coordinates to lists.                  double[] x = line.Key.X.Clone() as double[];                  double[] y = line.Key.Y.Clone() as double[];                    // find a matching line.                  int mergeCount = 1;                  Scene2D.ScenePoints found;                  MatchPosition foundPosition = this.FindMatch(linesIndex' lines' x' y' line.Value' epsilon' out found);                  while (found != null)                  { // TODO: keep expanding and duplicating until not possible anymore.                      // remove the found line.                      lines.Remove(found);                        // report progress.                      progress = (float)System.Math.Round((((double)(totalLines - lines.Count) / (double)totalLines) * 100));                      if (progress != latestProgress)                      {                          OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                              "Merging lines @z{3}e{4} ({1}/{2})... {0}%"' progress' totalLines - lines.Count' totalLines' zoomFactor' epsilon);                          latestProgress = progress;                      }                        // add the line.                      int lengthBefore = x.Length;                      Array.Resize(ref x' x.Length + found.X.Length - 1);                      Array.Resize(ref y' y.Length + found.Y.Length - 1);                        switch (foundPosition)                      {                          case MatchPosition.FirstFirst:                              found.X.InsertToReverse(1' x' 0' found.X.Length - 1);                              found.Y.InsertToReverse(1' y' 0' found.Y.Length - 1);                              break;                          case MatchPosition.FirstLast:                              found.X.InsertTo(0' x' 0' found.X.Length - 1);                              found.Y.InsertTo(0' y' 0' found.Y.Length - 1);                              break;                          case MatchPosition.LastFirst:                              found.X.CopyTo(x' lengthBefore - 1);                              found.Y.CopyTo(y' lengthBefore - 1);                              break;                          case MatchPosition.LastLast:                              found.X.CopyToReverse(x' lengthBefore - 1);                              found.Y.CopyToReverse(y' lengthBefore - 1);                              break;                      }                        // select a new line.                      foundPosition = this.FindMatch(linesIndex' lines' x' y' line.Value' epsilon' out found);                      mergeCount++;                  }                    // simplify first.                  double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                                                              epsilon);                    // add the new points.                  uint? pointsId = target.AddPoints(simplified[0]' simplified[1]);                    // add points again with appropriate styles.                  if (pointsId.HasValue)                  {                      foreach (var style in line.Value)                      {                          var scene2DStyleLine = (style as Scene2DStyleLine);                          if (scene2DStyleLine != null)                          {                              StyleLine styleLine = source.GetStyleLine(scene2DStyleLine.StyleLineId);                              target.AddStyleLine(pointsId.Value' styleLine.Layer' styleLine.MinZoom' styleLine.MaxZoom'                                  styleLine.Color' styleLine.Width' styleLine.LineJoin' styleLine.Dashes);                              continue;                          }                          var scene2DStyleLineText = (style as Scene2DStyleLineText);                          if (scene2DStyleLineText != null)                          {                              StyleText styleText = source.GetStyleLineText(scene2DStyleLineText.StyleLineTextId);                              string text = source.GetText(scene2DStyleLineText.TextId);                              target.AddStyleLineText(pointsId.Value' styleText.Layer' styleText.MinZoom' styleText.MaxZoom'                                  styleText.Color' styleText.Size' text' styleText.Font' styleText.HaloColor' styleText.HaloRadius);                              continue;                          }                      }                  }              }
Magic Number,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,The following statement contains a magic number: while (polygons.Count > 0)              {                  var polygon = polygons.First();                  polygons.Remove(polygon.Key);                    // report progress.                  float progress = (float)System.Math.Round((((double)(totalLines - polygons.Count) / (double)totalLines) * 100));                  if (progress != latestProgress)                  {                      OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                          "Merging polygons @z{3}e{4} ({1}/{2})... {0}%"' progress' totalLines - polygons.Count' totalLines' zoomFactor' epsilon);                      latestProgress = progress;                  }                    // copy the coordinates to lists.                  double[] x = polygon.Key.X.Clone() as double[];                  double[] y = polygon.Key.Y.Clone() as double[];                    //// find a matching line.                  //int mergeCount = 1;                  //Scene2D.ScenePoints found;                  //MatchPosition foundPosition = this.FindMatch(linesIndex' lines' x' y' line.Value' epsilon' out found);                  //while (found != null)                  //{ // TODO: keep expanding and duplicating until not possible anymore.                  //    // remove the found line.                  //    lines.Remove(found);                    //    // report progress.                  //    progress = (float)System.Math.Round((((double)(totalLines - lines.Count) / (double)totalLines) * 100));                  //    if (progress != latestProgress)                  //    {                  //        OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                  //            "Merging lines @z{3}e{4} ({1}/{2})... {0}%"' progress' totalLines - lines.Count' totalLines' zoomFactor' epsilon);                  //        latestProgress = progress;                  //    }                    //    // add the line.                  //    int lengthBefore = x.Length;                  //    Array.Resize(ref x' x.Length + found.X.Length - 1);                  //    Array.Resize(ref y' y.Length + found.Y.Length - 1);                    //    switch (foundPosition)                  //    {                  //        case MatchPosition.FirstFirst:                  //            found.X.InsertToReverse(1' x' 0' found.X.Length - 1);                  //            found.Y.InsertToReverse(1' y' 0' found.Y.Length - 1);                  //            break;                  //        case MatchPosition.FirstLast:                  //            found.X.InsertTo(0' x' 0' found.X.Length - 1);                  //            found.Y.InsertTo(0' y' 0' found.Y.Length - 1);                  //            break;                  //        case MatchPosition.LastFirst:                  //            found.X.CopyTo(x' lengthBefore - 1);                  //            found.Y.CopyTo(y' lengthBefore - 1);                  //            break;                  //        case MatchPosition.LastLast:                  //            found.X.CopyToReverse(x' lengthBefore - 1);                  //            found.Y.CopyToReverse(y' lengthBefore - 1);                  //            break;                  //    }                    //    // select a new line.                  //    foundPosition = this.FindMatch(linesIndex' lines' x' y' line.Value' epsilon' out found);                  //    mergeCount++;                  //}                    // simplify first.                  double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                                                              epsilon);                    // add the new points.                  uint? pointsId = target.AddPoints(simplified[0]' simplified[1]);                    // add points again with appropriate styles.                  if (pointsId.HasValue)                  {                      foreach (var style in polygon.Value)                      {                          var scene2DStylePolygon = (style as Scene2DStylePolygon);                          if (scene2DStylePolygon != null)                          {                              StylePolygon stylePolygon = source.GetStylePolygon(scene2DStylePolygon.StylePolygonId);                              target.AddStylePolygon(pointsId.Value' stylePolygon.Layer' stylePolygon.MinZoom' stylePolygon.MaxZoom'                                  stylePolygon.Color' stylePolygon.Width' stylePolygon.Fill);                              continue;                          }                      }                  }              }
Magic Number,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,FindMatch,The following statement contains a magic number: box = box.ResizeWith(epsilon * 1.1);
Magic Number,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DStylesSet,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DStylesSet.cs,GetHashCode,The following statement contains a magic number: int hashcode = 102348;
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,CalculateScaleFactor,The following statement contains a magic number: return (1.0 / Scene2D.CalculateSimplificationEpsilon(DefaultProjection' zoomFactor)).Power10Floor() * 10;
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Serialize,The following statement contains a magic number: stream.Seek(positionAfterMeta + 4' SeekOrigin.Begin);
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Serialize,The following statement contains a magic number: stream.Write(BitConverter.GetBytes(indexSize)' 0' 4);
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Serialize,The following statement contains a magic number: stream.Seek(positionAfterMeta + 4 + indexSize + 4 * sceneIndex.ZoomFactors.Length' SeekOrigin.Begin);
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Serialize,The following statement contains a magic number: stream.Seek(positionAfterMeta + 4 + indexSize + 4 * sceneIndex.ZoomFactors.Length' SeekOrigin.Begin);
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Serialize,The following statement contains a magic number: for (int idx = 0; idx < lengths.Length; idx++)              {                  long position = stream.Position;                    Dictionary<uint' SceneObject> sceneAtZoom = scene.GetObjectsAt(idx);                  RTreeMemoryIndex<SceneObject> memoryIndex = new RTreeMemoryIndex<SceneObject>(50' 100);                    float latestProgress = 0;                  int sceneObjectIdx = 0;                  foreach (KeyValuePair<uint' SceneObject> sceneObjectPair in sceneAtZoom)                  { // loop over all primitives in order.                      SceneObject sceneObject = sceneObjectPair.Value;                      uint id = sceneObjectPair.Key;                        switch (sceneObject.Enum)                      {                          case SceneObjectType.IconObject:                          case SceneObjectType.PointObject:                          case SceneObjectType.TextObject:                              OsmSharp.UI.Renderer.Scene.Scene2D.ScenePoint geo = scene.GetPoint(sceneObject.GeoId);                              PointF2D point = new PointF2D(geo.X' geo.Y);                              memoryIndex.Add(new BoxF2D(point)' sceneObject);                              break;                          case SceneObjectType.LineObject:                          case SceneObjectType.LineTextObject:                          case SceneObjectType.PolygonObject:                              OsmSharp.UI.Renderer.Scene.Scene2D.ScenePoints geos = scene.GetPoints(sceneObject.GeoId);                              memoryIndex.Add(new BoxF2D(geos.X' geos.Y)' sceneObject);                              break;                      }                        float progress = (float)System.Math.Round((((double)sceneObjectIdx / (double)sceneAtZoom.Count) * 100));                      if (progress != latestProgress)                      {                          OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                              "Indexing scene objects at zoom {1} ({2}/{3})... {0}%"' progress' sceneIndex.ZoomFactors[idx]'                                  sceneObjectIdx' sceneAtZoom.Count);                          latestProgress = progress;                      }                      sceneObjectIdx++;                  }                    // serialize the r-tree.                  OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                      "Serializing RTRee...");                  SceneObjectRTreeSerializer memoryIndexSerializer = new SceneObjectRTreeSerializer(                      scene' compress' idx' SceneSerializer.CalculateScaleFactor(sceneIndex.ZoomFactors[idx]));                  memoryIndexSerializer.Serialize(new LimitedStream(stream)' memoryIndex);                    lengths[idx] = (int)(stream.Position - position);              }
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Serialize,The following statement contains a magic number: for (int idx = 0; idx < lengths.Length; idx++)              {                  long position = stream.Position;                    Dictionary<uint' SceneObject> sceneAtZoom = scene.GetObjectsAt(idx);                  RTreeMemoryIndex<SceneObject> memoryIndex = new RTreeMemoryIndex<SceneObject>(50' 100);                    float latestProgress = 0;                  int sceneObjectIdx = 0;                  foreach (KeyValuePair<uint' SceneObject> sceneObjectPair in sceneAtZoom)                  { // loop over all primitives in order.                      SceneObject sceneObject = sceneObjectPair.Value;                      uint id = sceneObjectPair.Key;                        switch (sceneObject.Enum)                      {                          case SceneObjectType.IconObject:                          case SceneObjectType.PointObject:                          case SceneObjectType.TextObject:                              OsmSharp.UI.Renderer.Scene.Scene2D.ScenePoint geo = scene.GetPoint(sceneObject.GeoId);                              PointF2D point = new PointF2D(geo.X' geo.Y);                              memoryIndex.Add(new BoxF2D(point)' sceneObject);                              break;                          case SceneObjectType.LineObject:                          case SceneObjectType.LineTextObject:                          case SceneObjectType.PolygonObject:                              OsmSharp.UI.Renderer.Scene.Scene2D.ScenePoints geos = scene.GetPoints(sceneObject.GeoId);                              memoryIndex.Add(new BoxF2D(geos.X' geos.Y)' sceneObject);                              break;                      }                        float progress = (float)System.Math.Round((((double)sceneObjectIdx / (double)sceneAtZoom.Count) * 100));                      if (progress != latestProgress)                      {                          OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                              "Indexing scene objects at zoom {1} ({2}/{3})... {0}%"' progress' sceneIndex.ZoomFactors[idx]'                                  sceneObjectIdx' sceneAtZoom.Count);                          latestProgress = progress;                      }                      sceneObjectIdx++;                  }                    // serialize the r-tree.                  OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                      "Serializing RTRee...");                  SceneObjectRTreeSerializer memoryIndexSerializer = new SceneObjectRTreeSerializer(                      scene' compress' idx' SceneSerializer.CalculateScaleFactor(sceneIndex.ZoomFactors[idx]));                  memoryIndexSerializer.Serialize(new LimitedStream(stream)' memoryIndex);                    lengths[idx] = (int)(stream.Position - position);              }
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Serialize,The following statement contains a magic number: for (int idx = 0; idx < lengths.Length; idx++)              {                  long position = stream.Position;                    Dictionary<uint' SceneObject> sceneAtZoom = scene.GetObjectsAt(idx);                  RTreeMemoryIndex<SceneObject> memoryIndex = new RTreeMemoryIndex<SceneObject>(50' 100);                    float latestProgress = 0;                  int sceneObjectIdx = 0;                  foreach (KeyValuePair<uint' SceneObject> sceneObjectPair in sceneAtZoom)                  { // loop over all primitives in order.                      SceneObject sceneObject = sceneObjectPair.Value;                      uint id = sceneObjectPair.Key;                        switch (sceneObject.Enum)                      {                          case SceneObjectType.IconObject:                          case SceneObjectType.PointObject:                          case SceneObjectType.TextObject:                              OsmSharp.UI.Renderer.Scene.Scene2D.ScenePoint geo = scene.GetPoint(sceneObject.GeoId);                              PointF2D point = new PointF2D(geo.X' geo.Y);                              memoryIndex.Add(new BoxF2D(point)' sceneObject);                              break;                          case SceneObjectType.LineObject:                          case SceneObjectType.LineTextObject:                          case SceneObjectType.PolygonObject:                              OsmSharp.UI.Renderer.Scene.Scene2D.ScenePoints geos = scene.GetPoints(sceneObject.GeoId);                              memoryIndex.Add(new BoxF2D(geos.X' geos.Y)' sceneObject);                              break;                      }                        float progress = (float)System.Math.Round((((double)sceneObjectIdx / (double)sceneAtZoom.Count) * 100));                      if (progress != latestProgress)                      {                          OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                              "Indexing scene objects at zoom {1} ({2}/{3})... {0}%"' progress' sceneIndex.ZoomFactors[idx]'                                  sceneObjectIdx' sceneAtZoom.Count);                          latestProgress = progress;                      }                      sceneObjectIdx++;                  }                    // serialize the r-tree.                  OsmSharp.Logging.Log.TraceEvent("SceneSerializer"' OsmSharp.Logging.TraceEventType.Information'                      "Serializing RTRee...");                  SceneObjectRTreeSerializer memoryIndexSerializer = new SceneObjectRTreeSerializer(                      scene' compress' idx' SceneSerializer.CalculateScaleFactor(sceneIndex.ZoomFactors[idx]));                  memoryIndexSerializer.Serialize(new LimitedStream(stream)' memoryIndex);                    lengths[idx] = (int)(stream.Position - position);              }
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Serialize,The following statement contains a magic number: stream.Seek(positionAfterMeta + 4 + indexSize' SeekOrigin.Begin);
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Serialize,The following statement contains a magic number: for (int idx = 0; idx < lengths.Length; idx++)              {                  stream.Write(BitConverter.GetBytes(lengths[idx])' 0' 4);              }
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Deserialize,The following statement contains a magic number: var intBytes = new byte[4];
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Deserialize,The following statement contains a magic number: stream.Read(intBytes' 0' 4);
Magic Number,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Deserialize,The following statement contains a magic number: for (int idx = 0; idx < lengths.Length; idx++)              {                  stream.Read(intBytes' 0' 4);                  lengths[idx] = BitConverter.ToInt32(intBytes' 0);              }
Missing Default,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,PrepareForProcessing,The following switch statement is missing a default case: switch (selector.Type)                              {                                  case SelectorTypeEnum.Node:                                      _keysForNodes = null;                                      break;                                  case SelectorTypeEnum.Way:                                      _keysForWays = null;                                      break;                                  case SelectorTypeEnum.Relation:                                      _keysForRelations = null;                                      break;                                  case SelectorTypeEnum.Line:                                      _keysForLines = null;                                      break;                                  case SelectorTypeEnum.Area:                                      _keysForAreas = null;                                      break;                              }
Missing Default,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,PrepareForProcessing,The following switch statement is missing a default case: switch (selector.Type)                              {                                  case SelectorTypeEnum.Node:                                      selector.SelectorRule.AddRelevantKeysTo(_keysForNodes);                                      break;                                  case SelectorTypeEnum.Way:                                      selector.SelectorRule.AddRelevantKeysTo(_keysForWays);                                      break;                                  case SelectorTypeEnum.Relation:                                      selector.SelectorRule.AddRelevantKeysTo(_keysForRelations);                                      break;                                  case SelectorTypeEnum.Line:                                      selector.SelectorRule.AddRelevantKeysTo(_keysForLines);                                      break;                                  case SelectorTypeEnum.Area:                                      selector.SelectorRule.AddRelevantKeysTo(_keysForAreas);                                      break;                              }
Missing Default,OsmSharp.UI.Map.Styles.MapCSS,MapCSSInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\MapCSSInterpreter.cs,Translate,The following switch statement is missing a default case: switch (osmGeo.Type)              {                  case CompleteOsmType.Node:                      if (!_mapCSSFile.HasNodeIdSelector &&                          osmGeo.Tags.Count == 0)                      { // this node can never be selected' no tags and no id selectors.                          break;                      }                      if (!_mapCSSFile.HasNodeIdSelector &&                          _keysForNodes != null &&                          !osmGeo.Tags.ContainsOneOfKeys(_keysForNodes))                      { // no good keys present.                          break;                      }                      this.TranslateNode(scene' projection' osmGeo as Node);                      break;                  case CompleteOsmType.Way:                      var relevantWayTags = osmGeo.Tags;                      if (_keysForWays != null)                      { // filter the collection.                          relevantWayTags = relevantWayTags.KeepKeysOf(_keysForWays);                      }                      if (!_mapCSSFile.HasWayIdSelector &&                          _keysForWays != null &&                          relevantWayTags.Count == 0)                      { // no good keys present.                          break;                      }                      if (!_unsuccesfullWays.Contains(relevantWayTags))                      { // way has some potential.                          var completeWay = osmGeo as CompleteWay;                          if (completeWay.Nodes.Count > 0 && !this.TranslateWay(scene' projection' completeWay' relevantWayTags))                          { // ... but translate was unsuccesfull.                              _unsuccesfullWays.Add(relevantWayTags);                          }                      }                      break;                  case CompleteOsmType.Relation:                      if (!_mapCSSFile.HasRelationIdSelector &&                          _keysForRelations != null &&                          !osmGeo.Tags.ContainsOneOfKeys(_keysForRelations))                      { // no good keys present.                          break;                      }                      this.TranslateRelation(scene' projection' osmGeo as CompleteRelation);                      break;              }
Missing Default,OsmSharp.UI.Map.Styles.MapCSS.v0_2.Domain,Selector,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\Domain\Selector.cs,Selects,The following switch statement is missing a default case: switch (this.Type)              {                  case SelectorTypeEnum.Area:                      if (mapCSSObject.MapCSSType != MapCSSType.Area)                      {                          return false;                      }                      break;                  case SelectorTypeEnum.Canvas:                      // no way the canvas can be here!                      break;                  case SelectorTypeEnum.Line:                      if (mapCSSObject.MapCSSType != MapCSSType.Line)                      {                          return false;                      }                      break;                  case SelectorTypeEnum.Node:                      if (mapCSSObject.MapCSSType != MapCSSType.Node)                      {                          return false;                      }                      break;                  case SelectorTypeEnum.Way:                      if (mapCSSObject.MapCSSType != MapCSSType.Way)                      {                          return false;                      }                      break;                  case SelectorTypeEnum.Relation:                      if (mapCSSObject.MapCSSType != MapCSSType.Relation)                      {                          return false;                      }                      break;              }
Missing Default,OsmSharp.UI.Map.Styles.MapCSS.v0_2.Domain,SelectorTypeEnumExtensions,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\MapCSS\v0_2\Domain\SelectorTypeEnum.cs,ToMapCSSString,The following switch statement is missing a default case: switch (selectorTypeEnum)              {                  case SelectorTypeEnum.Way:                      return "way";                  case SelectorTypeEnum.Node:                      return "node";                  case SelectorTypeEnum.Line:                      return "line";                  case SelectorTypeEnum.Canvas:                      return "canvas";                  case SelectorTypeEnum.Relation:                      return "relation";                  case SelectorTypeEnum.Area:                      return "area";                  case SelectorTypeEnum.Star:                      return "*";              }
Missing Default,OsmSharp.UI.Map.Styles,StyleInterpreter,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\StyleInterpreter.cs,Translate,The following switch statement is missing a default case: switch (osmGeo.Type)              {                  case OsmGeoType.Node:                      var node = osmGeo as Node;                      if(node.Tags == null)                      { // make sure that a node has a tag collection by default.                          node.Tags= new TagsCollection();                      }                      this.Translate(scene' projection' node);                      break;                  case OsmGeoType.Way:                      this.Translate(scene' projection' CompleteWay.CreateFrom(osmGeo as Way' source));                      break;                  case OsmGeoType.Relation:                      this.Translate(scene' projection' CompleteRelation.CreateFrom(osmGeo as Relation' source));                      break;              }
Missing Default,OsmSharp.UI.Map.Styles,StyleSceneManager,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Map\Styles\StyleSceneManager.cs,FillScene,The following switch statement is missing a default case: switch (osmGeo.Type)                  {                      case Osm.OsmGeoType.Node:                          index = _interpretedNodes;                          break;                      case Osm.OsmGeoType.Way:                          index = _interpretedWays;                          break;                      case Osm.OsmGeoType.Relation:                          index = _interpretedRelations;                          break;                  }
Missing Default,OsmSharp.UI.Renderer,Renderer2D<TTarget>,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Renderer2D.cs,RenderPrimitives,The following switch statement is missing a default case: switch (primitive.Primitive2DType)                      {                          case Primitive2DType.Line2D:                              Line2D line = (Line2D)primitive;                                x = line.X;                              y = line.Y;                              if (x.Length > 4 && line.MaxZoom > zoomFactor * 2 && line.MaxZoom < 512)                              { // try and simplify.                                  double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                                      epsilon);                                  if (simplified[0].Length < line.X.Length)                                  {                                      simplifiedLines++;                                      x = simplified[0];                                      y = simplified[1];                                  }                                  double distance = epsilon * 2;                                  if (simplified[0].Length == 2)                                  { // check if the simplified version is smaller than epsilon.                                      distance = System.Math.Sqrt(                                          System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                                          System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                                  }                                  if (distance < epsilon)                                  {                                      droppedLines++;                                      continue;                                  }                              }                              this.DrawLine(target' x' y' line.Color'                                  this.FromPixels(target' view' line.Width)' line.LineJoin' line.Dashes);                              break;                          case Primitive2DType.Polygon2D:                              Polygon2D polygon = (Polygon2D)primitive;                                x = polygon.X;                              y = polygon.Y;                              //if (x.Length > 4 && polygon.MaxZoom > zoomFactor * 2 && polygon.MaxZoom < 512)                              //{ // try and simplify.                              //    double[][] simplified = OsmSharp.Math.Algorithms.SimplifyCurve.Simplify(new double[][] { x' y }'                              //        epsilon);                              //    if (simplified[0].Length < polygon.X.Length)                              //    {                              //        simplifiedLines++;                              //        x = simplified[0];                              //        y = simplified[1];                              //    }                              //    double distance = epsilon * 2;                              //    if (simplified[0].Length == 2)                              //    { // check if the simplified version is smaller than epsilon.                              //        distance = System.Math.Sqrt(                              //            System.Math.Pow((simplified[0][0] - simplified[0][1])' 2) +                              //            System.Math.Pow((simplified[1][0] - simplified[1][1])' 2));                              //    }                              //    //if (distance < epsilon)                              //    //{                              //    //    droppedLines++;                              //    //    continue;                              //    //}                              //}                              this.DrawPolygon(target' x' y' polygon.Color'                                  this.FromPixels(target' view' polygon.Width)' polygon.Fill);                              break;                          case Primitive2DType.LineText2D:                              LineText2D lineText = (LineText2D)primitive;                              this.DrawLineText(target' lineText.X' lineText.Y' lineText.Text' lineText.Color'                                  this.FromPixels(target' view' lineText.Size)' lineText.HaloColor' lineText.HaloRadius' lineText.Font);                              break;                          case Primitive2DType.Point2D:                              Point2D point = (Point2D)primitive;                              this.DrawPoint(target' point.X' point.Y' point.Color'                                  this.FromPixels(target' view' point.Size));                              break;                          case Primitive2DType.Icon2D:                              Icon2D icon = (Icon2D)primitive;                              this.DrawIcon(target' icon.X' icon.Y' icon.Image);                              break;                          case Primitive2DType.ImageTilted2D:                              ImageTilted2D imageTilted = (ImageTilted2D)primitive;                              this.DrawImage(target' imageTilted.Bounds' imageTilted.NativeImage);                              break;                          case Primitive2DType.Image2D:                              Image2D image = (Image2D)primitive;                              this.DrawImage(target' image.Left' image.Top' image.Right' image.Bottom' image.NativeImage);                              break;                          case Primitive2DType.Text2D:                              Text2D text = (Text2D)primitive;                              this.DrawText(target' text.X' text.Y' text.Text' text.Color'                                  this.FromPixels(target' view' text.Size)' text.HaloColor' text.HaloRadius' text.Font);                              break;                      }
Missing Default,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,Get,The following switch statement is missing a default case: switch (sceneObject.Enum)                          {                              case SceneObjectType.IconObject:                                  SceneIconObject icon = sceneObject as SceneIconObject;                                  byte[] iconStyle = _imageIndex[(int)icon.StyleId];                                  //if (Scene2DZoomRange.Contains(zoom))                                  //{                                  point = _pointIndex.Get(icon.GeoId);                                  if (view.Contains(point.X' point.Y))                                  {                                      primitives.Add(                                          this.ConvertToPrimitive(id' icon' iconStyle));                                  }                                  //}                                  break;                              case SceneObjectType.LineObject:                                  SceneLineObject line = sceneObject as SceneLineObject;                                  StyleLine styleLine = _lineStyles.Get(line.StyleId);                                  points = _pointsIndex.Get(line.GeoId);                                  if (Scene2DZoomRange.Contains(styleLine.MinZoom' styleLine.MaxZoom' zoom))                                  {                                      if (view.IsVisible(points.X' points.Y' false))                                      {                                          primitives.Add(                                              this.ConvertToPrimitive(id' line' styleLine));                                      }                                  }                                  break;                              case SceneObjectType.LineTextObject:                                  SceneLineTextObject lineText = sceneObject as SceneLineTextObject;                                  StyleText lineTextStyle = _textStyles.Get(lineText.StyleId);                                  points = _pointsIndex.Get(lineText.GeoId);                                  if (Scene2DZoomRange.Contains(lineTextStyle.MinZoom' lineTextStyle.MaxZoom' zoom))                                  {                                      if (view.IsVisible(points.X' points.Y' false))                                      {                                          primitives.Add(                                              this.ConvertToPrimitive(id' lineText' lineTextStyle));                                      }                                  }                                  break;                              case SceneObjectType.PointObject:                                  ScenePointObject pointObject = sceneObject as ScenePointObject;                                  StylePoint pointStyle = _pointStyles.Get(pointObject.StyleId);                                  point = _pointIndex.Get(pointObject.GeoId);                                  if (Scene2DZoomRange.Contains(pointStyle.MinZoom' pointStyle.MaxZoom' zoom))                                  {                                      if (view.Contains(point.X' point.Y))                                      {                                          primitives.Add(                                              this.ConvertToPrimitive(id' pointObject' pointStyle));                                      }                                  }                                  break;                              case SceneObjectType.PolygonObject:                                  ScenePolygonObject polygonObject = sceneObject as ScenePolygonObject;                                  StylePolygon polygonStyle = _polygonStyles.Get(polygonObject.StyleId);                                  points = _pointsIndex.Get(polygonObject.GeoId);                                  if (Scene2DZoomRange.Contains(polygonStyle.MinZoom' polygonStyle.MaxZoom' zoom))                                  {                                      if (view.IsVisible(points.X' points.Y' false))                                      {                                          primitives.Add(                                              this.ConvertToPrimitive(id' polygonObject' polygonStyle));                                      }                                  }                                  break;                              case SceneObjectType.TextObject:                                  SceneTextObject textObject = sceneObject as SceneTextObject;                                  StyleText textStyle = _textStyles.Get(textObject.StyleId);                                  point = _pointIndex.Get(textObject.GeoId);                                  if (Scene2DZoomRange.Contains(textStyle.MinZoom' textStyle.MaxZoom' zoom))                                  {                                      if (view.Contains(point.X' point.Y))                                      {                                          primitives.Add(                                              this.ConvertToPrimitive(id' textObject' textStyle));                                      }                                  }                                  break;                          }
Missing Default,OsmSharp.UI.Renderer.Scene,Scene2D,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Scene2D.cs,ConvertToPrimitive,The following switch statement is missing a default case: switch (sceneObject.Enum)              {                  case SceneObjectType.IconObject:                      return this.ConvertToPrimitive(id' sceneObject as SceneIconObject' _imageIndex[(int)sceneObject.StyleId]);                  case SceneObjectType.LineObject:                      return this.ConvertToPrimitive(id' sceneObject as SceneLineObject' _lineStyles.Get(sceneObject.StyleId));                  case SceneObjectType.LineTextObject:                      return this.ConvertToPrimitive(id' sceneObject as SceneLineTextObject' _textStyles.Get(sceneObject.StyleId));                  case SceneObjectType.PointObject:                      return this.ConvertToPrimitive(id' sceneObject as ScenePointObject' _pointStyles.Get(sceneObject.StyleId));                  case SceneObjectType.PolygonObject:                      return this.ConvertToPrimitive(id' sceneObject as ScenePolygonObject' _polygonStyles.Get(sceneObject.StyleId));                  case SceneObjectType.TextObject:                      return this.ConvertToPrimitive(id' sceneObject as SceneTextObject' _textStyles.Get(sceneObject.StyleId));              }
Missing Default,OsmSharp.UI.Renderer.Scene.Simplification,Scene2DObjectMerger,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Simplification\Scene2DObjectMerger.cs,MergeObjects,The following switch statement is missing a default case: switch (foundPosition)                      {                          case MatchPosition.FirstFirst:                              found.X.InsertToReverse(1' x' 0' found.X.Length - 1);                              found.Y.InsertToReverse(1' y' 0' found.Y.Length - 1);                              break;                          case MatchPosition.FirstLast:                              found.X.InsertTo(0' x' 0' found.X.Length - 1);                              found.Y.InsertTo(0' y' 0' found.Y.Length - 1);                              break;                          case MatchPosition.LastFirst:                              found.X.CopyTo(x' lengthBefore - 1);                              found.Y.CopyTo(y' lengthBefore - 1);                              break;                          case MatchPosition.LastLast:                              found.X.CopyToReverse(x' lengthBefore - 1);                              found.Y.CopyToReverse(y' lengthBefore - 1);                              break;                      }
Missing Default,OsmSharp.UI.Renderer.Scene.Storage,SceneObjectRTreeSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneObjectRTreeSerializer.cs,Serialize,The following switch statement is missing a default case: switch (sceneObject.Enum)                  {                      case SceneObjectType.IconObject:                          // get point.                          point = _scene.GetPoint(sceneObject.GeoId);                            // set point data and keep id.                          if (!addedPoint.TryGetValue(sceneObject.GeoId' out geoId))                          { // the point was not added yet.                               geoId = leafData.PointsX.Count;                              //leafData.PointsIndexes.Add(geoId);                              leafData.PointsX.Add((long)(scaleFactor * point.X));                              leafData.PointsY.Add((long)(scaleFactor * point.Y));                              addedPoint.Add(sceneObject.GeoId' geoId);                          }                          leafData.IconPointId.Add(geoId); // add point.                            // add image id.                          leafData.IconImageId.Add(sceneObject.StyleId);                          break;                      case SceneObjectType.PointObject:                          // get point.                          point = _scene.GetPoint(sceneObject.GeoId);                            // set point data and keep id.                          if (!addedPoint.TryGetValue(sceneObject.GeoId' out geoId))                          { // the point was not added yet.                               geoId = leafData.PointsX.Count;                              leafData.PointsX.Add((long)(scaleFactor * point.X));                              leafData.PointsY.Add((long)(scaleFactor * point.Y));                              //leafData.PointsIndexes.Add(leafData.PointsY.Count);                              addedPoint.Add(sceneObject.GeoId' geoId);                          }                          leafData.PointPointId.Add(geoId);                            // add point style.                          leafData.PointStyleId.Add(sceneObject.StyleId);                          break;                      case SceneObjectType.TextObject:                          // get point.                          point = _scene.GetPoint(sceneObject.GeoId);                            // set point data and keep id.                          if (!addedPoint.TryGetValue(sceneObject.GeoId' out geoId))                          { // the point was not added yet.                               geoId = leafData.PointsX.Count;                              leafData.PointsX.Add((long)(scaleFactor * point.X));                              leafData.PointsY.Add((long)(scaleFactor * point.Y));                              //leafData.PointsIndexes.Add(leafData.PointsY.Count);                              addedPoint.Add(sceneObject.GeoId' geoId);                          }                          leafData.TextPointPointId.Add(geoId);                            // add point style.                          leafData.TextPointStyleId.Add(sceneObject.StyleId);                            // add text.                          leafData.TextPointText.Add(                              _scene.GetText((sceneObject as SceneTextObject).TextId));                          break;                      case SceneObjectType.LineObject:                          // get points.                          points = _scene.GetPoints(sceneObject.GeoId);                            // set points data and keep id.                          if (!addedPoints.TryGetValue(sceneObject.GeoId' out geoId))                          { // the point was not added yet.                               geoId = leafData.PointsX.Count;                              leafData.PointsX.AddRange(points.X.ConvertToLongArray(scaleFactor));                              leafData.PointsY.AddRange(points.Y.ConvertToLongArray(scaleFactor));                              //leafData.PointsIndexes.Add(leafData.PointsY.Count);                              addedPoints.Add(sceneObject.GeoId' geoId);                          }                          leafData.LinePointsId.Add(geoId);                            // add point style.                          leafData.LineStyleId.Add(sceneObject.StyleId);                          break;                      case SceneObjectType.LineTextObject:                          // get points.                          points = _scene.GetPoints(sceneObject.GeoId);                            // set points data and keep id.                          if (!addedPoints.TryGetValue(sceneObject.GeoId' out geoId))                          { // the point was not added yet.                               geoId = leafData.PointsX.Count;                              leafData.PointsX.AddRange(points.X.ConvertToLongArray(scaleFactor));                              leafData.PointsY.AddRange(points.Y.ConvertToLongArray(scaleFactor));                              //leafData.PointsIndexes.Add(leafData.PointsY.Count);                              addedPoints.Add(sceneObject.GeoId' geoId);                          }                          leafData.LineTextPointsId.Add(geoId);                            // add point style.                          leafData.LineTextStyleId.Add(sceneObject.StyleId);                            // add text.                          leafData.LineTextText.Add(                              _scene.GetText((sceneObject as SceneLineTextObject).TextId));                          break;                      case SceneObjectType.PolygonObject:                          // get points.                          points = _scene.GetPoints(sceneObject.GeoId);                            // set points data and keep id.                          if (!addedPoints.TryGetValue(sceneObject.GeoId' out geoId))                          { // the point was not added yet.                               geoId = leafData.PointsX.Count;                              leafData.PointsX.AddRange(points.X.ConvertToLongArray(scaleFactor));                              leafData.PointsY.AddRange(points.Y.ConvertToLongArray(scaleFactor));                              //leafData.PointsIndexes.Add(leafData.PointsY.Count);                              addedPoints.Add(sceneObject.GeoId' geoId);                          }                          leafData.PolygonPointsId.Add(geoId);                            // add point style.                          leafData.PolygonStyleId.Add(sceneObject.StyleId);                          break;                  }
Missing Default,OsmSharp.UI.Renderer.Scene.Storage,SceneSerializer,C:\repos\OsmSharp_OsmSharp\OsmSharp.UI\Renderer\Scene\Storage\SceneSerializer.cs,Serialize,The following switch statement is missing a default case: switch (sceneObject.Enum)                      {                          case SceneObjectType.IconObject:                          case SceneObjectType.PointObject:                          case SceneObjectType.TextObject:                              OsmSharp.UI.Renderer.Scene.Scene2D.ScenePoint geo = scene.GetPoint(sceneObject.GeoId);                              PointF2D point = new PointF2D(geo.X' geo.Y);                              memoryIndex.Add(new BoxF2D(point)' sceneObject);                              break;                          case SceneObjectType.LineObject:                          case SceneObjectType.LineTextObject:                          case SceneObjectType.PolygonObject:                              OsmSharp.UI.Renderer.Scene.Scene2D.ScenePoints geos = scene.GetPoints(sceneObject.GeoId);                              memoryIndex.Add(new BoxF2D(geos.X' geos.Y)' sceneObject);                              break;                      }
