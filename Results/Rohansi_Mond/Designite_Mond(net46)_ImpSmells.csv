Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mond.Compiler,ExpressionCompiler,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\ExpressionCompiler.cs,GenerateDebugInfo,The method has 102 lines of code.
Long Method,Mond.Compiler,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Lexer.cs,TryLexString,The method has 107 lines of code.
Long Method,Mond.Compiler,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Lexer.cs,TryLexNumber,The method has 100 lines of code.
Long Method,Mond.Compiler,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Lexer.cs,Lexer,The method has 130 lines of code.
Long Method,Mond.Compiler,Parser,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parser.cs,Parser,The method has 109 lines of code.
Long Method,Mond,MondProgram,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondProgram.cs,SaveBytecode,The method has 102 lines of code.
Long Method,Mond,MondProgram,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondProgram.cs,LoadBytecode,The method has 121 lines of code.
Long Method,Mond.Libraries.Json,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Libraries\Json\Json.Deserialize.cs,MoveNext,The method has 190 lines of code.
Long Method,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,Run,The method has 881 lines of code.
Complex Method,Mond.Binding,Parameter,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MethodTable.cs,Parameter,Cyclomatic complexity of the method is 10
Complex Method,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,BuildDispatchExpression,Cyclomatic complexity of the method is 9
Complex Method,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,MakeReturnConversion,Cyclomatic complexity of the method is 9
Complex Method,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,BuildMethodTable,Cyclomatic complexity of the method is 8
Complex Method,Mond.Binding,MondModuleBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondModuleBinder.cs,BindImpl,Cyclomatic complexity of the method is 8
Complex Method,Mond.Compiler,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Lexer.cs,TryLexString,Cyclomatic complexity of the method is 18
Complex Method,Mond.Compiler,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Lexer.cs,TryLexNumber,Cyclomatic complexity of the method is 8
Complex Method,Mond.Compiler,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Lexer.cs,SkipComments,Cyclomatic complexity of the method is 8
Complex Method,Mond.Compiler.Expressions,BinaryOperatorExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\BinaryOperatorExpression.cs,Compile,Cyclomatic complexity of the method is 11
Complex Method,Mond.Compiler.Expressions.Statements,DestructuredArrayExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\DestructuredArrayExpression.cs,Compile,Cyclomatic complexity of the method is 12
Complex Method,Mond.Compiler.Expressions.Statements,ForExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\ForExpression.cs,Compile,Cyclomatic complexity of the method is 10
Complex Method,Mond.Compiler.Expressions.Statements,FunctionExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\FunctionExpression.cs,Compile,Cyclomatic complexity of the method is 10
Complex Method,Mond.Compiler.Expressions.Statements,SwitchExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\SwitchExpression.cs,Compile,Cyclomatic complexity of the method is 10
Complex Method,Mond.Compiler.Parselets,ObjectParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\ObjectParselet.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,Mond.Compiler.Parselets.Statements,FunctionParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\Statements\FunctionParselet.cs,ParseFunction,Cyclomatic complexity of the method is 11
Complex Method,Mond.Debugger,MondDebugInfo,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugInfo.cs,FindScope,Cyclomatic complexity of the method is 10
Complex Method,Mond,MondProgram,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondProgram.cs,SaveBytecode,Cyclomatic complexity of the method is 13
Complex Method,Mond,MondProgram,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondProgram.cs,LoadBytecode,Cyclomatic complexity of the method is 15
Complex Method,Mond,MondValue,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondValue.cs,SliceImpl,Cyclomatic complexity of the method is 10
Complex Method,Mond,MondValue,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondValue.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,Mond,MondValue,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondValue.cs,GetHashCode,Cyclomatic complexity of the method is 11
Complex Method,Mond,MondValue,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondValue.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Mond,MondValue,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondValue.cs,SerializeImpl,Cyclomatic complexity of the method is 17
Complex Method,Mond,MondValue,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondValue.cs,SerializeString,Cyclomatic complexity of the method is 9
Complex Method,Mond,MondValueTypeExtensions,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondValueType.cs,GetName,Cyclomatic complexity of the method is 9
Complex Method,Mond.Libraries.Core,RequireClass,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Libraries\Core\Require.cs,Require,Cyclomatic complexity of the method is 10
Complex Method,Mond.Libraries.Json,JsonModule,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Libraries\Json\Json.cs,SerializeImpl,Cyclomatic complexity of the method is 16
Complex Method,Mond.Libraries.Json,JsonModule,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Libraries\Json\Json.cs,SerializeString,Cyclomatic complexity of the method is 9
Complex Method,Mond.Libraries.Json,Parser,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Libraries\Json\Json.Deserialize.cs,ParseValue,Cyclomatic complexity of the method is 9
Complex Method,Mond.Libraries.Json,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Libraries\Json\Json.Deserialize.cs,MoveNext,Cyclomatic complexity of the method is 37
Complex Method,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,Call,Cyclomatic complexity of the method is 8
Complex Method,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,Run,Cyclomatic complexity of the method is 102
Long Parameter List,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,BindInstance,The method has 5 parameters. Parameters: className' methods' type' methodType' nameOverride
Long Parameter List,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,BuildDispatchExpression,The method has 7 parameters. Parameters: errorPrefix' methods' checkedArguments' parameters' instanceFunction' returnLabel' callFactory
Long Parameter List,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,BindFunctionCall,The method has 7 parameters. Parameters: errorPrefix' method' instanceType' instanceFunction' parameters' arguments' returnLabel
Long Parameter List,Mond.Compiler,FunctionContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\FunctionContext.cs,FunctionContext,The method has 6 parameters. Parameters: compiler' argIndex' localIndex' prevScope' parentName' name
Long Parameter List,Mond.Compiler,Scope,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Scope.cs,Scope,The method has 5 parameters. Parameters: id' argIndex' localIndex' previous' popAction
Long Parameter List,Mond.Compiler,Token,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Token.cs,Token,The method has 7 parameters. Parameters: fileName' line' column' type' contents' subType' tag
Long Parameter List,Mond.Compiler,Token,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Token.cs,Token,The method has 5 parameters. Parameters: token' type' contents' subType' tag
Long Parameter List,Mond.Compiler.Expressions,SliceExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\SliceExpression.cs,SliceExpression,The method has 5 parameters. Parameters: token' left' start' end' step
Long Parameter List,Mond.Compiler.Expressions.Statements,ForeachExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\ForeachExpression.cs,ForeachExpression,The method has 6 parameters. Parameters: token' inToken' identifier' expression' block' destructure
Long Parameter List,Mond.Compiler.Expressions.Statements,ForExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\ForExpression.cs,ForExpression,The method has 5 parameters. Parameters: token' initializer' condition' increment' block
Long Parameter List,Mond.Compiler.Expressions.Statements,FunctionExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\FunctionExpression.cs,FunctionExpression,The method has 6 parameters. Parameters: token' name' arguments' otherArgs' block' debugName
Long Parameter List,Mond.Compiler.Expressions.Statements,SequenceExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\SequenceExpression.cs,SequenceExpression,The method has 6 parameters. Parameters: token' name' arguments' otherArgs' block' debugName
Long Parameter List,Mond.Compiler.Expressions.Statements,SequenceBodyExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\SequenceExpression.cs,SequenceBodyExpression,The method has 6 parameters. Parameters: token' name' block' debugName' state' enumerable
Long Parameter List,Mond.Compiler.Parselets.Statements,FunctionParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\Statements\FunctionParselet.cs,ParseFunction,The method has 8 parameters. Parameters: parser' token' isStatement' trailingSemicolon' name' arguments' otherArgs' body
Long Parameter List,Mond.Debugger,MondDebugContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugContext.cs,MondDebugContext,The method has 8 parameters. Parameters: state' program' address' locals' args' callStack' callStackTop' callStackBottom
Long Parameter List,Mond.Debugger,CallStackEntry,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugContext.cs,CallStackEntry,The method has 6 parameters. Parameters: program' address' fileName' function' lineNumber' columnNumber
Long Parameter List,Mond.Debugger,MondDebugInfo,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugInfo.cs,MondDebugInfo,The method has 6 parameters. Parameters: fileName' sourceCode' functions' lines' statements' scopes
Long Parameter List,Mond.Debugger,Statement,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugInfo.cs,Statement,The method has 5 parameters. Parameters: address' startLine' startColumn' endLine' endColumn
Long Parameter List,Mond.Debugger,Scope,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugInfo.cs,Scope,The method has 6 parameters. Parameters: id' depth' parentId' startAddress' endAddress' identifiers
Long Parameter List,Mond,MondCompilerException,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondCompilerException.cs,MondCompilerException,The method has 5 parameters. Parameters: fileName' line' column' format' args
Long Parameter List,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,DebuggerBreak,The method has 5 parameters. Parameters: program' locals' args' address' initialCallDepth
Long Parameter List,Mond.VirtualMachine.Prototypes,ArrayPrototype,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Prototypes\ArrayPrototype.cs,SortImpl,The method has 5 parameters. Parameters: name' instance' index' count' reverse
Long Statement,Mond.Binding,MondClassBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondClassBinder.cs,BindImpl,The length of the statement  "                var propertyBinding = MondFunctionBinder.BindInstance(className' propertyArray' type' MondFunctionBinder.MethodType.Property' name)" is 131.
Long Statement,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,BindImpl,The length of the statement  "                var dispatches = BuildDispatchExpression(errorPrefix' methodTable.Methods[i]' i' parameters' instanceFunction' returnLabel' callFactory);" is 137.
Long Statement,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,BindImpl,The length of the statement  "                var dispatches = BuildDispatchExpression(errorPrefix' group' int.MaxValue' parameters' instanceFunction' returnLabel' callFactory);" is 131.
Long Statement,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,ThrowParameterTypeError,The length of the statement  "            var parameterTypeError = typeof(BindingError).GetMethod("ParameterTypeError"' BindingFlags.Public | BindingFlags.Static);" is 121.
Long Statement,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,ThrowParameterTypeError,The length of the statement  "            var errorString = Expression.Call(parameterTypeError' Expression.Constant(errorPrefix)' Expression.Constant(methodTable));" is 122.
Long Statement,Mond.Binding,MondModuleBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondModuleBinder.cs,BindImpl,The length of the statement  "                var propertyBinding = MondFunctionBinder.BindStatic(moduleName' propertyArray' MondFunctionBinder.MethodType.Property' name)" is 124.
Long Statement,Mond.Compiler.Parselets,GroupParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\GroupParselet.cs,Parse,The length of the statement  "            if ((parser.Match(TokenType.RightParen) && parser.Match(TokenType.Pointy' 1)) ||                                            // () ->" is 132.
Long Statement,Mond.Compiler.Parselets,GroupParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\GroupParselet.cs,Parse,The length of the statement  "                (parser.Match(TokenType.Identifier) && parser.Match(TokenType.RightParen' 1) && parser.Match(TokenType.Pointy' 2)) ||   // (ident) ->" is 133.
Long Statement,Mond.Compiler.Parselets,GroupParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\GroupParselet.cs,Parse,The length of the statement  "                (parser.Match(TokenType.Identifier) && parser.Match(TokenType.Comma' 1)) ||                                             // (ident'" is 130.
Long Statement,Mond.Compiler.Parselets,GroupParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\GroupParselet.cs,Parse,The length of the statement  "                 parser.Match(TokenType.Ellipsis))                                                                                      // (..." is 126.
Long Statement,Mond.Compiler.Parselets,NumberParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\NumberParselet.cs,Parse,The length of the statement  "                    success = double.TryParse(token.Contents' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture' out value);" is 144.
Long Statement,Mond.Compiler.Parselets,ObjectParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\ObjectParselet.cs,Parse,The length of the statement  "                    throw new MondCompilerException(errorToken' CompilerError.ExpectedButFound2' TokenType.Identifier' TokenType.String' errorToken);" is 129.
Long Statement,Mond.Compiler.Parselets.Statements,SwitchParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\Statements\SwitchParselet.cs,Parse,The length of the statement  "                throw new MondCompilerException(errorToken' CompilerError.ExpectedButFound2' TokenType.Case' TokenType.Default' errorToken);" is 124.
Long Statement,Mond.Compiler.Visitors,ExpressionPrintVisitor,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Visitors\ExpressionPrintVisitor.cs,Visit,The length of the statement  "            var fields = expression.Fields.Select(field => field.Alias != null ? string.Format("{0}: {1}"' field.Name' field.Alias) : field.Name).ToArray();" is 144.
Long Statement,Mond,MondProgram,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondProgram.cs,LoadBytecode,The length of the statement  "                throw new NotSupportedException(string.Format("Wrong bytecode version. Expected 0x{0:X2}' got 0x{1:X2}."' FormatVersion' version));" is 131.
Long Statement,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,GetAddressDebugInfo,The length of the statement  "                    return string.Format("{0}in {1}: line {2}:{3}"' prefix' fileName' position.Value.LineNumber' position.Value.ColumnNumber);" is 122.
Complex Conditional,Mond.Compiler,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Lexer.cs,GetEnumerator,The conditional expression  "!TryLexPunctuation(ch' out var token) &&                     !TryLexOperator(ch' out token) &&                     !TryLexString(ch' out token) &&                     !TryLexWord(ch' out token) &&                     !TryLexNumber(ch' out token)"  is complex.
Complex Conditional,Mond.Compiler.Parselets,GroupParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\GroupParselet.cs,Parse,The conditional expression  "(parser.Match(TokenType.RightParen) && parser.Match(TokenType.Pointy' 1)) ||                                            // () ->                 (parser.Match(TokenType.Identifier) && parser.Match(TokenType.RightParen' 1) && parser.Match(TokenType.Pointy' 2)) ||   // (ident) ->                 (parser.Match(TokenType.Identifier) && parser.Match(TokenType.Comma' 1)) ||                                             // (ident'                  parser.Match(TokenType.Ellipsis)"  is complex.
Complex Conditional,Mond.Debugger,MondDebugContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugContext.cs,TryGetLocalAccessor,The conditional expression  "string.IsNullOrEmpty(name) || debugInfo == null || debugInfo.Scopes == null || _locals == null"  is complex.
Complex Conditional,Mond,MondValue,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondValue.cs,SliceImpl,The conditional expression  "stepValue < 0 && (start == null || !start) && (end == null || !end)"  is complex.
Complex Conditional,Mond,MondValue,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondValue.cs,SliceImpl,The conditional expression  "(stepValue < 0 && endIndex > startIndex) || (stepValue > 0 && startIndex > endIndex)"  is complex.
Complex Conditional,Mond.VirtualMachine.Prototypes,ArrayPrototype,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Prototypes\ArrayPrototype.cs,SortImpl,The conditional expression  "index < 0 || index >= instance.ArrayValue.Count ||                 count < 0 || index + count > instance.ArrayValue.Count"  is complex.
Magic Number,Mond.Binding,Parameter,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MethodTable.cs,Parameter,The following statement contains a magic number: Priority = 10;
Magic Number,Mond.Binding,Parameter,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MethodTable.cs,Parameter,The following statement contains a magic number: Priority = 100;
Magic Number,Mond.Binding,Parameter,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MethodTable.cs,Parameter,The following statement contains a magic number: Priority = 75;
Magic Number,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,BindImpl,The following statement contains a magic number: var argumentsParam = parameters[instanceFunction ? 2 : 1];
Magic Number,Mond.Binding,MondFunctionBinder,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Binding\MondFunctionBinder.cs,BuildDispatchExpression,The following statement contains a magic number: var argumentsParam = parameters[instanceFunction ? 2 : 1];
Magic Number,Mond.Compiler,ExpressionCompiler,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\ExpressionCompiler.cs,GenerateDebugInfo,The following statement contains a magic number: var statements = AllInstructions()                 .Where(i => i.Type == InstructionType.Statement)                 .Select(s =>                 {                     var startLine = ((ImmediateOperand)s.Operands[0]).Value;                     var startColumn = ((ImmediateOperand)s.Operands[1]).Value;                     var endLine = ((ImmediateOperand)s.Operands[2]).Value;                     var endColumn = ((ImmediateOperand)s.Operands[3]).Value;                      return new MondDebugInfo.Statement(s.Offset' startLine' startColumn' endLine' endColumn);                 })                 .Where(s =>                 {                     if (s.Address == prevAddress)                         return false;                      prevAddress = s.Address;                     return true;                 })                 .ToList();
Magic Number,Mond.Compiler,ExpressionCompiler,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\ExpressionCompiler.cs,GenerateDebugInfo,The following statement contains a magic number: var statements = AllInstructions()                 .Where(i => i.Type == InstructionType.Statement)                 .Select(s =>                 {                     var startLine = ((ImmediateOperand)s.Operands[0]).Value;                     var startColumn = ((ImmediateOperand)s.Operands[1]).Value;                     var endLine = ((ImmediateOperand)s.Operands[2]).Value;                     var endColumn = ((ImmediateOperand)s.Operands[3]).Value;                      return new MondDebugInfo.Statement(s.Offset' startLine' startColumn' endLine' endColumn);                 })                 .Where(s =>                 {                     if (s.Address == prevAddress)                         return false;                      prevAddress = s.Address;                     return true;                 })                 .ToList();
Magic Number,Mond.Compiler,ExpressionCompiler,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\ExpressionCompiler.cs,GenerateDebugInfo,The following statement contains a magic number: var scopes = AllInstructions()                 .Where(i => i.Type == InstructionType.Scope)                 .Select(s =>                 {                     var id = ((ImmediateOperand)s.Operands[0]).Value;                     var depth = ((ImmediateOperand)s.Operands[1]).Value;                     var parentId = ((ImmediateOperand)s.Operands[2]).Value;                     var start = ((LabelOperand)s.Operands[3]).Position;                     var end = ((LabelOperand)s.Operands[4]).Position - 1;                     var identOperands = ((DeferredOperand<ListOperand<DebugIdentifierOperand>>)s.Operands[5]).Value.Operands;                      if (!start.HasValue || !end.HasValue)                         throw new Exception("scope labels not bound");                      var identifiers = identOperands                         .Select(i => new MondDebugInfo.Identifier(i.Name.Id' i.IsReadOnly' i.FrameIndex' i.Id))                         .ToList();                      return new MondDebugInfo.Scope(id' depth' parentId' start.Value' end.Value' identifiers);                 })                 .OrderBy(s => s.Id)                 .ToList();
Magic Number,Mond.Compiler,ExpressionCompiler,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\ExpressionCompiler.cs,GenerateDebugInfo,The following statement contains a magic number: var scopes = AllInstructions()                 .Where(i => i.Type == InstructionType.Scope)                 .Select(s =>                 {                     var id = ((ImmediateOperand)s.Operands[0]).Value;                     var depth = ((ImmediateOperand)s.Operands[1]).Value;                     var parentId = ((ImmediateOperand)s.Operands[2]).Value;                     var start = ((LabelOperand)s.Operands[3]).Position;                     var end = ((LabelOperand)s.Operands[4]).Position - 1;                     var identOperands = ((DeferredOperand<ListOperand<DebugIdentifierOperand>>)s.Operands[5]).Value.Operands;                      if (!start.HasValue || !end.HasValue)                         throw new Exception("scope labels not bound");                      var identifiers = identOperands                         .Select(i => new MondDebugInfo.Identifier(i.Name.Id' i.IsReadOnly' i.FrameIndex' i.Id))                         .ToList();                      return new MondDebugInfo.Scope(id' depth' parentId' start.Value' end.Value' identifiers);                 })                 .OrderBy(s => s.Id)                 .ToList();
Magic Number,Mond.Compiler,ExpressionCompiler,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\ExpressionCompiler.cs,GenerateDebugInfo,The following statement contains a magic number: var scopes = AllInstructions()                 .Where(i => i.Type == InstructionType.Scope)                 .Select(s =>                 {                     var id = ((ImmediateOperand)s.Operands[0]).Value;                     var depth = ((ImmediateOperand)s.Operands[1]).Value;                     var parentId = ((ImmediateOperand)s.Operands[2]).Value;                     var start = ((LabelOperand)s.Operands[3]).Position;                     var end = ((LabelOperand)s.Operands[4]).Position - 1;                     var identOperands = ((DeferredOperand<ListOperand<DebugIdentifierOperand>>)s.Operands[5]).Value.Operands;                      if (!start.HasValue || !end.HasValue)                         throw new Exception("scope labels not bound");                      var identifiers = identOperands                         .Select(i => new MondDebugInfo.Identifier(i.Name.Id' i.IsReadOnly' i.FrameIndex' i.Id))                         .ToList();                      return new MondDebugInfo.Scope(id' depth' parentId' start.Value' end.Value' identifiers);                 })                 .OrderBy(s => s.Id)                 .ToList();
Magic Number,Mond.Compiler,ExpressionCompiler,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\ExpressionCompiler.cs,GenerateDebugInfo,The following statement contains a magic number: var scopes = AllInstructions()                 .Where(i => i.Type == InstructionType.Scope)                 .Select(s =>                 {                     var id = ((ImmediateOperand)s.Operands[0]).Value;                     var depth = ((ImmediateOperand)s.Operands[1]).Value;                     var parentId = ((ImmediateOperand)s.Operands[2]).Value;                     var start = ((LabelOperand)s.Operands[3]).Position;                     var end = ((LabelOperand)s.Operands[4]).Position - 1;                     var identOperands = ((DeferredOperand<ListOperand<DebugIdentifierOperand>>)s.Operands[5]).Value.Operands;                      if (!start.HasValue || !end.HasValue)                         throw new Exception("scope labels not bound");                      var identifiers = identOperands                         .Select(i => new MondDebugInfo.Identifier(i.Name.Id' i.IsReadOnly' i.FrameIndex' i.Id))                         .ToList();                      return new MondDebugInfo.Scope(id' depth' parentId' start.Value' end.Value' identifiers);                 })                 .OrderBy(s => s.Id)                 .ToList();
Magic Number,Mond.Compiler,FunctionContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\FunctionContext.cs,LoadArray,The following statement contains a magic number: return -2 + 1;
Magic Number,Mond.Compiler,FunctionContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\FunctionContext.cs,StoreField,The following statement contains a magic number: return -2;
Magic Number,Mond.Compiler,FunctionContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\FunctionContext.cs,StoreArray,The following statement contains a magic number: return -3;
Magic Number,Mond.Compiler,FunctionContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\FunctionContext.cs,Slice,The following statement contains a magic number: return -4 + 1;
Magic Number,Mond.Compiler,FunctionContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\FunctionContext.cs,Dup2,The following statement contains a magic number: return 2;
Magic Number,Mond.Compiler,FunctionContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\FunctionContext.cs,BinaryOperation,The following statement contains a magic number: return -2 + 1;
Magic Number,Mond.Compiler,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Lexer.cs,Lexer,The following statement contains a magic number: _sourceCode = new StringBuilder(4096);
Magic Number,Mond.Compiler,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Lexer.cs,GetEnumerator,The following statement contains a magic number: _read = new List<char>(16);
Magic Number,Mond.Compiler,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Lexer.cs,TryLexString,The following statement contains a magic number: switch (ch)                 {                     case '\\':                         stringContentsBuilder.Append('\\');                         break;                      case '/':                         stringContentsBuilder.Append('/');                         break;                      case '"':                         stringContentsBuilder.Append('"');                         break;                      case '\'':                         stringContentsBuilder.Append('\'');                         break;                      case 'b':                         stringContentsBuilder.Append('\b');                         break;                      case 'f':                         stringContentsBuilder.Append('\f');                         break;                      case 'n':                         stringContentsBuilder.Append('\n');                         break;                      case 'r':                         stringContentsBuilder.Append('\r');                         break;                      case 't':                         stringContentsBuilder.Append('\t');                         break;                      case 'u':                         var i = 0;                         var hex = TakeWhile(c => ++i <= 4);                         short hexValue;                          if (!short.TryParse(hex' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out hexValue))                         {                             start = _positions.Peek();                             throw new MondCompilerException(_fileName' start.Line' start.Column' CompilerError.InvalidEscapeSequence' ch + hex);                         }                          stringContentsBuilder.Append((char)hexValue);                         break;                      default:                         start = _positions.Peek();                         throw new MondCompilerException(_fileName' start.Line' start.Column' CompilerError.InvalidEscapeSequence' ch);                 }
Magic Number,Mond.Compiler,Lexer,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Lexer.cs,TryLexNumber,The following statement contains a magic number: PeekChar(2) == '_'
Magic Number,Mond.Compiler,Parser,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parser.cs,Parser,The following statement contains a magic number: _read = new List<Token>(8);
Magic Number,Mond.Compiler,Token,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Token.cs,ToString,The following statement contains a magic number: switch (Type)             {                 case TokenType.Identifier:                 case TokenType.Number:                 case TokenType.String:                     var contentsStr = Contents;                     if (contentsStr.Length > 16)                         contentsStr = contentsStr.Substring(0' 13) + "...";                      return string.Format("{0}('{1}')"' Type' contentsStr);                  default:                     return string.Format("{0}({1})"' Type' SubType);             }
Magic Number,Mond.Compiler,Token,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Token.cs,ToString,The following statement contains a magic number: switch (Type)             {                 case TokenType.Identifier:                 case TokenType.Number:                 case TokenType.String:                     var contentsStr = Contents;                     if (contentsStr.Length > 16)                         contentsStr = contentsStr.Substring(0' 13) + "...";                      return string.Format("{0}('{1}')"' Type' contentsStr);                  default:                     return string.Format("{0}({1})"' Type' SubType);             }
Magic Number,Mond.Compiler.Expressions,BinaryOperatorExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\BinaryOperatorExpression.cs,Compile,The following statement contains a magic number: var preTimes = needResult ? 3 : 2;
Magic Number,Mond.Compiler.Expressions,BinaryOperatorExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\BinaryOperatorExpression.cs,Compile,The following statement contains a magic number: var preTimes = needResult ? 3 : 2;
Magic Number,Mond.Compiler.Expressions,BinaryOperatorExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\BinaryOperatorExpression.cs,Compile,The following statement contains a magic number: switch (preTotal / preTimes)                     {                         case 0:                             break;                         case 1:                             stack += context.Swap();                             break;                         case 2:                             stack += context.Swap1For2();                             break;                         default:                             throw new NotSupportedException();                     }
Magic Number,Mond.Compiler.Expressions.Statements,SwitchExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\SwitchExpression.cs,TryBuildTable,The following statement contains a magic number: holeSize > 3
Magic Number,Mond.Compiler.Expressions.Statements,SwitchExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\SwitchExpression.cs,TryBuildTable,The following statement contains a magic number: tableEntries.Count < 3
Magic Number,Mond.Compiler.Expressions.Statements,SwitchExpression,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Expressions\Statements\SwitchExpression.cs,TryBuildTable,The following statement contains a magic number: (double)tableHoles / tableEntries.Count >= 0.25
Magic Number,Mond.Compiler.Parselets,GroupParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\GroupParselet.cs,Parse,The following statement contains a magic number: (parser.Match(TokenType.RightParen) && parser.Match(TokenType.Pointy' 1)) ||                                            // () ->                 (parser.Match(TokenType.Identifier) && parser.Match(TokenType.RightParen' 1) && parser.Match(TokenType.Pointy' 2)) ||   // (ident) ->                 (parser.Match(TokenType.Identifier) && parser.Match(TokenType.Comma' 1)) ||                                             // (ident'                  parser.Match(TokenType.Ellipsis)
Magic Number,Mond.Compiler.Parselets,NumberParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\NumberParselet.cs,TryHexToInt32,The following statement contains a magic number: string.IsNullOrEmpty(number) || number.Length > 8
Magic Number,Mond.Compiler.Parselets,NumberParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\NumberParselet.cs,TryHexToInt32,The following statement contains a magic number: result <<= 4;
Magic Number,Mond.Compiler.Parselets,NumberParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\NumberParselet.cs,TryBinToInt32,The following statement contains a magic number: string.IsNullOrEmpty(number) || number.Length > 32
Magic Number,Mond.Compiler.Parselets.Statements,FunctionParselet,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Compiler\Parselets\Statements\FunctionParselet.cs,ParseFunction,The following statement contains a magic number: arguments.Count != 1 && arguments.Count != 2
Magic Number,Mond.Debugger,MondDebugContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugContext.cs,CreateLocalObject,The following statement contains a magic number: obj["__get"] = new MondFunction((_' args) =>             {                 if (args.Length != 2)                     throw new MondRuntimeException("LocalObject.__get: requires 2 parameters");                  var name = (string)args[1];                                  if (!TryGetLocalAccessor(name' out var getter' out var setter))                     throw new MondRuntimeException("`{0}` is not defined"' name);                  return getter();             });
Magic Number,Mond.Debugger,MondDebugContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugContext.cs,CreateLocalObject,The following statement contains a magic number: obj["__set"] = new MondFunction((_' args) =>             {                 if (args.Length != 3)                     throw new MondRuntimeException("LocalObject.__set: requires 3 parameters");                  var name = (string)args[1];                 var value = args[2];                                  if (!TryGetLocalAccessor(name' out var getter' out var setter))                     throw new MondRuntimeException("`{0}` is not defined"' name);                  if (setter == null)                     throw new MondRuntimeException("`{0}` is read-only"' name);                  setter(value);                 return value;             });
Magic Number,Mond.Debugger,MondDebugContext,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugContext.cs,CreateLocalObject,The following statement contains a magic number: obj["__set"] = new MondFunction((_' args) =>             {                 if (args.Length != 3)                     throw new MondRuntimeException("LocalObject.__set: requires 3 parameters");                  var name = (string)args[1];                 var value = args[2];                                  if (!TryGetLocalAccessor(name' out var getter' out var setter))                     throw new MondRuntimeException("`{0}` is not defined"' name);                  if (setter == null)                     throw new MondRuntimeException("`{0}` is read-only"' name);                  setter(value);                 return value;             });
Magic Number,Mond.Debugger,MondDebugInfo,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugInfo.cs,FindScope,The following statement contains a magic number: _unpackedScopes = new List<List<Scope>>(16);
Magic Number,Mond.Debugger,MondDebugInfo,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Debugger\MondDebugInfo.cs,FindScope,The following statement contains a magic number: _unpackedScopes.Add(new List<Scope>(16));
Magic Number,Mond,MondValue,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondValue.cs,SerializeImpl,The following statement contains a magic number: depth >= 32
Magic Number,Mond.Libraries.Json,JsonModule,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Libraries\Json\Json.cs,SerializeImpl,The following statement contains a magic number: depth >= 32
Magic Number,Mond.Libraries.Json,Parser,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\Libraries\Json\Json.Deserialize.cs,Parser,The following statement contains a magic number: _read = new List<Token>(4);
Magic Number,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,Run,The following statement contains a magic number: switch (code[ip++])                     {                         #region Stack Manipulation                         case (int)InstructionType.Dup:                             {                                 Push(Peek());                                 break;                             }                          case (int)InstructionType.Dup2:                             {                                 var value2 = Pop();                                 var value1 = Pop();                                 Push(value1);                                 Push(value2);                                 Push(value1);                                 Push(value2);                                 break;                             }                          case (int)InstructionType.Drop:                             {                                 Pop();                                 break;                             }                          case (int)InstructionType.Swap:                             {                                 var value1 = Pop();                                 var value2 = Pop();                                 Push(value1);                                 Push(value2);                                 break;                             }                          case (int)InstructionType.Swap1For2:                             {                                 var one = Pop();                                 var two2 = Pop();                                 var two1 = Pop();                                 Push(one);                                 Push(two1);                                 Push(two2);                                 break;                             }                         #endregion                          #region Constants                         case (int)InstructionType.LdUndef:                             {                                 Push(MondValue.Undefined);                                 break;                             }                          case (int)InstructionType.LdNull:                             {                                 Push(MondValue.Null);                                 break;                             }                          case (int)InstructionType.LdTrue:                             {                                 Push(MondValue.True);                                 break;                             }                          case (int)InstructionType.LdFalse:                             {                                 Push(MondValue.False);                                 break;                             }                          case (int)InstructionType.LdNum:                             {                                 var numId = ReadInt32(code' ref ip);                                 Push(program.Numbers[numId]);                                 break;                             }                          case (int)InstructionType.LdStr:                             {                                 var strId = ReadInt32(code' ref ip);                                 Push(program.Strings[strId]);                                 break;                             }                          case (int)InstructionType.LdGlobal:                             {                                 Push(Global);                                 break;                             }                         #endregion                          #region Storables                         case (int)InstructionType.LdLocF:                             {                                 var index = ReadInt32(code' ref ip);                                 Push(locals.Values[index]);                                 break;                             }                          case (int)InstructionType.StLocF:                             {                                 var index = ReadInt32(code' ref ip);                                 locals.Values[index] = Pop();                                 break;                             }                          case (int)InstructionType.LdLoc:                             {                                 var depth = ReadInt32(code' ref ip);                                 var index = ReadInt32(code' ref ip);                                  if (depth < 0)                                     Push(args.Get(-depth' index));                                 else                                     Push(locals.Get(depth' index));                                  break;                             }                          case (int)InstructionType.StLoc:                             {                                 var depth = ReadInt32(code' ref ip);                                 var index = ReadInt32(code' ref ip);                                  if (depth < 0)                                     args.Set(-depth' index' Pop());                                 else                                     locals.Set(depth' index' Pop());                                  break;                             }                          case (int)InstructionType.LdFld:                             {                                 var obj = Pop();                                 Push(obj[program.Strings[ReadInt32(code' ref ip)]]);                                 break;                             }                          case (int)InstructionType.StFld:                             {                                 var obj = Pop();                                 var value = Pop();                                  obj[program.Strings[ReadInt32(code' ref ip)]] = value;                                 break;                             }                          case (int)InstructionType.LdArr:                             {                                 var index = Pop();                                 var array = Pop();                                 Push(array[index]);                                 break;                             }                          case (int)InstructionType.StArr:                             {                                 var index = Pop();                                 var array = Pop();                                 var value = Pop();                                 array[index] = value;                                 break;                             }                          case (int)InstructionType.LdState:                             {                                 var depth = ReadInt32(code' ref ip);                                 var frame = locals.GetFrame(depth);                                 locals = frame.StoredFrame;                                  PopLocal();                                 PushLocal(locals);                                  var evals = frame.StoredEvals;                                 if (evals != null)                                 {                                     for (var i = evals.Count - 1; i >= 0; i--)                                     {                                         Push(evals[i]);                                     }                                      evals.Clear();                                 }                                  break;                             }                          case (int)InstructionType.StState:                             {                                 var depth = ReadInt32(code' ref ip);                                 var frame = locals.GetFrame(depth);                                 frame.StoredFrame = locals;                                  var initialEvals = _callStackSize > 0 ? PeekCall().EvalDepth : 0;                                 var currentEvals = _evalStackSize;                                  if (currentEvals != initialEvals)                                 {                                     var evals = frame.StoredEvals ?? (frame.StoredEvals = new List<MondValue>());                                      while (currentEvals != initialEvals)                                     {                                         evals.Add(Pop());                                         currentEvals--;                                     }                                 }                                  break;                             }                         #endregion                          #region Object Creation                         case (int)InstructionType.NewObject:                             {                                 var obj = new MondValue(_state);                                 Push(obj);                                 break;                             }                          case (int)InstructionType.NewArray:                             {                                 var count = ReadInt32(code' ref ip);                                 var array = new MondValue(MondValueType.Array);                                 array.ArrayValue.Capacity = count;                                  for (var i = 0; i < count; i++)                                     array.ArrayValue.Add(default(MondValue));                                  Push(array);                                 break;                             }                          case (int)InstructionType.Slice:                             {                                 var step = Pop();                                 var end = Pop();                                 var start = Pop();                                 var array = Pop();                                  Push(array.Slice(start' end' step));                                 break;                             }                         #endregion                          #region Math                         case (int)InstructionType.Add:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left + right);                                 break;                             }                          case (int)InstructionType.Sub:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left - right);                                 break;                             }                          case (int)InstructionType.Mul:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left * right);                                 break;                             }                          case (int)InstructionType.Div:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left / right);                                 break;                             }                          case (int)InstructionType.Mod:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left % right);                                 break;                             }                          case (int)InstructionType.Exp:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.Pow(right));                                 break;                             }                          case (int)InstructionType.BitLShift:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.LShift(right));                                 break;                             }                          case (int)InstructionType.BitRShift:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.RShift(right));                                 break;                             }                          case (int)InstructionType.BitAnd:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left & right);                                 break;                             }                          case (int)InstructionType.BitOr:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left | right);                                 break;                             }                          case (int)InstructionType.BitXor:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left ^ right);                                 break;                             }                          case (int)InstructionType.Neg:                             {                                 Push(-Pop());                                 break;                             }                          case (int)InstructionType.BitNot:                             {                                 Push(~Pop());                                 break;                             }                         #endregion                          #region Logic                         case (int)InstructionType.Eq:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left == right);                                 break;                             }                          case (int)InstructionType.Neq:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left != right);                                 break;                             }                          case (int)InstructionType.Gt:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left > right);                                 break;                             }                          case (int)InstructionType.Gte:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left >= right);                                 break;                             }                          case (int)InstructionType.Lt:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left < right);                                 break;                             }                          case (int)InstructionType.Lte:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left <= right);                                 break;                             }                          case (int)InstructionType.Not:                             {                                 Push(!Pop());                                 break;                             }                          case (int)InstructionType.In:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(right.Contains(left));                                 break;                             }                          case (int)InstructionType.NotIn:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(!right.Contains(left));                                 break;                             }                         #endregion                          #region Functions                         case (int)InstructionType.Closure:                             {                                 var address = ReadInt32(code' ref ip);                                 Push(new MondValue(new Closure(program' address' args' locals)));                                 break;                             }                          case (int)InstructionType.Call:                             {                                 var argCount = ReadInt32(code' ref ip);                                 var unpackCount = code[ip++];                                  var function = Pop();                                  List<MondValue> unpackedArgs = null;                                  if (unpackCount > 0)                                     unpackedArgs = UnpackArgs(code' ref ip' argCount' unpackCount);                                  var returnAddress = ip;                                  if (function.Type == MondValueType.Object)                                 {                                     MondValue[] argArr;                                      if (unpackedArgs == null)                                     {                                         argArr = new MondValue[argCount + 1];                                          for (var i = argCount; i >= 1; i--)                                         {                                             argArr[i] = Pop();                                         }                                          argArr[0] = function;                                     }                                     else                                     {                                         unpackedArgs.Insert(0' function);                                         argArr = unpackedArgs.ToArray();                                     }                                      if (function.TryDispatch("__call"' out var result' argArr))                                     {                                         Push(result);                                         break;                                     }                                 }                                  if (function.Type != MondValueType.Function)                                 {                                     var ldFldBase = ip - 1 - 4 - 1 - 4 - 1;                                     if (ldFldBase >= 0 && code[ldFldBase] == (int)InstructionType.LdFld)                                     {                                         var ldFldIdx = ldFldBase + 1;                                         var fieldNameIdx = ReadInt32(code' ref ldFldIdx);                                          if (fieldNameIdx >= 0 && fieldNameIdx < program.Strings.Count)                                         {                                             var fieldName = program.Strings[fieldNameIdx];                                             throw new MondRuntimeException(RuntimeError.FieldNotCallable' (string)fieldName);                                         }                                     }                                      throw new MondRuntimeException(RuntimeError.ValueNotCallable' function.Type.GetName());                                 }                                  var closure = function.FunctionValue;                                  var argFrame = function.FunctionValue.Arguments;                                 var argFrameCount = unpackedArgs?.Count ?? argCount;                                  if (argFrame == null)                                     argFrame = new Frame(1' null' argFrameCount);                                 else                                     argFrame = new Frame(argFrame.Depth + 1' argFrame' argFrameCount);                                  // copy arguments into frame                                 if (unpackedArgs == null)                                 {                                     for (var i = argFrameCount - 1; i >= 0; i--)                                     {                                         argFrame.Values[i] = Pop();                                     }                                 }                                 else                                 {                                     for (var i = 0; i < argFrameCount; i++)                                     {                                         argFrame.Values[i] = unpackedArgs[i];                                     }                                 }                                  switch (closure.Type)                                 {                                     case ClosureType.Mond:                                         PushCall(new ReturnAddress(program' returnAddress' argFrame' _evalStackSize));                                         PushLocal(closure.Locals);                                          program = closure.Program;                                         code = program.Bytecode;                                         ip = closure.Address;                                         args = argFrame;                                         locals = closure.Locals;                                          if (Debugger != null)                                             DebuggerCheckCall();                                          break;                                      case ClosureType.Native:                                         var result = closure.NativeFunction(_state' argFrame.Values);                                         Push(result);                                         break;                                      default:                                         throw new MondRuntimeException(RuntimeError.UnhandledClosureType);                                 }                                  break;                             }                          case (int)InstructionType.TailCall:                             {                                 var argCount = ReadInt32(code' ref ip);                                 var address = ReadInt32(code' ref ip);                                 var unpackCount = code[ip++];                                  List<MondValue> unpackedArgs = null;                                  if (unpackCount > 0)                                     unpackedArgs = UnpackArgs(code' ref ip' argCount' unpackCount);                                  var returnAddress = PopCall();                                 var argFrame = returnAddress.Arguments;                                 var argFrameCount = unpackedArgs?.Count ?? argCount;                                  // make sure we have the correct number of values                                 if (argFrameCount != argFrame.Values.Length)                                     argFrame.Values = new MondValue[argFrameCount];                                  // copy arguments into frame                                 if (unpackedArgs == null)                                 {                                     for (var i = argFrameCount - 1; i >= 0; i--)                                     {                                         argFrame.Values[i] = Pop();                                     }                                 }                                 else                                 {                                     for (var i = 0; i < argFrameCount; i++)                                     {                                         argFrame.Values[i] = unpackedArgs[i];                                     }                                 }                                  // get rid of old locals                                 PushLocal(PopLocal().Previous);                                  PushCall(new ReturnAddress(returnAddress.Program' returnAddress.Address' argFrame' _evalStackSize));                                  ip = address;                                 break;                             }                          case (int)InstructionType.Enter:                             {                                 var localCount = ReadInt32(code' ref ip);                                  var frame = PopLocal();                                 frame = new Frame(frame?.Depth + 1 ?? 0' frame' localCount);                                  PushLocal(frame);                                 locals = frame;                                 break;                             }                          case (int)InstructionType.Leave:                             {                                 var frame = PopLocal();                                 frame = frame.Previous;                                  PushLocal(frame);                                 locals = frame;                                 break;                             }                          case (int)InstructionType.Ret:                             {                                 var returnAddress = PopCall();                                 PopLocal();                                  program = returnAddress.Program;                                 code = program.Bytecode;                                 ip = returnAddress.Address;                                  args = _callStackSize > 0 ? PeekCall().Arguments : null;                                 locals = _localStackSize > 0 ? PeekLocal() : null;                                  if (_callStackSize == initialCallDepth)                                     return Pop();                                  if (Debugger != null && DebuggerCheckReturn())                                     DebuggerBreak(program' locals' args' ip' initialCallDepth);                                  break;                             }                          case (int)InstructionType.VarArgs:                             {                                 var fixedCount = ReadInt32(code' ref ip);                                 var varArgs = new MondValue(MondValueType.Array);                                  for (var i = fixedCount; i < args.Values.Length; i++)                                 {                                     varArgs.ArrayValue.Add(args.Values[i]);                                 }                                  args.Set(args.Depth' fixedCount' varArgs);                                 break;                             }                         #endregion                          #region Branching                         case (int)InstructionType.Jmp:                             {                                 var address = ReadInt32(code' ref ip);                                 ip = address;                                 break;                             }                          case (int)InstructionType.JmpTrueP:                             {                                 var address = ReadInt32(code' ref ip);                                  if (Peek())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpFalseP:                             {                                 var address = ReadInt32(code' ref ip);                                  if (!Peek())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpTrue:                             {                                 var address = ReadInt32(code' ref ip);                                  if (Pop())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpFalse:                             {                                 var address = ReadInt32(code' ref ip);                                  if (!Pop())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpTable:                             {                                 var start = ReadInt32(code' ref ip);                                 var count = ReadInt32(code' ref ip);                                  var endIp = ip + count * 4;                                  var value = Pop();                                 if (value.Type == MondValueType.Number)                                 {                                     var number = (double)value;                                     var numberInt = (int)number;                                      if (number >= start && number < start + count &&                                         Math.Abs(number - numberInt) <= double.Epsilon)                                     {                                         ip += (numberInt - start) * 4;                                         ip = ReadInt32(code' ref ip);                                         break;                                     }                                 }                                  ip = endIp;                                 break;                             }                         #endregion                          case (int)InstructionType.Breakpoint:                             {                                 if (Debugger == null)                                     break;                                  DebuggerBreak(program' locals' args' ip' initialCallDepth);                                  // we stop for the statement *after* the debugger statement so we                                 // skip the next break opportunity' otherwise we break twice                                 _debugSkip = true;                                 break;                             }                          default:                             throw new MondRuntimeException(RuntimeError.UnhandledOpcode);                     }
Magic Number,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,Run,The following statement contains a magic number: switch (code[ip++])                     {                         #region Stack Manipulation                         case (int)InstructionType.Dup:                             {                                 Push(Peek());                                 break;                             }                          case (int)InstructionType.Dup2:                             {                                 var value2 = Pop();                                 var value1 = Pop();                                 Push(value1);                                 Push(value2);                                 Push(value1);                                 Push(value2);                                 break;                             }                          case (int)InstructionType.Drop:                             {                                 Pop();                                 break;                             }                          case (int)InstructionType.Swap:                             {                                 var value1 = Pop();                                 var value2 = Pop();                                 Push(value1);                                 Push(value2);                                 break;                             }                          case (int)InstructionType.Swap1For2:                             {                                 var one = Pop();                                 var two2 = Pop();                                 var two1 = Pop();                                 Push(one);                                 Push(two1);                                 Push(two2);                                 break;                             }                         #endregion                          #region Constants                         case (int)InstructionType.LdUndef:                             {                                 Push(MondValue.Undefined);                                 break;                             }                          case (int)InstructionType.LdNull:                             {                                 Push(MondValue.Null);                                 break;                             }                          case (int)InstructionType.LdTrue:                             {                                 Push(MondValue.True);                                 break;                             }                          case (int)InstructionType.LdFalse:                             {                                 Push(MondValue.False);                                 break;                             }                          case (int)InstructionType.LdNum:                             {                                 var numId = ReadInt32(code' ref ip);                                 Push(program.Numbers[numId]);                                 break;                             }                          case (int)InstructionType.LdStr:                             {                                 var strId = ReadInt32(code' ref ip);                                 Push(program.Strings[strId]);                                 break;                             }                          case (int)InstructionType.LdGlobal:                             {                                 Push(Global);                                 break;                             }                         #endregion                          #region Storables                         case (int)InstructionType.LdLocF:                             {                                 var index = ReadInt32(code' ref ip);                                 Push(locals.Values[index]);                                 break;                             }                          case (int)InstructionType.StLocF:                             {                                 var index = ReadInt32(code' ref ip);                                 locals.Values[index] = Pop();                                 break;                             }                          case (int)InstructionType.LdLoc:                             {                                 var depth = ReadInt32(code' ref ip);                                 var index = ReadInt32(code' ref ip);                                  if (depth < 0)                                     Push(args.Get(-depth' index));                                 else                                     Push(locals.Get(depth' index));                                  break;                             }                          case (int)InstructionType.StLoc:                             {                                 var depth = ReadInt32(code' ref ip);                                 var index = ReadInt32(code' ref ip);                                  if (depth < 0)                                     args.Set(-depth' index' Pop());                                 else                                     locals.Set(depth' index' Pop());                                  break;                             }                          case (int)InstructionType.LdFld:                             {                                 var obj = Pop();                                 Push(obj[program.Strings[ReadInt32(code' ref ip)]]);                                 break;                             }                          case (int)InstructionType.StFld:                             {                                 var obj = Pop();                                 var value = Pop();                                  obj[program.Strings[ReadInt32(code' ref ip)]] = value;                                 break;                             }                          case (int)InstructionType.LdArr:                             {                                 var index = Pop();                                 var array = Pop();                                 Push(array[index]);                                 break;                             }                          case (int)InstructionType.StArr:                             {                                 var index = Pop();                                 var array = Pop();                                 var value = Pop();                                 array[index] = value;                                 break;                             }                          case (int)InstructionType.LdState:                             {                                 var depth = ReadInt32(code' ref ip);                                 var frame = locals.GetFrame(depth);                                 locals = frame.StoredFrame;                                  PopLocal();                                 PushLocal(locals);                                  var evals = frame.StoredEvals;                                 if (evals != null)                                 {                                     for (var i = evals.Count - 1; i >= 0; i--)                                     {                                         Push(evals[i]);                                     }                                      evals.Clear();                                 }                                  break;                             }                          case (int)InstructionType.StState:                             {                                 var depth = ReadInt32(code' ref ip);                                 var frame = locals.GetFrame(depth);                                 frame.StoredFrame = locals;                                  var initialEvals = _callStackSize > 0 ? PeekCall().EvalDepth : 0;                                 var currentEvals = _evalStackSize;                                  if (currentEvals != initialEvals)                                 {                                     var evals = frame.StoredEvals ?? (frame.StoredEvals = new List<MondValue>());                                      while (currentEvals != initialEvals)                                     {                                         evals.Add(Pop());                                         currentEvals--;                                     }                                 }                                  break;                             }                         #endregion                          #region Object Creation                         case (int)InstructionType.NewObject:                             {                                 var obj = new MondValue(_state);                                 Push(obj);                                 break;                             }                          case (int)InstructionType.NewArray:                             {                                 var count = ReadInt32(code' ref ip);                                 var array = new MondValue(MondValueType.Array);                                 array.ArrayValue.Capacity = count;                                  for (var i = 0; i < count; i++)                                     array.ArrayValue.Add(default(MondValue));                                  Push(array);                                 break;                             }                          case (int)InstructionType.Slice:                             {                                 var step = Pop();                                 var end = Pop();                                 var start = Pop();                                 var array = Pop();                                  Push(array.Slice(start' end' step));                                 break;                             }                         #endregion                          #region Math                         case (int)InstructionType.Add:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left + right);                                 break;                             }                          case (int)InstructionType.Sub:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left - right);                                 break;                             }                          case (int)InstructionType.Mul:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left * right);                                 break;                             }                          case (int)InstructionType.Div:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left / right);                                 break;                             }                          case (int)InstructionType.Mod:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left % right);                                 break;                             }                          case (int)InstructionType.Exp:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.Pow(right));                                 break;                             }                          case (int)InstructionType.BitLShift:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.LShift(right));                                 break;                             }                          case (int)InstructionType.BitRShift:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.RShift(right));                                 break;                             }                          case (int)InstructionType.BitAnd:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left & right);                                 break;                             }                          case (int)InstructionType.BitOr:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left | right);                                 break;                             }                          case (int)InstructionType.BitXor:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left ^ right);                                 break;                             }                          case (int)InstructionType.Neg:                             {                                 Push(-Pop());                                 break;                             }                          case (int)InstructionType.BitNot:                             {                                 Push(~Pop());                                 break;                             }                         #endregion                          #region Logic                         case (int)InstructionType.Eq:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left == right);                                 break;                             }                          case (int)InstructionType.Neq:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left != right);                                 break;                             }                          case (int)InstructionType.Gt:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left > right);                                 break;                             }                          case (int)InstructionType.Gte:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left >= right);                                 break;                             }                          case (int)InstructionType.Lt:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left < right);                                 break;                             }                          case (int)InstructionType.Lte:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left <= right);                                 break;                             }                          case (int)InstructionType.Not:                             {                                 Push(!Pop());                                 break;                             }                          case (int)InstructionType.In:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(right.Contains(left));                                 break;                             }                          case (int)InstructionType.NotIn:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(!right.Contains(left));                                 break;                             }                         #endregion                          #region Functions                         case (int)InstructionType.Closure:                             {                                 var address = ReadInt32(code' ref ip);                                 Push(new MondValue(new Closure(program' address' args' locals)));                                 break;                             }                          case (int)InstructionType.Call:                             {                                 var argCount = ReadInt32(code' ref ip);                                 var unpackCount = code[ip++];                                  var function = Pop();                                  List<MondValue> unpackedArgs = null;                                  if (unpackCount > 0)                                     unpackedArgs = UnpackArgs(code' ref ip' argCount' unpackCount);                                  var returnAddress = ip;                                  if (function.Type == MondValueType.Object)                                 {                                     MondValue[] argArr;                                      if (unpackedArgs == null)                                     {                                         argArr = new MondValue[argCount + 1];                                          for (var i = argCount; i >= 1; i--)                                         {                                             argArr[i] = Pop();                                         }                                          argArr[0] = function;                                     }                                     else                                     {                                         unpackedArgs.Insert(0' function);                                         argArr = unpackedArgs.ToArray();                                     }                                      if (function.TryDispatch("__call"' out var result' argArr))                                     {                                         Push(result);                                         break;                                     }                                 }                                  if (function.Type != MondValueType.Function)                                 {                                     var ldFldBase = ip - 1 - 4 - 1 - 4 - 1;                                     if (ldFldBase >= 0 && code[ldFldBase] == (int)InstructionType.LdFld)                                     {                                         var ldFldIdx = ldFldBase + 1;                                         var fieldNameIdx = ReadInt32(code' ref ldFldIdx);                                          if (fieldNameIdx >= 0 && fieldNameIdx < program.Strings.Count)                                         {                                             var fieldName = program.Strings[fieldNameIdx];                                             throw new MondRuntimeException(RuntimeError.FieldNotCallable' (string)fieldName);                                         }                                     }                                      throw new MondRuntimeException(RuntimeError.ValueNotCallable' function.Type.GetName());                                 }                                  var closure = function.FunctionValue;                                  var argFrame = function.FunctionValue.Arguments;                                 var argFrameCount = unpackedArgs?.Count ?? argCount;                                  if (argFrame == null)                                     argFrame = new Frame(1' null' argFrameCount);                                 else                                     argFrame = new Frame(argFrame.Depth + 1' argFrame' argFrameCount);                                  // copy arguments into frame                                 if (unpackedArgs == null)                                 {                                     for (var i = argFrameCount - 1; i >= 0; i--)                                     {                                         argFrame.Values[i] = Pop();                                     }                                 }                                 else                                 {                                     for (var i = 0; i < argFrameCount; i++)                                     {                                         argFrame.Values[i] = unpackedArgs[i];                                     }                                 }                                  switch (closure.Type)                                 {                                     case ClosureType.Mond:                                         PushCall(new ReturnAddress(program' returnAddress' argFrame' _evalStackSize));                                         PushLocal(closure.Locals);                                          program = closure.Program;                                         code = program.Bytecode;                                         ip = closure.Address;                                         args = argFrame;                                         locals = closure.Locals;                                          if (Debugger != null)                                             DebuggerCheckCall();                                          break;                                      case ClosureType.Native:                                         var result = closure.NativeFunction(_state' argFrame.Values);                                         Push(result);                                         break;                                      default:                                         throw new MondRuntimeException(RuntimeError.UnhandledClosureType);                                 }                                  break;                             }                          case (int)InstructionType.TailCall:                             {                                 var argCount = ReadInt32(code' ref ip);                                 var address = ReadInt32(code' ref ip);                                 var unpackCount = code[ip++];                                  List<MondValue> unpackedArgs = null;                                  if (unpackCount > 0)                                     unpackedArgs = UnpackArgs(code' ref ip' argCount' unpackCount);                                  var returnAddress = PopCall();                                 var argFrame = returnAddress.Arguments;                                 var argFrameCount = unpackedArgs?.Count ?? argCount;                                  // make sure we have the correct number of values                                 if (argFrameCount != argFrame.Values.Length)                                     argFrame.Values = new MondValue[argFrameCount];                                  // copy arguments into frame                                 if (unpackedArgs == null)                                 {                                     for (var i = argFrameCount - 1; i >= 0; i--)                                     {                                         argFrame.Values[i] = Pop();                                     }                                 }                                 else                                 {                                     for (var i = 0; i < argFrameCount; i++)                                     {                                         argFrame.Values[i] = unpackedArgs[i];                                     }                                 }                                  // get rid of old locals                                 PushLocal(PopLocal().Previous);                                  PushCall(new ReturnAddress(returnAddress.Program' returnAddress.Address' argFrame' _evalStackSize));                                  ip = address;                                 break;                             }                          case (int)InstructionType.Enter:                             {                                 var localCount = ReadInt32(code' ref ip);                                  var frame = PopLocal();                                 frame = new Frame(frame?.Depth + 1 ?? 0' frame' localCount);                                  PushLocal(frame);                                 locals = frame;                                 break;                             }                          case (int)InstructionType.Leave:                             {                                 var frame = PopLocal();                                 frame = frame.Previous;                                  PushLocal(frame);                                 locals = frame;                                 break;                             }                          case (int)InstructionType.Ret:                             {                                 var returnAddress = PopCall();                                 PopLocal();                                  program = returnAddress.Program;                                 code = program.Bytecode;                                 ip = returnAddress.Address;                                  args = _callStackSize > 0 ? PeekCall().Arguments : null;                                 locals = _localStackSize > 0 ? PeekLocal() : null;                                  if (_callStackSize == initialCallDepth)                                     return Pop();                                  if (Debugger != null && DebuggerCheckReturn())                                     DebuggerBreak(program' locals' args' ip' initialCallDepth);                                  break;                             }                          case (int)InstructionType.VarArgs:                             {                                 var fixedCount = ReadInt32(code' ref ip);                                 var varArgs = new MondValue(MondValueType.Array);                                  for (var i = fixedCount; i < args.Values.Length; i++)                                 {                                     varArgs.ArrayValue.Add(args.Values[i]);                                 }                                  args.Set(args.Depth' fixedCount' varArgs);                                 break;                             }                         #endregion                          #region Branching                         case (int)InstructionType.Jmp:                             {                                 var address = ReadInt32(code' ref ip);                                 ip = address;                                 break;                             }                          case (int)InstructionType.JmpTrueP:                             {                                 var address = ReadInt32(code' ref ip);                                  if (Peek())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpFalseP:                             {                                 var address = ReadInt32(code' ref ip);                                  if (!Peek())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpTrue:                             {                                 var address = ReadInt32(code' ref ip);                                  if (Pop())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpFalse:                             {                                 var address = ReadInt32(code' ref ip);                                  if (!Pop())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpTable:                             {                                 var start = ReadInt32(code' ref ip);                                 var count = ReadInt32(code' ref ip);                                  var endIp = ip + count * 4;                                  var value = Pop();                                 if (value.Type == MondValueType.Number)                                 {                                     var number = (double)value;                                     var numberInt = (int)number;                                      if (number >= start && number < start + count &&                                         Math.Abs(number - numberInt) <= double.Epsilon)                                     {                                         ip += (numberInt - start) * 4;                                         ip = ReadInt32(code' ref ip);                                         break;                                     }                                 }                                  ip = endIp;                                 break;                             }                         #endregion                          case (int)InstructionType.Breakpoint:                             {                                 if (Debugger == null)                                     break;                                  DebuggerBreak(program' locals' args' ip' initialCallDepth);                                  // we stop for the statement *after* the debugger statement so we                                 // skip the next break opportunity' otherwise we break twice                                 _debugSkip = true;                                 break;                             }                          default:                             throw new MondRuntimeException(RuntimeError.UnhandledOpcode);                     }
Magic Number,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,Run,The following statement contains a magic number: switch (code[ip++])                     {                         #region Stack Manipulation                         case (int)InstructionType.Dup:                             {                                 Push(Peek());                                 break;                             }                          case (int)InstructionType.Dup2:                             {                                 var value2 = Pop();                                 var value1 = Pop();                                 Push(value1);                                 Push(value2);                                 Push(value1);                                 Push(value2);                                 break;                             }                          case (int)InstructionType.Drop:                             {                                 Pop();                                 break;                             }                          case (int)InstructionType.Swap:                             {                                 var value1 = Pop();                                 var value2 = Pop();                                 Push(value1);                                 Push(value2);                                 break;                             }                          case (int)InstructionType.Swap1For2:                             {                                 var one = Pop();                                 var two2 = Pop();                                 var two1 = Pop();                                 Push(one);                                 Push(two1);                                 Push(two2);                                 break;                             }                         #endregion                          #region Constants                         case (int)InstructionType.LdUndef:                             {                                 Push(MondValue.Undefined);                                 break;                             }                          case (int)InstructionType.LdNull:                             {                                 Push(MondValue.Null);                                 break;                             }                          case (int)InstructionType.LdTrue:                             {                                 Push(MondValue.True);                                 break;                             }                          case (int)InstructionType.LdFalse:                             {                                 Push(MondValue.False);                                 break;                             }                          case (int)InstructionType.LdNum:                             {                                 var numId = ReadInt32(code' ref ip);                                 Push(program.Numbers[numId]);                                 break;                             }                          case (int)InstructionType.LdStr:                             {                                 var strId = ReadInt32(code' ref ip);                                 Push(program.Strings[strId]);                                 break;                             }                          case (int)InstructionType.LdGlobal:                             {                                 Push(Global);                                 break;                             }                         #endregion                          #region Storables                         case (int)InstructionType.LdLocF:                             {                                 var index = ReadInt32(code' ref ip);                                 Push(locals.Values[index]);                                 break;                             }                          case (int)InstructionType.StLocF:                             {                                 var index = ReadInt32(code' ref ip);                                 locals.Values[index] = Pop();                                 break;                             }                          case (int)InstructionType.LdLoc:                             {                                 var depth = ReadInt32(code' ref ip);                                 var index = ReadInt32(code' ref ip);                                  if (depth < 0)                                     Push(args.Get(-depth' index));                                 else                                     Push(locals.Get(depth' index));                                  break;                             }                          case (int)InstructionType.StLoc:                             {                                 var depth = ReadInt32(code' ref ip);                                 var index = ReadInt32(code' ref ip);                                  if (depth < 0)                                     args.Set(-depth' index' Pop());                                 else                                     locals.Set(depth' index' Pop());                                  break;                             }                          case (int)InstructionType.LdFld:                             {                                 var obj = Pop();                                 Push(obj[program.Strings[ReadInt32(code' ref ip)]]);                                 break;                             }                          case (int)InstructionType.StFld:                             {                                 var obj = Pop();                                 var value = Pop();                                  obj[program.Strings[ReadInt32(code' ref ip)]] = value;                                 break;                             }                          case (int)InstructionType.LdArr:                             {                                 var index = Pop();                                 var array = Pop();                                 Push(array[index]);                                 break;                             }                          case (int)InstructionType.StArr:                             {                                 var index = Pop();                                 var array = Pop();                                 var value = Pop();                                 array[index] = value;                                 break;                             }                          case (int)InstructionType.LdState:                             {                                 var depth = ReadInt32(code' ref ip);                                 var frame = locals.GetFrame(depth);                                 locals = frame.StoredFrame;                                  PopLocal();                                 PushLocal(locals);                                  var evals = frame.StoredEvals;                                 if (evals != null)                                 {                                     for (var i = evals.Count - 1; i >= 0; i--)                                     {                                         Push(evals[i]);                                     }                                      evals.Clear();                                 }                                  break;                             }                          case (int)InstructionType.StState:                             {                                 var depth = ReadInt32(code' ref ip);                                 var frame = locals.GetFrame(depth);                                 frame.StoredFrame = locals;                                  var initialEvals = _callStackSize > 0 ? PeekCall().EvalDepth : 0;                                 var currentEvals = _evalStackSize;                                  if (currentEvals != initialEvals)                                 {                                     var evals = frame.StoredEvals ?? (frame.StoredEvals = new List<MondValue>());                                      while (currentEvals != initialEvals)                                     {                                         evals.Add(Pop());                                         currentEvals--;                                     }                                 }                                  break;                             }                         #endregion                          #region Object Creation                         case (int)InstructionType.NewObject:                             {                                 var obj = new MondValue(_state);                                 Push(obj);                                 break;                             }                          case (int)InstructionType.NewArray:                             {                                 var count = ReadInt32(code' ref ip);                                 var array = new MondValue(MondValueType.Array);                                 array.ArrayValue.Capacity = count;                                  for (var i = 0; i < count; i++)                                     array.ArrayValue.Add(default(MondValue));                                  Push(array);                                 break;                             }                          case (int)InstructionType.Slice:                             {                                 var step = Pop();                                 var end = Pop();                                 var start = Pop();                                 var array = Pop();                                  Push(array.Slice(start' end' step));                                 break;                             }                         #endregion                          #region Math                         case (int)InstructionType.Add:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left + right);                                 break;                             }                          case (int)InstructionType.Sub:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left - right);                                 break;                             }                          case (int)InstructionType.Mul:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left * right);                                 break;                             }                          case (int)InstructionType.Div:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left / right);                                 break;                             }                          case (int)InstructionType.Mod:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left % right);                                 break;                             }                          case (int)InstructionType.Exp:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.Pow(right));                                 break;                             }                          case (int)InstructionType.BitLShift:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.LShift(right));                                 break;                             }                          case (int)InstructionType.BitRShift:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.RShift(right));                                 break;                             }                          case (int)InstructionType.BitAnd:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left & right);                                 break;                             }                          case (int)InstructionType.BitOr:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left | right);                                 break;                             }                          case (int)InstructionType.BitXor:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left ^ right);                                 break;                             }                          case (int)InstructionType.Neg:                             {                                 Push(-Pop());                                 break;                             }                          case (int)InstructionType.BitNot:                             {                                 Push(~Pop());                                 break;                             }                         #endregion                          #region Logic                         case (int)InstructionType.Eq:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left == right);                                 break;                             }                          case (int)InstructionType.Neq:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left != right);                                 break;                             }                          case (int)InstructionType.Gt:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left > right);                                 break;                             }                          case (int)InstructionType.Gte:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left >= right);                                 break;                             }                          case (int)InstructionType.Lt:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left < right);                                 break;                             }                          case (int)InstructionType.Lte:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left <= right);                                 break;                             }                          case (int)InstructionType.Not:                             {                                 Push(!Pop());                                 break;                             }                          case (int)InstructionType.In:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(right.Contains(left));                                 break;                             }                          case (int)InstructionType.NotIn:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(!right.Contains(left));                                 break;                             }                         #endregion                          #region Functions                         case (int)InstructionType.Closure:                             {                                 var address = ReadInt32(code' ref ip);                                 Push(new MondValue(new Closure(program' address' args' locals)));                                 break;                             }                          case (int)InstructionType.Call:                             {                                 var argCount = ReadInt32(code' ref ip);                                 var unpackCount = code[ip++];                                  var function = Pop();                                  List<MondValue> unpackedArgs = null;                                  if (unpackCount > 0)                                     unpackedArgs = UnpackArgs(code' ref ip' argCount' unpackCount);                                  var returnAddress = ip;                                  if (function.Type == MondValueType.Object)                                 {                                     MondValue[] argArr;                                      if (unpackedArgs == null)                                     {                                         argArr = new MondValue[argCount + 1];                                          for (var i = argCount; i >= 1; i--)                                         {                                             argArr[i] = Pop();                                         }                                          argArr[0] = function;                                     }                                     else                                     {                                         unpackedArgs.Insert(0' function);                                         argArr = unpackedArgs.ToArray();                                     }                                      if (function.TryDispatch("__call"' out var result' argArr))                                     {                                         Push(result);                                         break;                                     }                                 }                                  if (function.Type != MondValueType.Function)                                 {                                     var ldFldBase = ip - 1 - 4 - 1 - 4 - 1;                                     if (ldFldBase >= 0 && code[ldFldBase] == (int)InstructionType.LdFld)                                     {                                         var ldFldIdx = ldFldBase + 1;                                         var fieldNameIdx = ReadInt32(code' ref ldFldIdx);                                          if (fieldNameIdx >= 0 && fieldNameIdx < program.Strings.Count)                                         {                                             var fieldName = program.Strings[fieldNameIdx];                                             throw new MondRuntimeException(RuntimeError.FieldNotCallable' (string)fieldName);                                         }                                     }                                      throw new MondRuntimeException(RuntimeError.ValueNotCallable' function.Type.GetName());                                 }                                  var closure = function.FunctionValue;                                  var argFrame = function.FunctionValue.Arguments;                                 var argFrameCount = unpackedArgs?.Count ?? argCount;                                  if (argFrame == null)                                     argFrame = new Frame(1' null' argFrameCount);                                 else                                     argFrame = new Frame(argFrame.Depth + 1' argFrame' argFrameCount);                                  // copy arguments into frame                                 if (unpackedArgs == null)                                 {                                     for (var i = argFrameCount - 1; i >= 0; i--)                                     {                                         argFrame.Values[i] = Pop();                                     }                                 }                                 else                                 {                                     for (var i = 0; i < argFrameCount; i++)                                     {                                         argFrame.Values[i] = unpackedArgs[i];                                     }                                 }                                  switch (closure.Type)                                 {                                     case ClosureType.Mond:                                         PushCall(new ReturnAddress(program' returnAddress' argFrame' _evalStackSize));                                         PushLocal(closure.Locals);                                          program = closure.Program;                                         code = program.Bytecode;                                         ip = closure.Address;                                         args = argFrame;                                         locals = closure.Locals;                                          if (Debugger != null)                                             DebuggerCheckCall();                                          break;                                      case ClosureType.Native:                                         var result = closure.NativeFunction(_state' argFrame.Values);                                         Push(result);                                         break;                                      default:                                         throw new MondRuntimeException(RuntimeError.UnhandledClosureType);                                 }                                  break;                             }                          case (int)InstructionType.TailCall:                             {                                 var argCount = ReadInt32(code' ref ip);                                 var address = ReadInt32(code' ref ip);                                 var unpackCount = code[ip++];                                  List<MondValue> unpackedArgs = null;                                  if (unpackCount > 0)                                     unpackedArgs = UnpackArgs(code' ref ip' argCount' unpackCount);                                  var returnAddress = PopCall();                                 var argFrame = returnAddress.Arguments;                                 var argFrameCount = unpackedArgs?.Count ?? argCount;                                  // make sure we have the correct number of values                                 if (argFrameCount != argFrame.Values.Length)                                     argFrame.Values = new MondValue[argFrameCount];                                  // copy arguments into frame                                 if (unpackedArgs == null)                                 {                                     for (var i = argFrameCount - 1; i >= 0; i--)                                     {                                         argFrame.Values[i] = Pop();                                     }                                 }                                 else                                 {                                     for (var i = 0; i < argFrameCount; i++)                                     {                                         argFrame.Values[i] = unpackedArgs[i];                                     }                                 }                                  // get rid of old locals                                 PushLocal(PopLocal().Previous);                                  PushCall(new ReturnAddress(returnAddress.Program' returnAddress.Address' argFrame' _evalStackSize));                                  ip = address;                                 break;                             }                          case (int)InstructionType.Enter:                             {                                 var localCount = ReadInt32(code' ref ip);                                  var frame = PopLocal();                                 frame = new Frame(frame?.Depth + 1 ?? 0' frame' localCount);                                  PushLocal(frame);                                 locals = frame;                                 break;                             }                          case (int)InstructionType.Leave:                             {                                 var frame = PopLocal();                                 frame = frame.Previous;                                  PushLocal(frame);                                 locals = frame;                                 break;                             }                          case (int)InstructionType.Ret:                             {                                 var returnAddress = PopCall();                                 PopLocal();                                  program = returnAddress.Program;                                 code = program.Bytecode;                                 ip = returnAddress.Address;                                  args = _callStackSize > 0 ? PeekCall().Arguments : null;                                 locals = _localStackSize > 0 ? PeekLocal() : null;                                  if (_callStackSize == initialCallDepth)                                     return Pop();                                  if (Debugger != null && DebuggerCheckReturn())                                     DebuggerBreak(program' locals' args' ip' initialCallDepth);                                  break;                             }                          case (int)InstructionType.VarArgs:                             {                                 var fixedCount = ReadInt32(code' ref ip);                                 var varArgs = new MondValue(MondValueType.Array);                                  for (var i = fixedCount; i < args.Values.Length; i++)                                 {                                     varArgs.ArrayValue.Add(args.Values[i]);                                 }                                  args.Set(args.Depth' fixedCount' varArgs);                                 break;                             }                         #endregion                          #region Branching                         case (int)InstructionType.Jmp:                             {                                 var address = ReadInt32(code' ref ip);                                 ip = address;                                 break;                             }                          case (int)InstructionType.JmpTrueP:                             {                                 var address = ReadInt32(code' ref ip);                                  if (Peek())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpFalseP:                             {                                 var address = ReadInt32(code' ref ip);                                  if (!Peek())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpTrue:                             {                                 var address = ReadInt32(code' ref ip);                                  if (Pop())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpFalse:                             {                                 var address = ReadInt32(code' ref ip);                                  if (!Pop())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpTable:                             {                                 var start = ReadInt32(code' ref ip);                                 var count = ReadInt32(code' ref ip);                                  var endIp = ip + count * 4;                                  var value = Pop();                                 if (value.Type == MondValueType.Number)                                 {                                     var number = (double)value;                                     var numberInt = (int)number;                                      if (number >= start && number < start + count &&                                         Math.Abs(number - numberInt) <= double.Epsilon)                                     {                                         ip += (numberInt - start) * 4;                                         ip = ReadInt32(code' ref ip);                                         break;                                     }                                 }                                  ip = endIp;                                 break;                             }                         #endregion                          case (int)InstructionType.Breakpoint:                             {                                 if (Debugger == null)                                     break;                                  DebuggerBreak(program' locals' args' ip' initialCallDepth);                                  // we stop for the statement *after* the debugger statement so we                                 // skip the next break opportunity' otherwise we break twice                                 _debugSkip = true;                                 break;                             }                          default:                             throw new MondRuntimeException(RuntimeError.UnhandledOpcode);                     }
Magic Number,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,Run,The following statement contains a magic number: switch (code[ip++])                     {                         #region Stack Manipulation                         case (int)InstructionType.Dup:                             {                                 Push(Peek());                                 break;                             }                          case (int)InstructionType.Dup2:                             {                                 var value2 = Pop();                                 var value1 = Pop();                                 Push(value1);                                 Push(value2);                                 Push(value1);                                 Push(value2);                                 break;                             }                          case (int)InstructionType.Drop:                             {                                 Pop();                                 break;                             }                          case (int)InstructionType.Swap:                             {                                 var value1 = Pop();                                 var value2 = Pop();                                 Push(value1);                                 Push(value2);                                 break;                             }                          case (int)InstructionType.Swap1For2:                             {                                 var one = Pop();                                 var two2 = Pop();                                 var two1 = Pop();                                 Push(one);                                 Push(two1);                                 Push(two2);                                 break;                             }                         #endregion                          #region Constants                         case (int)InstructionType.LdUndef:                             {                                 Push(MondValue.Undefined);                                 break;                             }                          case (int)InstructionType.LdNull:                             {                                 Push(MondValue.Null);                                 break;                             }                          case (int)InstructionType.LdTrue:                             {                                 Push(MondValue.True);                                 break;                             }                          case (int)InstructionType.LdFalse:                             {                                 Push(MondValue.False);                                 break;                             }                          case (int)InstructionType.LdNum:                             {                                 var numId = ReadInt32(code' ref ip);                                 Push(program.Numbers[numId]);                                 break;                             }                          case (int)InstructionType.LdStr:                             {                                 var strId = ReadInt32(code' ref ip);                                 Push(program.Strings[strId]);                                 break;                             }                          case (int)InstructionType.LdGlobal:                             {                                 Push(Global);                                 break;                             }                         #endregion                          #region Storables                         case (int)InstructionType.LdLocF:                             {                                 var index = ReadInt32(code' ref ip);                                 Push(locals.Values[index]);                                 break;                             }                          case (int)InstructionType.StLocF:                             {                                 var index = ReadInt32(code' ref ip);                                 locals.Values[index] = Pop();                                 break;                             }                          case (int)InstructionType.LdLoc:                             {                                 var depth = ReadInt32(code' ref ip);                                 var index = ReadInt32(code' ref ip);                                  if (depth < 0)                                     Push(args.Get(-depth' index));                                 else                                     Push(locals.Get(depth' index));                                  break;                             }                          case (int)InstructionType.StLoc:                             {                                 var depth = ReadInt32(code' ref ip);                                 var index = ReadInt32(code' ref ip);                                  if (depth < 0)                                     args.Set(-depth' index' Pop());                                 else                                     locals.Set(depth' index' Pop());                                  break;                             }                          case (int)InstructionType.LdFld:                             {                                 var obj = Pop();                                 Push(obj[program.Strings[ReadInt32(code' ref ip)]]);                                 break;                             }                          case (int)InstructionType.StFld:                             {                                 var obj = Pop();                                 var value = Pop();                                  obj[program.Strings[ReadInt32(code' ref ip)]] = value;                                 break;                             }                          case (int)InstructionType.LdArr:                             {                                 var index = Pop();                                 var array = Pop();                                 Push(array[index]);                                 break;                             }                          case (int)InstructionType.StArr:                             {                                 var index = Pop();                                 var array = Pop();                                 var value = Pop();                                 array[index] = value;                                 break;                             }                          case (int)InstructionType.LdState:                             {                                 var depth = ReadInt32(code' ref ip);                                 var frame = locals.GetFrame(depth);                                 locals = frame.StoredFrame;                                  PopLocal();                                 PushLocal(locals);                                  var evals = frame.StoredEvals;                                 if (evals != null)                                 {                                     for (var i = evals.Count - 1; i >= 0; i--)                                     {                                         Push(evals[i]);                                     }                                      evals.Clear();                                 }                                  break;                             }                          case (int)InstructionType.StState:                             {                                 var depth = ReadInt32(code' ref ip);                                 var frame = locals.GetFrame(depth);                                 frame.StoredFrame = locals;                                  var initialEvals = _callStackSize > 0 ? PeekCall().EvalDepth : 0;                                 var currentEvals = _evalStackSize;                                  if (currentEvals != initialEvals)                                 {                                     var evals = frame.StoredEvals ?? (frame.StoredEvals = new List<MondValue>());                                      while (currentEvals != initialEvals)                                     {                                         evals.Add(Pop());                                         currentEvals--;                                     }                                 }                                  break;                             }                         #endregion                          #region Object Creation                         case (int)InstructionType.NewObject:                             {                                 var obj = new MondValue(_state);                                 Push(obj);                                 break;                             }                          case (int)InstructionType.NewArray:                             {                                 var count = ReadInt32(code' ref ip);                                 var array = new MondValue(MondValueType.Array);                                 array.ArrayValue.Capacity = count;                                  for (var i = 0; i < count; i++)                                     array.ArrayValue.Add(default(MondValue));                                  Push(array);                                 break;                             }                          case (int)InstructionType.Slice:                             {                                 var step = Pop();                                 var end = Pop();                                 var start = Pop();                                 var array = Pop();                                  Push(array.Slice(start' end' step));                                 break;                             }                         #endregion                          #region Math                         case (int)InstructionType.Add:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left + right);                                 break;                             }                          case (int)InstructionType.Sub:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left - right);                                 break;                             }                          case (int)InstructionType.Mul:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left * right);                                 break;                             }                          case (int)InstructionType.Div:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left / right);                                 break;                             }                          case (int)InstructionType.Mod:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left % right);                                 break;                             }                          case (int)InstructionType.Exp:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.Pow(right));                                 break;                             }                          case (int)InstructionType.BitLShift:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.LShift(right));                                 break;                             }                          case (int)InstructionType.BitRShift:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left.RShift(right));                                 break;                             }                          case (int)InstructionType.BitAnd:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left & right);                                 break;                             }                          case (int)InstructionType.BitOr:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left | right);                                 break;                             }                          case (int)InstructionType.BitXor:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left ^ right);                                 break;                             }                          case (int)InstructionType.Neg:                             {                                 Push(-Pop());                                 break;                             }                          case (int)InstructionType.BitNot:                             {                                 Push(~Pop());                                 break;                             }                         #endregion                          #region Logic                         case (int)InstructionType.Eq:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left == right);                                 break;                             }                          case (int)InstructionType.Neq:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left != right);                                 break;                             }                          case (int)InstructionType.Gt:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left > right);                                 break;                             }                          case (int)InstructionType.Gte:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left >= right);                                 break;                             }                          case (int)InstructionType.Lt:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left < right);                                 break;                             }                          case (int)InstructionType.Lte:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(left <= right);                                 break;                             }                          case (int)InstructionType.Not:                             {                                 Push(!Pop());                                 break;                             }                          case (int)InstructionType.In:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(right.Contains(left));                                 break;                             }                          case (int)InstructionType.NotIn:                             {                                 var right = Pop();                                 var left = Pop();                                 Push(!right.Contains(left));                                 break;                             }                         #endregion                          #region Functions                         case (int)InstructionType.Closure:                             {                                 var address = ReadInt32(code' ref ip);                                 Push(new MondValue(new Closure(program' address' args' locals)));                                 break;                             }                          case (int)InstructionType.Call:                             {                                 var argCount = ReadInt32(code' ref ip);                                 var unpackCount = code[ip++];                                  var function = Pop();                                  List<MondValue> unpackedArgs = null;                                  if (unpackCount > 0)                                     unpackedArgs = UnpackArgs(code' ref ip' argCount' unpackCount);                                  var returnAddress = ip;                                  if (function.Type == MondValueType.Object)                                 {                                     MondValue[] argArr;                                      if (unpackedArgs == null)                                     {                                         argArr = new MondValue[argCount + 1];                                          for (var i = argCount; i >= 1; i--)                                         {                                             argArr[i] = Pop();                                         }                                          argArr[0] = function;                                     }                                     else                                     {                                         unpackedArgs.Insert(0' function);                                         argArr = unpackedArgs.ToArray();                                     }                                      if (function.TryDispatch("__call"' out var result' argArr))                                     {                                         Push(result);                                         break;                                     }                                 }                                  if (function.Type != MondValueType.Function)                                 {                                     var ldFldBase = ip - 1 - 4 - 1 - 4 - 1;                                     if (ldFldBase >= 0 && code[ldFldBase] == (int)InstructionType.LdFld)                                     {                                         var ldFldIdx = ldFldBase + 1;                                         var fieldNameIdx = ReadInt32(code' ref ldFldIdx);                                          if (fieldNameIdx >= 0 && fieldNameIdx < program.Strings.Count)                                         {                                             var fieldName = program.Strings[fieldNameIdx];                                             throw new MondRuntimeException(RuntimeError.FieldNotCallable' (string)fieldName);                                         }                                     }                                      throw new MondRuntimeException(RuntimeError.ValueNotCallable' function.Type.GetName());                                 }                                  var closure = function.FunctionValue;                                  var argFrame = function.FunctionValue.Arguments;                                 var argFrameCount = unpackedArgs?.Count ?? argCount;                                  if (argFrame == null)                                     argFrame = new Frame(1' null' argFrameCount);                                 else                                     argFrame = new Frame(argFrame.Depth + 1' argFrame' argFrameCount);                                  // copy arguments into frame                                 if (unpackedArgs == null)                                 {                                     for (var i = argFrameCount - 1; i >= 0; i--)                                     {                                         argFrame.Values[i] = Pop();                                     }                                 }                                 else                                 {                                     for (var i = 0; i < argFrameCount; i++)                                     {                                         argFrame.Values[i] = unpackedArgs[i];                                     }                                 }                                  switch (closure.Type)                                 {                                     case ClosureType.Mond:                                         PushCall(new ReturnAddress(program' returnAddress' argFrame' _evalStackSize));                                         PushLocal(closure.Locals);                                          program = closure.Program;                                         code = program.Bytecode;                                         ip = closure.Address;                                         args = argFrame;                                         locals = closure.Locals;                                          if (Debugger != null)                                             DebuggerCheckCall();                                          break;                                      case ClosureType.Native:                                         var result = closure.NativeFunction(_state' argFrame.Values);                                         Push(result);                                         break;                                      default:                                         throw new MondRuntimeException(RuntimeError.UnhandledClosureType);                                 }                                  break;                             }                          case (int)InstructionType.TailCall:                             {                                 var argCount = ReadInt32(code' ref ip);                                 var address = ReadInt32(code' ref ip);                                 var unpackCount = code[ip++];                                  List<MondValue> unpackedArgs = null;                                  if (unpackCount > 0)                                     unpackedArgs = UnpackArgs(code' ref ip' argCount' unpackCount);                                  var returnAddress = PopCall();                                 var argFrame = returnAddress.Arguments;                                 var argFrameCount = unpackedArgs?.Count ?? argCount;                                  // make sure we have the correct number of values                                 if (argFrameCount != argFrame.Values.Length)                                     argFrame.Values = new MondValue[argFrameCount];                                  // copy arguments into frame                                 if (unpackedArgs == null)                                 {                                     for (var i = argFrameCount - 1; i >= 0; i--)                                     {                                         argFrame.Values[i] = Pop();                                     }                                 }                                 else                                 {                                     for (var i = 0; i < argFrameCount; i++)                                     {                                         argFrame.Values[i] = unpackedArgs[i];                                     }                                 }                                  // get rid of old locals                                 PushLocal(PopLocal().Previous);                                  PushCall(new ReturnAddress(returnAddress.Program' returnAddress.Address' argFrame' _evalStackSize));                                  ip = address;                                 break;                             }                          case (int)InstructionType.Enter:                             {                                 var localCount = ReadInt32(code' ref ip);                                  var frame = PopLocal();                                 frame = new Frame(frame?.Depth + 1 ?? 0' frame' localCount);                                  PushLocal(frame);                                 locals = frame;                                 break;                             }                          case (int)InstructionType.Leave:                             {                                 var frame = PopLocal();                                 frame = frame.Previous;                                  PushLocal(frame);                                 locals = frame;                                 break;                             }                          case (int)InstructionType.Ret:                             {                                 var returnAddress = PopCall();                                 PopLocal();                                  program = returnAddress.Program;                                 code = program.Bytecode;                                 ip = returnAddress.Address;                                  args = _callStackSize > 0 ? PeekCall().Arguments : null;                                 locals = _localStackSize > 0 ? PeekLocal() : null;                                  if (_callStackSize == initialCallDepth)                                     return Pop();                                  if (Debugger != null && DebuggerCheckReturn())                                     DebuggerBreak(program' locals' args' ip' initialCallDepth);                                  break;                             }                          case (int)InstructionType.VarArgs:                             {                                 var fixedCount = ReadInt32(code' ref ip);                                 var varArgs = new MondValue(MondValueType.Array);                                  for (var i = fixedCount; i < args.Values.Length; i++)                                 {                                     varArgs.ArrayValue.Add(args.Values[i]);                                 }                                  args.Set(args.Depth' fixedCount' varArgs);                                 break;                             }                         #endregion                          #region Branching                         case (int)InstructionType.Jmp:                             {                                 var address = ReadInt32(code' ref ip);                                 ip = address;                                 break;                             }                          case (int)InstructionType.JmpTrueP:                             {                                 var address = ReadInt32(code' ref ip);                                  if (Peek())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpFalseP:                             {                                 var address = ReadInt32(code' ref ip);                                  if (!Peek())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpTrue:                             {                                 var address = ReadInt32(code' ref ip);                                  if (Pop())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpFalse:                             {                                 var address = ReadInt32(code' ref ip);                                  if (!Pop())                                     ip = address;                                  break;                             }                          case (int)InstructionType.JmpTable:                             {                                 var start = ReadInt32(code' ref ip);                                 var count = ReadInt32(code' ref ip);                                  var endIp = ip + count * 4;                                  var value = Pop();                                 if (value.Type == MondValueType.Number)                                 {                                     var number = (double)value;                                     var numberInt = (int)number;                                      if (number >= start && number < start + count &&                                         Math.Abs(number - numberInt) <= double.Epsilon)                                     {                                         ip += (numberInt - start) * 4;                                         ip = ReadInt32(code' ref ip);                                         break;                                     }                                 }                                  ip = endIp;                                 break;                             }                         #endregion                          case (int)InstructionType.Breakpoint:                             {                                 if (Debugger == null)                                     break;                                  DebuggerBreak(program' locals' args' ip' initialCallDepth);                                  // we stop for the statement *after* the debugger statement so we                                 // skip the next break opportunity' otherwise we break twice                                 _debugSkip = true;                                 break;                             }                          default:                             throw new MondRuntimeException(RuntimeError.UnhandledOpcode);                     }
Magic Number,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,UnpackArgs,The following statement contains a magic number: var unpackedArgs = new List<MondValue>(argCount + unpackCount * 16);
Magic Number,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,ReadInt32,The following statement contains a magic number: return buffer[offset++] <<  0 |                    buffer[offset++] <<  8 |                    buffer[offset++] << 16 |                    buffer[offset++] << 24;
Magic Number,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,ReadInt32,The following statement contains a magic number: return buffer[offset++] <<  0 |                    buffer[offset++] <<  8 |                    buffer[offset++] << 16 |                    buffer[offset++] << 24;
Magic Number,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,ReadInt32,The following statement contains a magic number: return buffer[offset++] <<  0 |                    buffer[offset++] <<  8 |                    buffer[offset++] << 16 |                    buffer[offset++] << 24;
Missing Default,Mond,MondValue,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\MondValue.cs,GetHashCode,The following switch statement is missing a default case: switch (Type)             {                 case MondValueType.Undefined:                     return int.MinValue;                  case MondValueType.Null:                     return int.MaxValue;                  case MondValueType.True:                     return 1;                  case MondValueType.False:                     return 0;                  case MondValueType.Object:                     if (TryDispatch("__hash"' out var result' this))                     {                         if (result.Type != MondValueType.Number)                             throw new MondRuntimeException(RuntimeError.HashWrongType);                          return (int)result;                     }                      return ObjectValue.GetHashCode();                  case MondValueType.Array:                     return ArrayValue.GetHashCode();                  case MondValueType.Number:                     return _numberValue.GetHashCode();                  case MondValueType.String:                     return _stringValue.GetHashCode();                  case MondValueType.Function:                     return FunctionValue.GetHashCode();             }
Missing Default,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,DebuggerCheckCall,The following switch statement is missing a default case: switch (_debugAction)             {                 case MondDebugAction.StepInto:                     _debugAlign = true;                     return;                  case MondDebugAction.StepOver:                 case MondDebugAction.StepOut:                     _debugDepth++;                     _debugAlign = false;                     return;             }
Missing Default,Mond.VirtualMachine,Machine,C:\research\architectureSmells\repos\Rohansi_Mond\Mond\VirtualMachine\Machine.cs,DebuggerCheckReturn,The following switch statement is missing a default case: switch (_debugAction)             {                 case MondDebugAction.StepInto:                     return !_debugAlign;                  case MondDebugAction.StepOver:                     --_debugDepth;                      if (_debugDepth < 0)                         return true;                      _debugAlign = _debugDepth == 0;                     return false;                  case MondDebugAction.StepOut:                     return --_debugDepth < 0;             }
