Implementation smell,Namespace,Class,File,Method,Description
Long Statement,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,DrawScene,The length of the statement  "            ImmediateContext.ClearDepthStencilView(DepthStencilView' DepthStencilClearFlags.Depth|DepthStencilClearFlags.Stencil' 1.0f' 0 );" is 128.
Long Statement,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildShapeGeometryBuffers,The length of the statement  "            var vbd = new BufferDescription(VertexPN.Stride * totalVertexCount' ResourceUsage.Immutable' BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);" is 167.
Long Statement,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildShapeGeometryBuffers,The length of the statement  "            var ibd = new BufferDescription(sizeof(int) * totalIndexCount' ResourceUsage.Immutable' BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);" is 161.
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,LitSkullDemo,The following statement contains a magic number: for (var i = 0; i < 5; i++) {                 _cylWorld[i * 2] = Matrix.Translation(-5.0f' 1.5f' -10.0f + i * 5.0f);                 _cylWorld[i * 2 + 1] = Matrix.Translation(5.0f' 1.5f' -10.0f + i * 5.0f);                  _sphereWorld[i * 2] = Matrix.Translation(-5.0f' 3.5f' -10.0f + i * 5.0f);                 _sphereWorld[i * 2 + 1] = Matrix.Translation(5.0f' 3.5f' -10.0f + i * 5.0f);             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,LitSkullDemo,The following statement contains a magic number: for (var i = 0; i < 5; i++) {                 _cylWorld[i * 2] = Matrix.Translation(-5.0f' 1.5f' -10.0f + i * 5.0f);                 _cylWorld[i * 2 + 1] = Matrix.Translation(5.0f' 1.5f' -10.0f + i * 5.0f);                  _sphereWorld[i * 2] = Matrix.Translation(-5.0f' 3.5f' -10.0f + i * 5.0f);                 _sphereWorld[i * 2 + 1] = Matrix.Translation(5.0f' 3.5f' -10.0f + i * 5.0f);             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,LitSkullDemo,The following statement contains a magic number: for (var i = 0; i < 5; i++) {                 _cylWorld[i * 2] = Matrix.Translation(-5.0f' 1.5f' -10.0f + i * 5.0f);                 _cylWorld[i * 2 + 1] = Matrix.Translation(5.0f' 1.5f' -10.0f + i * 5.0f);                  _sphereWorld[i * 2] = Matrix.Translation(-5.0f' 3.5f' -10.0f + i * 5.0f);                 _sphereWorld[i * 2 + 1] = Matrix.Translation(5.0f' 3.5f' -10.0f + i * 5.0f);             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,LitSkullDemo,The following statement contains a magic number: for (var i = 0; i < 5; i++) {                 _cylWorld[i * 2] = Matrix.Translation(-5.0f' 1.5f' -10.0f + i * 5.0f);                 _cylWorld[i * 2 + 1] = Matrix.Translation(5.0f' 1.5f' -10.0f + i * 5.0f);                  _sphereWorld[i * 2] = Matrix.Translation(-5.0f' 3.5f' -10.0f + i * 5.0f);                 _sphereWorld[i * 2 + 1] = Matrix.Translation(5.0f' 3.5f' -10.0f + i * 5.0f);             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,LitSkullDemo,The following statement contains a magic number: for (var i = 0; i < 5; i++) {                 _cylWorld[i * 2] = Matrix.Translation(-5.0f' 1.5f' -10.0f + i * 5.0f);                 _cylWorld[i * 2 + 1] = Matrix.Translation(5.0f' 1.5f' -10.0f + i * 5.0f);                  _sphereWorld[i * 2] = Matrix.Translation(-5.0f' 3.5f' -10.0f + i * 5.0f);                 _sphereWorld[i * 2 + 1] = Matrix.Translation(5.0f' 3.5f' -10.0f + i * 5.0f);             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,DrawScene,The following statement contains a magic number: switch (_lightCount) {                 case 1:                     activeTech = _fx.Light1Tech;                     break;                 case 2:                     activeTech = _fx.Light2Tech;                     break;                 case 3:                     activeTech = _fx.Light3Tech;                     break;             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,DrawScene,The following statement contains a magic number: switch (_lightCount) {                 case 1:                     activeTech = _fx.Light1Tech;                     break;                 case 2:                     activeTech = _fx.Light2Tech;                     break;                 case 3:                     activeTech = _fx.Light3Tech;                     break;             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildShapeGeometryBuffers,The following statement contains a magic number: var grid = GeometryGenerator.CreateGrid(20' 30' 60' 40);
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildShapeGeometryBuffers,The following statement contains a magic number: var grid = GeometryGenerator.CreateGrid(20' 30' 60' 40);
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildShapeGeometryBuffers,The following statement contains a magic number: var grid = GeometryGenerator.CreateGrid(20' 30' 60' 40);
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildShapeGeometryBuffers,The following statement contains a magic number: var grid = GeometryGenerator.CreateGrid(20' 30' 60' 40);
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildShapeGeometryBuffers,The following statement contains a magic number: var sphere = GeometryGenerator.CreateSphere(0.5f' 20' 20);
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildShapeGeometryBuffers,The following statement contains a magic number: var sphere = GeometryGenerator.CreateSphere(0.5f' 20' 20);
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildShapeGeometryBuffers,The following statement contains a magic number: var cylinder = GeometryGenerator.CreateCylinder(0.5f' 0.3f' 3.0f' 20' 20);
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildShapeGeometryBuffers,The following statement contains a magic number: var cylinder = GeometryGenerator.CreateCylinder(0.5f' 0.3f' 3.0f' 20' 20);
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                 var vertices = new List<VertexPN>();                 var indices = new List<int>();                 var vcount = 0;                 var tcount = 0;                 using (var reader = new StreamReader("Models\\skull.txt")) {                       var input = reader.ReadLine();                     if (input != null)                         // VertexCount: X                         vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      input = reader.ReadLine();                     if (input != null)                         //TriangleCount: X                         tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      // skip ahead to the vertex data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the vertices                       for (int i = 0; i < vcount; i++) {                         input = reader.ReadLine();                         if (input != null) {                             var vals = input.Split(new[] { ' ' });                             vertices.Add(                                 new VertexPN(                                     new Vector3(                                         Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture))'                                     new Vector3(                                         Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))                                 )                             );                         }                     }                     // skip ahead to the index data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the indices                     _skullIndexCount = 3 * tcount;                     for (var i = 0; i < tcount; i++) {                         input = reader.ReadLine();                         if (input == null) {                             break;                         }                         var m = input.Trim().Split(new[] { ' ' });                         indices.Add(Convert.ToInt32(m[0].Trim()));                         indices.Add(Convert.ToInt32(m[1].Trim()));                         indices.Add(Convert.ToInt32(m[2].Trim()));                     }                 }                  var vbd = new BufferDescription(VertexPN.Stride * vcount' ResourceUsage.Immutable'                     BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                  var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                     BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);               } catch (Exception ex) {                 MessageBox.Show(ex.Message);             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                 var vertices = new List<VertexPN>();                 var indices = new List<int>();                 var vcount = 0;                 var tcount = 0;                 using (var reader = new StreamReader("Models\\skull.txt")) {                       var input = reader.ReadLine();                     if (input != null)                         // VertexCount: X                         vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      input = reader.ReadLine();                     if (input != null)                         //TriangleCount: X                         tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      // skip ahead to the vertex data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the vertices                       for (int i = 0; i < vcount; i++) {                         input = reader.ReadLine();                         if (input != null) {                             var vals = input.Split(new[] { ' ' });                             vertices.Add(                                 new VertexPN(                                     new Vector3(                                         Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture))'                                     new Vector3(                                         Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))                                 )                             );                         }                     }                     // skip ahead to the index data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the indices                     _skullIndexCount = 3 * tcount;                     for (var i = 0; i < tcount; i++) {                         input = reader.ReadLine();                         if (input == null) {                             break;                         }                         var m = input.Trim().Split(new[] { ' ' });                         indices.Add(Convert.ToInt32(m[0].Trim()));                         indices.Add(Convert.ToInt32(m[1].Trim()));                         indices.Add(Convert.ToInt32(m[2].Trim()));                     }                 }                  var vbd = new BufferDescription(VertexPN.Stride * vcount' ResourceUsage.Immutable'                     BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                  var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                     BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);               } catch (Exception ex) {                 MessageBox.Show(ex.Message);             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                 var vertices = new List<VertexPN>();                 var indices = new List<int>();                 var vcount = 0;                 var tcount = 0;                 using (var reader = new StreamReader("Models\\skull.txt")) {                       var input = reader.ReadLine();                     if (input != null)                         // VertexCount: X                         vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      input = reader.ReadLine();                     if (input != null)                         //TriangleCount: X                         tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      // skip ahead to the vertex data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the vertices                       for (int i = 0; i < vcount; i++) {                         input = reader.ReadLine();                         if (input != null) {                             var vals = input.Split(new[] { ' ' });                             vertices.Add(                                 new VertexPN(                                     new Vector3(                                         Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture))'                                     new Vector3(                                         Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))                                 )                             );                         }                     }                     // skip ahead to the index data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the indices                     _skullIndexCount = 3 * tcount;                     for (var i = 0; i < tcount; i++) {                         input = reader.ReadLine();                         if (input == null) {                             break;                         }                         var m = input.Trim().Split(new[] { ' ' });                         indices.Add(Convert.ToInt32(m[0].Trim()));                         indices.Add(Convert.ToInt32(m[1].Trim()));                         indices.Add(Convert.ToInt32(m[2].Trim()));                     }                 }                  var vbd = new BufferDescription(VertexPN.Stride * vcount' ResourceUsage.Immutable'                     BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                  var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                     BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);               } catch (Exception ex) {                 MessageBox.Show(ex.Message);             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                 var vertices = new List<VertexPN>();                 var indices = new List<int>();                 var vcount = 0;                 var tcount = 0;                 using (var reader = new StreamReader("Models\\skull.txt")) {                       var input = reader.ReadLine();                     if (input != null)                         // VertexCount: X                         vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      input = reader.ReadLine();                     if (input != null)                         //TriangleCount: X                         tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      // skip ahead to the vertex data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the vertices                       for (int i = 0; i < vcount; i++) {                         input = reader.ReadLine();                         if (input != null) {                             var vals = input.Split(new[] { ' ' });                             vertices.Add(                                 new VertexPN(                                     new Vector3(                                         Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture))'                                     new Vector3(                                         Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))                                 )                             );                         }                     }                     // skip ahead to the index data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the indices                     _skullIndexCount = 3 * tcount;                     for (var i = 0; i < tcount; i++) {                         input = reader.ReadLine();                         if (input == null) {                             break;                         }                         var m = input.Trim().Split(new[] { ' ' });                         indices.Add(Convert.ToInt32(m[0].Trim()));                         indices.Add(Convert.ToInt32(m[1].Trim()));                         indices.Add(Convert.ToInt32(m[2].Trim()));                     }                 }                  var vbd = new BufferDescription(VertexPN.Stride * vcount' ResourceUsage.Immutable'                     BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                  var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                     BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);               } catch (Exception ex) {                 MessageBox.Show(ex.Message);             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                 var vertices = new List<VertexPN>();                 var indices = new List<int>();                 var vcount = 0;                 var tcount = 0;                 using (var reader = new StreamReader("Models\\skull.txt")) {                       var input = reader.ReadLine();                     if (input != null)                         // VertexCount: X                         vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      input = reader.ReadLine();                     if (input != null)                         //TriangleCount: X                         tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      // skip ahead to the vertex data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the vertices                       for (int i = 0; i < vcount; i++) {                         input = reader.ReadLine();                         if (input != null) {                             var vals = input.Split(new[] { ' ' });                             vertices.Add(                                 new VertexPN(                                     new Vector3(                                         Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture))'                                     new Vector3(                                         Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))                                 )                             );                         }                     }                     // skip ahead to the index data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the indices                     _skullIndexCount = 3 * tcount;                     for (var i = 0; i < tcount; i++) {                         input = reader.ReadLine();                         if (input == null) {                             break;                         }                         var m = input.Trim().Split(new[] { ' ' });                         indices.Add(Convert.ToInt32(m[0].Trim()));                         indices.Add(Convert.ToInt32(m[1].Trim()));                         indices.Add(Convert.ToInt32(m[2].Trim()));                     }                 }                  var vbd = new BufferDescription(VertexPN.Stride * vcount' ResourceUsage.Immutable'                     BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                  var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                     BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);               } catch (Exception ex) {                 MessageBox.Show(ex.Message);             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                 var vertices = new List<VertexPN>();                 var indices = new List<int>();                 var vcount = 0;                 var tcount = 0;                 using (var reader = new StreamReader("Models\\skull.txt")) {                       var input = reader.ReadLine();                     if (input != null)                         // VertexCount: X                         vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      input = reader.ReadLine();                     if (input != null)                         //TriangleCount: X                         tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                      // skip ahead to the vertex data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the vertices                       for (int i = 0; i < vcount; i++) {                         input = reader.ReadLine();                         if (input != null) {                             var vals = input.Split(new[] { ' ' });                             vertices.Add(                                 new VertexPN(                                     new Vector3(                                         Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                         Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture))'                                     new Vector3(                                         Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))                                 )                             );                         }                     }                     // skip ahead to the index data                     do {                         input = reader.ReadLine();                     } while (input != null && !input.StartsWith("{"));                     // Get the indices                     _skullIndexCount = 3 * tcount;                     for (var i = 0; i < tcount; i++) {                         input = reader.ReadLine();                         if (input == null) {                             break;                         }                         var m = input.Trim().Split(new[] { ' ' });                         indices.Add(Convert.ToInt32(m[0].Trim()));                         indices.Add(Convert.ToInt32(m[1].Trim()));                         indices.Add(Convert.ToInt32(m[2].Trim()));                     }                 }                  var vbd = new BufferDescription(VertexPN.Stride * vcount' ResourceUsage.Immutable'                     BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                  var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                     BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                 _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);               } catch (Exception ex) {                 MessageBox.Show(ex.Message);             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,SwitchLights,The following statement contains a magic number: switch (e.KeyCode) {                 case Keys.D0:                     _lightCount = 0;                     break;                 case Keys.D1:                     _lightCount = 1;                     break;                 case Keys.D2:                     _lightCount = 2;                     break;                 case Keys.D3:                     _lightCount = 3;                     break;             }
Magic Number,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,SwitchLights,The following statement contains a magic number: switch (e.KeyCode) {                 case Keys.D0:                     _lightCount = 0;                     break;                 case Keys.D1:                     _lightCount = 1;                     break;                 case Keys.D2:                     _lightCount = 2;                     break;                 case Keys.D3:                     _lightCount = 3;                     break;             }
Missing Default,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,DrawScene,The following switch statement is missing a default case: switch (_lightCount) {                 case 1:                     activeTech = _fx.Light1Tech;                     break;                 case 2:                     activeTech = _fx.Light2Tech;                     break;                 case 3:                     activeTech = _fx.Light3Tech;                     break;             }
Missing Default,LitSkull,LitSkullDemo,C:\repos\ericrrichards_dx11\DX11\LitSkull\Program.cs,SwitchLights,The following switch statement is missing a default case: switch (e.KeyCode) {                 case Keys.D0:                     _lightCount = 0;                     break;                 case Keys.D1:                     _lightCount = 1;                     break;                 case Keys.D2:                     _lightCount = 2;                     break;                 case Keys.D3:                     _lightCount = 3;                     break;             }
