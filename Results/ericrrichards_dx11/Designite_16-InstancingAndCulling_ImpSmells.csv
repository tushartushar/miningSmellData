Implementation smell,Namespace,Class,File,Method,Description
Complex Method,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,UpdateScene,Cyclomatic complexity of the method is 14
Long Statement,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,UpdateScene,The length of the statement  "            MainWindowCaption = String.Format("Instancing and Culling Demo    {0} objects visible out of {1}"' _visibleObjectCount' _instancedData.Count); " is 142.
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,InstancingAndCullingDemo,The following statement contains a magic number: _cam = new FpsCamera {                  Position = new Vector3(0' 2' -15)              };
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,InstancingAndCullingDemo,The following statement contains a magic number: _cam = new FpsCamera {                  Position = new Vector3(0' 2' -15)              };
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,DrawScene,The following statement contains a magic number: if (_skullsOrBoxes) {                  for (int p = 0; p < activeTech.Description.PassCount; p++) {                      if (_instancing) {                          ImmediateContext.InputAssembler.SetVertexBuffers(                              0'                              new VertexBufferBinding(_skullVB' stride[0]' offset[0])'                              new VertexBufferBinding(_instanceBuffer' stride[1]' offset[1])                              );                          ImmediateContext.InputAssembler.SetIndexBuffer(_skullIB' Format.R32_UInt' 0);                            Effects.InstancedBasicFX.SetViewProj(viewProj);                          Effects.InstancedBasicFX.SetMaterial(_skullMat);                            activeTech.GetPassByIndex(p).Apply(ImmediateContext);                          ImmediateContext.DrawIndexedInstanced(_skullIndexCount' _visibleObjectCount' 0' 0' 0);                      } else {                          ImmediateContext.InputAssembler.SetVertexBuffers(                              0'                              new VertexBufferBinding(_skullVB' stride[0]' offset[0])                              );                          ImmediateContext.InputAssembler.SetIndexBuffer(_skullIB' Format.R32_UInt' 0);                          Effects.BasicFX.SetMaterial(_skullMat);                          foreach (var data in _instancedData) {                              var world = data.World;                              var wit = MathF.InverseTranspose(world);                              var wvp = world*_cam.ViewProj;                              Effects.BasicFX.SetWorld(world);                              Effects.BasicFX.SetWorldInvTranspose(wit);                              Effects.BasicFX.SetWorldViewProj(wvp);                              activeTech.GetPassByIndex(p).Apply(ImmediateContext);                              ImmediateContext.DrawIndexed(_skullIndexCount' 0' 0);                          }                      }                  }              } else {                  for (int p = 0; p < activeTech.Description.PassCount; p++) {                      if (_instancing) {                          ImmediateContext.InputAssembler.SetVertexBuffers(                              0'                              new VertexBufferBinding(_boxVB' stride[0]' offset[0])'                              new VertexBufferBinding(_instanceBuffer' stride[1]' offset[1])                              );                          ImmediateContext.InputAssembler.SetIndexBuffer(_boxIB' Format.R32_UInt' 0);                            Effects.InstancedBasicFX.SetViewProj(viewProj);                          Effects.InstancedBasicFX.SetMaterial(_skullMat);                            activeTech.GetPassByIndex(p).Apply(ImmediateContext);                          ImmediateContext.DrawIndexedInstanced(36' _visibleObjectCount' 0' 0' 0);                      } else {                          ImmediateContext.InputAssembler.SetVertexBuffers(                              0'                              new VertexBufferBinding(_boxVB' stride[0]' offset[0])                              );                          ImmediateContext.InputAssembler.SetIndexBuffer(_boxIB' Format.R32_UInt' 0);                          Effects.BasicFX.SetMaterial(_skullMat);                          foreach (var data in _instancedData) {                              var world = data.World;                              var wit = MathF.InverseTranspose(world);                              var wvp = world * _cam.ViewProj;                              Effects.BasicFX.SetWorld(world);                              Effects.BasicFX.SetWorldInvTranspose(wit);                              Effects.BasicFX.SetWorldViewProj(wvp);                              activeTech.GetPassByIndex(p).Apply(ImmediateContext);                              ImmediateContext.DrawIndexed(36' 0' 0);                          }                      }                  }              }
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,DrawScene,The following statement contains a magic number: if (_skullsOrBoxes) {                  for (int p = 0; p < activeTech.Description.PassCount; p++) {                      if (_instancing) {                          ImmediateContext.InputAssembler.SetVertexBuffers(                              0'                              new VertexBufferBinding(_skullVB' stride[0]' offset[0])'                              new VertexBufferBinding(_instanceBuffer' stride[1]' offset[1])                              );                          ImmediateContext.InputAssembler.SetIndexBuffer(_skullIB' Format.R32_UInt' 0);                            Effects.InstancedBasicFX.SetViewProj(viewProj);                          Effects.InstancedBasicFX.SetMaterial(_skullMat);                            activeTech.GetPassByIndex(p).Apply(ImmediateContext);                          ImmediateContext.DrawIndexedInstanced(_skullIndexCount' _visibleObjectCount' 0' 0' 0);                      } else {                          ImmediateContext.InputAssembler.SetVertexBuffers(                              0'                              new VertexBufferBinding(_skullVB' stride[0]' offset[0])                              );                          ImmediateContext.InputAssembler.SetIndexBuffer(_skullIB' Format.R32_UInt' 0);                          Effects.BasicFX.SetMaterial(_skullMat);                          foreach (var data in _instancedData) {                              var world = data.World;                              var wit = MathF.InverseTranspose(world);                              var wvp = world*_cam.ViewProj;                              Effects.BasicFX.SetWorld(world);                              Effects.BasicFX.SetWorldInvTranspose(wit);                              Effects.BasicFX.SetWorldViewProj(wvp);                              activeTech.GetPassByIndex(p).Apply(ImmediateContext);                              ImmediateContext.DrawIndexed(_skullIndexCount' 0' 0);                          }                      }                  }              } else {                  for (int p = 0; p < activeTech.Description.PassCount; p++) {                      if (_instancing) {                          ImmediateContext.InputAssembler.SetVertexBuffers(                              0'                              new VertexBufferBinding(_boxVB' stride[0]' offset[0])'                              new VertexBufferBinding(_instanceBuffer' stride[1]' offset[1])                              );                          ImmediateContext.InputAssembler.SetIndexBuffer(_boxIB' Format.R32_UInt' 0);                            Effects.InstancedBasicFX.SetViewProj(viewProj);                          Effects.InstancedBasicFX.SetMaterial(_skullMat);                            activeTech.GetPassByIndex(p).Apply(ImmediateContext);                          ImmediateContext.DrawIndexedInstanced(36' _visibleObjectCount' 0' 0' 0);                      } else {                          ImmediateContext.InputAssembler.SetVertexBuffers(                              0'                              new VertexBufferBinding(_boxVB' stride[0]' offset[0])                              );                          ImmediateContext.InputAssembler.SetIndexBuffer(_boxIB' Format.R32_UInt' 0);                          Effects.BasicFX.SetMaterial(_skullMat);                          foreach (var data in _instancedData) {                              var world = data.World;                              var wit = MathF.InverseTranspose(world);                              var wvp = world * _cam.ViewProj;                              Effects.BasicFX.SetWorld(world);                              Effects.BasicFX.SetWorldInvTranspose(wit);                              Effects.BasicFX.SetWorldViewProj(wvp);                              activeTech.GetPassByIndex(p).Apply(ImmediateContext);                              ImmediateContext.DrawIndexed(36' 0' 0);                          }                      }                  }              }
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,DrawScene,The following statement contains a magic number: Console.WriteLine("frame time: {0} msec"' elapsed * 1000);
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                    var min = new Vector3(float.MaxValue' float.MaxValue' float.MaxValue);                  var max = new Vector3(float.MinValue' float.MinValue' float.MinValue);                  var vertices = new List<Basic32>();                  var indices = new List<int>();                  var vcount = 0;                  var tcount = 0;                  using (var reader = new StreamReader("Models\\skull.txt")) {                          var input = reader.ReadLine();                      if (input != null)                          // VertexCount: X                          vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        input = reader.ReadLine();                      if (input != null)                          //TriangleCount: X                          tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        // skip ahead to the vertex data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the vertices                        for (int i = 0; i < vcount; i++) {                          input = reader.ReadLine();                          if (input != null) {                              var vals = input.Split(new[] { ' ' });                              var position = new Vector3(                                  Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture));                              vertices.Add(                                  new Basic32(                                      position'                                      new Vector3(                                          Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))'                                      new Vector2()                                  )                              );                              min = Vector3.Minimize(min' position);                              max = Vector3.Maximize(max' position);                          }                      }                      _skullBox = new BoundingBox(min' max);                        // skip ahead to the index data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the indices                      _skullIndexCount = 3 * tcount;                      for (var i = 0; i < tcount; i++) {                          input = reader.ReadLine();                          if (input == null) {                              break;                          }                          var m = input.Trim().Split(new[] { ' ' });                          indices.Add(Convert.ToInt32(m[0].Trim()));                          indices.Add(Convert.ToInt32(m[1].Trim()));                          indices.Add(Convert.ToInt32(m[2].Trim()));                      }                  }                    var vbd = new BufferDescription(Basic32.Stride * vcount' ResourceUsage.Immutable'                      BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                    var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                      BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);                  } catch (Exception ex) {                  MessageBox.Show(ex.Message);              }
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                    var min = new Vector3(float.MaxValue' float.MaxValue' float.MaxValue);                  var max = new Vector3(float.MinValue' float.MinValue' float.MinValue);                  var vertices = new List<Basic32>();                  var indices = new List<int>();                  var vcount = 0;                  var tcount = 0;                  using (var reader = new StreamReader("Models\\skull.txt")) {                          var input = reader.ReadLine();                      if (input != null)                          // VertexCount: X                          vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        input = reader.ReadLine();                      if (input != null)                          //TriangleCount: X                          tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        // skip ahead to the vertex data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the vertices                        for (int i = 0; i < vcount; i++) {                          input = reader.ReadLine();                          if (input != null) {                              var vals = input.Split(new[] { ' ' });                              var position = new Vector3(                                  Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture));                              vertices.Add(                                  new Basic32(                                      position'                                      new Vector3(                                          Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))'                                      new Vector2()                                  )                              );                              min = Vector3.Minimize(min' position);                              max = Vector3.Maximize(max' position);                          }                      }                      _skullBox = new BoundingBox(min' max);                        // skip ahead to the index data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the indices                      _skullIndexCount = 3 * tcount;                      for (var i = 0; i < tcount; i++) {                          input = reader.ReadLine();                          if (input == null) {                              break;                          }                          var m = input.Trim().Split(new[] { ' ' });                          indices.Add(Convert.ToInt32(m[0].Trim()));                          indices.Add(Convert.ToInt32(m[1].Trim()));                          indices.Add(Convert.ToInt32(m[2].Trim()));                      }                  }                    var vbd = new BufferDescription(Basic32.Stride * vcount' ResourceUsage.Immutable'                      BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                    var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                      BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);                  } catch (Exception ex) {                  MessageBox.Show(ex.Message);              }
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                    var min = new Vector3(float.MaxValue' float.MaxValue' float.MaxValue);                  var max = new Vector3(float.MinValue' float.MinValue' float.MinValue);                  var vertices = new List<Basic32>();                  var indices = new List<int>();                  var vcount = 0;                  var tcount = 0;                  using (var reader = new StreamReader("Models\\skull.txt")) {                          var input = reader.ReadLine();                      if (input != null)                          // VertexCount: X                          vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        input = reader.ReadLine();                      if (input != null)                          //TriangleCount: X                          tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        // skip ahead to the vertex data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the vertices                        for (int i = 0; i < vcount; i++) {                          input = reader.ReadLine();                          if (input != null) {                              var vals = input.Split(new[] { ' ' });                              var position = new Vector3(                                  Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture));                              vertices.Add(                                  new Basic32(                                      position'                                      new Vector3(                                          Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))'                                      new Vector2()                                  )                              );                              min = Vector3.Minimize(min' position);                              max = Vector3.Maximize(max' position);                          }                      }                      _skullBox = new BoundingBox(min' max);                        // skip ahead to the index data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the indices                      _skullIndexCount = 3 * tcount;                      for (var i = 0; i < tcount; i++) {                          input = reader.ReadLine();                          if (input == null) {                              break;                          }                          var m = input.Trim().Split(new[] { ' ' });                          indices.Add(Convert.ToInt32(m[0].Trim()));                          indices.Add(Convert.ToInt32(m[1].Trim()));                          indices.Add(Convert.ToInt32(m[2].Trim()));                      }                  }                    var vbd = new BufferDescription(Basic32.Stride * vcount' ResourceUsage.Immutable'                      BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                    var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                      BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);                  } catch (Exception ex) {                  MessageBox.Show(ex.Message);              }
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                    var min = new Vector3(float.MaxValue' float.MaxValue' float.MaxValue);                  var max = new Vector3(float.MinValue' float.MinValue' float.MinValue);                  var vertices = new List<Basic32>();                  var indices = new List<int>();                  var vcount = 0;                  var tcount = 0;                  using (var reader = new StreamReader("Models\\skull.txt")) {                          var input = reader.ReadLine();                      if (input != null)                          // VertexCount: X                          vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        input = reader.ReadLine();                      if (input != null)                          //TriangleCount: X                          tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        // skip ahead to the vertex data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the vertices                        for (int i = 0; i < vcount; i++) {                          input = reader.ReadLine();                          if (input != null) {                              var vals = input.Split(new[] { ' ' });                              var position = new Vector3(                                  Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture));                              vertices.Add(                                  new Basic32(                                      position'                                      new Vector3(                                          Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))'                                      new Vector2()                                  )                              );                              min = Vector3.Minimize(min' position);                              max = Vector3.Maximize(max' position);                          }                      }                      _skullBox = new BoundingBox(min' max);                        // skip ahead to the index data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the indices                      _skullIndexCount = 3 * tcount;                      for (var i = 0; i < tcount; i++) {                          input = reader.ReadLine();                          if (input == null) {                              break;                          }                          var m = input.Trim().Split(new[] { ' ' });                          indices.Add(Convert.ToInt32(m[0].Trim()));                          indices.Add(Convert.ToInt32(m[1].Trim()));                          indices.Add(Convert.ToInt32(m[2].Trim()));                      }                  }                    var vbd = new BufferDescription(Basic32.Stride * vcount' ResourceUsage.Immutable'                      BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                    var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                      BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);                  } catch (Exception ex) {                  MessageBox.Show(ex.Message);              }
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                    var min = new Vector3(float.MaxValue' float.MaxValue' float.MaxValue);                  var max = new Vector3(float.MinValue' float.MinValue' float.MinValue);                  var vertices = new List<Basic32>();                  var indices = new List<int>();                  var vcount = 0;                  var tcount = 0;                  using (var reader = new StreamReader("Models\\skull.txt")) {                          var input = reader.ReadLine();                      if (input != null)                          // VertexCount: X                          vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        input = reader.ReadLine();                      if (input != null)                          //TriangleCount: X                          tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        // skip ahead to the vertex data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the vertices                        for (int i = 0; i < vcount; i++) {                          input = reader.ReadLine();                          if (input != null) {                              var vals = input.Split(new[] { ' ' });                              var position = new Vector3(                                  Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture));                              vertices.Add(                                  new Basic32(                                      position'                                      new Vector3(                                          Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))'                                      new Vector2()                                  )                              );                              min = Vector3.Minimize(min' position);                              max = Vector3.Maximize(max' position);                          }                      }                      _skullBox = new BoundingBox(min' max);                        // skip ahead to the index data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the indices                      _skullIndexCount = 3 * tcount;                      for (var i = 0; i < tcount; i++) {                          input = reader.ReadLine();                          if (input == null) {                              break;                          }                          var m = input.Trim().Split(new[] { ' ' });                          indices.Add(Convert.ToInt32(m[0].Trim()));                          indices.Add(Convert.ToInt32(m[1].Trim()));                          indices.Add(Convert.ToInt32(m[2].Trim()));                      }                  }                    var vbd = new BufferDescription(Basic32.Stride * vcount' ResourceUsage.Immutable'                      BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                    var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                      BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);                  } catch (Exception ex) {                  MessageBox.Show(ex.Message);              }
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,BuildSkullGeometryBuffers,The following statement contains a magic number: try {                    var min = new Vector3(float.MaxValue' float.MaxValue' float.MaxValue);                  var max = new Vector3(float.MinValue' float.MinValue' float.MinValue);                  var vertices = new List<Basic32>();                  var indices = new List<int>();                  var vcount = 0;                  var tcount = 0;                  using (var reader = new StreamReader("Models\\skull.txt")) {                          var input = reader.ReadLine();                      if (input != null)                          // VertexCount: X                          vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        input = reader.ReadLine();                      if (input != null)                          //TriangleCount: X                          tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                        // skip ahead to the vertex data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the vertices                        for (int i = 0; i < vcount; i++) {                          input = reader.ReadLine();                          if (input != null) {                              var vals = input.Split(new[] { ' ' });                              var position = new Vector3(                                  Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                  Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture));                              vertices.Add(                                  new Basic32(                                      position'                                      new Vector3(                                          Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                          Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))'                                      new Vector2()                                  )                              );                              min = Vector3.Minimize(min' position);                              max = Vector3.Maximize(max' position);                          }                      }                      _skullBox = new BoundingBox(min' max);                        // skip ahead to the index data                      do {                          input = reader.ReadLine();                      } while (input != null && !input.StartsWith("{"));                      // Get the indices                      _skullIndexCount = 3 * tcount;                      for (var i = 0; i < tcount; i++) {                          input = reader.ReadLine();                          if (input == null) {                              break;                          }                          var m = input.Trim().Split(new[] { ' ' });                          indices.Add(Convert.ToInt32(m[0].Trim()));                          indices.Add(Convert.ToInt32(m[1].Trim()));                          indices.Add(Convert.ToInt32(m[2].Trim()));                      }                  }                    var vbd = new BufferDescription(Basic32.Stride * vcount' ResourceUsage.Immutable'                      BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullVB = new Buffer(Device' new DataStream(vertices.ToArray()' false' false)' vbd);                    var ibd = new BufferDescription(sizeof(int) * _skullIndexCount' ResourceUsage.Immutable'                      BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0);                  _skullIB = new Buffer(Device' new DataStream(indices.ToArray()' false' false)' ibd);                  } catch (Exception ex) {                  MessageBox.Show(ex.Message);              }
Magic Number,InstancingAndCulling,InstancingAndCullingDemo,C:\repos\ericrrichards_dx11\DX11\InstancingAndCulling\Program.cs,BuildInstancedBuffer,The following statement contains a magic number: const int n = 5;
