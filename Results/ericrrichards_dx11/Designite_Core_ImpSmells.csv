Implementation smell,Namespace,Class,File,Method,Description
Long Method,Core,InputLayouts,C:\repos\ericrrichards_dx11\DX11\Core\InputLayouts.cs,InitAll,The method has 113 lines of code.
Long Method,Core,RenderStates,C:\repos\ericrrichards_dx11\DX11\Core\RenderStates.cs,InitAll,The method has 141 lines of code.
Long Method,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,BasicEffect,The method has 109 lines of code.
Complex Method,Core,InputLayouts,C:\repos\ericrrichards_dx11\DX11\Core\InputLayouts.cs,InitAll,Cyclomatic complexity of the method is 12
Complex Method,Core.Model,AnimEvaluator,C:\repos\ericrrichards_dx11\DX11\Core\Model\AnimEvaluator.cs,Evaluate,Cyclomatic complexity of the method is 20
Complex Method,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,BasicModel,Cyclomatic complexity of the method is 8
Complex Method,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,LoadSdkMesh,Cyclomatic complexity of the method is 8
Complex Method,Core.Model,SceneAnimator,C:\repos\ericrrichards_dx11\DX11\Core\Model\SceneAnimator.cs,Init,Cyclomatic complexity of the method is 10
Complex Method,Core.Terrain,QuadTreeNode,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\QuadTree.cs,Intersects,Cyclomatic complexity of the method is 11
Complex Method,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,DrawCameraFrustum,Cyclomatic complexity of the method is 9
Complex Method,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,CalculateWalkability,Cyclomatic complexity of the method is 9
Complex Method,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,ConnectNeighboringTiles,Cyclomatic complexity of the method is 8
Complex Method,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,CreateTileSets,Cyclomatic complexity of the method is 8
Complex Method,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,GetPath,Cyclomatic complexity of the method is 11
Complex Method,Core.Terrain,WalkMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,CreateWalkableTexture,Cyclomatic complexity of the method is 8
Long Parameter List,Core,MathF,C:\repos\ericrrichards_dx11\DX11\Core\CosTable.cs,PerlinNoise2D,The method has 5 parameters. Parameters: seed' persistence' octave' x' y
Long Parameter List,Core,FontCache,C:\repos\ericrrichards_dx11\DX11\Core\FontCache.cs,RegisterFont,The method has 6 parameters. Parameters: name' fontSize' fontFace' fontWeight' fontStyle' fontStretch
Long Parameter List,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateCylinder,The method has 5 parameters. Parameters: bottomRadius' topRadius' height' sliceCount' stackCount
Long Parameter List,Core,Vertex,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,Vertex,The method has 11 parameters. Parameters: px' py' pz' nx' ny' nz' tx' ty' tz' u' v
Long Parameter List,Core,ParticleSystem,C:\repos\ericrrichards_dx11\DX11\Core\ParticleSystem.cs,Init,The method has 5 parameters. Parameters: device' fx' texArraySRV' randomTexSRV' maxParticles
Long Parameter List,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,Ssao,The method has 6 parameters. Parameters: device' dc' width' height' fovY' farZ
Long Parameter List,Core,Util,C:\repos\ericrrichards_dx11\DX11\Core\Util.cs,CreateTexture2DArraySRV,The method has 6 parameters. Parameters: device' immediateContext' filenames' format' filter' mipFilter
Long Parameter List,Core,PosNormalTexTanSkinned,C:\repos\ericrrichards_dx11\DX11\Core\Vertex.cs,PosNormalTexTanSkinned,The method has 6 parameters. Parameters: pos' norm' uv' tan' weight' boneIndices
Long Parameter List,Core,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Waves.cs,Init,The method has 6 parameters. Parameters: m' n' dx' dt' speed' damping
Long Parameter List,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,BasicModel,The method has 5 parameters. Parameters: device' texMgr' filename' texturePath' flipUv
Long Parameter List,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,CreateCylinder,The method has 6 parameters. Parameters: device' bottomRadius' topRadius' height' sliceCount' stackCount
Long Parameter List,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,CreateGrid,The method has 5 parameters. Parameters: device' width' depth' xVerts' zVerts
Long Parameter List,Core.Model,IModel<TVertexType>,C:\repos\ericrrichards_dx11\DX11\Core\Model\IModel.cs,CreateCylinder,The method has 6 parameters. Parameters: device' bottomRadius' topRadius' height' sliceCount' stackCount
Long Parameter List,Core.Model,IModel<TVertexType>,C:\repos\ericrrichards_dx11\DX11\Core\Model\IModel.cs,CreateGrid,The method has 5 parameters. Parameters: device' width' depth' xVerts' zVerts
Long Parameter List,Core.Model,IModelInstance<T>,C:\repos\ericrrichards_dx11\DX11\Core\Model\IModel.cs,Draw,The method has 5 parameters. Parameters: dc' effectPass' view' proj' method
Long Parameter List,Core.Model,IModelInstance<T>,C:\repos\ericrrichards_dx11\DX11\Core\Model\IModel.cs,Draw,The method has 5 parameters. Parameters: dc' effectPass' view' proj' renderMode
Long Parameter List,Core.Model,MeshGeometry,C:\repos\ericrrichards_dx11\DX11\Core\Model\MeshGeometry.cs,DrawInstanced,The method has 5 parameters. Parameters: dc' subsetId' instanceBuffer' numInstances' instanceStride
Long Parameter List,Core.Model,SkinnedModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\SkinnedModel.cs,SkinnedModel,The method has 5 parameters. Parameters: device' texMgr' filename' texturePath' flipTexY
Long Parameter List,Core.Model,SkinnedModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\SkinnedModel.cs,CreateCylinder,The method has 6 parameters. Parameters: device' bottomRadius' topRadius' height' sliceCount' stackCount
Long Parameter List,Core.Model,SkinnedModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\SkinnedModel.cs,CreateGrid,The method has 5 parameters. Parameters: device' width' depth' xVerts' zVerts
Long Parameter List,Core.Model,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Model\Waves.cs,Init,The method has 6 parameters. Parameters: device' texMgr' width' depth' texture1' texture2
Long Parameter List,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,CreateRandomHeightMapParallel,The method has 5 parameters. Parameters: seed' noiseSize' persistence' octaves' drawProgress
Long Parameter List,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,Minimap,The method has 6 parameters. Parameters: device' dc' minimapWidth' minimapHeight' terrain' viewCam
Long Parameter List,Vertex,PosNormalTexTanSkinned,C:\repos\ericrrichards_dx11\DX11\Core\Vertex.cs,PosNormalTexTanSkinned,The method has 6 parameters. Parameters: pos' norm' uv' tan' weight' boneIndices
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light0TexAlphaClipFogReflectTech is 32.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light1TexAlphaClipFogReflectTech is 32.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light2TexAlphaClipFogReflectTech is 32.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light3TexAlphaClipFogReflectTech is 32.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light0TexAlphaClipFogSkinnedTech is 32.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light1TexAlphaClipFogSkinnedTech is 32.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light2TexAlphaClipFogSkinnedTech is 32.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light3TexAlphaClipFogSkinnedTech is 32.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light0TexAlphaClipReflectSkinnedTech is 36.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light1TexAlphaClipReflectSkinnedTech is 36.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light2TexAlphaClipReflectSkinnedTech is 36.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light3TexAlphaClipReflectSkinnedTech is 36.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light0TexFogReflectSkinnedTech is 30.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light1TexFogReflectSkinnedTech is 30.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light2TexFogReflectSkinnedTech is 30.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light3TexFogReflectSkinnedTech is 30.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light0TexAlphaClipFogReflectSkinnedTech is 39.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light1TexAlphaClipFogReflectSkinnedTech is 39.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light2TexAlphaClipFogReflectSkinnedTech is 39.
Long Identifier,Core.FX,BasicEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BasicEffect.cs,,The length of the parameter Light3TexAlphaClipFogReflectSkinnedTech is 39.
Long Identifier,Core.FX,BuildShadowMapEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\BuildShadowMapEffect.cs,,The length of the parameter TessBuildShadowMapAlphaClipTech is 31.
Long Statement,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,InitDirect3D,The length of the statement  "                Console.WriteLine("Direct3D Feature Level 11 unsupported\nSupported feature level: " + Enum.GetName(Device.FeatureLevel.GetType()' Device.FeatureLevel)); " is 153.
Long Statement,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,InitDirect3D,The length of the statement  "                    SampleDescription = Enable4XMsaa && Device.FeatureLevel >= FeatureLevel.Level_10_1 ? new SampleDescription(4' Msaa4XQuality - 1) : new SampleDescription(1' 0)' " is 159.
Long Statement,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,BuildScreenQuadGeometryBuffers,The length of the statement  "            var vbd = new BufferDescription(Basic32.Stride * verts.Count' ResourceUsage.Immutable' BindFlags.VertexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0); " is 161.
Long Statement,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,BuildScreenQuadGeometryBuffers,The length of the statement  "            var ibd = new BufferDescription(sizeof(int) * quad.Indices.Count' ResourceUsage.Immutable' BindFlags.IndexBuffer' CpuAccessFlags.None' ResourceOptionFlags.None' 0); " is 164.
Long Statement,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,OnResize,The length of the statement  "                SampleDescription = (Enable4XMsaa && Device.FeatureLevel >= FeatureLevel.Level_10_1) ? new SampleDescription(4' Msaa4XQuality - 1) : new SampleDescription(1' 0)' " is 161.
Long Statement,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateGrid,The length of the statement  "                    ret.Vertices.Add(new Vertex(new Vector3(x' 0' z)' new Vector3(0' 1' 0)' new Vector3(1' 0' 0)' new Vector2(j * du' i * dv))); " is 124.
Long Statement,Core,InputLayouts,C:\repos\ericrrichards_dx11\DX11\Core\InputLayouts.cs,InitAll,The length of the statement  "                    if (passDesc.Signature != null) PosNormal = new InputLayout(device' passDesc.Signature' InputLayoutDescriptions.PosNormal); " is 123.
Long Statement,Core,InputLayouts,C:\repos\ericrrichards_dx11\DX11\Core\InputLayouts.cs,InitAll,The length of the statement  "                    InstancedPosNormalTexTan = new InputLayout(device' passDesc.Signature' InputLayoutDescriptions.InstancedPosNormalTexTan); " is 121.
Long Statement,Core,Util,C:\repos\ericrrichards_dx11\DX11\Core\Util.cs,CreateRandomTexture1DSRV,The length of the statement  "                randomValues.Add(new Vector4(MathF.Rand(-1.0f' 1.0f)' MathF.Rand(-1.0f' 1.0f)' MathF.Rand(-1.0f' 1.0f)' MathF.Rand(-1.0f' 1.0f))); " is 130.
Long Statement,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,LoadFromTxtFile,The length of the statement  "            ret.Vertices.AddRange(vertices.Select(v => new PosNormalTexTan(v.Position' v.Normal' v.Tex' new Vector3(1' 0' 0))).ToList()); " is 125.
Long Statement,Core.Model,MeshGeometry,C:\repos\ericrrichards_dx11\DX11\Core\Model\MeshGeometry.cs,DrawInstanced,The length of the statement  "            dc.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(_vb' _vertexStride' offset)' new VertexBufferBinding(instanceBuffer' instanceStride' 0)); " is 151.
Long Statement,Core.Model,MeshGeometry,C:\repos\ericrrichards_dx11\DX11\Core\Model\MeshGeometry.cs,DrawInstanced,The length of the statement  "            dc.DrawIndexedInstanced(_subsetTable[subsetId].FaceCount * 3' numInstances' _subsetTable[subsetId].FaceStart * 3'  0' 0); " is 121.
Long Statement,Core.Model,SdkMeshVertexBuffer,C:\repos\ericrrichards_dx11\DX11\Core\Model\SDKMesh.cs,ToString,The length of the statement  "                    sb.AppendLine("\tVertexElement(Stream: " + elem.Stream + " Offset: " + elem.Offset + " Type: " + elem.Type + " Method: " + elem.Method + " Usage: " + elem.Usage + " UsageIndex: " + elem.UsageIndex + ")"); " is 204.
Long Statement,Core.Model,SkinnedModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\SkinnedModel.cs,ExtractVertices,The length of the statement  "                var v = new PosNormalTexTanSkinned(pos' norm.ToVector3()' texC.ToVector2()' tan.ToVector3()' weights.First()' boneIndices); " is 123.
Long Statement,Core.Terrain,PriorityQueue<T>,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\PriorityQueue.cs,HasHigherPriority,The length of the statement  "            return higher.Priority < lower.Priority || (Math.Abs(higher.Priority - lower.Priority) < float.Epsilon && higher.InsertionIndex < lower.InsertionIndex); " is 152.
Long Statement,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,DrawCameraFrustum,The length of the statement  "                points[i] = new Vector3(Math.Min(Math.Max(hit.X' -float.MaxValue)' float.MaxValue)' 0' Math.Min(Math.Max(hit.Z' -float.MaxValue)' float.MaxValue)); " is 147.
Long Statement,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,BuildQuadTree,The length of the statement  "            var quadNode = new QuadTreeNode { Bounds = new BoundingBox(new Vector3(minX' minMaxY.X' minZ)' new Vector3(maxX' minMaxY.Y' maxZ)) }; " is 133.
Long Statement,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,CreateBlendMap,The length of the statement  "                D3DApp.GD3DApp.ProgressUpdate.Draw(0.70f + 0.05f * ((float)y / terrain.HeightMap.HeightMapHeight)' "Generating blendmap"); " is 122.
Long Statement,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,CreateBlendMap,The length of the statement  "            var blendTex = new Texture2D(device' texDec' new DataRectangle(terrain.HeightMap.HeightMapWidth * Marshal.SizeOf(typeof(Color4))' new DataStream(colors.ToArray()' false' false))) { DebugName = "terrain blend texture" }; " is 219.
Long Statement,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,CreateBlendMap,The length of the statement  "            var srvDesc = new ShaderResourceViewDescription { Format = texDec.Format' Dimension = ShaderResourceViewDimension.Texture2D' MostDetailedMip = 0' MipLevels = -1 }; " is 163.
Complex Conditional,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,Contains,The conditional expression  "p.X >= ScreenPosition.X && p.X <= ScreenPosition.X + Size.X &&                  p.Y >= ScreenPosition.Y && p.Y <= ScreenPosition.Y + Size.Y"  is complex.
Complex Conditional,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,GetPath,The conditional expression  "!Within(start) || !Within(goal) || start == goal || startTile == null || goalTile == null"  is complex.
Complex Conditional,Core.Terrain,WalkMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,CreateWalkableTexture,The conditional expression  "y1 < 0 || y1 >= heightInTiles || x1 < 0 || x1 >= widthInTiles"  is complex.
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: var hNear = 2 * MathF.Tan(FovY / 2) * NearZ;
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: var hNear = 2 * MathF.Tan(FovY / 2) * NearZ;
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: var hFar = 2 * MathF.Tan(FovY / 2) * FarZ;
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: var hFar = 2 * MathF.Tan(FovY / 2) * FarZ;
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,CameraBase,C:\repos\ericrrichards_dx11\DX11\Core\Camera\CameraBase.cs,GetFrustumCorners,The following statement contains a magic number: return new[] {                  //ntl                  cNear + (Up*hNear/2) - (Right*wNear/2)'                  //ntr                  cNear + (Up*hNear/2) + (Right*wNear/2)'                  //nbl                  cNear - (Up *hNear/2) - (Right*wNear/2)'                  //nbr                  cNear - (Up *hNear/2) + (Right*wNear/2)'                  //ftl                  cFar + (Up*hFar/2) - (Right*wFar/2)'                  //ftr                  cFar + (Up*hFar/2) + (Right*wFar/2)'                  //fbl                  cFar - (Up *hFar/2) - (Right*wFar/2)'                  //fbr                  cFar - (Up *hFar/2) + (Right*wFar/2)'              };
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,Zoom,The following statement contains a magic number: var newFov = MathF.Clamp(FovY + dr' 0.1f' MathF.PI / 2);
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[2' 0] = Right.Z;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[3' 0] = x;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[2' 1] = Up.Z;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[3' 1] = y;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[0' 2] = Look.X;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[1' 2] = Look.Y;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[2' 2] = Look.Z;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[2' 2] = Look.Z;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[3' 2] = z;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[3' 2] = z;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[0' 3] = v[1' 3] = v[2' 3] = 0;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[0' 3] = v[1' 3] = v[2' 3] = 0;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[0' 3] = v[1' 3] = v[2' 3] = 0;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[0' 3] = v[1' 3] = v[2' 3] = 0;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[3' 3] = 1;
Magic Number,Core.Camera,FpsCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\FpsCamera.cs,UpdateViewMatrix,The following statement contains a magic number: v[3' 3] = 1;
Magic Number,Core.Camera,OrthoCamera,C:\repos\ericrrichards_dx11\DX11\Core\Camera\OrthoCamera.cs,SetLens,The following statement contains a magic number: Proj = Matrix.OrthoLH(width' height' 0.1f' 2000);
Magic Number,Core.Controls,ColorPickButton,C:\repos\ericrrichards_dx11\DX11\Core\Controls\ColorPickButton.cs,ColorFromVector3,The following statement contains a magic number: return Color.FromArgb((int)(colorVector.X * 256)' (int)(colorVector.Y * 256)' (int)(colorVector.Z * 256));
Magic Number,Core.Controls,ColorPickButton,C:\repos\ericrrichards_dx11\DX11\Core\Controls\ColorPickButton.cs,ColorFromVector3,The following statement contains a magic number: return Color.FromArgb((int)(colorVector.X * 256)' (int)(colorVector.Y * 256)' (int)(colorVector.Z * 256));
Magic Number,Core.Controls,ColorPickButton,C:\repos\ericrrichards_dx11\DX11\Core\Controls\ColorPickButton.cs,ColorFromVector3,The following statement contains a magic number: return Color.FromArgb((int)(colorVector.X * 256)' (int)(colorVector.Y * 256)' (int)(colorVector.Z * 256));
Magic Number,Core,MathF,C:\repos\ericrrichards_dx11\DX11\Core\CosTable.cs,LookupCos,The following statement contains a magic number: var a1 = (int)(a * 1000);
Magic Number,Core,MathF,C:\repos\ericrrichards_dx11\DX11\Core\CosTable.cs,Noise,The following statement contains a magic number: x = (x << 13) ^ x;
Magic Number,Core,MathF,C:\repos\ericrrichards_dx11\DX11\Core\CosTable.cs,Noise,The following statement contains a magic number: return (1.0f - ((x * (x * x * 15731) + 1376312589) & 0x7fffffff) / 1073741824.0f);
Magic Number,Core,MathF,C:\repos\ericrrichards_dx11\DX11\Core\CosTable.cs,Noise,The following statement contains a magic number: return (1.0f - ((x * (x * x * 15731) + 1376312589) & 0x7fffffff) / 1073741824.0f);
Magic Number,Core,MathF,C:\repos\ericrrichards_dx11\DX11\Core\CosTable.cs,PerlinNoise2D,The following statement contains a magic number: var v1 = Noise(txi + tyi * 57 + seed);
Magic Number,Core,MathF,C:\repos\ericrrichards_dx11\DX11\Core\CosTable.cs,PerlinNoise2D,The following statement contains a magic number: var v2 = Noise(txi + 1 + tyi * 57 + seed);
Magic Number,Core,MathF,C:\repos\ericrrichards_dx11\DX11\Core\CosTable.cs,PerlinNoise2D,The following statement contains a magic number: var v3 = Noise(txi + (tyi + 1) * 57 + seed);
Magic Number,Core,MathF,C:\repos\ericrrichards_dx11\DX11\Core\CosTable.cs,PerlinNoise2D,The following statement contains a magic number: var v4 = Noise(txi + 1 + (tyi + 1) * 57 + seed);
Magic Number,Core,MathF,C:\repos\ericrrichards_dx11\DX11\Core\CosTable.cs,AngleFromXY,The following statement contains a magic number: if (x >= 0.0f) {                  theta = Atan(y/x);                  if (theta < 0.0f) {                      theta += 2*PI;                  }              } else {                  theta = Atan(y/x) + PI;              }
Magic Number,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,InitMainWindow,The following statement contains a magic number: try {                  Window = new D3DForm {                      Text = MainWindowCaption'                      Name = "D3DWndClassName"'                      FormBorderStyle = FormBorderStyle.Sizable'                      ClientSize = new Size(ClientWidth' ClientHeight)'                      StartPosition = FormStartPosition.CenterScreen'                      MyWndProc = WndProc'                      MinimumSize = new Size(200' 200)'                  };                  Window.MouseDown += OnMouseDown;                  Window.MouseUp += OnMouseUp;                  Window.MouseMove += OnMouseMove;                  Window.MouseWheel += OnMouseWheel;                  Window.ResizeBegin += (sender' args) => {                      AppPaused = true;                      Resizing = true;                      Timer.Stop();                  };                  Window.ResizeEnd += (sender' args) => {                      AppPaused = false;                      Resizing = false;                      Timer.Start();                      OnResize();                  };                      Window.Show();                  Window.Update();                  return true;              } catch (Exception ex) {                  MessageBox.Show(ex.Message + "\n" + ex.StackTrace' "Error");                  return false;              }
Magic Number,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,InitMainWindow,The following statement contains a magic number: try {                  Window = new D3DForm {                      Text = MainWindowCaption'                      Name = "D3DWndClassName"'                      FormBorderStyle = FormBorderStyle.Sizable'                      ClientSize = new Size(ClientWidth' ClientHeight)'                      StartPosition = FormStartPosition.CenterScreen'                      MyWndProc = WndProc'                      MinimumSize = new Size(200' 200)'                  };                  Window.MouseDown += OnMouseDown;                  Window.MouseUp += OnMouseUp;                  Window.MouseMove += OnMouseMove;                  Window.MouseWheel += OnMouseWheel;                  Window.ResizeBegin += (sender' args) => {                      AppPaused = true;                      Resizing = true;                      Timer.Stop();                  };                  Window.ResizeEnd += (sender' args) => {                      AppPaused = false;                      Resizing = false;                      Timer.Start();                      OnResize();                  };                      Window.Show();                  Window.Update();                  return true;              } catch (Exception ex) {                  MessageBox.Show(ex.Message + "\n" + ex.StackTrace' "Error");                  return false;              }
Magic Number,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,WndProc,The following statement contains a magic number: switch (m.Msg) {                  case WM_ACTIVATE:                      if (m.WParam.ToInt32().LowWord() == 0) {                          AppPaused = true;                          Timer.Stop();                      } else {                          AppPaused = false;                          Timer.Start();                      }                      return true;                  case WM_SIZE:                      ClientWidth = m.LParam.ToInt32().LowWord();                      ClientHeight = m.LParam.ToInt32().HighWord();                      if (Device != null) {                          if (m.WParam.ToInt32() == 1) { // SIZE_MINIMIZED                              AppPaused = true;                              Minimized = true;                              Maximized = false;                          } else if (m.WParam.ToInt32() == 2) { // SIZE_MAXIMIZED                              AppPaused = false;                              Minimized = false;                              Maximized = true;                              OnResize();                          } else if (m.WParam.ToInt32() == 0) { // SIZE_RESTORED                              if (Minimized) {                                  AppPaused = false;                                  Minimized = false;                                  OnResize();                              } else if (Maximized) {                                  AppPaused = false;                                  Maximized = false;                                  OnResize();                              } else if (Resizing) {                                } else {                                  OnResize();                              }                          }                      }                      return true;                  case WM_DESTROY:                      _running = false;                      return true;              }
Magic Number,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,InitDirect3D,The following statement contains a magic number: try {                  var format = GammaCorrectedBackBuffer ? Format.R8G8B8A8_UNorm_SRGB : Format.R8G8B8A8_UNorm;                  var sd = new SwapChainDescription {                      ModeDescription = new ModeDescription(ClientWidth' ClientHeight' new Rational(60' 1)' format) {                          ScanlineOrdering = DisplayModeScanlineOrdering.Unspecified'                          Scaling = DisplayModeScaling.Unspecified                      }'                      SampleDescription = Enable4XMsaa && Device.FeatureLevel >= FeatureLevel.Level_10_1 ? new SampleDescription(4' Msaa4XQuality - 1) : new SampleDescription(1' 0)'                      Usage = Usage.RenderTargetOutput'                      BufferCount = 1'                      OutputHandle = Window.Handle'                      IsWindowed = true'                      SwapEffect = SwapEffect.Discard'                      Flags = SwapChainFlags.None                    };                  SwapChain = new SwapChain(Device.Factory' Device' sd);              } catch (Exception ex) {                  MessageBox.Show("SwapChain creation failed\n" + ex.Message + "\n" + ex.StackTrace' "Error");                  return false;              }
Magic Number,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,InitDirect3D,The following statement contains a magic number: try {                  var format = GammaCorrectedBackBuffer ? Format.R8G8B8A8_UNorm_SRGB : Format.R8G8B8A8_UNorm;                  var sd = new SwapChainDescription {                      ModeDescription = new ModeDescription(ClientWidth' ClientHeight' new Rational(60' 1)' format) {                          ScanlineOrdering = DisplayModeScanlineOrdering.Unspecified'                          Scaling = DisplayModeScaling.Unspecified                      }'                      SampleDescription = Enable4XMsaa && Device.FeatureLevel >= FeatureLevel.Level_10_1 ? new SampleDescription(4' Msaa4XQuality - 1) : new SampleDescription(1' 0)'                      Usage = Usage.RenderTargetOutput'                      BufferCount = 1'                      OutputHandle = Window.Handle'                      IsWindowed = true'                      SwapEffect = SwapEffect.Discard'                      Flags = SwapChainFlags.None                    };                  SwapChain = new SwapChain(Device.Factory' Device' sd);              } catch (Exception ex) {                  MessageBox.Show("SwapChain creation failed\n" + ex.Message + "\n" + ex.StackTrace' "Error");                  return false;              }
Magic Number,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,D3DApp,The following statement contains a magic number: ClientWidth = 800;
Magic Number,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,D3DApp,The following statement contains a magic number: ClientHeight = 600;
Magic Number,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,OnResize,The following statement contains a magic number: var depthStencilDesc = new Texture2DDescription {                  Width = ClientWidth'                  Height = ClientHeight'                  MipLevels = 1'                  ArraySize = 1'                  Format = Format.D24_UNorm_S8_UInt'                  SampleDescription = (Enable4XMsaa && Device.FeatureLevel >= FeatureLevel.Level_10_1) ? new SampleDescription(4' Msaa4XQuality - 1) : new SampleDescription(1' 0)'                  Usage = ResourceUsage.Default'                  BindFlags = BindFlags.DepthStencil'                  CpuAccessFlags = CpuAccessFlags.None'                  OptionFlags = ResourceOptionFlags.None              };
Magic Number,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,Run,The following statement contains a magic number: while (_running) {                  Application.DoEvents();                  Timer.Tick();                    if (!AppPaused) {                      CalculateFrameRateStats();                      UpdateScene(Timer.DeltaTime);                      DrawScene();                      } else {                      Thread.Sleep(100);                  }              }
Magic Number,Core,FontCache,C:\repos\ericrrichards_dx11\DX11\Core\FontCache.cs,FontCache,The following statement contains a magic number: _default = new TextBlockRenderer(sprite' "Arial"' FontWeight.Normal' FontStyle.Normal' FontStretch.Normal' 12);
Magic Number,Core,Frustum,C:\repos\ericrrichards_dx11\DX11\Core\Frustum.cs,Intersect,The following statement contains a magic number: if (totalIn == 6) {                 return 2;             }
Magic Number,Core,Frustum,C:\repos\ericrrichards_dx11\DX11\Core\Frustum.cs,Intersect,The following statement contains a magic number: if (totalIn == 6) {                 return 2;             }
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateBox,The following statement contains a magic number: ret.Indices.AddRange(new[]{                  0'1'2'0'2'3'                  4'5'6'4'6'7'                  8'9'10'8'10'11'                  12'13'14'12'14'15'                  16'17'18'16'18'19'                  20'21'22'20'22'23              });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateSphere,The following statement contains a magic number: for (var i = 1; i <= stackCount - 1; i++) {                  var phi = i * phiStep;                  for (var j = 0; j <= sliceCount; j++) {                      var theta = j * thetaStep;                      var p = new Vector3(                          (radius * MathF.Sin(phi) * MathF.Cos(theta))'                          (radius * MathF.Cos(phi))'                          (radius * MathF.Sin(phi) * MathF.Sin(theta))                          );                        var t = new Vector3(-radius * MathF.Sin(phi) * MathF.Sin(theta)' 0' radius * MathF.Sin(phi) * MathF.Cos(theta));                      t.Normalize();                      var n = Vector3.Normalize(p);                        var uv = new Vector2(theta / (MathF.PI * 2)' phi / MathF.PI);                      ret.Vertices.Add(new Vertex(p' n' t' uv));                  }              }
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateSphere,The following statement contains a magic number: for (var i = 0; i < stackCount - 2; i++) {                  for (var j = 0; j < sliceCount; j++) {                      ret.Indices.Add(baseIndex + i * ringVertexCount + j);                      ret.Indices.Add(baseIndex + i * ringVertexCount + j + 1);                      ret.Indices.Add(baseIndex + (i + 1) * ringVertexCount + j);                        ret.Indices.Add(baseIndex + (i + 1) * ringVertexCount + j);                      ret.Indices.Add(baseIndex + i * ringVertexCount + j + 1);                      ret.Indices.Add(baseIndex + (i + 1) * ringVertexCount + j + 1);                  }              }
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateGeosphere,The following statement contains a magic number: for (var i = 0; i < tempMesh.Vertices.Count; i++) {                  // Project onto unit sphere.                  var n = Vector3.Normalize(tempMesh.Vertices[i].Position);                  // Project onto sphere.                  var p = radius * n;                    // Derive texture coordinates from spherical coordinates.                  var theta = MathF.AngleFromXY(tempMesh.Vertices[i].Position.X' tempMesh.Vertices[i].Position.Z);                  var phi = MathF.Acos(tempMesh.Vertices[i].Position.Y / radius);                  var texC = new Vector2(theta / (2 * MathF.PI)' phi / MathF.PI);                    // Partial derivative of P with respect to theta                  var tangent = new Vector3(                      -radius * MathF.Sin(phi) * MathF.Sin(theta)'                      0'                      radius * MathF.Sin(phi) * MathF.Cos(theta)                  );                  tangent.Normalize();                    tempMesh.Vertices[i] = new Vertex(p' n' tangent' texC);              }
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateFullScreenQuad,The following statement contains a magic number: ret.Indices.AddRange(new[] { 0' 1' 2' 0' 2' 3 });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateFullScreenQuad,The following statement contains a magic number: ret.Indices.AddRange(new[] { 0' 1' 2' 0' 2' 3 });
Magic Number,Core,GeometryGenerator,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,CreateFullScreenQuad,The following statement contains a magic number: ret.Indices.AddRange(new[] { 0' 1' 2' 0' 2' 3 });
Magic Number,Core,Subdivider,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,Subdivide4,The following statement contains a magic number: var numTris = mesh.Indices.Count / 3;
Magic Number,Core,Subdivider,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,Subdivide4,The following statement contains a magic number: for (var i = 0; i < numTris; i++) {                      //       i2                      //       *                      //      / \                      //     /   \                      //   a*-----*b                      //   / \   / \                      //  /   \ /   \                      // *-----*-----*                      // i1    c      i3                        var i1 = mesh.Indices[i * 3];                      var i2 = mesh.Indices[i * 3 + 1];                      var i3 = mesh.Indices[i * 3 + 2];                        var a = GetNewVertex(i1' i2);                      var b = GetNewVertex(i2' i3);                      var c = GetNewVertex(i3' i1);                        _indices.AddRange(new[] {                  i1' a' c'                  i2' b' a'                  i3' c' b'                  a' b' c              });                  }
Magic Number,Core,Subdivider,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,Subdivide4,The following statement contains a magic number: for (var i = 0; i < numTris; i++) {                      //       i2                      //       *                      //      / \                      //     /   \                      //   a*-----*b                      //   / \   / \                      //  /   \ /   \                      // *-----*-----*                      // i1    c      i3                        var i1 = mesh.Indices[i * 3];                      var i2 = mesh.Indices[i * 3 + 1];                      var i3 = mesh.Indices[i * 3 + 2];                        var a = GetNewVertex(i1' i2);                      var b = GetNewVertex(i2' i3);                      var c = GetNewVertex(i3' i1);                        _indices.AddRange(new[] {                  i1' a' c'                  i2' b' a'                  i3' c' b'                  a' b' c              });                  }
Magic Number,Core,Subdivider,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,Subdivide4,The following statement contains a magic number: for (var i = 0; i < numTris; i++) {                      //       i2                      //       *                      //      / \                      //     /   \                      //   a*-----*b                      //   / \   / \                      //  /   \ /   \                      // *-----*-----*                      // i1    c      i3                        var i1 = mesh.Indices[i * 3];                      var i2 = mesh.Indices[i * 3 + 1];                      var i3 = mesh.Indices[i * 3 + 2];                        var a = GetNewVertex(i1' i2);                      var b = GetNewVertex(i2' i3);                      var c = GetNewVertex(i3' i1);                        _indices.AddRange(new[] {                  i1' a' c'                  i2' b' a'                  i3' c' b'                  a' b' c              });                  }
Magic Number,Core,Subdivider,C:\repos\ericrrichards_dx11\DX11\Core\GeometryGenerator.cs,Subdivide4,The following statement contains a magic number: for (var i = 0; i < numTris; i++) {                      //       i2                      //       *                      //      / \                      //     /   \                      //   a*-----*b                      //   / \   / \                      //  /   \ /   \                      // *-----*-----*                      // i1    c      i3                        var i1 = mesh.Indices[i * 3];                      var i2 = mesh.Indices[i * 3 + 1];                      var i3 = mesh.Indices[i * 3 + 2];                        var a = GetNewVertex(i1' i2);                      var b = GetNewVertex(i2' i3);                      var c = GetNewVertex(i3' i1);                        _indices.AddRange(new[] {                  i1' a' c'                  i2' b' a'                  i3' c' b'                  a' b' c              });                  }
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _borderBounds = new Rectangle(18' rt1.PixelSize.Height / 2 - 2' rt1.PixelSize.Width - 36' 24);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _borderBounds = new Rectangle(18' rt1.PixelSize.Height / 2 - 2' rt1.PixelSize.Width - 36' 24);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _borderBounds = new Rectangle(18' rt1.PixelSize.Height / 2 - 2' rt1.PixelSize.Width - 36' 24);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _borderBounds = new Rectangle(18' rt1.PixelSize.Height / 2 - 2' rt1.PixelSize.Width - 36' 24);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _borderBounds = new Rectangle(18' rt1.PixelSize.Height / 2 - 2' rt1.PixelSize.Width - 36' 24);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _barBounds = new Rectangle(20' rt1.PixelSize.Height / 2' rt1.PixelSize.Width - 40' 20);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _barBounds = new Rectangle(20' rt1.PixelSize.Height / 2' rt1.PixelSize.Width - 40' 20);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _barBounds = new Rectangle(20' rt1.PixelSize.Height / 2' rt1.PixelSize.Width - 40' 20);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _barBounds = new Rectangle(20' rt1.PixelSize.Height / 2' rt1.PixelSize.Width - 40' 20);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _txtFormat = new TextFormat(_factory' "Arial"' FontWeight.Normal' FontStyle.Normal' FontStretch.Normal' 18' "en-us") {                  TextAlignment = TextAlignment.Center              };
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _textRect = new Rectangle(100' rt1.PixelSize.Height / 2 - 25' _rt.PixelSize.Width - 200' 20);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _textRect = new Rectangle(100' rt1.PixelSize.Height / 2 - 25' _rt.PixelSize.Width - 200' 20);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _textRect = new Rectangle(100' rt1.PixelSize.Height / 2 - 25' _rt.PixelSize.Width - 200' 20);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _textRect = new Rectangle(100' rt1.PixelSize.Height / 2 - 25' _rt.PixelSize.Width - 200' 20);
Magic Number,Core,ProgressUpdate,C:\repos\ericrrichards_dx11\DX11\Core\ProgressUpdate.cs,ProgressUpdate,The following statement contains a magic number: _textRect = new Rectangle(100' rt1.PixelSize.Height / 2 - 25' _rt.PixelSize.Width - 200' 20);
Magic Number,Core,Sky,C:\repos\ericrrichards_dx11\DX11\Core\Sky.cs,Sky,The following statement contains a magic number: var sphere = GeometryGenerator.CreateSphere(skySphereRadius' 30' 30);
Magic Number,Core,Sky,C:\repos\ericrrichards_dx11\DX11\Core\Sky.cs,Sky,The following statement contains a magic number: var sphere = GeometryGenerator.CreateSphere(skySphereRadius' 30' 30);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,ComputeSsao,The following statement contains a magic number: for (var p = 0; p < tech.Description.PassCount; p++) {                  tech.GetPassByIndex(p).Apply(_dc);                  _dc.DrawIndexed(6' 0' 0);              }
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BlurAmbientMap,The following statement contains a magic number: for (var p = 0; p < tech.Description.PassCount; p++) {                  var pass = tech.GetPassByIndex(p);                  pass.Apply(_dc);                  _dc.DrawIndexed(6' 0' 0);                  Effects.SsaoBlurFX.SetInputImage(null);                  pass.Apply(_dc);              }
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFrustumFarCorners,The following statement contains a magic number: _frustumFarCorners[2] = new Vector4(+halfWidth' +halfHeight' farz' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFrustumFarCorners,The following statement contains a magic number: _frustumFarCorners[3] = new Vector4(+halfWidth' -halfHeight' farz' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFullScreenQuad,The following statement contains a magic number: var v = new Basic32[4];
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFullScreenQuad,The following statement contains a magic number: v[2] = new Basic32(new Vector3(+1' +1' 0)' new Vector3(2' 0' 0)' new Vector2(1' 0));
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFullScreenQuad,The following statement contains a magic number: v[2] = new Basic32(new Vector3(+1' +1' 0)' new Vector3(2' 0' 0)' new Vector2(1' 0));
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFullScreenQuad,The following statement contains a magic number: v[3] = new Basic32(new Vector3(+1' -1' 0)' new Vector3(3' 0' 0)' new Vector2(1' 1));
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFullScreenQuad,The following statement contains a magic number: v[3] = new Basic32(new Vector3(+1' -1' 0)' new Vector3(3' 0' 0)' new Vector2(1' 1));
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFullScreenQuad,The following statement contains a magic number: var vbd = new BufferDescription(Basic32.Stride * 4' ResourceUsage.Immutable' BindFlags.VertexBuffer'                  CpuAccessFlags.None' ResourceOptionFlags.None' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFullScreenQuad,The following statement contains a magic number: var indices = new short[] { 0' 1' 2' 0' 2' 3 };
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFullScreenQuad,The following statement contains a magic number: var indices = new short[] { 0' 1' 2' 0' 2' 3 };
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFullScreenQuad,The following statement contains a magic number: var indices = new short[] { 0' 1' 2' 0' 2' 3 };
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildFullScreenQuad,The following statement contains a magic number: var ibd = new BufferDescription(sizeof(short) * 6' ResourceUsage.Immutable' BindFlags.IndexBuffer'                  CpuAccessFlags.None' ResourceOptionFlags.None' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildTextureViews,The following statement contains a magic number: texDesc.Width = _renderTargetWidth / 2;
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildTextureViews,The following statement contains a magic number: texDesc.Height = _renderTargetHeight / 2;
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildRandomVectorTexture,The following statement contains a magic number: var texDesc = new Texture2DDescription {                  Width = 256'                  Height = 256'                  MipLevels = 1'                  ArraySize = 1'                  Format = Format.R8G8B8A8_UNorm'                  SampleDescription = new SampleDescription(1' 0)'                  Usage = ResourceUsage.Dynamic'                  BindFlags = BindFlags.ShaderResource'                  CpuAccessFlags = CpuAccessFlags.Write'                  OptionFlags = ResourceOptionFlags.None              };
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildRandomVectorTexture,The following statement contains a magic number: var texDesc = new Texture2DDescription {                  Width = 256'                  Height = 256'                  MipLevels = 1'                  ArraySize = 1'                  Format = Format.R8G8B8A8_UNorm'                  SampleDescription = new SampleDescription(1' 0)'                  Usage = ResourceUsage.Dynamic'                  BindFlags = BindFlags.ShaderResource'                  CpuAccessFlags = CpuAccessFlags.Write'                  OptionFlags = ResourceOptionFlags.None              };
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildRandomVectorTexture,The following statement contains a magic number: for (var i = 0; i < 256; i++) {                  for (var j = 0; j < 256; j++) {                      var v = new Vector3(MathF.Rand(0' 1)' MathF.Rand(0' 1)' MathF.Rand(0' 1));                      color.Add(new Color4(0' v.X' v.Y' v.Z));                  }              }
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildRandomVectorTexture,The following statement contains a magic number: for (var i = 0; i < 256; i++) {                  for (var j = 0; j < 256; j++) {                      var v = new Vector3(MathF.Rand(0' 1)' MathF.Rand(0' 1)' MathF.Rand(0' 1));                      color.Add(new Color4(0' v.X' v.Y' v.Z));                  }              }
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildRandomVectorTexture,The following statement contains a magic number: foreach (var color4 in color) {                  box.Data.Write((byte)(color4.Red * 255));                  box.Data.Write((byte)(color4.Green * 255));                  box.Data.Write((byte)(color4.Blue * 255));                  box.Data.Write((byte)(0));              }
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildRandomVectorTexture,The following statement contains a magic number: foreach (var color4 in color) {                  box.Data.Write((byte)(color4.Red * 255));                  box.Data.Write((byte)(color4.Green * 255));                  box.Data.Write((byte)(color4.Blue * 255));                  box.Data.Write((byte)(0));              }
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildRandomVectorTexture,The following statement contains a magic number: foreach (var color4 in color) {                  box.Data.Write((byte)(color4.Red * 255));                  box.Data.Write((byte)(color4.Green * 255));                  box.Data.Write((byte)(color4.Blue * 255));                  box.Data.Write((byte)(0));              }
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[2] = new Vector4(-1' +1' +1' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[3] = new Vector4(+1' -1' -1' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[4] = new Vector4(+1' +1' -1' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[5] = new Vector4(-1' -1' +1' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[6] = new Vector4(-1' +1' -1' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[7] = new Vector4(+1' -1' +1' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[8] = new Vector4(-1' 0' 0' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[9] = new Vector4(+1' 0' 0' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[10] = new Vector4(0' -1' 0' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[11] = new Vector4(0' +1' 0' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[12] = new Vector4(0' 0' -1' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: _offsets[13] = new Vector4(0' 0' +1' 0);
Magic Number,Core,Ssao,C:\repos\ericrrichards_dx11\DX11\Core\SSAO.cs,BuildOffsetVectors,The following statement contains a magic number: for (var i = 0; i < 14; i++) {                  var s = MathF.Rand(0.25f' 1.0f);                  var v = s * Vector4.Normalize(_offsets[i]);                  _offsets[i] = v;              }
Magic Number,Core,TextureAtlas,C:\repos\ericrrichards_dx11\DX11\Core\TextureAtlas.cs,TextureAtlas,The following statement contains a magic number: Columns = Math.Min(8192 / w' (int)Math.Ceiling(Math.Sqrt(NumCells)));
Magic Number,Core,TextureAtlas,C:\repos\ericrrichards_dx11\DX11\Core\TextureAtlas.cs,TextureAtlas,The following statement contains a magic number: Rows = Math.Min(8192 / h' (int)Math.Ceiling((float)NumCells/Columns));
Magic Number,Core,TextureAtlas,C:\repos\ericrrichards_dx11\DX11\Core\TextureAtlas.cs,TextureAtlas,The following statement contains a magic number: using (var g = Graphics.FromImage(bitmap)) {                  g.Clear(Color.Black);                  var r = 0;                  var c = 0;                  foreach (var filename in filenames) {                      g.DrawImage(new Bitmap(filename)' new Point(c*w' r*h) );                        _texTransforms[r * Columns + c] =                          Matrix.Scaling(1.0f/(Columns*2)' 1.0f / (2*Rows)' 0) *                           Matrix.Translation(c * w / (float)bitmap.Width' r * h / (float)bitmap.Width' 0);                        c++;                      if (c >= Columns) {                          c = 0;                          r++;                      }                    }              }
Magic Number,Core,TextureAtlas,C:\repos\ericrrichards_dx11\DX11\Core\TextureAtlas.cs,TextureAtlas,The following statement contains a magic number: using (var g = Graphics.FromImage(bitmap)) {                  g.Clear(Color.Black);                  var r = 0;                  var c = 0;                  foreach (var filename in filenames) {                      g.DrawImage(new Bitmap(filename)' new Point(c*w' r*h) );                        _texTransforms[r * Columns + c] =                          Matrix.Scaling(1.0f/(Columns*2)' 1.0f / (2*Rows)' 0) *                           Matrix.Translation(c * w / (float)bitmap.Width' r * h / (float)bitmap.Width' 0);                        c++;                      if (c >= Columns) {                          c = 0;                          r++;                      }                    }              }
Magic Number,Core,Util,C:\repos\ericrrichards_dx11\DX11\Core\Util.cs,Center,The following statement contains a magic number: return (b.Maximum + b.Minimum) / 2;
Magic Number,Core,Util,C:\repos\ericrrichards_dx11\DX11\Core\Util.cs,ToMatrix,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  for (int j = 0; j < 4; j++) {                      ret[i' j] = m[i + 1' j + 1];                  }              }
Magic Number,Core,Util,C:\repos\ericrrichards_dx11\DX11\Core\Util.cs,ToMatrix,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  for (int j = 0; j < 4; j++) {                      ret[i' j] = m[i + 1' j + 1];                  }              }
Magic Number,Core,Util,C:\repos\ericrrichards_dx11\DX11\Core\Util.cs,HighWord,The following statement contains a magic number: return (i >> 16) & 0xFFFF;
Magic Number,Core,Util,C:\repos\ericrrichards_dx11\DX11\Core\Util.cs,CreateRandomTexture1DSRV,The following statement contains a magic number: for (int i = 0; i < 1024; i++) {                  randomValues.Add(new Vector4(MathF.Rand(-1.0f' 1.0f)' MathF.Rand(-1.0f' 1.0f)' MathF.Rand(-1.0f' 1.0f)' MathF.Rand(-1.0f' 1.0f)));              }
Magic Number,Core,Util,C:\repos\ericrrichards_dx11\DX11\Core\Util.cs,CreateRandomTexture1DSRV,The following statement contains a magic number: var texDesc = new Texture1DDescription() {                  ArraySize = 1'                  BindFlags = BindFlags.ShaderResource'                  CpuAccessFlags = CpuAccessFlags.None'                  Format = Format.R32G32B32A32_Float'                  MipLevels = 1'                  OptionFlags = ResourceOptionFlags.None'                  Usage = ResourceUsage.Immutable'                  Width = 1024              };
Magic Number,Core,PosNormalTexTanSkinned,C:\repos\ericrrichards_dx11\DX11\Core\Vertex.cs,PosNormalTexTanSkinned,The following statement contains a magic number: for (int index = 0; index < boneIndices.Length; index++) {                      switch (index) {                          case 0:                              BoneIndices.B0 = boneIndices[index];                              break;                          case 1:                              BoneIndices.B1 = boneIndices[index];                              break;                          case 2:                              BoneIndices.B2 = boneIndices[index];                              break;                          case 3:                              BoneIndices.B3 = boneIndices[index];                              break;                      }                  }
Magic Number,Core,PosNormalTexTanSkinned,C:\repos\ericrrichards_dx11\DX11\Core\Vertex.cs,PosNormalTexTanSkinned,The following statement contains a magic number: for (int index = 0; index < boneIndices.Length; index++) {                      switch (index) {                          case 0:                              BoneIndices.B0 = boneIndices[index];                              break;                          case 1:                              BoneIndices.B1 = boneIndices[index];                              break;                          case 2:                              BoneIndices.B2 = boneIndices[index];                              break;                          case 3:                              BoneIndices.B3 = boneIndices[index];                              break;                      }                  }
Magic Number,Core,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Waves.cs,Init,The following statement contains a magic number: TriangleCount = (m - 1) * (n - 1) * 2;
Magic Number,Core,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Waves.cs,Disturb,The following statement contains a magic number: Debug.Assert(i > 1 && i < RowCount-2);
Magic Number,Core,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Waves.cs,Disturb,The following statement contains a magic number: Debug.Assert(j > 1 && j < ColumnCount -2);
Magic Number,Core.FX,TerrainEffect,C:\repos\ericrrichards_dx11\DX11\Core\FX\TerrainEffect.cs,SetWorldFrustumPlanes,The following statement contains a magic number: Debug.Assert(planes.Length == 6);
Magic Number,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,BasicModel,The following statement contains a magic number: foreach (var mesh in model.Meshes) {                  var verts = new List<PosNormalTexTan>();                  var subset = new MeshGeometry.Subset {                        VertexCount = mesh.VertexCount'                      VertexStart = Vertices.Count'                      FaceStart = Indices.Count / 3'                      FaceCount = mesh.FaceCount                  };                  Subsets.Add(subset);                  // bounding box corners                      for (var i = 0; i < mesh.VertexCount; i++) {                      var pos = mesh.HasVertices ? mesh.Vertices[i].ToVector3() : new Vector3();                      min = Vector3.Minimize(min' pos);                      max = Vector3.Maximize(max' pos);                        var norm = mesh.HasNormals ? mesh.Normals[i] : new Vector3D();                      var texC = mesh.HasTextureCoords(0) ? mesh.TextureCoordinateChannels[0][i] : new Vector3D();                      var tan = mesh.HasTangentBasis ? mesh.Tangents[i] : new Vector3D();                      var v = new PosNormalTexTan(pos' norm.ToVector3()' texC.ToVector2()' tan.ToVector3());                      verts.Add(v);                  }                    Vertices.AddRange(verts);                    var indices = mesh.GetIndices().Select(i => ((int)i + subset.VertexStart)).ToList();                  Indices.AddRange(indices);                    var mat = model.Materials[mesh.MaterialIndex];                  var material = mat.ToMaterial();                    Materials.Add(material);                  TextureSlot diffuseSlot;                  mat.GetMaterialTexture(TextureType.Diffuse' 0' out diffuseSlot);                  var diffusePath = diffuseSlot.FilePath;                  if (Path.GetExtension(diffusePath) == ".tga") {                      // DirectX doesn't like to load tgas' so you will need to convert them to pngs yourself with an image editor                      diffusePath = diffusePath.Replace(".tga"' ".png");                  }                  if (!string.IsNullOrEmpty(diffusePath)) {                      DiffuseMapSRV.Add(texMgr.CreateTexture(Path.Combine(texturePath' diffusePath)));                  }                  TextureSlot normalSlot;                  mat.GetMaterialTexture(TextureType.Normals' 0' out normalSlot);                  var normalPath = normalSlot.FilePath;                  if (!string.IsNullOrEmpty(normalPath)) {                      NormalMapSRV.Add(texMgr.CreateTexture(Path.Combine(texturePath' normalPath)));                  } else {                      var normalExt = Path.GetExtension(diffusePath);                      normalPath = Path.GetFileNameWithoutExtension(diffusePath) + "_nmap" + normalExt;                        NormalMapSRV.Add(texMgr.CreateTexture(Path.Combine(texturePath' normalPath)));                    }              }
Magic Number,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,InitFromMeshData,The following statement contains a magic number: var subset = new MeshGeometry.Subset {                  FaceCount = mesh.Indices.Count / 3'                  FaceStart = 0'                  VertexCount = mesh.Vertices.Count'                  VertexStart = 0              };
Magic Number,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,InitFromMeshData,The following statement contains a magic number: Materials.Add(new Material { Ambient = Color.Gray' Diffuse = Color.White' Specular = new Color4(16' 1' 1' 1) });
Magic Number,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,LoadFromTxtFile,The following statement contains a magic number: using (var reader = new StreamReader(filename)) {                      var input = reader.ReadLine();                  if (input != null)                      // VertexCount: X                      vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                    input = reader.ReadLine();                  if (input != null)                      //TriangleCount: X                      tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                    // skip ahead to the vertex data                  do {                      input = reader.ReadLine();                  } while (input != null && !input.StartsWith("{"));                  // Get the vertices                    for (int i = 0; i < vcount; i++) {                      input = reader.ReadLine();                      if (input != null) {                          var vals = input.Split(new[] { ' ' });                          vertices.Add(                                       new Basic32(                                           new Vector3(                                               Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture))'                                           new Vector3(                                               Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))'                                           new Vector2()                                           )                              );                      }                  }                  // skip ahead to the index data                  do {                      input = reader.ReadLine();                  } while (input != null && !input.StartsWith("{"));                  // Get the indices                    for (var i = 0; i < tcount; i++) {                      input = reader.ReadLine();                      if (input == null) {                          break;                      }                      var m = input.Trim().Split(new[] { ' ' });                      indices.Add(Convert.ToInt32(m[0].Trim()));                      indices.Add(Convert.ToInt32(m[1].Trim()));                      indices.Add(Convert.ToInt32(m[2].Trim()));                  }              }
Magic Number,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,LoadFromTxtFile,The following statement contains a magic number: using (var reader = new StreamReader(filename)) {                      var input = reader.ReadLine();                  if (input != null)                      // VertexCount: X                      vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                    input = reader.ReadLine();                  if (input != null)                      //TriangleCount: X                      tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                    // skip ahead to the vertex data                  do {                      input = reader.ReadLine();                  } while (input != null && !input.StartsWith("{"));                  // Get the vertices                    for (int i = 0; i < vcount; i++) {                      input = reader.ReadLine();                      if (input != null) {                          var vals = input.Split(new[] { ' ' });                          vertices.Add(                                       new Basic32(                                           new Vector3(                                               Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture))'                                           new Vector3(                                               Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))'                                           new Vector2()                                           )                              );                      }                  }                  // skip ahead to the index data                  do {                      input = reader.ReadLine();                  } while (input != null && !input.StartsWith("{"));                  // Get the indices                    for (var i = 0; i < tcount; i++) {                      input = reader.ReadLine();                      if (input == null) {                          break;                      }                      var m = input.Trim().Split(new[] { ' ' });                      indices.Add(Convert.ToInt32(m[0].Trim()));                      indices.Add(Convert.ToInt32(m[1].Trim()));                      indices.Add(Convert.ToInt32(m[2].Trim()));                  }              }
Magic Number,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,LoadFromTxtFile,The following statement contains a magic number: using (var reader = new StreamReader(filename)) {                      var input = reader.ReadLine();                  if (input != null)                      // VertexCount: X                      vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                    input = reader.ReadLine();                  if (input != null)                      //TriangleCount: X                      tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                    // skip ahead to the vertex data                  do {                      input = reader.ReadLine();                  } while (input != null && !input.StartsWith("{"));                  // Get the vertices                    for (int i = 0; i < vcount; i++) {                      input = reader.ReadLine();                      if (input != null) {                          var vals = input.Split(new[] { ' ' });                          vertices.Add(                                       new Basic32(                                           new Vector3(                                               Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture))'                                           new Vector3(                                               Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))'                                           new Vector2()                                           )                              );                      }                  }                  // skip ahead to the index data                  do {                      input = reader.ReadLine();                  } while (input != null && !input.StartsWith("{"));                  // Get the indices                    for (var i = 0; i < tcount; i++) {                      input = reader.ReadLine();                      if (input == null) {                          break;                      }                      var m = input.Trim().Split(new[] { ' ' });                      indices.Add(Convert.ToInt32(m[0].Trim()));                      indices.Add(Convert.ToInt32(m[1].Trim()));                      indices.Add(Convert.ToInt32(m[2].Trim()));                  }              }
Magic Number,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,LoadFromTxtFile,The following statement contains a magic number: using (var reader = new StreamReader(filename)) {                      var input = reader.ReadLine();                  if (input != null)                      // VertexCount: X                      vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                    input = reader.ReadLine();                  if (input != null)                      //TriangleCount: X                      tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                    // skip ahead to the vertex data                  do {                      input = reader.ReadLine();                  } while (input != null && !input.StartsWith("{"));                  // Get the vertices                    for (int i = 0; i < vcount; i++) {                      input = reader.ReadLine();                      if (input != null) {                          var vals = input.Split(new[] { ' ' });                          vertices.Add(                                       new Basic32(                                           new Vector3(                                               Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture))'                                           new Vector3(                                               Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))'                                           new Vector2()                                           )                              );                      }                  }                  // skip ahead to the index data                  do {                      input = reader.ReadLine();                  } while (input != null && !input.StartsWith("{"));                  // Get the indices                    for (var i = 0; i < tcount; i++) {                      input = reader.ReadLine();                      if (input == null) {                          break;                      }                      var m = input.Trim().Split(new[] { ' ' });                      indices.Add(Convert.ToInt32(m[0].Trim()));                      indices.Add(Convert.ToInt32(m[1].Trim()));                      indices.Add(Convert.ToInt32(m[2].Trim()));                  }              }
Magic Number,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,LoadFromTxtFile,The following statement contains a magic number: using (var reader = new StreamReader(filename)) {                      var input = reader.ReadLine();                  if (input != null)                      // VertexCount: X                      vcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                    input = reader.ReadLine();                  if (input != null)                      //TriangleCount: X                      tcount = Convert.ToInt32(input.Split(new[] { ':' })[1].Trim());                    // skip ahead to the vertex data                  do {                      input = reader.ReadLine();                  } while (input != null && !input.StartsWith("{"));                  // Get the vertices                    for (int i = 0; i < vcount; i++) {                      input = reader.ReadLine();                      if (input != null) {                          var vals = input.Split(new[] { ' ' });                          vertices.Add(                                       new Basic32(                                           new Vector3(                                               Convert.ToSingle(vals[0].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[1].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[2].Trim()' CultureInfo.InvariantCulture))'                                           new Vector3(                                               Convert.ToSingle(vals[3].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[4].Trim()' CultureInfo.InvariantCulture)'                                               Convert.ToSingle(vals[5].Trim()' CultureInfo.InvariantCulture))'                                           new Vector2()                                           )                              );                      }                  }                  // skip ahead to the index data                  do {                      input = reader.ReadLine();                  } while (input != null && !input.StartsWith("{"));                  // Get the indices                    for (var i = 0; i < tcount; i++) {                      input = reader.ReadLine();                      if (input == null) {                          break;                      }                      var m = input.Trim().Split(new[] { ' ' });                      indices.Add(Convert.ToInt32(m[0].Trim()));                      indices.Add(Convert.ToInt32(m[1].Trim()));                      indices.Add(Convert.ToInt32(m[2].Trim()));                  }              }
Magic Number,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,LoadFromTxtFile,The following statement contains a magic number: var subset = new MeshGeometry.Subset {                  FaceCount = indices.Count / 3'                  FaceStart = 0'                  VertexCount = vertices.Count'                  VertexStart = 0              };
Magic Number,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,LoadFromTxtFile,The following statement contains a magic number: ret.Materials.Add(new Material { Ambient = Color.Gray' Diffuse = Color.White' Specular = new Color4(16' 1' 1' 1) });
Magic Number,Core.Model,BasicModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\BasicModel.cs,LoadSdkMesh,The following statement contains a magic number: foreach (var sdkMeshSubset in sdkMesh.Subsets) {                  var subset = new MeshGeometry.Subset {                      FaceCount = (int)(sdkMeshSubset.IndexCount / 3)'                      FaceStart = faceStart'                      VertexCount = (int)sdkMeshSubset.VertexCount'                      VertexStart = vertexStart                  };                  // fixup any subset indices that assume that all vertices and indices are not in the same buffers                  faceStart = subset.FaceStart + subset.FaceCount;                  vertexStart = subset.VertexStart + subset.VertexCount;                  ret.Subsets.Add(subset);              }
Magic Number,Core.Model,MeshGeometry,C:\repos\ericrrichards_dx11\DX11\Core\Model\MeshGeometry.cs,Draw,The following statement contains a magic number: dc.DrawIndexed(_subsetTable[subsetId].FaceCount*3' _subsetTable[subsetId].FaceStart*3' 0);
Magic Number,Core.Model,MeshGeometry,C:\repos\ericrrichards_dx11\DX11\Core\Model\MeshGeometry.cs,Draw,The following statement contains a magic number: dc.DrawIndexed(_subsetTable[subsetId].FaceCount*3' _subsetTable[subsetId].FaceStart*3' 0);
Magic Number,Core.Model,MeshGeometry,C:\repos\ericrrichards_dx11\DX11\Core\Model\MeshGeometry.cs,DrawInstanced,The following statement contains a magic number: dc.DrawIndexedInstanced(_subsetTable[subsetId].FaceCount * 3' numInstances' _subsetTable[subsetId].FaceStart * 3'  0' 0);
Magic Number,Core.Model,MeshGeometry,C:\repos\ericrrichards_dx11\DX11\Core\Model\MeshGeometry.cs,DrawInstanced,The following statement contains a magic number: dc.DrawIndexedInstanced(_subsetTable[subsetId].FaceCount * 3' numInstances' _subsetTable[subsetId].FaceStart * 3'  0' 0);
Magic Number,Core.Model,SdkMeshHeader,C:\repos\ericrrichards_dx11\DX11\Core\Model\SDKMesh.cs,SdkMeshHeader,The following statement contains a magic number: reader.ReadBytes(3);
Magic Number,Core.Model,SdkMeshVertexBuffer,C:\repos\ericrrichards_dx11\DX11\Core\Model\SDKMesh.cs,SdkMeshVertexBuffer,The following statement contains a magic number: for (int j = 0; j < MaxVertexElements; j++) {                      var stream = reader.ReadUInt16();                      var offset = reader.ReadUInt16();                      var type = reader.ReadByte();                      var method = reader.ReadByte();                      var usage = reader.ReadByte();                      var usageIndex = reader.ReadByte();                      if (stream < 16 && processElem) {                          var element = new VertexElement((short)stream' (short)offset' (DeclarationType)type' (DeclarationMethod)method' (DeclarationUsage)usage' usageIndex);                          Decl.Add(element);                      } else {                          processElem = false;                      }                  }
Magic Number,Core.Model,SdkMeshMesh,C:\repos\ericrrichards_dx11\DX11\Core\Model\SDKMesh.cs,SdkMeshMesh,The following statement contains a magic number: reader.ReadBytes(3);
Magic Number,Core.Model,SdkMeshFrame,C:\repos\ericrrichards_dx11\DX11\Core\Model\SDKMesh.cs,SdkMeshFrame,The following statement contains a magic number: for (int j = 0; j < 4; j++) {                      for (int k = 0; k < 4; k++) {                          Matrix[k' j] = reader.ReadSingle();                      }                  }
Magic Number,Core.Model,SdkMeshFrame,C:\repos\ericrrichards_dx11\DX11\Core\Model\SDKMesh.cs,SdkMeshFrame,The following statement contains a magic number: for (int j = 0; j < 4; j++) {                      for (int k = 0; k < 4; k++) {                          Matrix[k' j] = reader.ReadSingle();                      }                  }
Magic Number,Core.Model,SkinnedModel,C:\repos\ericrrichards_dx11\DX11\Core\Model\SkinnedModel.cs,SkinnedModel,The following statement contains a magic number: foreach (var mesh in model.Meshes) {                  ExtractBoneWeightsFromMesh(mesh' vertToBoneWeight);                  var subset = new MeshGeometry.Subset {                      VertexCount = mesh.VertexCount'                      VertexStart = Vertices.Count'                      FaceStart = Indices.Count / 3'                      FaceCount = mesh.FaceCount                  };                  Subsets.Add(subset);                    var verts = ExtractVertices(mesh' vertToBoneWeight' flipTexY);                  Vertices.AddRange(verts);                  // extract indices and shift them to the proper offset into the combined vertex buffer                  var indices = mesh.GetIndices().Select(i => ((int)i + subset.VertexStart)).ToList();                  Indices.AddRange(indices);                    // extract materials                  var mat = model.Materials[mesh.MaterialIndex];                  var material = mat.ToMaterial();                  Materials.Add(material);                    // extract material textures                  TextureSlot diffuseSlot;                  mat.GetMaterialTexture(TextureType.Diffuse' 0' out diffuseSlot);                  var diffusePath = diffuseSlot.FilePath;                  if (!string.IsNullOrEmpty(diffusePath)) {                      DiffuseMapSRV.Add(texMgr.CreateTexture(Path.Combine(texturePath' diffusePath)));                  }                    TextureSlot normalSlot;                  mat.GetMaterialTexture(TextureType.Normals' 0' out normalSlot);                  var normalPath = normalSlot.FilePath;                  if (!string.IsNullOrEmpty(normalPath)) {                      NormalMapSRV.Add(texMgr.CreateTexture(Path.Combine(texturePath' normalPath)));                  } else {                      // for models created without a normal map baked' we'll check for a texture with the same                       // filename as the diffure texture' and _nmap suffixed                      // this lets us add our own normal maps easily                      var normalExt = Path.GetExtension(diffusePath);                      normalPath = Path.GetFileNameWithoutExtension(diffusePath) + "_nmap" + normalExt;                      if (File.Exists(Path.Combine(texturePath' normalPath))) {                          NormalMapSRV.Add(texMgr.CreateTexture(Path.Combine(texturePath' normalPath)));                      }                  }              }
Magic Number,Core.Model,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Model\Waves.cs,Waves,The following statement contains a magic number: DispScale0 = new Vector3(2'2' 1);
Magic Number,Core.Model,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Model\Waves.cs,Waves,The following statement contains a magic number: DispScale0 = new Vector3(2'2' 1);
Magic Number,Core.Model,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Model\Waves.cs,Waves,The following statement contains a magic number: NormalScale0 = new Vector3(22'22'1 );
Magic Number,Core.Model,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Model\Waves.cs,Waves,The following statement contains a magic number: NormalScale0 = new Vector3(22'22'1 );
Magic Number,Core.Model,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Model\Waves.cs,Waves,The following statement contains a magic number: NormalScale1 = new Vector3(16'16' 1);
Magic Number,Core.Model,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Model\Waves.cs,Waves,The following statement contains a magic number: NormalScale1 = new Vector3(16'16' 1);
Magic Number,Core.Model,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Model\Waves.cs,Init,The following statement contains a magic number: _gridModel.CreateGrid(device' width' depth' ((int)width) * 2' ((int)depth) * 2);
Magic Number,Core.Model,Waves,C:\repos\ericrrichards_dx11\DX11\Core\Model\Waves.cs,Init,The following statement contains a magic number: _gridModel.CreateGrid(device' width' depth' ((int)width) * 2' ((int)depth) * 2);
Magic Number,Core.Terrain,Heuristics,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Heuristics.cs,DiagonalDistance2,The following statement contains a magic number: var h = (dx + dy) + (MathF.Sqrt2 - 2) * Math.Min(dx' dy);
Magic Number,Core.Terrain,PriorityQueue<T>,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\PriorityQueue.cs,OnNodeUpdated,The following statement contains a magic number: var parentIndex = node.QueueIndex/2;
Magic Number,Core.Terrain,PriorityQueue<T>,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\PriorityQueue.cs,CascadeUp,The following statement contains a magic number: var parent = node.QueueIndex/2;
Magic Number,Core.Terrain,PriorityQueue<T>,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\PriorityQueue.cs,CascadeUp,The following statement contains a magic number: while (parent >= 1) {                  var parentNode = _nodes[parent];                  if (HasHigherPriority(parentNode' node)) {                      break;                  }                    Swap(node' parentNode);                  parent = node.QueueIndex/2;              }
Magic Number,Core.Terrain,PriorityQueue<T>,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\PriorityQueue.cs,CascadeDown,The following statement contains a magic number: while (true) {                  var newParent = node;                  var childLeftIndex = 2*finalQueueIndex;                  if (childLeftIndex > Count) {                      node.QueueIndex = finalQueueIndex;                      _nodes[finalQueueIndex] = node;                      break;                  }                  var childLeft = _nodes[childLeftIndex];                  if (HasHigherPriority(childLeft' newParent)) {                      newParent = childLeft;                  }                  var childRightIndex = childLeftIndex + 1;                  if (childRightIndex <= Count) {                      var childRight = _nodes[childRightIndex];                      if (HasHigherPriority(childRight' newParent)) {                          newParent = childRight;                      }                  }                  if (newParent != node) {                      _nodes[finalQueueIndex] = newParent;                      var temp = newParent.QueueIndex;                      newParent.QueueIndex = finalQueueIndex;                      finalQueueIndex = temp;                  } else {                      node.QueueIndex = finalQueueIndex;                      _nodes[finalQueueIndex] = node;                      break;                  }              }
Magic Number,Core.Terrain,QuadTreeNode,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\QuadTree.cs,Intersects,The following statement contains a magic number: if (Children == null) {          float d;          // check if the ray intersects this leaf node's bounding box          if (!Ray.Intersects(ray' Bounds' out d)) {              // No intersection              node = null;              return false;          }          // return the centerpoint of the leaf's bounding box          hit = (Bounds.Minimum + Bounds.Maximum) / 2;          node = this;          return true;      }
Magic Number,Core.Terrain,QuadTreeNode,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\QuadTree.cs,Intersects,The following statement contains a magic number: var bestHit = ray.Position + ray.Direction * 1000;
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,BuildHeightMapThumb,The following statement contains a magic number: var userBuffer = _heightMap.Select(h => (byte)((h / MaxHeight) * 255)).ToArray();
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,BuildHeightMapThumb,The following statement contains a magic number: for (var i = 0; i < values.Length; i++) {                  values[i] = userBuffer[i / 3];              }
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,CreateRandomHeightMap,The following statement contains a magic number: for (var y = 0; y < HeightMapHeight; y++) {                  for (var x = 0; x < HeightMapWidth; x++) {                          var xf = (x / (float)HeightMapWidth) * noiseSize;                      var yf = (y / (float)HeightMapHeight) * noiseSize;                        var total = 0.0f;                      for (var i = 0; i < octaves; i++) {                          var freq = (float)Math.Pow(2.0f' i);                          var amp = (float)Math.Pow(persistence' i);                          var tx = xf * freq;                          var ty = yf * freq;                          var txi = (int)tx;                          var tyi = (int)ty;                          var fracX = tx - txi;                          var fracY = ty - tyi;                            var v1 = MathF.Noise(txi + tyi * 57 + seed);                          var v2 = MathF.Noise(txi + 1 + tyi * 57 + seed);                          var v3 = MathF.Noise(txi + (tyi + 1) * 57 + seed);                          var v4 = MathF.Noise(txi + 1 + (tyi + 1) * 57 + seed);                            var i1 = MathF.CosInterpolate(v1' v2' fracX);                          var i2 = MathF.CosInterpolate(v3' v4' fracX);                          total += MathF.CosInterpolate(i1' i2' fracY) * amp;                      }                      var b = (int)(128 + total * 128.0f);                      if (b < 0) b = 0;                      if (b > 255) b = 255;                        _heightMap[x + y * HeightMapHeight] = (b / 255.0f) * MaxHeight;                  }              }
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,CreateRandomHeightMap,The following statement contains a magic number: for (var y = 0; y < HeightMapHeight; y++) {                  for (var x = 0; x < HeightMapWidth; x++) {                          var xf = (x / (float)HeightMapWidth) * noiseSize;                      var yf = (y / (float)HeightMapHeight) * noiseSize;                        var total = 0.0f;                      for (var i = 0; i < octaves; i++) {                          var freq = (float)Math.Pow(2.0f' i);                          var amp = (float)Math.Pow(persistence' i);                          var tx = xf * freq;                          var ty = yf * freq;                          var txi = (int)tx;                          var tyi = (int)ty;                          var fracX = tx - txi;                          var fracY = ty - tyi;                            var v1 = MathF.Noise(txi + tyi * 57 + seed);                          var v2 = MathF.Noise(txi + 1 + tyi * 57 + seed);                          var v3 = MathF.Noise(txi + (tyi + 1) * 57 + seed);                          var v4 = MathF.Noise(txi + 1 + (tyi + 1) * 57 + seed);                            var i1 = MathF.CosInterpolate(v1' v2' fracX);                          var i2 = MathF.CosInterpolate(v3' v4' fracX);                          total += MathF.CosInterpolate(i1' i2' fracY) * amp;                      }                      var b = (int)(128 + total * 128.0f);                      if (b < 0) b = 0;                      if (b > 255) b = 255;                        _heightMap[x + y * HeightMapHeight] = (b / 255.0f) * MaxHeight;                  }              }
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,CreateRandomHeightMap,The following statement contains a magic number: for (var y = 0; y < HeightMapHeight; y++) {                  for (var x = 0; x < HeightMapWidth; x++) {                          var xf = (x / (float)HeightMapWidth) * noiseSize;                      var yf = (y / (float)HeightMapHeight) * noiseSize;                        var total = 0.0f;                      for (var i = 0; i < octaves; i++) {                          var freq = (float)Math.Pow(2.0f' i);                          var amp = (float)Math.Pow(persistence' i);                          var tx = xf * freq;                          var ty = yf * freq;                          var txi = (int)tx;                          var tyi = (int)ty;                          var fracX = tx - txi;                          var fracY = ty - tyi;                            var v1 = MathF.Noise(txi + tyi * 57 + seed);                          var v2 = MathF.Noise(txi + 1 + tyi * 57 + seed);                          var v3 = MathF.Noise(txi + (tyi + 1) * 57 + seed);                          var v4 = MathF.Noise(txi + 1 + (tyi + 1) * 57 + seed);                            var i1 = MathF.CosInterpolate(v1' v2' fracX);                          var i2 = MathF.CosInterpolate(v3' v4' fracX);                          total += MathF.CosInterpolate(i1' i2' fracY) * amp;                      }                      var b = (int)(128 + total * 128.0f);                      if (b < 0) b = 0;                      if (b > 255) b = 255;                        _heightMap[x + y * HeightMapHeight] = (b / 255.0f) * MaxHeight;                  }              }
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,CreateRandomHeightMap,The following statement contains a magic number: for (var y = 0; y < HeightMapHeight; y++) {                  for (var x = 0; x < HeightMapWidth; x++) {                          var xf = (x / (float)HeightMapWidth) * noiseSize;                      var yf = (y / (float)HeightMapHeight) * noiseSize;                        var total = 0.0f;                      for (var i = 0; i < octaves; i++) {                          var freq = (float)Math.Pow(2.0f' i);                          var amp = (float)Math.Pow(persistence' i);                          var tx = xf * freq;                          var ty = yf * freq;                          var txi = (int)tx;                          var tyi = (int)ty;                          var fracX = tx - txi;                          var fracY = ty - tyi;                            var v1 = MathF.Noise(txi + tyi * 57 + seed);                          var v2 = MathF.Noise(txi + 1 + tyi * 57 + seed);                          var v3 = MathF.Noise(txi + (tyi + 1) * 57 + seed);                          var v4 = MathF.Noise(txi + 1 + (tyi + 1) * 57 + seed);                            var i1 = MathF.CosInterpolate(v1' v2' fracX);                          var i2 = MathF.CosInterpolate(v3' v4' fracX);                          total += MathF.CosInterpolate(i1' i2' fracY) * amp;                      }                      var b = (int)(128 + total * 128.0f);                      if (b < 0) b = 0;                      if (b > 255) b = 255;                        _heightMap[x + y * HeightMapHeight] = (b / 255.0f) * MaxHeight;                  }              }
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,CreateRandomHeightMap,The following statement contains a magic number: for (var y = 0; y < HeightMapHeight; y++) {                  for (var x = 0; x < HeightMapWidth; x++) {                          var xf = (x / (float)HeightMapWidth) * noiseSize;                      var yf = (y / (float)HeightMapHeight) * noiseSize;                        var total = 0.0f;                      for (var i = 0; i < octaves; i++) {                          var freq = (float)Math.Pow(2.0f' i);                          var amp = (float)Math.Pow(persistence' i);                          var tx = xf * freq;                          var ty = yf * freq;                          var txi = (int)tx;                          var tyi = (int)ty;                          var fracX = tx - txi;                          var fracY = ty - tyi;                            var v1 = MathF.Noise(txi + tyi * 57 + seed);                          var v2 = MathF.Noise(txi + 1 + tyi * 57 + seed);                          var v3 = MathF.Noise(txi + (tyi + 1) * 57 + seed);                          var v4 = MathF.Noise(txi + 1 + (tyi + 1) * 57 + seed);                            var i1 = MathF.CosInterpolate(v1' v2' fracX);                          var i2 = MathF.CosInterpolate(v3' v4' fracX);                          total += MathF.CosInterpolate(i1' i2' fracY) * amp;                      }                      var b = (int)(128 + total * 128.0f);                      if (b < 0) b = 0;                      if (b > 255) b = 255;                        _heightMap[x + y * HeightMapHeight] = (b / 255.0f) * MaxHeight;                  }              }
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,CreateRandomHeightMap,The following statement contains a magic number: for (var y = 0; y < HeightMapHeight; y++) {                  for (var x = 0; x < HeightMapWidth; x++) {                          var xf = (x / (float)HeightMapWidth) * noiseSize;                      var yf = (y / (float)HeightMapHeight) * noiseSize;                        var total = 0.0f;                      for (var i = 0; i < octaves; i++) {                          var freq = (float)Math.Pow(2.0f' i);                          var amp = (float)Math.Pow(persistence' i);                          var tx = xf * freq;                          var ty = yf * freq;                          var txi = (int)tx;                          var tyi = (int)ty;                          var fracX = tx - txi;                          var fracY = ty - tyi;                            var v1 = MathF.Noise(txi + tyi * 57 + seed);                          var v2 = MathF.Noise(txi + 1 + tyi * 57 + seed);                          var v3 = MathF.Noise(txi + (tyi + 1) * 57 + seed);                          var v4 = MathF.Noise(txi + 1 + (tyi + 1) * 57 + seed);                            var i1 = MathF.CosInterpolate(v1' v2' fracX);                          var i2 = MathF.CosInterpolate(v3' v4' fracX);                          total += MathF.CosInterpolate(i1' i2' fracY) * amp;                      }                      var b = (int)(128 + total * 128.0f);                      if (b < 0) b = 0;                      if (b > 255) b = 255;                        _heightMap[x + y * HeightMapHeight] = (b / 255.0f) * MaxHeight;                  }              }
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,CreateRandomHeightMap,The following statement contains a magic number: for (var y = 0; y < HeightMapHeight; y++) {                  for (var x = 0; x < HeightMapWidth; x++) {                          var xf = (x / (float)HeightMapWidth) * noiseSize;                      var yf = (y / (float)HeightMapHeight) * noiseSize;                        var total = 0.0f;                      for (var i = 0; i < octaves; i++) {                          var freq = (float)Math.Pow(2.0f' i);                          var amp = (float)Math.Pow(persistence' i);                          var tx = xf * freq;                          var ty = yf * freq;                          var txi = (int)tx;                          var tyi = (int)ty;                          var fracX = tx - txi;                          var fracY = ty - tyi;                            var v1 = MathF.Noise(txi + tyi * 57 + seed);                          var v2 = MathF.Noise(txi + 1 + tyi * 57 + seed);                          var v3 = MathF.Noise(txi + (tyi + 1) * 57 + seed);                          var v4 = MathF.Noise(txi + 1 + (tyi + 1) * 57 + seed);                            var i1 = MathF.CosInterpolate(v1' v2' fracX);                          var i2 = MathF.CosInterpolate(v3' v4' fracX);                          total += MathF.CosInterpolate(i1' i2' fracY) * amp;                      }                      var b = (int)(128 + total * 128.0f);                      if (b < 0) b = 0;                      if (b > 255) b = 255;                        _heightMap[x + y * HeightMapHeight] = (b / 255.0f) * MaxHeight;                  }              }
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,CreateRandomHeightMapParallel,The following statement contains a magic number: for (var y = 0; y < HeightMapHeight; y++) {                  var tasks = new List<Action>();                  var y1 = y;                      for (var x = 0; x < HeightMapWidth; x++) {                      var x1 = x;                      tasks.Add(() => {                          var xf = (x1 / (float)HeightMapWidth) * noiseSize;                          var yf = (y1 / (float)HeightMapHeight) * noiseSize;                            var total = 0.0f;                          for (var i = 0; i < octaves; i++) {                              var f = MathF.PerlinNoise2D(seed' persistence' i' xf' yf);                              total += f;                          }                          var b = (int)(128 + total * 128.0f);                          if (b < 0) b = 0;                          if (b > 255) b = 255;                            _heightMap[x1 + y1 * HeightMapHeight] = (b / 255.0f) * MaxHeight;                      });                  }                  if (drawProgress) {                      D3DApp.GD3DApp.ProgressUpdate.Draw(0.1f + 0.40f * ((float)y / HeightMapHeight)' "Generating random terrain");                  }                  Parallel.Invoke(tasks.ToArray());              }
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,CreateRandomHeightMapParallel,The following statement contains a magic number: for (var y = 0; y < HeightMapHeight; y++) {                  var tasks = new List<Action>();                  var y1 = y;                      for (var x = 0; x < HeightMapWidth; x++) {                      var x1 = x;                      tasks.Add(() => {                          var xf = (x1 / (float)HeightMapWidth) * noiseSize;                          var yf = (y1 / (float)HeightMapHeight) * noiseSize;                            var total = 0.0f;                          for (var i = 0; i < octaves; i++) {                              var f = MathF.PerlinNoise2D(seed' persistence' i' xf' yf);                              total += f;                          }                          var b = (int)(128 + total * 128.0f);                          if (b < 0) b = 0;                          if (b > 255) b = 255;                            _heightMap[x1 + y1 * HeightMapHeight] = (b / 255.0f) * MaxHeight;                      });                  }                  if (drawProgress) {                      D3DApp.GD3DApp.ProgressUpdate.Draw(0.1f + 0.40f * ((float)y / HeightMapHeight)' "Generating random terrain");                  }                  Parallel.Invoke(tasks.ToArray());              }
Magic Number,Core.Terrain,HeightMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\HeightMap.cs,CreateRandomHeightMapParallel,The following statement contains a magic number: for (var y = 0; y < HeightMapHeight; y++) {                  var tasks = new List<Action>();                  var y1 = y;                      for (var x = 0; x < HeightMapWidth; x++) {                      var x1 = x;                      tasks.Add(() => {                          var xf = (x1 / (float)HeightMapWidth) * noiseSize;                          var yf = (y1 / (float)HeightMapHeight) * noiseSize;                            var total = 0.0f;                          for (var i = 0; i < octaves; i++) {                              var f = MathF.PerlinNoise2D(seed' persistence' i' xf' yf);                              total += f;                          }                          var b = (int)(128 + total * 128.0f);                          if (b < 0) b = 0;                          if (b > 255) b = 255;                            _heightMap[x1 + y1 * HeightMapHeight] = (b / 255.0f) * MaxHeight;                      });                  }                  if (drawProgress) {                      D3DApp.GD3DApp.ProgressUpdate.Draw(0.1f + 0.40f * ((float)y / HeightMapHeight)' "Generating random terrain");                  }                  Parallel.Invoke(tasks.ToArray());              }
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,Minimap,The following statement contains a magic number: var vbd = new BufferDescription(                  VertexPC.Stride * 5'                  ResourceUsage.Dynamic'                  BindFlags.VertexBuffer'                  CpuAccessFlags.Write'                  ResourceOptionFlags.None'                  0              );
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,Minimap,The following statement contains a magic number: _edgePlanes = new[] {                  new Plane(1' 0' 0' -_terrain.Width / 2)'                  new Plane(-1' 0' 0' _terrain.Width / 2)'                  new Plane(0' 1' 0' -_terrain.Depth / 2)'                  new Plane(0' -1' 0' _terrain.Depth / 2)              };
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,Minimap,The following statement contains a magic number: _edgePlanes = new[] {                  new Plane(1' 0' 0' -_terrain.Width / 2)'                  new Plane(-1' 0' 0' _terrain.Width / 2)'                  new Plane(0' 1' 0' -_terrain.Depth / 2)'                  new Plane(0' -1' 0' _terrain.Depth / 2)              };
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,Minimap,The following statement contains a magic number: _edgePlanes = new[] {                  new Plane(1' 0' 0' -_terrain.Width / 2)'                  new Plane(-1' 0' 0' _terrain.Width / 2)'                  new Plane(0' 1' 0' -_terrain.Depth / 2)'                  new Plane(0' -1' 0' _terrain.Depth / 2)              };
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,Minimap,The following statement contains a magic number: _edgePlanes = new[] {                  new Plane(1' 0' 0' -_terrain.Width / 2)'                  new Plane(-1' 0' 0' _terrain.Width / 2)'                  new Plane(0' 1' 0' -_terrain.Depth / 2)'                  new Plane(0' -1' 0' _terrain.Depth / 2)              };
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,SetupOrthoCamera,The following statement contains a magic number: _orthoCamera.SetLens(_terrain.Width' _terrain.Depth' 1' _terrain.Depth * 2);
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,OnClick,The following statement contains a magic number: if (Contains(ref p)) {                  // convert minimap-space to world-space and set the camera target                  var terrainX = _terrain.Width * p.X - _terrain.Width / 2;                  var terrainZ = -_terrain.Depth * p.Y + _terrain.Depth / 2;                  var cam = _viewCam as LookAtCamera;                  if (cam != null) {                      cam.Target = new Vector3(terrainX' _terrain.Height(terrainX' terrainZ)' terrainZ);                  }              }
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,OnClick,The following statement contains a magic number: if (Contains(ref p)) {                  // convert minimap-space to world-space and set the camera target                  var terrainX = _terrain.Width * p.X - _terrain.Width / 2;                  var terrainZ = -_terrain.Depth * p.Y + _terrain.Depth / 2;                  var cam = _viewCam as LookAtCamera;                  if (cam != null) {                      cam.Target = new Vector3(terrainX' _terrain.Height(terrainX' terrainZ)' terrainZ);                  }              }
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,DrawCameraFrustum,The following statement contains a magic number: var points = new Vector3[4];
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,DrawCameraFrustum,The following statement contains a magic number: for (var i = 0; i < 4 && ok; i++) {                  // transform the view-space vector into world-space                  dirs[i] = Vector3.Normalize(Vector3.TransformNormal(dirs[i]' invView));                  // extend the near-plane vectors into very far away points                  dirs[i] *= 100000.0f;                    Vector3 hit;                  // check if the ray between the camera origin and the far point intersects the ground plane                  if (!Plane.Intersects(groundPlane' org' dirs[i]' out hit)) {                      ok = false;                  }                  // make sure that the intersection is on the positive side of the frustum near plane                  var n = _viewCam.FrustumPlanes[Frustum.Near];                  var d = n.Normal.X * hit.X + n.Normal.Y * hit.Y + n.Normal.Z * hit.Z + n.D;                  if (d < 0.0f) {                      ok = false;                      // if we're here' the ray was pointing away from the ground                      // so we will instead intersect the ray with the terrain boundary planes                      foreach (var edgePlane in _edgePlanes) {                          if (!Plane.Intersects(edgePlane' org' dirs[i]' out hit)) {                              continue;                          }                          d = n.Normal.X * hit.X + n.Normal.Y * hit.Y + n.Normal.Z * hit.Z + n.D;                          if (!(d >= 0.0f)) {                              continue;                          }                          // bump out the intersection point' so that if we're looking into the corners' the                          // frustum doesn't show that we shouldn't be able to see terrain that we can see                          hit *= 2;                          ok = true;                          break;                      }                  }                  points[i] = new Vector3(Math.Min(Math.Max(hit.X' -float.MaxValue)' float.MaxValue)' 0' Math.Min(Math.Max(hit.Z' -float.MaxValue)' float.MaxValue));              }
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,DrawCameraFrustum,The following statement contains a magic number: for (var i = 0; i < 4 && ok; i++) {                  // transform the view-space vector into world-space                  dirs[i] = Vector3.Normalize(Vector3.TransformNormal(dirs[i]' invView));                  // extend the near-plane vectors into very far away points                  dirs[i] *= 100000.0f;                    Vector3 hit;                  // check if the ray between the camera origin and the far point intersects the ground plane                  if (!Plane.Intersects(groundPlane' org' dirs[i]' out hit)) {                      ok = false;                  }                  // make sure that the intersection is on the positive side of the frustum near plane                  var n = _viewCam.FrustumPlanes[Frustum.Near];                  var d = n.Normal.X * hit.X + n.Normal.Y * hit.Y + n.Normal.Z * hit.Z + n.D;                  if (d < 0.0f) {                      ok = false;                      // if we're here' the ray was pointing away from the ground                      // so we will instead intersect the ray with the terrain boundary planes                      foreach (var edgePlane in _edgePlanes) {                          if (!Plane.Intersects(edgePlane' org' dirs[i]' out hit)) {                              continue;                          }                          d = n.Normal.X * hit.X + n.Normal.Y * hit.Y + n.Normal.Z * hit.Z + n.D;                          if (!(d >= 0.0f)) {                              continue;                          }                          // bump out the intersection point' so that if we're looking into the corners' the                          // frustum doesn't show that we shouldn't be able to see terrain that we can see                          hit *= 2;                          ok = true;                          break;                      }                  }                  points[i] = new Vector3(Math.Min(Math.Max(hit.X' -float.MaxValue)' float.MaxValue)' 0' Math.Min(Math.Max(hit.Z' -float.MaxValue)' float.MaxValue));              }
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,DrawCameraFrustum,The following statement contains a magic number: buf.Data.Write(new VertexPC(points[2]' Color.White));
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,DrawCameraFrustum,The following statement contains a magic number: buf.Data.Write(new VertexPC(points[3]' Color.White));
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,DrawCameraFrustum,The following statement contains a magic number: for (var i = 0; i < Effects.ColorFX.ColorTech.Description.PassCount; i++) {                  Effects.ColorFX.SetWorldViewProj(_orthoCamera.ViewProj);                  Effects.ColorFX.ColorTech.GetPassByIndex(i).Apply(_dc);                  _dc.Draw(5' 0);              }
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,Draw,The following statement contains a magic number: var world = new Matrix {                  M11 = Size.X'                  M22 = Size.Y'                  M33 = 1.0f'                  M41 = -1.0f + 2 * ScreenPosition.X + (Size.X)'                  M42 = 1.0f - 2 * ScreenPosition.Y - (Size.Y)'                  M44 = 1.0f              };
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,Draw,The following statement contains a magic number: var world = new Matrix {                  M11 = Size.X'                  M22 = Size.Y'                  M33 = 1.0f'                  M41 = -1.0f + 2 * ScreenPosition.X + (Size.X)'                  M42 = 1.0f - 2 * ScreenPosition.Y - (Size.Y)'                  M44 = 1.0f              };
Magic Number,Core.Terrain,Minimap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Minimap.cs,Draw,The following statement contains a magic number: for (var p = 0; p < tech.Description.PassCount; p++) {                  Effects.DebugTexFX.SetWorldViewProj(world);                  Effects.DebugTexFX.SetTexture(MinimapSRV);                  tech.GetPassByIndex(p).Apply(dc);                  dc.DrawIndexed(6' 0' 0);              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,TessFactor,The following statement contains a magic number: var c = (Bounds.Maximum - Bounds.Minimum) / 2 + Bounds.Minimum;
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,TessFactor,The following statement contains a magic number: return (int)Math.Pow(2' (int)(TerrainRenderer.MinTess + (TerrainRenderer.MaxTess-1 - TerrainRenderer.MinTess) * s));
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildCenterIndices,The following statement contains a magic number: for (var tessLevel = 0; tessLevel <= 6; tessLevel++) {                  var t = (int)Math.Pow(2' tessLevel);                  var indices = new List<short>();                  for (int z = 0 + t' z0 = t; z < width; z += t' z0 += t) {                      for (int x = 0 + t' x0 = t; x < width; x += t' x0 += t) {                          indices.Add((short)(z0 * (width + 1) + x0));                          indices.Add((short)(z0 * (width + 1) + x0 + t));                          indices.Add((short)((z0 + t) * (width + 1) + x0));                            indices.Add((short)((z0 + t) * (width + 1) + x0));                          indices.Add((short)(z0 * (width + 1) + x0 + t));                          indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      }                  }                    var ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                    if (CenterIB != null) {                      if (indices.Count > 0) {                          CenterIB[t] = new Buffer(                              device'                               new DataStream(indices.ToArray()' false' true)'                               ibd                          );                      } else {                          CenterIB[t] = null;                      }                  }                  CenterIndexCount[t] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildCenterIndices,The following statement contains a magic number: for (var tessLevel = 0; tessLevel <= 6; tessLevel++) {                  var t = (int)Math.Pow(2' tessLevel);                  var indices = new List<short>();                  for (int z = 0 + t' z0 = t; z < width; z += t' z0 += t) {                      for (int x = 0 + t' x0 = t; x < width; x += t' x0 += t) {                          indices.Add((short)(z0 * (width + 1) + x0));                          indices.Add((short)(z0 * (width + 1) + x0 + t));                          indices.Add((short)((z0 + t) * (width + 1) + x0));                            indices.Add((short)((z0 + t) * (width + 1) + x0));                          indices.Add((short)(z0 * (width + 1) + x0 + t));                          indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      }                  }                    var ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                    if (CenterIB != null) {                      if (indices.Count > 0) {                          CenterIB[t] = new Buffer(                              device'                               new DataStream(indices.ToArray()' false' true)'                               ibd                          );                      } else {                          CenterIB[t] = null;                      }                  }                  CenterIndexCount[t] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildIndices,The following statement contains a magic number: for (var tessLevel = 0; tessLevel <= 6; tessLevel++) {                  var t = (int)Math.Pow(2' tessLevel);                  var indices = new List<short>();                  for (int z = 0' z0 = 0; z < width; z += t' z0 += t) {                      for (int x = 0' x0 = 0; x < width; x += t' x0 += t) {                          indices.Add((short)(z0 * (width + 1) + x0));                          indices.Add((short)(z0 * (width + 1) + x0 + t));                          indices.Add((short)((z0 + t) * (width + 1) + x0));                            indices.Add((short)((z0 + t) * (width + 1) + x0));                          indices.Add((short)(z0 * (width + 1) + x0 + t));                          indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      }                  }                    var ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                    if (IB != null) {                      if (indices.Count > 0) {                          IB[t] = new Buffer(                              device'                              new DataStream(indices.ToArray()' false' true)'                              ibd                          );                      } else {                          IB[t] = null;                      }                  }                  IndexCount[t] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildIndices,The following statement contains a magic number: for (var tessLevel = 0; tessLevel <= 6; tessLevel++) {                  var t = (int)Math.Pow(2' tessLevel);                  var indices = new List<short>();                  for (int z = 0' z0 = 0; z < width; z += t' z0 += t) {                      for (int x = 0' x0 = 0; x < width; x += t' x0 += t) {                          indices.Add((short)(z0 * (width + 1) + x0));                          indices.Add((short)(z0 * (width + 1) + x0 + t));                          indices.Add((short)((z0 + t) * (width + 1) + x0));                            indices.Add((short)((z0 + t) * (width + 1) + x0));                          indices.Add((short)(z0 * (width + 1) + x0 + t));                          indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      }                  }                    var ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                    if (IB != null) {                      if (indices.Count > 0) {                          IB[t] = new Buffer(                              device'                              new DataStream(indices.ToArray()' false' true)'                              ibd                          );                      } else {                          IB[t] = null;                      }                  }                  IndexCount[t] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildLeftEdges,The following statement contains a magic number: for (var i = 0; i < 6; i++) {                  t = (int)Math.Pow(2' i);                  key = new Tuple<int' int>(t' t);                  indices = new List<short>();                  x0 = 0;                  for (int z = 0' z0 = 0; z < width; z += t' z0 += t) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)(z0 * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0 + t) * (width + 1) + x0));                      indices.Add((short)(z0 * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                  }                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Left][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Left][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildLeftEdges,The following statement contains a magic number: for (var i = 0; i < 6; i++) {                  t = (int)Math.Pow(2' i);                  key = new Tuple<int' int>(t' t);                  indices = new List<short>();                  x0 = 0;                  for (int z = 0' z0 = 0; z < width; z += t' z0 += t) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)(z0 * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0 + t) * (width + 1) + x0));                      indices.Add((short)(z0 * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                  }                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Left][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Left][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildLeftEdges,The following statement contains a magic number: for (var i = 0; i < 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i + 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  x0 = 0;                    indices.Add(0);                  indices.Add((short)((width+1) + t));                  indices.Add((short)(t1*(width+1)));                    indices.Add((short)((width + 1) + t));                  indices.Add((short)(t1 * (width + 1) + t));                  indices.Add((short)(t1 * (width + 1)));                                      for (int z = 0+t1' z0 = t1; z < width; z += t1' z0 += t1) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)(z0 * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                        indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                        indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                  }                                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Left][key] = new Buffer(                      device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Left][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildLeftEdges,The following statement contains a magic number: for (var i = 0; i < 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i + 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  x0 = 0;                    indices.Add(0);                  indices.Add((short)((width+1) + t));                  indices.Add((short)(t1*(width+1)));                    indices.Add((short)((width + 1) + t));                  indices.Add((short)(t1 * (width + 1) + t));                  indices.Add((short)(t1 * (width + 1)));                                      for (int z = 0+t1' z0 = t1; z < width; z += t1' z0 += t1) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)(z0 * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                        indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                        indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                  }                                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Left][key] = new Buffer(                      device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Left][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildLeftEdges,The following statement contains a magic number: for (var i = 0; i < 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i + 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  x0 = 0;                    indices.Add(0);                  indices.Add((short)((width+1) + t));                  indices.Add((short)(t1*(width+1)));                    indices.Add((short)((width + 1) + t));                  indices.Add((short)(t1 * (width + 1) + t));                  indices.Add((short)(t1 * (width + 1)));                                      for (int z = 0+t1' z0 = t1; z < width; z += t1' z0 += t1) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)(z0 * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                        indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                        indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                  }                                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Left][key] = new Buffer(                      device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Left][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildLeftEdges,The following statement contains a magic number: for (var i = 1; i <= 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i - 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  x0 = 0;                    for (int z = 0 ' z0 = 0; z < width - t1; z += t' z0 += t) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                        indices.Add((short)((z0 + t1) * (width + 1) + x0));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                  }                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Left][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Left][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildLeftEdges,The following statement contains a magic number: for (var i = 1; i <= 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i - 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  x0 = 0;                    for (int z = 0 ' z0 = 0; z < width - t1; z += t' z0 += t) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                        indices.Add((short)((z0 + t1) * (width + 1) + x0));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                  }                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Left][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Left][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildLeftEdges,The following statement contains a magic number: for (var i = 1; i <= 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i - 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  x0 = 0;                    for (int z = 0 ' z0 = 0; z < width - t1; z += t' z0 += t) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                        indices.Add((short)((z0 + t1) * (width + 1) + x0));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t1) * (width + 1) + x0));                  }                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Left][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Left][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildTopEdges,The following statement contains a magic number: for (var i = 0; i < 6; i++) {                  t = (int)Math.Pow(2' i);                  key = new Tuple<int' int>(t' t);                  indices = new List<short>();                  z0 = 0;                  for (int x = 0' x0 = 0; x < width; x += t' x0 += t) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)(z0 * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0 + t) * (width + 1) + x0));                      indices.Add((short)(z0 * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                  }                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Top][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Top][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildTopEdges,The following statement contains a magic number: for (var i = 0; i < 6; i++) {                  t = (int)Math.Pow(2' i);                  key = new Tuple<int' int>(t' t);                  indices = new List<short>();                  z0 = 0;                  for (int x = 0' x0 = 0; x < width; x += t' x0 += t) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)(z0 * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0 + t) * (width + 1) + x0));                      indices.Add((short)(z0 * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                  }                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Top][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Top][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildTopEdges,The following statement contains a magic number: for (var i = 0; i < 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i + 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  z0 = 0;                                      indices.Add(0);                  indices.Add((short)(t1));                  indices.Add((short)((z0 + t) * (width + 1) + t));                    indices.Add((short)(t1));                  indices.Add((short)(t * (width + 1) + t1));                  indices.Add((short)((t) * (width + 1) + t));                                    for (int x = 0 + t1' x0 = t1; x < width; x += t1' x0 += t1) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0+t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0+t) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                        indices.Add((short)((z0) * (width + 1) + x0 ));                      indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0+t));                  }                                      ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Top][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Top][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildTopEdges,The following statement contains a magic number: for (var i = 0; i < 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i + 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  z0 = 0;                                      indices.Add(0);                  indices.Add((short)(t1));                  indices.Add((short)((z0 + t) * (width + 1) + t));                    indices.Add((short)(t1));                  indices.Add((short)(t * (width + 1) + t1));                  indices.Add((short)((t) * (width + 1) + t));                                    for (int x = 0 + t1' x0 = t1; x < width; x += t1' x0 += t1) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0+t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0+t) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                        indices.Add((short)((z0) * (width + 1) + x0 ));                      indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0+t));                  }                                      ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Top][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Top][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildTopEdges,The following statement contains a magic number: for (var i = 0; i < 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i + 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  z0 = 0;                                      indices.Add(0);                  indices.Add((short)(t1));                  indices.Add((short)((z0 + t) * (width + 1) + t));                    indices.Add((short)(t1));                  indices.Add((short)(t * (width + 1) + t1));                  indices.Add((short)((t) * (width + 1) + t));                                    for (int x = 0 + t1' x0 = t1; x < width; x += t1' x0 += t1) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0+t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0+t) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                        indices.Add((short)((z0) * (width + 1) + x0 ));                      indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0+t));                  }                                      ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Top][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Top][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildTopEdges,The following statement contains a magic number: for (var i = 1; i <= 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i - 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  z0 = 0;                                      for (int x = 0 ' x0 = 0; x <width - t1; x += t' x0 += t) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                        indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                  }                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Top][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Top][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildTopEdges,The following statement contains a magic number: for (var i = 1; i <= 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i - 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  z0 = 0;                                      for (int x = 0 ' x0 = 0; x <width - t1; x += t' x0 += t) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                        indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                  }                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Top][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Top][key] = indices.Count;              }
Magic Number,Core.Terrain,Patch,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Patch.cs,BuildTopEdges,The following statement contains a magic number: for (var i = 1; i <= 6; i++) {                  t = (int)Math.Pow(2' i);                  var t1 = (int)Math.Pow(2' i - 1);                  key = new Tuple<int' int>(t' t1);                  indices = new List<short>();                  z0 = 0;                                      for (int x = 0 ' x0 = 0; x <width - t1; x += t' x0 += t) {                      indices.Add((short)(z0 * (width + 1) + x0));                      indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                        indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                        indices.Add((short)((z0) * (width + 1) + x0 + t1));                      indices.Add((short)((z0 + t) * (width + 1) + x0 + t));                      indices.Add((short)((z0 + t) * (width + 1) + x0));                  }                    ibd = new BufferDescription(                      sizeof(short) * indices.Count'                      ResourceUsage.Dynamic'                      BindFlags.IndexBuffer'                      CpuAccessFlags.Write'                      ResourceOptionFlags.None'                      0                      );                  EdgeIbs[NeighborDir.Top][key] = new Buffer(device' new DataStream(indices.ToArray()' false' false)' ibd);                  EdgeIndiceCount[NeighborDir.Top][key] = indices.Count;              }
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,SetTilePositionsAndTypes,The following statement contains a magic number: for (var y = 0; y < _heightInTiles; y++) {                  for (var x = 0; x < _widthInTiles; x++) {                      var tile = GetTile(x' y);                      tile.MapPosition = new Point(x' y);                      // Calculate world position of tile center                      var worldX = (x * Info.CellSpacing * TileSize) + (Info.CellSpacing * TileSize / 2) - (Width / 2);                      var worldZ = (-y * Info.CellSpacing * TileSize) - (Info.CellSpacing * TileSize / 2) + (Depth / 2);                      var height = Height(worldX' worldZ);                      tile.WorldPos = new Vector3(worldX' height' worldZ);                        // Set tile type                      if (tile.Height < HeightMap.MaxHeight * (0.05f)) {                          tile.Type = 0;                      } else if (tile.Height < HeightMap.MaxHeight * (0.4f)) {                          tile.Type = 1;                      } else if (tile.Height < HeightMap.MaxHeight * (0.75f)) {                          tile.Type = 2;                      } else {                          tile.Type = 3;                      }                  }              }
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,SetTilePositionsAndTypes,The following statement contains a magic number: for (var y = 0; y < _heightInTiles; y++) {                  for (var x = 0; x < _widthInTiles; x++) {                      var tile = GetTile(x' y);                      tile.MapPosition = new Point(x' y);                      // Calculate world position of tile center                      var worldX = (x * Info.CellSpacing * TileSize) + (Info.CellSpacing * TileSize / 2) - (Width / 2);                      var worldZ = (-y * Info.CellSpacing * TileSize) - (Info.CellSpacing * TileSize / 2) + (Depth / 2);                      var height = Height(worldX' worldZ);                      tile.WorldPos = new Vector3(worldX' height' worldZ);                        // Set tile type                      if (tile.Height < HeightMap.MaxHeight * (0.05f)) {                          tile.Type = 0;                      } else if (tile.Height < HeightMap.MaxHeight * (0.4f)) {                          tile.Type = 1;                      } else if (tile.Height < HeightMap.MaxHeight * (0.75f)) {                          tile.Type = 2;                      } else {                          tile.Type = 3;                      }                  }              }
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,SetTilePositionsAndTypes,The following statement contains a magic number: for (var y = 0; y < _heightInTiles; y++) {                  for (var x = 0; x < _widthInTiles; x++) {                      var tile = GetTile(x' y);                      tile.MapPosition = new Point(x' y);                      // Calculate world position of tile center                      var worldX = (x * Info.CellSpacing * TileSize) + (Info.CellSpacing * TileSize / 2) - (Width / 2);                      var worldZ = (-y * Info.CellSpacing * TileSize) - (Info.CellSpacing * TileSize / 2) + (Depth / 2);                      var height = Height(worldX' worldZ);                      tile.WorldPos = new Vector3(worldX' height' worldZ);                        // Set tile type                      if (tile.Height < HeightMap.MaxHeight * (0.05f)) {                          tile.Type = 0;                      } else if (tile.Height < HeightMap.MaxHeight * (0.4f)) {                          tile.Type = 1;                      } else if (tile.Height < HeightMap.MaxHeight * (0.75f)) {                          tile.Type = 2;                      } else {                          tile.Type = 3;                      }                  }              }
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,SetTilePositionsAndTypes,The following statement contains a magic number: for (var y = 0; y < _heightInTiles; y++) {                  for (var x = 0; x < _widthInTiles; x++) {                      var tile = GetTile(x' y);                      tile.MapPosition = new Point(x' y);                      // Calculate world position of tile center                      var worldX = (x * Info.CellSpacing * TileSize) + (Info.CellSpacing * TileSize / 2) - (Width / 2);                      var worldZ = (-y * Info.CellSpacing * TileSize) - (Info.CellSpacing * TileSize / 2) + (Depth / 2);                      var height = Height(worldX' worldZ);                      tile.WorldPos = new Vector3(worldX' height' worldZ);                        // Set tile type                      if (tile.Height < HeightMap.MaxHeight * (0.05f)) {                          tile.Type = 0;                      } else if (tile.Height < HeightMap.MaxHeight * (0.4f)) {                          tile.Type = 1;                      } else if (tile.Height < HeightMap.MaxHeight * (0.75f)) {                          tile.Type = 2;                      } else {                          tile.Type = 3;                      }                  }              }
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,SetTilePositionsAndTypes,The following statement contains a magic number: for (var y = 0; y < _heightInTiles; y++) {                  for (var x = 0; x < _widthInTiles; x++) {                      var tile = GetTile(x' y);                      tile.MapPosition = new Point(x' y);                      // Calculate world position of tile center                      var worldX = (x * Info.CellSpacing * TileSize) + (Info.CellSpacing * TileSize / 2) - (Width / 2);                      var worldZ = (-y * Info.CellSpacing * TileSize) - (Info.CellSpacing * TileSize / 2) + (Depth / 2);                      var height = Height(worldX' worldZ);                      tile.WorldPos = new Vector3(worldX' height' worldZ);                        // Set tile type                      if (tile.Height < HeightMap.MaxHeight * (0.05f)) {                          tile.Type = 0;                      } else if (tile.Height < HeightMap.MaxHeight * (0.4f)) {                          tile.Type = 1;                      } else if (tile.Height < HeightMap.MaxHeight * (0.75f)) {                          tile.Type = 2;                      } else {                          tile.Type = 3;                      }                  }              }
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,SetTilePositionsAndTypes,The following statement contains a magic number: for (var y = 0; y < _heightInTiles; y++) {                  for (var x = 0; x < _widthInTiles; x++) {                      var tile = GetTile(x' y);                      tile.MapPosition = new Point(x' y);                      // Calculate world position of tile center                      var worldX = (x * Info.CellSpacing * TileSize) + (Info.CellSpacing * TileSize / 2) - (Width / 2);                      var worldZ = (-y * Info.CellSpacing * TileSize) - (Info.CellSpacing * TileSize / 2) + (Depth / 2);                      var height = Height(worldX' worldZ);                      tile.WorldPos = new Vector3(worldX' height' worldZ);                        // Set tile type                      if (tile.Height < HeightMap.MaxHeight * (0.05f)) {                          tile.Type = 0;                      } else if (tile.Height < HeightMap.MaxHeight * (0.4f)) {                          tile.Type = 1;                      } else if (tile.Height < HeightMap.MaxHeight * (0.75f)) {                          tile.Type = 2;                      } else {                          tile.Type = 3;                      }                  }              }
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,ConnectNeighboringTiles,The following statement contains a magic number: for (var y = 0; y < _heightInTiles; y++) {                  for (var x = 0; x < _widthInTiles; x++) {                      var tile = GetTile(x' y);                      if (tile == null || !tile.Walkable) {                          continue;                      }                      for (var i = 0; i < 8; i++) {                          tile.Edges[i] = null;                      }                      var p = new[] {                          new Point(x - 1' y - 1)' new Point(x' y - 1)' new Point(x + 1' y - 1)'                          new Point(x - 1' y)' new Point(x + 1' y)'                          new Point(x - 1' y + 1)' new Point(x' y + 1)' new Point(x + 1' y + 1)                      };                      for (var i = 0; i < 8; i++) {                          var point = p[i];                          if (!Within(point)) {                              continue;                          }                          var neighbor = GetTile(point);                          if (neighbor != null && neighbor.Walkable) {                              tile.Edges[i] = MapEdge.Create(tile' neighbor);                          }                      }                  }              }
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,ConnectNeighboringTiles,The following statement contains a magic number: for (var y = 0; y < _heightInTiles; y++) {                  for (var x = 0; x < _widthInTiles; x++) {                      var tile = GetTile(x' y);                      if (tile == null || !tile.Walkable) {                          continue;                      }                      for (var i = 0; i < 8; i++) {                          tile.Edges[i] = null;                      }                      var p = new[] {                          new Point(x - 1' y - 1)' new Point(x' y - 1)' new Point(x + 1' y - 1)'                          new Point(x - 1' y)' new Point(x + 1' y)'                          new Point(x - 1' y + 1)' new Point(x' y + 1)' new Point(x + 1' y + 1)                      };                      for (var i = 0; i < 8; i++) {                          var point = p[i];                          if (!Within(point)) {                              continue;                          }                          var neighbor = GetTile(point);                          if (neighbor != null && neighbor.Walkable) {                              tile.Edges[i] = MapEdge.Create(tile' neighbor);                          }                      }                  }              }
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,GetPath,The following statement contains a magic number: while (open.Any() && current != goalTile) {                  current = open.Dequeue();                  closed.Add(current);                  for (var i = 0; i < 8; i++) {                      var edge = current.Edges[i];                        if (edge == null) {                          continue;                      }                      var neighbor = edge.Node2;                      var cost = current.G + edge.Cost;                            if (open.Contains(neighbor) && cost < neighbor.G) {                          open.Remove(neighbor);                      }                      if (closed.Contains(neighbor) && cost < neighbor.G) {                          closed.Remove(neighbor);                      }                      if (!open.Contains(neighbor) && !closed.Contains(neighbor)) {                          neighbor.G = cost;                          var f = cost + h(neighbor.MapPosition' goal);                          open.Enqueue(neighbor' f);                          neighbor.Parent = current;                        }                  }              }
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,BuildQuadTree,The following statement contains a magic number: var minX = topLeft.X * Info.CellSpacing - Width / 2;
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,BuildQuadTree,The following statement contains a magic number: var maxX = bottomRight.X * Info.CellSpacing - Width / 2;
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,BuildQuadTree,The following statement contains a magic number: var minZ = -topLeft.Y * Info.CellSpacing + Depth / 2;
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,BuildQuadTree,The following statement contains a magic number: var maxZ = -bottomRight.Y * Info.CellSpacing + Depth / 2;
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,BuildQuadTree,The following statement contains a magic number: var width = (int)Math.Floor((bottomRight.X - topLeft.X) / 2);
Magic Number,Core.Terrain,Terrain,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\Terrain.cs,BuildQuadTree,The following statement contains a magic number: var depth = (int)Math.Floor((bottomRight.Y - topLeft.Y) / 2);
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,BuildPatches,The following statement contains a magic number: for (var z = 0; z < (NumPatchVertRows - 1); z++) {                  var z1 = z * Terrain.CellsPerPatch;                  for (var x = 0; x < (NumPatchVertCols - 1); x++) {                      var x1 = x * Terrain.CellsPerPatch;                      var r = new Rectangle(x1' z1' Terrain.CellsPerPatch' Terrain.CellsPerPatch);                      var p = new Patch();                      p.CreateMesh(_terrain' r' device);                      _patches.Add(p);                  }                  D3DApp.GD3DApp.ProgressUpdate.Draw(0.75f + 0.1f * ((float)z / (NumPatchVertRows - 2))' "Building terrain patches");              }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,SmoothBlendMap,The following statement contains a magic number: for (var y = 0; y < terrain.HeightMap.HeightMapHeight; y++) {                  for (var x = 0; x < terrain.HeightMap.HeightMapWidth; x++) {                      var sum = colors[x + y * hm.HeightMapHeight];                      var num = 0;                      for (var y1 = y - 1; y1 < y + 2; y1++) {                          for (var x1 = x - 1; x1 < x + 1; x1++) {                              if (!hm.InBounds(y1' x1)) {                                  continue;                              }                              sum += colors[x1 + y1 * hm.HeightMapHeight];                              num++;                          }                      }                      colors[x + y * hm.HeightMapHeight] = new Color4(sum.Alpha / num' sum.Red / num' sum.Green / num' sum.Blue / num);                  }              }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following statement contains a magic number: if (level == 9) {                  _bvhVerts.AddRange(corners.Select(c => {                      var color = Color.White;                      switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }                      return new VertexPC(c' color);                  }));                  _aabCount++;                  _bvhIndices.AddRange(                                       new[] { 0' 1' 1' 2' 2' 3' 3' 0' 4' 5' 5' 6' 6' 7' 7' 4' 4' 0' 5' 1' 7' 3' 6' 2 }.Select(                                                                                                                               i => i + vertBase));                }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,Draw,The following statement contains a magic number: if (_useTessellation) {                    dc.InputAssembler.PrimitiveTopology = PrimitiveTopology.PatchListWith4ControlPoints;                  dc.InputAssembler.InputLayout = InputLayouts.TerrainCP;                    var stride = TerrainCP.Stride;                  const int offset = 0;                    dc.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(_quadPatchVB' stride' offset));                  dc.InputAssembler.SetIndexBuffer(_quadPatchIB' Format.R16_UInt' 0);                    var viewProj = cam.ViewProj;                  var planes = cam.FrustumPlanes;                  var toTexSpace = Matrix.Scaling(0.5f' -0.5f' 1.0f) * Matrix.Translation(0.5f' 0.5f' 0);                    Effects.TerrainFX.SetViewProj(viewProj);                  Effects.TerrainFX.SetEyePosW(cam.Position);                  Effects.TerrainFX.SetDirLights(lights);                  Effects.TerrainFX.SetFogColor(Color.Silver);                  Effects.TerrainFX.SetFogStart(15.0f);                  Effects.TerrainFX.SetFogRange(175.0f);                  Effects.TerrainFX.SetMinDist(MinDist);                  Effects.TerrainFX.SetMaxDist(MaxDist);                  Effects.TerrainFX.SetMinTess(MinTess);                  Effects.TerrainFX.SetMaxTess(MaxTess);                  Effects.TerrainFX.SetTexelCellSpaceU(1.0f / _terrain.Info.HeightMapWidth);                  Effects.TerrainFX.SetTexelCellSpaceV(1.0f / _terrain.Info.HeightMapHeight);                  Effects.TerrainFX.SetWorldCellSpace(_terrain.Info.CellSpacing);                  Effects.TerrainFX.SetWorldFrustumPlanes(planes);                  Effects.TerrainFX.SetLayerMapArray(_layerMapArraySRV);                  Effects.TerrainFX.SetBlendMap(_blendMapSRV);                  Effects.TerrainFX.SetHeightMap(_heightMapSRV);                  Effects.TerrainFX.SetMaterial(_material);                  Effects.TerrainFX.SetViewProjTex(viewProj * toTexSpace);                  Effects.TerrainFX.SetWalkMap(_walkMap.WalkableTiles);                  Effects.TerrainFX.SetUnwalkableTex(_walkMap.UnwalkableSRV);                    var tech = Shadows ? Effects.TerrainFX.Light1ShadowTech : Effects.TerrainFX.Light1Tech;                  for (var p = 0; p < tech.Description.PassCount; p++) {                      var pass = tech.GetPassByIndex(p);                      pass.Apply(dc);                      dc.DrawIndexed(_numPatchQuadFaces * 4' 0' 0);                  }                  dc.HullShader.Set(null);                  dc.DomainShader.Set(null);                    if (DebugQuadTree) {                      DrawQuadTreeDebugBuffers(dc' cam' offset);                  }              } else {                  dc.InputAssembler.PrimitiveTopology = PrimitiveTopology.TriangleList;                  dc.InputAssembler.InputLayout = InputLayouts.TerrainCP;                      var viewProj = cam.ViewProj;                  Effects.TerrainFX.SetViewProj(viewProj);                  Effects.TerrainFX.SetEyePosW(cam.Position);                  Effects.TerrainFX.SetDirLights(lights);                  Effects.TerrainFX.SetFogColor(Color.Silver);                  Effects.TerrainFX.SetFogStart(15.0f);                  Effects.TerrainFX.SetFogRange(175.0f);                    Effects.TerrainFX.SetTexelCellSpaceU(1.0f / _terrain.Info.HeightMapWidth);                  Effects.TerrainFX.SetTexelCellSpaceV(1.0f / _terrain.Info.HeightMapHeight);                  Effects.TerrainFX.SetWorldCellSpace(_terrain.Info.CellSpacing);                    Effects.TerrainFX.SetLayerMapArray(_layerMapArraySRV);                  Effects.TerrainFX.SetBlendMap(_blendMapSRV);                  Effects.TerrainFX.SetHeightMap(_heightMapSRV);                  Effects.TerrainFX.SetMaterial(_material);                  Effects.TerrainFX.SetWalkMap(_walkMap.WalkableTiles);                  Effects.TerrainFX.SetUnwalkableTex(_walkMap.UnwalkableSRV);                  var tech = Effects.TerrainFX.Light1TechNT;                  for (var p = 0; p < tech.Description.PassCount; p++) {                      var pass = tech.GetPassByIndex(p);                      pass.Apply(dc);                      for (var i = 0; i < _patches.Count; i++) {                          var patch = _patches[i];                          if (cam.Visible(patch.Bounds)) {                              var ns = new Dictionary<NeighborDir' Patch>();                              if (i < NumPatchVertCols) {                                  ns[NeighborDir.Top] = null;                              } else {                                  ns[NeighborDir.Top] = _patches[i - NumPatchVertCols + 1];                              }                              if (i % (NumPatchVertCols - 1) == 0) {                                  ns[NeighborDir.Left] = null;                              } else {                                  ns[NeighborDir.Left] = _patches[i - 1];                              }                              if (Util.IsKeyDown(Keys.N)) {                                  patch.Draw(dc' cam.Position);                              } else {                                  patch.Draw(dc' cam.Position' ns);                              }                          }                      }                  }                  if (DebugQuadTree) {                      DrawQuadTreeDebugBuffers(dc' cam' 0);                  }              }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,ComputeSsao,The following statement contains a magic number: for (var p = 0; p < tech.Description.PassCount; p++) {                  var pass = tech.GetPassByIndex(p);                  pass.Apply(dc);                  dc.DrawIndexed(_numPatchQuadFaces * 4' 0' 0);              }
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,ComputeSsao,The following statement contains a magic number: ssao.BlurAmbientMap(4);
Magic Number,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,DrawToShadowMap,The following statement contains a magic number: for (var p = 0; p < tech.Description.PassCount; p++) {                  var pass = tech.GetPassByIndex(p);                  pass.Apply(dc);                  dc.DrawIndexed(_numPatchQuadFaces * 4' 0' 0);              }
Magic Number,Core.Terrain,WalkMap,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,CreateWalkableTexture,The following statement contains a magic number: for (var y = 0; y < heightInTiles; y++) {                      for (var x = 0; x < widthInTiles; x++) {                          // walkable tiles are black' unwalkable tiles are white                          colors.Add((byte)(tiles[x + widthInTiles * y].Walkable ? 0 : 255));                      }                  }
Magic Number,Vertex,PosNormalTexTanSkinned,C:\repos\ericrrichards_dx11\DX11\Core\Vertex.cs,PosNormalTexTanSkinned,The following statement contains a magic number: for (int index = 0; index < boneIndices.Length; index++) {                      switch (index) {                          case 0:                              BoneIndices.B0 = boneIndices[index];                              break;                          case 1:                              BoneIndices.B1 = boneIndices[index];                              break;                          case 2:                              BoneIndices.B2 = boneIndices[index];                              break;                          case 3:                              BoneIndices.B3 = boneIndices[index];                              break;                      }                  }
Magic Number,Vertex,PosNormalTexTanSkinned,C:\repos\ericrrichards_dx11\DX11\Core\Vertex.cs,PosNormalTexTanSkinned,The following statement contains a magic number: for (int index = 0; index < boneIndices.Length; index++) {                      switch (index) {                          case 0:                              BoneIndices.B0 = boneIndices[index];                              break;                          case 1:                              BoneIndices.B1 = boneIndices[index];                              break;                          case 2:                              BoneIndices.B2 = boneIndices[index];                              break;                          case 3:                              BoneIndices.B3 = boneIndices[index];                              break;                      }                  }
Missing Default,Core,D3DApp,C:\repos\ericrrichards_dx11\DX11\Core\D3DApp.cs,WndProc,The following switch statement is missing a default case: switch (m.Msg) {                  case WM_ACTIVATE:                      if (m.WParam.ToInt32().LowWord() == 0) {                          AppPaused = true;                          Timer.Stop();                      } else {                          AppPaused = false;                          Timer.Start();                      }                      return true;                  case WM_SIZE:                      ClientWidth = m.LParam.ToInt32().LowWord();                      ClientHeight = m.LParam.ToInt32().HighWord();                      if (Device != null) {                          if (m.WParam.ToInt32() == 1) { // SIZE_MINIMIZED                              AppPaused = true;                              Minimized = true;                              Maximized = false;                          } else if (m.WParam.ToInt32() == 2) { // SIZE_MAXIMIZED                              AppPaused = false;                              Minimized = false;                              Maximized = true;                              OnResize();                          } else if (m.WParam.ToInt32() == 0) { // SIZE_RESTORED                              if (Minimized) {                                  AppPaused = false;                                  Minimized = false;                                  OnResize();                              } else if (Maximized) {                                  AppPaused = false;                                  Maximized = false;                                  OnResize();                              } else if (Resizing) {                                } else {                                  OnResize();                              }                          }                      }                      return true;                  case WM_DESTROY:                      _running = false;                      return true;              }
Missing Default,Core,PosNormalTexTanSkinned,C:\repos\ericrrichards_dx11\DX11\Core\Vertex.cs,PosNormalTexTanSkinned,The following switch statement is missing a default case: switch (index) {                          case 0:                              BoneIndices.B0 = boneIndices[index];                              break;                          case 1:                              BoneIndices.B1 = boneIndices[index];                              break;                          case 2:                              BoneIndices.B2 = boneIndices[index];                              break;                          case 3:                              BoneIndices.B3 = boneIndices[index];                              break;                      }
Missing Default,Core.Model,SdkMeshVertexBuffer,C:\repos\ericrrichards_dx11\DX11\Core\Model\SDKMesh.cs,ReadVertices,The following switch statement is missing a default case: switch (element.Type) {                              case DeclarationType.Float3:                                  var v3 = new Vector3(reader.ReadSingle()' reader.ReadSingle()' reader.ReadSingle());                                  switch (element.Usage) {                                      case DeclarationUsage.Position:                                          vertex.Pos = v3;                                          break;                                      case DeclarationUsage.Normal:                                          vertex.Normal = v3;                                          break;                                      case DeclarationUsage.Tangent:                                          vertex.Tan = v3;                                          break;                                  }                                  //Console.WriteLine("{0} - {1}"' element.Usage' v3);                                  break;                              case DeclarationType.Float2:                                  var v2 = new Vector2(reader.ReadSingle()' reader.ReadSingle());                                  switch (element.Usage) {                                      case DeclarationUsage.TextureCoordinate:                                          vertex.Tex = v2;                                          break;                                  }                                  //Console.WriteLine("{0} - {1}"' element.Usage' v2);                                  break;                          }
Missing Default,Core.Model,SdkMeshVertexBuffer,C:\repos\ericrrichards_dx11\DX11\Core\Model\SDKMesh.cs,ReadVertices,The following switch statement is missing a default case: switch (element.Usage) {                                      case DeclarationUsage.Position:                                          vertex.Pos = v3;                                          break;                                      case DeclarationUsage.Normal:                                          vertex.Normal = v3;                                          break;                                      case DeclarationUsage.Tangent:                                          vertex.Tan = v3;                                          break;                                  }
Missing Default,Core.Model,SdkMeshVertexBuffer,C:\repos\ericrrichards_dx11\DX11\Core\Model\SDKMesh.cs,ReadVertices,The following switch statement is missing a default case: switch (element.Usage) {                                      case DeclarationUsage.TextureCoordinate:                                          vertex.Tex = v2;                                          break;                                  }
Missing Default,Core.Terrain,TerrainRenderer,C:\repos\ericrrichards_dx11\DX11\Core\Terrain\TerrainRenderer.cs,GetQuadTreeVerticesAndIndices,The following switch statement is missing a default case: switch (_aabCount % 4) {                          case 1:                              color = Color.Blue;                              break;                          case 2:                              color = Color.Magenta;                              break;                          case 3:                              color = Color.Yellow;                              break;                      }
Missing Default,Vertex,PosNormalTexTanSkinned,C:\repos\ericrrichards_dx11\DX11\Core\Vertex.cs,PosNormalTexTanSkinned,The following switch statement is missing a default case: switch (index) {                          case 0:                              BoneIndices.B0 = boneIndices[index];                              break;                          case 1:                              BoneIndices.B1 = boneIndices[index];                              break;                          case 2:                              BoneIndices.B2 = boneIndices[index];                              break;                          case 3:                              BoneIndices.B3 = boneIndices[index];                              break;                      }
