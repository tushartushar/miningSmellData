Implementation smell,Namespace,Class,File,Method,Description
Long Method,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The method has 195 lines of code.
Long Method,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The method has 206 lines of code.
Long Method,ScriptSharp.ScriptModel,SymbolSet,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\SymbolSet.cs,ResolveIntrinsicType,The method has 114 lines of code.
Long Method,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The method has 136 lines of code.
Long Method,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,NextToken,The method has 389 lines of code.
Long Method,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParsePrimaryExpression,The method has 103 lines of code.
Long Method,ScriptSharp.Parser,PreprocessorLexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\PreprocessorLexer.cs,NextToken,The method has 107 lines of code.
Long Method,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildMetadata,The method has 154 lines of code.
Long Method,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessBinaryExpressionNode,The method has 201 lines of code.
Long Method,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessDotExpressionNode,The method has 112 lines of code.
Long Method,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessOpenParenExpressionNode,The method has 423 lines of code.
Long Method,ScriptSharp.Validator,CodeModelValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\CodeModelValidator.cs,GetValidatorType,The method has 104 lines of code.
Long Method,ScriptSharp.Validator,CustomTypeNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\CustomTypeNodeValidator.cs,Validate,The method has 172 lines of code.
Long Method,ScriptSharp.Generator,ExpressionGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\ExpressionGenerator.cs,GenerateBinaryExpression,The method has 153 lines of code.
Long Method,ScriptSharp.Generator,ExpressionGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\ExpressionGenerator.cs,GenerateLateBoundExpression,The method has 101 lines of code.
Long Method,ScriptSharp.Generator,ScriptGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\ScriptGenerator.cs,GenerateScript,The method has 142 lines of code.
Complex Method,ScriptSharp,Utility,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Utility.cs,QuoteString,Cyclomatic complexity of the method is 10
Complex Method,ScriptSharp,ScriptCompiler,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptCompiler.cs,BuildMetadata,Cyclomatic complexity of the method is 14
Complex Method,ScriptSharp.Importer.IL,ImmediateModuleReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,ReadModule,Cyclomatic complexity of the method is 10
Complex Method,ScriptSharp.Importer.IL,ImmediateModuleReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,ReadType,Cyclomatic complexity of the method is 8
Complex Method,ScriptSharp.Importer.IL,SignatureReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,ReadMethodSignature,Cyclomatic complexity of the method is 9
Complex Method,ScriptSharp.Importer.IL,BaseAssemblyResolver,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\BaseAssemblyResolver.cs,Resolve,Cyclomatic complexity of the method is 12
Complex Method,ScriptSharp.Importer.IL,MetadataSystem,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\MetadataSystem.cs,Clear,Cyclomatic complexity of the method is 18
Complex Method,ScriptSharp.ScriptModel,SymbolSetTransformer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\SymbolSetTransformer.cs,TransformSymbolSet,Cyclomatic complexity of the method is 11
Complex Method,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportAssemblies,Cyclomatic complexity of the method is 14
Complex Method,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportMethods,Cyclomatic complexity of the method is 13
Complex Method,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportProperties,Cyclomatic complexity of the method is 11
Complex Method,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportType,Cyclomatic complexity of the method is 10
Complex Method,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ResolveType,Cyclomatic complexity of the method is 9
Complex Method,ScriptSharp.Importer,MetadataSource,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataSource.cs,LoadReferences,Cyclomatic complexity of the method is 10
Complex Method,ScriptSharp.CodeModel,CodeModelBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\CodeModelBuilder.cs,BuildCodeModel,Cyclomatic complexity of the method is 9
Complex Method,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ScanType,Cyclomatic complexity of the method is 8
Complex Method,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildAssembly,Cyclomatic complexity of the method is 12
Complex Method,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildMembers,Cyclomatic complexity of the method is 10
Complex Method,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildMetadata,Cyclomatic complexity of the method is 30
Complex Method,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildMethod,Cyclomatic complexity of the method is 8
Complex Method,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildType,Cyclomatic complexity of the method is 15
Complex Method,ScriptSharp.Compiler,ImplementationBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ImplementationBuilder.cs,BuildImplementation,Cyclomatic complexity of the method is 11
Complex Method,ScriptSharp.Compiler,StatementBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\StatementBuilder.cs,ProcessSwitchStatement,Cyclomatic complexity of the method is 8
Complex Method,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessBinaryExpressionNode,Cyclomatic complexity of the method is 30
Complex Method,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessDotExpressionNode,Cyclomatic complexity of the method is 8
Complex Method,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessDotExpressionNode,Cyclomatic complexity of the method is 11
Complex Method,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessNewNode,Cyclomatic complexity of the method is 9
Complex Method,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessOpenParenExpressionNode,Cyclomatic complexity of the method is 10
Complex Method,ScriptSharp.Validator,CustomTypeNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\CustomTypeNodeValidator.cs,Validate,Cyclomatic complexity of the method is 38
Complex Method,ScriptSharp.Validator,NamespaceNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\NamespaceNodeValidator.cs,Validate,Cyclomatic complexity of the method is 8
Complex Method,ScriptSharp.Validator,MethodDeclarationNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\MethodDeclarationNodeValidator.cs,Validate,Cyclomatic complexity of the method is 8
Complex Method,ScriptSharp.Generator,MemberGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\MemberGenerator.cs,GenerateEvent,Cyclomatic complexity of the method is 13
Complex Method,ScriptSharp.Generator,MemberGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\MemberGenerator.cs,GenerateIndexer,Cyclomatic complexity of the method is 9
Complex Method,ScriptSharp.Generator,MemberGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\MemberGenerator.cs,GenerateMethod,Cyclomatic complexity of the method is 12
Complex Method,ScriptSharp.Generator,MemberGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\MemberGenerator.cs,GenerateProperty,Cyclomatic complexity of the method is 11
Complex Method,ScriptSharp.Generator,TypeGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\TypeGenerator.cs,GenerateClass,Cyclomatic complexity of the method is 19
Complex Method,ScriptSharp.Generator,TypeGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\TypeGenerator.cs,GenerateClassConstructorScript,Cyclomatic complexity of the method is 8
Complex Method,ScriptSharp.Generator,ScriptGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\ScriptGenerator.cs,GenerateScript,Cyclomatic complexity of the method is 29
Long Parameter List,ScriptSharp.Importer.IL,TypeReference,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\TypeReference.cs,TypeReference,The method has 5 parameters. Parameters: namespace' name' module' scope' valueType
Long Parameter List,ScriptSharp.Importer.IL.Metadata,Row,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Metadata\Row.cs,Row,The method has 5 parameters. Parameters: col1' col2' col3' col4' col5
Long Parameter List,ScriptSharp.Importer.IL.Metadata,Row,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Metadata\Row.cs,Row,The method has 6 parameters. Parameters: col1' col2' col3' col4' col5' col6
Long Parameter List,ScriptSharp.Importer.IL.Metadata,Row,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Metadata\Row.cs,Row,The method has 9 parameters. Parameters: col1' col2' col3' col4' col5' col6' col7' col8' col9
Long Parameter List,ScriptSharp.CodeModel,AccessorNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\AccessorNode.cs,AccessorNode,The method has 5 parameters. Parameters: token' attributes' name' body' modifiers
Long Parameter List,ScriptSharp.CodeModel,ConstantFieldDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\ConstantFieldDeclarationNode.cs,ConstantFieldDeclarationNode,The method has 5 parameters. Parameters: token' attributes' modifiers' type' initializers
Long Parameter List,ScriptSharp.CodeModel,ConstructorDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\ConstructorDeclarationNode.cs,ConstructorDeclarationNode,The method has 8 parameters. Parameters: token' attributes' modifiers' name' formals' callBase' baseArguments' body
Long Parameter List,ScriptSharp.CodeModel,OperatorDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\OperatorDeclarationNode.cs,OperatorDeclarationNode,The method has 7 parameters. Parameters: token' attributes' modifiers' operatorNodeType' returnType' formals' body
Long Parameter List,ScriptSharp.CodeModel,DestructorDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\DestructorDeclarationNode.cs,DestructorDeclarationNode,The method has 5 parameters. Parameters: token' attributes' modifiers' name' body
Long Parameter List,ScriptSharp.CodeModel,MethodDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\MethodDeclarationNode.cs,MethodDeclarationNode,The method has 10 parameters. Parameters: token' attributes' modifiers' returnType' interfaceType' name' typeParameters' formals' constraints' body
Long Parameter List,ScriptSharp.CodeModel,MethodDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\MethodDeclarationNode.cs,MethodDeclarationNode,The method has 8 parameters. Parameters: nodeType' token' attributes' modifiers' returnType' name' formals' body
Long Parameter List,ScriptSharp.CodeModel,IndexerDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\IndexerDeclarationNode.cs,IndexerDeclarationNode,The method has 8 parameters. Parameters: token' attributes' modifiers' type' interfaceType' parameters' get' set
Long Parameter List,ScriptSharp.CodeModel,PropertyDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\PropertyDeclarationNode.cs,PropertyDeclarationNode,The method has 8 parameters. Parameters: token' attributes' modifiers' type' interfaceType' name' getOrRemove' setOrAdd
Long Parameter List,ScriptSharp.CodeModel,PropertyDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\PropertyDeclarationNode.cs,PropertyDeclarationNode,The method has 8 parameters. Parameters: nodeType' token' attributes' modifiers' type' interfaceType' getOrRemove' setOrAdd
Long Parameter List,ScriptSharp.CodeModel,FieldDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\FieldDeclarationNode.cs,FieldDeclarationNode,The method has 6 parameters. Parameters: token' attributes' modifiers' type' initializers' isFixed
Long Parameter List,ScriptSharp.CodeModel,FieldDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\FieldDeclarationNode.cs,FieldDeclarationNode,The method has 7 parameters. Parameters: nodeType' token' attributes' modifiers' type' initializers' isFixed
Long Parameter List,ScriptSharp.CodeModel,ParameterNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\ParameterNode.cs,ParameterNode,The method has 5 parameters. Parameters: token' attributes' flags' type' name
Long Parameter List,ScriptSharp.CodeModel,ConstantDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Statements\ConstantDeclarationNode.cs,ConstantDeclarationNode,The method has 5 parameters. Parameters: token' attributes' modifiers' type' initializers
Long Parameter List,ScriptSharp.CodeModel,ForeachNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Statements\ForeachNode.cs,ForeachNode,The method has 5 parameters. Parameters: token' type' name' container' body
Long Parameter List,ScriptSharp.CodeModel,ForNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Statements\ForNode.cs,ForNode,The method has 5 parameters. Parameters: token' initializer' condition' increment' body
Long Parameter List,ScriptSharp.CodeModel,VariableDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Statements\VariableDeclarationNode.cs,VariableDeclarationNode,The method has 6 parameters. Parameters: token' attributes' modifiers' type' initializers' isFixed
Long Parameter List,ScriptSharp.CodeModel,VariableDeclarationNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Statements\VariableDeclarationNode.cs,VariableDeclarationNode,The method has 7 parameters. Parameters: nodeType' token' attributes' modifiers' type' initializers' isFixed
Long Parameter List,ScriptSharp.CodeModel,CompilationUnitNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Types\CompilationUnitNode.cs,CompilationUnitNode,The method has 5 parameters. Parameters: token' externAliases' usingClauses' attributes' members
Long Parameter List,ScriptSharp.CodeModel,DelegateTypeNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Types\DelegateTypeNode.cs,DelegateTypeNode,The method has 8 parameters. Parameters: token' attributes' modifiers' returnType' name' typeParameters' parameters' constraintClauses
Long Parameter List,ScriptSharp.CodeModel,CustomTypeNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Types\CustomTypeNode.cs,CustomTypeNode,The method has 9 parameters. Parameters: token' type' attributes' modifiers' name' typeParameters' baseTypes' constraintClauses' members
Long Parameter List,ScriptSharp.CodeModel,UserTypeNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Types\UserTypeNode.cs,UserTypeNode,The method has 8 parameters. Parameters: type' token' tokenType' attributes' modifiers' name' typeParameters' constraintClauses
Long Parameter List,ScriptSharp.CodeModel,NamespaceNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Types\NamespaceNode.cs,NamespaceNode,The method has 5 parameters. Parameters: token' nameNode' externAliases' usingClauses' members
Long Parameter List,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseMethod,The method has 5 parameters. Parameters: token' attributes' modifiers' type' interfaceType
Long Parameter List,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseIndexer,The method has 5 parameters. Parameters: token' attributes' modifiers' type' interfaceType
Long Parameter List,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseProperty,The method has 6 parameters. Parameters: token' attributes' modifiers' type' interfaceType' isEvent
Long Identifier,ScriptSharp.Parser,ParseError,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\ParseError.cs,,The length of the parameter FixedVariablesMustBeOfPointerType is 33.
Long Identifier,ScriptSharp.Parser,ParseError,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\ParseError.cs,,The length of the parameter WrongNumberOfArgsToUnaryOperator is 32.
Long Identifier,ScriptSharp.Parser,ParseError,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\ParseError.cs,,The length of the parameter WrongNumberOfArgsToBinnaryOperator is 34.
Long Identifier,ScriptSharp.Parser,ParseError,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\ParseError.cs,,The length of the parameter DuplicateConstructorConstraint is 30.
Long Identifier,ScriptSharp.Parser,ParseError,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\ParseError.cs,,The length of the parameter ConstructorConstraintMustBeLast is 31.
Long Statement,ScriptSharp,ScriptCompiler,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptCompiler.cs,BuildMetadata,The length of the statement  "                    string error = "The type '" + appType.FullName + "' conflicts with with '" + types[name].FullName + "' as they have the same name."; " is 132.
Long Statement,ScriptSharp,ScriptCompiler,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptCompiler.cs,BuildMetadata,The length of the statement  "                ICollection<Symbol> transformedSymbols = symbolSetTransformer.TransformSymbolSet(_symbols' /* useInheritanceOrder */ true); " is 123.
Long Statement,ScriptSharp,ScriptCompiler,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptCompiler.cs,BuildMetadata,The length of the statement  "                        testWriter.WriteLine("    Member '" + transformedSymbol.Name + "' renamed to '" + transformedSymbol.GeneratedName + "'"); " is 121.
Long Statement,ScriptSharp.ScriptModel,SymbolSet,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\SymbolSet.cs,CreateGenericMember,The length of the statement  "            Debug.Fail("Unexpected generic member '" + templateMember.Name + " on type '" + ((TypeSymbol)templateMember.Parent).FullName + "'."); " is 133.
Long Statement,ScriptSharp.ScriptModel,SymbolSet,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\SymbolSet.cs,CreateGenericTypeCore,The length of the statement  "                InterfaceSymbol instanceInterface = new InterfaceSymbol(genericInterface.Name' (NamespaceSymbol)genericInterface.Parent); " is 121.
Long Statement,ScriptSharp.ScriptModel,TypeSymbol,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\TypeSymbol.cs,FindSymbol,The length of the statement  "                    TypeSymbol objectType = (TypeSymbol)((ISymbolTable)this.SymbolSet.SystemNamespace).FindSymbol("Object"' null' SymbolFilter.Types); " is 130.
Long Statement,ScriptSharp.ScriptModel,SymbolObfuscator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\SymbolObfuscator.cs,TransformMember,The length of the statement  "                        baseType = (ClassSymbol)((ISymbolTable)memberSymbol.SymbolSet.SystemNamespace).FindSymbol("Object"' null' SymbolFilter.Types); " is 126.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                TypeSymbol objectType = (TypeSymbol)((ISymbolTable)_symbols.SystemNamespace).FindSymbol("Object"' null' SymbolFilter.Types); " is 124.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                TypeSymbol stringType = (TypeSymbol)((ISymbolTable)_symbols.SystemNamespace).FindSymbol("String"' null' SymbolFilter.Types); " is 124.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                TypeSymbol boolType = (TypeSymbol)((ISymbolTable)_symbols.SystemNamespace).FindSymbol("Boolean"' null' SymbolFilter.Types); " is 123.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                TypeSymbol dateType = (TypeSymbol)((ISymbolTable)_symbols.SystemNamespace).FindSymbol("Date"' null' SymbolFilter.Types); " is 120.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                MethodSymbol enumerateMethod = new MethodSymbol("Enumerate"' classSymbol' objectType' MemberVisibility.Public | MemberVisibility.Static); " is 137.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                MethodSymbol typeNameMethod = new MethodSymbol("GetTypeName"' classSymbol' stringType' MemberVisibility.Public | MemberVisibility.Static); " is 138.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                MethodSymbol compareDatesMethod = new MethodSymbol("CompareDates"' classSymbol' boolType' MemberVisibility.Public | MemberVisibility.Static); " is 141.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                TypeSymbol objectType = (TypeSymbol)((ISymbolTable)_symbols.SystemNamespace).FindSymbol("Object"' null' SymbolFilter.Types); " is 124.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                TypeSymbol intType = (TypeSymbol)((ISymbolTable)_symbols.SystemNamespace).FindSymbol("Int32"' null' SymbolFilter.Types); " is 120.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                TypeSymbol stringType = (TypeSymbol)((ISymbolTable)_symbols.SystemNamespace).FindSymbol("String"' null' SymbolFilter.Types); " is 124.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                MethodSymbol getKeysMethod = new MethodSymbol("GetKeys"' classSymbol' _symbols.CreateArrayTypeSymbol(stringType)' MemberVisibility.Public | MemberVisibility.Static); " is 165.
Long Statement,ScriptSharp.Importer,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataImporter.cs,ImportPseudoMembers,The length of the statement  "                MethodSymbol countMethod = new MethodSymbol("GetKeyCount"' classSymbol' intType' MemberVisibility.Public | MemberVisibility.Static); " is 132.
Long Statement,ScriptSharp.Importer,MetadataSource,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataSource.cs,LoadReferences,The length of the statement  "                        errorHandler.ReportError("The referenced assembly '" + referencePath + "' could not be loaded as an assembly."' String.Empty); " is 126.
Long Statement,ScriptSharp.Importer,MetadataSource,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataSource.cs,LoadReferences,The length of the statement  "                    errorHandler.ReportError("The referenced assembly '" + referencePath + "' could not be loaded as an assembly."' String.Empty); " is 126.
Long Statement,ScriptSharp.Importer,MetadataHelpers,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataHelpers.cs,GetScriptAlias,The length of the statement  "            CustomAttribute scriptAliasAttribute = GetAttribute(attributeProvider' "System.Runtime.CompilerServices.ScriptAliasAttribute"); " is 127.
Long Statement,ScriptSharp.Importer,MetadataHelpers,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\MetadataHelpers.cs,GetScriptDependencyName,The length of the statement  "            CustomAttribute scriptDependencyAttribute = GetAttribute(attributeProvider' "System.Runtime.CompilerServices.ScriptDependencyAttribute"); " is 137.
Long Statement,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,NextToken,The length of the statement  "                                            float f = float.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture); " is 132.
Long Statement,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,NextToken,The length of the statement  "                                            double d = double.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture); " is 134.
Long Statement,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,NextToken,The length of the statement  "                                            decimal dec = decimal.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture); " is 138.
Long Statement,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseClassOrStructMember,The length of the statement  "                        return ParseConstructor(token' attributes' CheckModifiers(0 != (modifiers & Modifiers.Static) ? Modifiers.StaticConstructorModifiers : Modifiers.ConstructorModifiers' modifiers)); " is 179.
Long Statement,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseClassOrStructMember,The length of the statement  "                                return ParseOperator(token' attributes' CheckModifiers(Modifiers.OperatorModifiers' modifiers)' CheckIsType(type' false)); " is 122.
Long Statement,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseClassOrStructMember,The length of the statement  "                                return ParseIndexer(token' attributes' CheckModifiers(Modifiers.IndexerModifiers' modifiers)' CheckIsType(type' false)' interfaceType); " is 135.
Long Statement,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseClassOrStructMember,The length of the statement  "                                return ParseProperty(token' attributes' CheckModifiers(Modifiers.PropertyModifiers' modifiers)' CheckIsType(type' false)' interfaceType' false); " is 144.
Long Statement,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseArrayRanks,The length of the statement  "                } while (PeekType() == TokenType.OpenSquare && (PeekType(1) == TokenType.Comma || PeekType(1) == TokenType.CloseSquare)); " is 121.
Long Statement,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildAssembly,The length of the statement  "                string errorMessage = "The ScriptAssembly attribute referenced an invalid name '{0}'. Script names must only contain letters' numbers' dots or underscores."; " is 157.
Long Statement,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildEnumField,The length of the statement  "            EnumerationFieldSymbol fieldSymbol = new EnumerationFieldSymbol(fieldNode.Name' typeSymbol' fieldNode.Value' fieldTypeSymbol); " is 126.
Long Statement,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildMetadata,The length of the statement  "                            partialTypeSymbol = (ClassSymbol)((ISymbolTable)namespaceSymbol).FindSymbol(userTypeNode.Name' /* context */ null' SymbolFilter.Types); " is 135.
Long Statement,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildType,The length of the statement  "                    Debug.Assert((dependencyAttribute.Arguments.Count != 0) && (dependencyAttribute.Arguments[0].NodeType == ParseNodeType.Literal)); " is 129.
Long Statement,ScriptSharp.Compiler,StatementBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\StatementBuilder.cs,ProcessForStatement,The length of the statement  "                    VariableDeclarationStatement initializer = (VariableDeclarationStatement)BuildStatement((StatementNode)node.Initializer); " is 121.
Long Statement,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessDotExpressionNode,The length of the statement  "                            = new MethodExpression(new TypeExpression(memberSymbol.AssociatedType' SymbolFilter.Public | SymbolFilter.StaticMembers)' " is 121.
Long Statement,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessOpenParenExpressionNode,The length of the statement  "                    methodExpression = new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)' " is 121.
Long Statement,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessOpenParenExpressionNode,The length of the statement  "                        Expression expr = new BinaryExpression(Operator.EqualEqualEqual' args[0]' TransformMemberExpression(undefinedExpression)); " is 122.
Long Statement,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessOpenParenExpressionNode,The length of the statement  "                        methodExpression = new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)' " is 121.
Long Statement,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessOpenParenExpressionNode,The length of the statement  "                            _errorHandler.ReportError("You must store the type returned from a method or property into a local variable to use with Type.CreateInstance."' " is 142.
Long Statement,ScriptSharp.Validator,CustomTypeNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\CustomTypeNodeValidator.cs,Validate,The length of the statement  "                        errorHandler.ReportError("Classes marked with ScriptObject must not derive from another class or implement interfaces."' " is 120.
Long Statement,ScriptSharp.Validator,CustomTypeNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\CustomTypeNodeValidator.cs,Validate,The length of the statement  "                        errorHandler.ReportError("Classes marked with ScriptObject attribute should only have a constructor and field members."' " is 120.
Long Statement,ScriptSharp.Validator,MethodDeclarationNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\MethodDeclarationNodeValidator.cs,Validate,The length of the statement  "                    errorHandler.ReportError("Extern methods used to declare alternate signatures should have a corresponding non-extern implementation as well."' " is 142.
Long Statement,ScriptSharp.Validator,MethodDeclarationNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\MethodDeclarationNodeValidator.cs,Validate,The length of the statement  "                    errorHandler.ReportError("The implemenation method and associated alternate signature methods should have the same access type."' " is 129.
Complex Conditional,ScriptSharp,Utility,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Utility.cs,QuoteString,The conditional expression  "c == '\r' || c == '\t' ||                      c == '\\' || c == '\r' || c < ' ' || c > 0x7F ||                      ((c == '\"') && useDoubleQuotes) ||                      ((c == '\'') && (useDoubleQuotes == false))"  is complex.
Complex Conditional,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,NextToken,The conditional expression  "IsDigit(nextChar) || ((nextChar == '+' || nextChar == '-') && IsDigit(PeekChar(2)))"  is complex.
Complex Conditional,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,ScanCharValue,The conditional expression  "i != 8 || (!allowSurrogates && surrogateValue > 0xFFFF) || surrogateValue > 0x10FFFF"  is complex.
Complex Conditional,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseGlobalAttributes,The conditional expression  "PeekType() == TokenType.OpenSquare &&                     PeekType(1) == TokenType.Identifier &&                     PeekType(2) == TokenType.Colon &&                     (((IdentifierToken)PeekToken(1)).Symbol == assemblyName ||                      ((IdentifierToken)PeekToken(1)).Symbol == moduleName)"  is complex.
Complex Conditional,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseAccessors,The conditional expression  "attributes.Count != 0 || PeekType() == TokenType.Identifier || (!isEvent && PeekModifier())"  is complex.
Complex Conditional,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseAccessors,The conditional expression  "(name.Identifier.Symbol == getName && !isEvent) ||                      (name.Identifier.Symbol == removeName && isEvent)"  is complex.
Complex Conditional,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseAccessors,The conditional expression  "(name.Identifier.Symbol == setName && !isEvent) ||                           (name.Identifier.Symbol == addName && isEvent)"  is complex.
Complex Conditional,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseSwitch,The conditional expression  "type != TokenType.Case && type != TokenType.Default && type != TokenType.CloseCurly && type != TokenType.EOF"  is complex.
Complex Conditional,ScriptSharp.Compiler,ImplementationBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ImplementationBuilder.cs,BuildField,The conditional expression  "(fieldType == symbolSet.ResolveIntrinsicType(IntrinsicType.Integer)) ||                      (fieldType == symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedInteger)) ||                      (fieldType == symbolSet.ResolveIntrinsicType(IntrinsicType.Long)) ||                      (fieldType == symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedLong)) ||                      (fieldType == symbolSet.ResolveIntrinsicType(IntrinsicType.Short)) ||                      (fieldType == symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedShort)) ||                      (fieldType == symbolSet.ResolveIntrinsicType(IntrinsicType.Byte)) ||                      (fieldType == symbolSet.ResolveIntrinsicType(IntrinsicType.SignedByte)) ||                      (fieldType == symbolSet.ResolveIntrinsicType(IntrinsicType.Double)) ||                      (fieldType == symbolSet.ResolveIntrinsicType(IntrinsicType.Single)) ||                      (fieldType == symbolSet.ResolveIntrinsicType(IntrinsicType.Decimal))"  is complex.
Complex Conditional,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessBinaryExpressionNode,The conditional expression  "(operatorType == Operator.BitwiseAnd) ||                      (operatorType == Operator.BitwiseAndEquals) ||                      (operatorType == Operator.BitwiseOr) ||                      (operatorType == Operator.BitwiseOrEquals) ||                      (operatorType == Operator.BitwiseXor) ||                      (operatorType == Operator.BitwiseXorEquals)"  is complex.
Complex Conditional,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessBinaryExpressionNode,The conditional expression  "(leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.Byte)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedShort)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedInteger)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedLong))"  is complex.
Complex Conditional,ScriptSharp.Validator,CustomTypeNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\CustomTypeNodeValidator.cs,Validate,The conditional expression  "(extensionAttribute.Arguments.Count != 1) ||                          !(extensionAttribute.Arguments[0] is LiteralNode) ||                          !(((LiteralNode)extensionAttribute.Arguments[0]).Value is string) ||                          String.IsNullOrEmpty((string)((LiteralNode)extensionAttribute.Arguments[0]).Value)"  is complex.
Complex Conditional,ScriptSharp.Validator,CustomTypeNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\CustomTypeNodeValidator.cs,Validate,The conditional expression  "recordRestrictions &&                          (((memberNode.Modifiers & Modifiers.Static) != 0) ||                           ((memberNode.NodeType != ParseNodeType.ConstructorDeclaration) &&                            (memberNode.NodeType != ParseNodeType.FieldDeclaration)))"  is complex.
Complex Conditional,ScriptSharp.Generator,ExpressionGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\ExpressionGenerator.cs,GenerateBinaryExpression,The conditional expression  "(expression.Operator == Operator.PlusEquals) ||                       (expression.Operator == Operator.MinusEquals) ||                       (expression.Operator == Operator.MultiplyEquals) ||                       (expression.Operator == Operator.DivideEquals) ||                       (expression.Operator == Operator.ModEquals) ||                       (expression.Operator == Operator.BitwiseOrEquals) ||                       (expression.Operator == Operator.BitwiseAndEquals) ||                       (expression.Operator == Operator.BitwiseXorEquals) ||                       (expression.Operator == Operator.ShiftLeftEquals) ||                       (expression.Operator == Operator.ShiftRightEquals) ||                       (expression.Operator == Operator.UnsignedShiftRightEquals)"  is complex.
Complex Conditional,ScriptSharp.Generator,ExpressionGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\ExpressionGenerator.cs,GenerateBinaryExpression,The conditional expression  "(compareValue && (expression.Operator == Operator.NotEqualEqual)) ||                              (!compareValue && (expression.Operator == Operator.EqualEqualEqual))"  is complex.
Complex Conditional,ScriptSharp.Generator,ExpressionGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\ExpressionGenerator.cs,GenerateBinaryExpression,The conditional expression  "(expression.LeftOperand.Parenthesized == false) &&                              ((expression.LeftOperand.Type == ExpressionType.Binary) ||                                  (expression.LeftOperand.Type == ExpressionType.Conditional) ||                                  (expression.LeftOperand.Type == ExpressionType.InlineScript))"  is complex.
Complex Conditional,ScriptSharp.Generator,ExpressionGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\ExpressionGenerator.cs,GenerateUnaryExpression,The conditional expression  "(propExpression != null) &&                  ((expression.Operator == Operator.PreIncrement) || (expression.Operator == Operator.PostIncrement) ||                   (expression.Operator == Operator.PreDecrement) || (expression.Operator == Operator.PostDecrement))"  is complex.
Virtual Method Call from Constructor,ScriptSharp.ScriptModel,AnonymousMethodSymbol,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\AnonymousMethodSymbol.cs,AnonymousMethodSymbol,The constructor "AnonymousMethodSymbol" calls a virtual method "AddAnonymousMethod".
Empty Catch Block,ScriptSharp.Importer.IL.Cil,SymbolProvider,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\Symbols.cs,GetPlatformType,The method has an empty catch block.
Empty Catch Block,ScriptSharp.Importer.IL.Cil,SymbolProvider,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\Symbols.cs,GetPlatformType,The method has an empty catch block.
Empty Catch Block,ScriptSharp.Collections.Generic,Collection<T>,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Utility\Collection.cs,Add,The method has an empty catch block.
Empty Catch Block,ScriptSharp.Collections.Generic,Collection<T>,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Utility\Collection.cs,Add,The method has an empty catch block.
Empty Catch Block,ScriptSharp.Collections.Generic,Collection<T>,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Utility\Collection.cs,IndexOf,The method has an empty catch block.
Empty Catch Block,ScriptSharp.Collections.Generic,Collection<T>,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Utility\Collection.cs,IndexOf,The method has an empty catch block.
Empty Catch Block,ScriptSharp.Collections.Generic,Collection<T>,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Utility\Collection.cs,Insert,The method has an empty catch block.
Empty Catch Block,ScriptSharp.Collections.Generic,Collection<T>,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Utility\Collection.cs,Insert,The method has an empty catch block.
Empty Catch Block,ScriptSharp.Collections.Generic,Collection<T>,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Utility\Collection.cs,Remove,The method has an empty catch block.
Empty Catch Block,ScriptSharp.Collections.Generic,Collection<T>,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Utility\Collection.cs,Remove,The method has an empty catch block.
Empty Catch Block,ScriptSharp.CodeModel,EnumerationFieldNode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Members\EnumerationFieldNode.cs,EnumerationFieldNode,The method has an empty catch block.
Empty Catch Block,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,NextToken,The method has an empty catch block.
Magic Number,ScriptSharp,Utility,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Utility.cs,QuoteString,The following statement contains a magic number: for (int i = 0; i < s.Length; i++) {                  char c = s[i];                    // Append the unhandled characters (that do not require special treament)                  // to the string builder when special characters are detected.                  if (c == '\r' || c == '\t' ||                      c == '\\' || c == '\r' || c < ' ' || c > 0x7F ||                      ((c == '\"') && useDoubleQuotes) ||                      ((c == '\'') && (useDoubleQuotes == false))) {                      if (b == null) {                          b = new StringBuilder(s.Length + 6);                      }                        if (count > 0) {                          b.Append(s' startIndex' count);                      }                        startIndex = i + 1;                      count = 0;                  }                    switch (c) {                      case '\r':                          b.Append("\\r");                          break;                      case '\t':                          b.Append("\\t");                          break;                      case '\\':                          b.Append("\\\\");                          break;                      case '\n':                          b.Append("\\n");                          break;                      case '\"':                          if (useDoubleQuotes) {                              b.Append("\\\"");                              break;                          }                          goto default;                      case '\'':                          if (!useDoubleQuotes) {                              b.Append("\\\'");                              break;                          }                          goto default;                      default:                          if ((c < ' ') || (c > 0x7F)) {                              b.AppendFormat(CultureInfo.InvariantCulture' "\\u{0:x4}"' (int)c);                          }                          else {                              count++;                          }                          break;                  }              }
Magic Number,ScriptSharp,ScriptCompiler,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptCompiler.cs,PreprocessTemplate,The following statement contains a magic number: return includePattern.Replace(template' delegate(Match include) {                  string includedScript = String.Empty;                    if (include.Groups.Count == 2) {                      string includePath = include.Groups[1].Value;                        IStreamSource includeSource = _options.IncludeResolver.Resolve(includePath);                      if (includeSource != null) {                          Stream includeStream = includeSource.GetStream();                          StreamReader reader = new StreamReader(includeStream);                            includedScript = reader.ReadToEnd();                          includeSource.CloseStream(includeStream);                      }                  }                    return includedScript;              });
Magic Number,ScriptSharp.Importer.IL,AssemblyNameReference,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  				var token = tokens [i].Trim ();    				if (i == 0) {  					name.Name = token;  					continue;  				}    				var parts = token.Split ('=');  				if (parts.Length != 2)  					throw new ArgumentException ("Malformed name");    				switch (parts [0]) {  				case "Version":  					name.Version = new Version (parts [1]);  					break;  				case "Culture":  					name.Culture = parts [1];  					break;  				case "PublicKeyToken":  					string pk_token = parts [1];  					if (pk_token == "null")  						break;    					name.PublicKeyToken = new byte [pk_token.Length / 2];  					for (int j = 0; j < name.PublicKeyToken.Length; j++) {  						name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  					}  					break;  				}  			}
Magic Number,ScriptSharp.Importer.IL,AssemblyNameReference,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  				var token = tokens [i].Trim ();    				if (i == 0) {  					name.Name = token;  					continue;  				}    				var parts = token.Split ('=');  				if (parts.Length != 2)  					throw new ArgumentException ("Malformed name");    				switch (parts [0]) {  				case "Version":  					name.Version = new Version (parts [1]);  					break;  				case "Culture":  					name.Culture = parts [1];  					break;  				case "PublicKeyToken":  					string pk_token = parts [1];  					if (pk_token == "null")  						break;    					name.PublicKeyToken = new byte [pk_token.Length / 2];  					for (int j = 0; j < name.PublicKeyToken.Length; j++) {  						name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  					}  					break;  				}  			}
Magic Number,ScriptSharp.Importer.IL,AssemblyNameReference,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  				var token = tokens [i].Trim ();    				if (i == 0) {  					name.Name = token;  					continue;  				}    				var parts = token.Split ('=');  				if (parts.Length != 2)  					throw new ArgumentException ("Malformed name");    				switch (parts [0]) {  				case "Version":  					name.Version = new Version (parts [1]);  					break;  				case "Culture":  					name.Culture = parts [1];  					break;  				case "PublicKeyToken":  					string pk_token = parts [1];  					if (pk_token == "null")  						break;    					name.PublicKeyToken = new byte [pk_token.Length / 2];  					for (int j = 0; j < name.PublicKeyToken.Length; j++) {  						name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  					}  					break;  				}  			}
Magic Number,ScriptSharp.Importer.IL,AssemblyNameReference,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  				var token = tokens [i].Trim ();    				if (i == 0) {  					name.Name = token;  					continue;  				}    				var parts = token.Split ('=');  				if (parts.Length != 2)  					throw new ArgumentException ("Malformed name");    				switch (parts [0]) {  				case "Version":  					name.Version = new Version (parts [1]);  					break;  				case "Culture":  					name.Culture = parts [1];  					break;  				case "PublicKeyToken":  					string pk_token = parts [1];  					if (pk_token == "null")  						break;    					name.PublicKeyToken = new byte [pk_token.Length / 2];  					for (int j = 0; j < name.PublicKeyToken.Length; j++) {  						name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  					}  					break;  				}  			}
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,ReadByIndexSize,The following statement contains a magic number: if (size == 4)  				return ReadUInt32 ();  			else  				return ReadUInt16 ();
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,ReadBlob,The following statement contains a magic number: if (blob_heap == null) {  				position += 2;  				return Empty<byte>.Array;  			}
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,ReadBlobIndex,The following statement contains a magic number: return ReadByIndexSize (blob_heap != null ? blob_heap.IndexSize : 2);
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,Populate,The following statement contains a magic number: Advance (2);
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,GetManagedResourceStream,The following statement contains a magic number: var length = buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24);
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,GetManagedResourceStream,The following statement contains a magic number: var length = buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24);
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,GetManagedResourceStream,The following statement contains a magic number: var length = buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24);
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,GetManagedResourceStream,The following statement contains a magic number: var length = buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24);
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,GetManagedResourceStream,The following statement contains a magic number: var length = buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24);
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,GetManagedResourceStream,The following statement contains a magic number: return new MemoryStream (buffer' (int) position + 4' length);
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: switch (type.etype) {  			case ElementType.Boolean:  			case ElementType.U1:  			case ElementType.I1:  				size = 1;  				break;  			case ElementType.U2:  			case ElementType.I2:  			case ElementType.Char:  				size = 2;  				break;  			case ElementType.U4:  			case ElementType.I4:  			case ElementType.R4:  				size = 4;  				break;  			case ElementType.U8:  			case ElementType.I8:  			case ElementType.R8:  				size = 8;  				break;  			case ElementType.Ptr:  			case ElementType.FnPtr:  				size = IntPtr.Size;  				break;  			case ElementType.CModOpt:  			case ElementType.CModReqD:  				return GetFieldTypeSize (((IModifierType) type).ElementType);  			default:  				var field_type = type.CheckedResolve ();  				if (field_type.HasLayoutInfo)  					size = field_type.ClassSize;    				break;  			}
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: switch (type.etype) {  			case ElementType.Boolean:  			case ElementType.U1:  			case ElementType.I1:  				size = 1;  				break;  			case ElementType.U2:  			case ElementType.I2:  			case ElementType.Char:  				size = 2;  				break;  			case ElementType.U4:  			case ElementType.I4:  			case ElementType.R4:  				size = 4;  				break;  			case ElementType.U8:  			case ElementType.I8:  			case ElementType.R8:  				size = 8;  				break;  			case ElementType.Ptr:  			case ElementType.FnPtr:  				size = IntPtr.Size;  				break;  			case ElementType.CModOpt:  			case ElementType.CModReqD:  				return GetFieldTypeSize (((IModifierType) type).ElementType);  			default:  				var field_type = type.CheckedResolve ();  				if (field_type.HasLayoutInfo)  					size = field_type.ClassSize;    				break;  			}
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: switch (type.etype) {  			case ElementType.Boolean:  			case ElementType.U1:  			case ElementType.I1:  				size = 1;  				break;  			case ElementType.U2:  			case ElementType.I2:  			case ElementType.Char:  				size = 2;  				break;  			case ElementType.U4:  			case ElementType.I4:  			case ElementType.R4:  				size = 4;  				break;  			case ElementType.U8:  			case ElementType.I8:  			case ElementType.R8:  				size = 8;  				break;  			case ElementType.Ptr:  			case ElementType.FnPtr:  				size = IntPtr.Size;  				break;  			case ElementType.CModOpt:  			case ElementType.CModReqD:  				return GetFieldTypeSize (((IModifierType) type).ElementType);  			default:  				var field_type = type.CheckedResolve ();  				if (field_type.HasLayoutInfo)  					size = field_type.ClassSize;    				break;  			}
Magic Number,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,InitializeGenericParameters,The following statement contains a magic number: metadata.GenericParameters = InitializeRanges (  				Table.GenericParam' () => {  					Advance (4);  					var next = ReadMetadataToken (CodedIndex.TypeOrMethodDef);  					ReadStringIndex ();  					return next;  			});
Magic Number,ScriptSharp.Importer.IL,BaseAssemblyResolver,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\BaseAssemblyResolver.cs,BaseAssemblyResolver,The following statement contains a magic number: directories = new Collection<string> (2) { "."' "bin" };
Magic Number,ScriptSharp.Importer.IL,BaseAssemblyResolver,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  				if (version.Major == 1)  					path = Path.Combine (path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine (path' "2.1");  					else  						path = Path.Combine (path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine (path' "4.0");  				else  					throw new NotSupportedException ("Version not supported: " + version);  			} else {  				switch (version.Major) {  				case 1:  					if (version.MajorRevision == 3300)  						path = Path.Combine (path' "v1.0.3705");  					else  						path = Path.Combine (path' "v1.0.5000.0");  					break;  				case 2:  					path = Path.Combine (path' "v2.0.50727");  					break;  				case 4:  					path = Path.Combine (path' "v4.0.30319");  					break;  				default:  					throw new NotSupportedException ("Version not supported: " + version);  				}  			}
Magic Number,ScriptSharp.Importer.IL,BaseAssemblyResolver,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  				if (version.Major == 1)  					path = Path.Combine (path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine (path' "2.1");  					else  						path = Path.Combine (path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine (path' "4.0");  				else  					throw new NotSupportedException ("Version not supported: " + version);  			} else {  				switch (version.Major) {  				case 1:  					if (version.MajorRevision == 3300)  						path = Path.Combine (path' "v1.0.3705");  					else  						path = Path.Combine (path' "v1.0.5000.0");  					break;  				case 2:  					path = Path.Combine (path' "v2.0.50727");  					break;  				case 4:  					path = Path.Combine (path' "v4.0.30319");  					break;  				default:  					throw new NotSupportedException ("Version not supported: " + version);  				}  			}
Magic Number,ScriptSharp.Importer.IL,BaseAssemblyResolver,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  				if (version.Major == 1)  					path = Path.Combine (path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine (path' "2.1");  					else  						path = Path.Combine (path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine (path' "4.0");  				else  					throw new NotSupportedException ("Version not supported: " + version);  			} else {  				switch (version.Major) {  				case 1:  					if (version.MajorRevision == 3300)  						path = Path.Combine (path' "v1.0.3705");  					else  						path = Path.Combine (path' "v1.0.5000.0");  					break;  				case 2:  					path = Path.Combine (path' "v2.0.50727");  					break;  				case 4:  					path = Path.Combine (path' "v4.0.30319");  					break;  				default:  					throw new NotSupportedException ("Version not supported: " + version);  				}  			}
Magic Number,ScriptSharp.Importer.IL,BaseAssemblyResolver,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  				if (version.Major == 1)  					path = Path.Combine (path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine (path' "2.1");  					else  						path = Path.Combine (path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine (path' "4.0");  				else  					throw new NotSupportedException ("Version not supported: " + version);  			} else {  				switch (version.Major) {  				case 1:  					if (version.MajorRevision == 3300)  						path = Path.Combine (path' "v1.0.3705");  					else  						path = Path.Combine (path' "v1.0.5000.0");  					break;  				case 2:  					path = Path.Combine (path' "v2.0.50727");  					break;  				case 4:  					path = Path.Combine (path' "v4.0.30319");  					break;  				default:  					throw new NotSupportedException ("Version not supported: " + version);  				}  			}
Magic Number,ScriptSharp.Importer.IL,BaseAssemblyResolver,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  				if (version.Major == 1)  					path = Path.Combine (path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine (path' "2.1");  					else  						path = Path.Combine (path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine (path' "4.0");  				else  					throw new NotSupportedException ("Version not supported: " + version);  			} else {  				switch (version.Major) {  				case 1:  					if (version.MajorRevision == 3300)  						path = Path.Combine (path' "v1.0.3705");  					else  						path = Path.Combine (path' "v1.0.5000.0");  					break;  				case 2:  					path = Path.Combine (path' "v2.0.50727");  					break;  				case 4:  					path = Path.Combine (path' "v4.0.30319");  					break;  				default:  					throw new NotSupportedException ("Version not supported: " + version);  				}  			}
Magic Number,ScriptSharp.Importer.IL,BaseAssemblyResolver,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  				if (version.Major == 1)  					path = Path.Combine (path' "1.0");  				else if (version.Major == 2) {  					if (version.MajorRevision == 5)  						path = Path.Combine (path' "2.1");  					else  						path = Path.Combine (path' "2.0");  				} else if (version.Major == 4)  					path = Path.Combine (path' "4.0");  				else  					throw new NotSupportedException ("Version not supported: " + version);  			} else {  				switch (version.Major) {  				case 1:  					if (version.MajorRevision == 3300)  						path = Path.Combine (path' "v1.0.3705");  					else  						path = Path.Combine (path' "v1.0.5000.0");  					break;  				case 2:  					path = Path.Combine (path' "v2.0.50727");  					break;  				case 4:  					path = Path.Combine (path' "v4.0.30319");  					break;  				default:  					throw new NotSupportedException ("Version not supported: " + version);  				}  			}
Magic Number,ScriptSharp.Importer.IL,BaseAssemblyResolver,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\BaseAssemblyResolver.cs,GetGacPaths,The following statement contains a magic number: var paths = new Collection<string> (2);
Magic Number,ScriptSharp.Importer.IL,BaseAssemblyResolver,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\BaseAssemblyResolver.cs,GetAssemblyInNetGac,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  				for (int j = 0; j < gacs.Length; j++) {  					var gac = Path.Combine (gac_paths [i]' gacs [j]);  					var file = GetAssemblyFile (reference' prefixes [i]' gac);  					if (Directory.Exists (gac) && File.Exists (file))  						return GetAssembly (file' parameters);  				}  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  				integer = data [position];  				position++;  			} else if ((data [position] & 0x40) == 0) {  				integer = (uint) (data [position] & ~0x80) << 8;  				integer |= data [position + 1];  				position += 2;  			} else {  				integer = (uint) (data [position] & ~0xc0) << 24;  				integer |= (uint) data [position + 1] << 16;  				integer |= (uint) data [position + 2] << 8;  				integer |= (uint) data [position + 3];  				position += 4;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  				integer = data [position];  				position++;  			} else if ((data [position] & 0x40) == 0) {  				integer = (uint) (data [position] & ~0x80) << 8;  				integer |= data [position + 1];  				position += 2;  			} else {  				integer = (uint) (data [position] & ~0xc0) << 24;  				integer |= (uint) data [position + 1] << 16;  				integer |= (uint) data [position + 2] << 8;  				integer |= (uint) data [position + 3];  				position += 4;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  				integer = data [position];  				position++;  			} else if ((data [position] & 0x40) == 0) {  				integer = (uint) (data [position] & ~0x80) << 8;  				integer |= data [position + 1];  				position += 2;  			} else {  				integer = (uint) (data [position] & ~0xc0) << 24;  				integer |= (uint) data [position + 1] << 16;  				integer |= (uint) data [position + 2] << 8;  				integer |= (uint) data [position + 3];  				position += 4;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  				integer = data [position];  				position++;  			} else if ((data [position] & 0x40) == 0) {  				integer = (uint) (data [position] & ~0x80) << 8;  				integer |= data [position + 1];  				position += 2;  			} else {  				integer = (uint) (data [position] & ~0xc0) << 24;  				integer |= (uint) data [position + 1] << 16;  				integer |= (uint) data [position + 2] << 8;  				integer |= (uint) data [position + 3];  				position += 4;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  				integer = data [position];  				position++;  			} else if ((data [position] & 0x40) == 0) {  				integer = (uint) (data [position] & ~0x80) << 8;  				integer |= data [position + 1];  				position += 2;  			} else {  				integer = (uint) (data [position] & ~0xc0) << 24;  				integer |= (uint) data [position + 1] << 16;  				integer |= (uint) data [position + 2] << 8;  				integer |= (uint) data [position + 3];  				position += 4;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  				integer = data [position];  				position++;  			} else if ((data [position] & 0x40) == 0) {  				integer = (uint) (data [position] & ~0x80) << 8;  				integer |= data [position + 1];  				position += 2;  			} else {  				integer = (uint) (data [position] & ~0xc0) << 24;  				integer |= (uint) data [position + 1] << 16;  				integer |= (uint) data [position + 2] << 8;  				integer |= (uint) data [position + 3];  				position += 4;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  				integer = data [position];  				position++;  			} else if ((data [position] & 0x40) == 0) {  				integer = (uint) (data [position] & ~0x80) << 8;  				integer |= data [position + 1];  				position += 2;  			} else {  				integer = (uint) (data [position] & ~0xc0) << 24;  				integer |= (uint) data [position + 1] << 16;  				integer |= (uint) data [position + 2] << 8;  				integer |= (uint) data [position + 3];  				position += 4;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  				integer = data [position];  				position++;  			} else if ((data [position] & 0x40) == 0) {  				integer = (uint) (data [position] & ~0x80) << 8;  				integer |= data [position + 1];  				position += 2;  			} else {  				integer = (uint) (data [position] & ~0xc0) << 24;  				integer |= (uint) data [position + 1] << 16;  				integer |= (uint) data [position + 2] << 8;  				integer |= (uint) data [position + 3];  				position += 4;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasConstant:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				case 2:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasCustomAttribute:  				rid = data >> 5;  				switch (data & 31) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.Field; goto ret;  				case 2:  					token_type = TokenType.TypeRef; goto ret;  				case 3:  					token_type = TokenType.TypeDef; goto ret;  				case 4:  					token_type = TokenType.Param; goto ret;  				case 5:  					token_type = TokenType.InterfaceImpl; goto ret;  				case 6:  					token_type = TokenType.MemberRef; goto ret;  				case 7:  					token_type = TokenType.Module; goto ret;  				case 8:  					token_type = TokenType.Permission; goto ret;  				case 9:  					token_type = TokenType.Property; goto ret;  				case 10:  					token_type = TokenType.Event; goto ret;  				case 11:  					token_type = TokenType.Signature; goto ret;  				case 12:  					token_type = TokenType.ModuleRef; goto ret;  				case 13:  					token_type = TokenType.TypeSpec; goto ret;  				case 14:  					token_type = TokenType.Assembly; goto ret;  				case 15:  					token_type = TokenType.AssemblyRef; goto ret;  				case 16:  					token_type = TokenType.File; goto ret;  				case 17:  					token_type = TokenType.ExportedType; goto ret;  				case 18:  					token_type = TokenType.ManifestResource; goto ret;  				case 19:  					token_type = TokenType.GenericParam; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasFieldMarshal:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Param; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasDeclSecurity:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				case 2:  					token_type = TokenType.Assembly; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberRefParent:  				rid = data >> 3;  				switch (data & 7) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.TypeRef; goto ret;  				case 2:  					token_type = TokenType.ModuleRef; goto ret;  				case 3:  					token_type = TokenType.Method; goto ret;  				case 4:  					token_type = TokenType.TypeSpec; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.HasSemantics:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Event; goto ret;  				case 1:  					token_type = TokenType.Property; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MethodDefOrRef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Method; goto ret;  				case 1:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.MemberForwarded:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.Field; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.Implementation:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.File; goto ret;  				case 1:  					token_type = TokenType.AssemblyRef; goto ret;  				case 2:  					token_type = TokenType.ExportedType; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.CustomAttributeType:  				rid = data >> 3;  				switch (data & 7) {  				case 2:  					token_type = TokenType.Method; goto ret;  				case 3:  					token_type = TokenType.MemberRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.ResolutionScope:  				rid = data >> 2;  				switch (data & 3) {  				case 0:  					token_type = TokenType.Module; goto ret;  				case 1:  					token_type = TokenType.ModuleRef; goto ret;  				case 2:  					token_type = TokenType.AssemblyRef; goto ret;  				case 3:  					token_type = TokenType.TypeRef; goto ret;  				default:  					goto exit;  				}  			case CodedIndex.TypeOrMethodDef:  				rid = data >> 1;  				switch (data & 1) {  				case 0:  					token_type = TokenType.TypeDef; goto ret;  				case 1:  					token_type = TokenType.Method; goto ret;  				default: goto exit;  				}  			default:  				goto exit;  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetSize,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.TypeSpec };  				break;  			case CodedIndex.HasConstant:  				bits = 2;  				tables = new [] { Table.Field' Table.Param' Table.Property };  				break;  			case CodedIndex.HasCustomAttribute:  				bits = 5;  				tables = new [] {  					Table.Method' Table.Field' Table.TypeRef' Table.TypeDef' Table.Param' Table.InterfaceImpl' Table.MemberRef'  					Table.Module' Table.DeclSecurity' Table.Property' Table.Event' Table.StandAloneSig' Table.ModuleRef'  					Table.TypeSpec' Table.Assembly' Table.AssemblyRef' Table.File' Table.ExportedType'  					Table.ManifestResource' Table.GenericParam  				};  				break;  			case CodedIndex.HasFieldMarshal:  				bits = 1;  				tables = new [] { Table.Field' Table.Param };  				break;  			case CodedIndex.HasDeclSecurity:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.Method' Table.Assembly };  				break;  			case CodedIndex.MemberRefParent:  				bits = 3;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.ModuleRef' Table.Method' Table.TypeSpec };  				break;  			case CodedIndex.HasSemantics:  				bits = 1;  				tables = new [] { Table.Event' Table.Property };  				break;  			case CodedIndex.MethodDefOrRef:  				bits = 1;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.MemberForwarded:  				bits = 1;  				tables = new [] { Table.Field' Table.Method };  				break;  			case CodedIndex.Implementation:  				bits = 2;  				tables = new [] { Table.File' Table.AssemblyRef' Table.ExportedType };  				break;  			case CodedIndex.CustomAttributeType:  				bits = 3;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.ResolutionScope:  				bits = 2;  				tables = new [] { Table.Module' Table.ModuleRef' Table.AssemblyRef' Table.TypeRef };  				break;  			case CodedIndex.TypeOrMethodDef:  				bits = 1;  				tables = new [] { Table.TypeDef' Table.Method };  				break;  			default:  				throw new ArgumentException ();  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetSize,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.TypeSpec };  				break;  			case CodedIndex.HasConstant:  				bits = 2;  				tables = new [] { Table.Field' Table.Param' Table.Property };  				break;  			case CodedIndex.HasCustomAttribute:  				bits = 5;  				tables = new [] {  					Table.Method' Table.Field' Table.TypeRef' Table.TypeDef' Table.Param' Table.InterfaceImpl' Table.MemberRef'  					Table.Module' Table.DeclSecurity' Table.Property' Table.Event' Table.StandAloneSig' Table.ModuleRef'  					Table.TypeSpec' Table.Assembly' Table.AssemblyRef' Table.File' Table.ExportedType'  					Table.ManifestResource' Table.GenericParam  				};  				break;  			case CodedIndex.HasFieldMarshal:  				bits = 1;  				tables = new [] { Table.Field' Table.Param };  				break;  			case CodedIndex.HasDeclSecurity:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.Method' Table.Assembly };  				break;  			case CodedIndex.MemberRefParent:  				bits = 3;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.ModuleRef' Table.Method' Table.TypeSpec };  				break;  			case CodedIndex.HasSemantics:  				bits = 1;  				tables = new [] { Table.Event' Table.Property };  				break;  			case CodedIndex.MethodDefOrRef:  				bits = 1;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.MemberForwarded:  				bits = 1;  				tables = new [] { Table.Field' Table.Method };  				break;  			case CodedIndex.Implementation:  				bits = 2;  				tables = new [] { Table.File' Table.AssemblyRef' Table.ExportedType };  				break;  			case CodedIndex.CustomAttributeType:  				bits = 3;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.ResolutionScope:  				bits = 2;  				tables = new [] { Table.Module' Table.ModuleRef' Table.AssemblyRef' Table.TypeRef };  				break;  			case CodedIndex.TypeOrMethodDef:  				bits = 1;  				tables = new [] { Table.TypeDef' Table.Method };  				break;  			default:  				throw new ArgumentException ();  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetSize,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.TypeSpec };  				break;  			case CodedIndex.HasConstant:  				bits = 2;  				tables = new [] { Table.Field' Table.Param' Table.Property };  				break;  			case CodedIndex.HasCustomAttribute:  				bits = 5;  				tables = new [] {  					Table.Method' Table.Field' Table.TypeRef' Table.TypeDef' Table.Param' Table.InterfaceImpl' Table.MemberRef'  					Table.Module' Table.DeclSecurity' Table.Property' Table.Event' Table.StandAloneSig' Table.ModuleRef'  					Table.TypeSpec' Table.Assembly' Table.AssemblyRef' Table.File' Table.ExportedType'  					Table.ManifestResource' Table.GenericParam  				};  				break;  			case CodedIndex.HasFieldMarshal:  				bits = 1;  				tables = new [] { Table.Field' Table.Param };  				break;  			case CodedIndex.HasDeclSecurity:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.Method' Table.Assembly };  				break;  			case CodedIndex.MemberRefParent:  				bits = 3;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.ModuleRef' Table.Method' Table.TypeSpec };  				break;  			case CodedIndex.HasSemantics:  				bits = 1;  				tables = new [] { Table.Event' Table.Property };  				break;  			case CodedIndex.MethodDefOrRef:  				bits = 1;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.MemberForwarded:  				bits = 1;  				tables = new [] { Table.Field' Table.Method };  				break;  			case CodedIndex.Implementation:  				bits = 2;  				tables = new [] { Table.File' Table.AssemblyRef' Table.ExportedType };  				break;  			case CodedIndex.CustomAttributeType:  				bits = 3;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.ResolutionScope:  				bits = 2;  				tables = new [] { Table.Module' Table.ModuleRef' Table.AssemblyRef' Table.TypeRef };  				break;  			case CodedIndex.TypeOrMethodDef:  				bits = 1;  				tables = new [] { Table.TypeDef' Table.Method };  				break;  			default:  				throw new ArgumentException ();  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetSize,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.TypeSpec };  				break;  			case CodedIndex.HasConstant:  				bits = 2;  				tables = new [] { Table.Field' Table.Param' Table.Property };  				break;  			case CodedIndex.HasCustomAttribute:  				bits = 5;  				tables = new [] {  					Table.Method' Table.Field' Table.TypeRef' Table.TypeDef' Table.Param' Table.InterfaceImpl' Table.MemberRef'  					Table.Module' Table.DeclSecurity' Table.Property' Table.Event' Table.StandAloneSig' Table.ModuleRef'  					Table.TypeSpec' Table.Assembly' Table.AssemblyRef' Table.File' Table.ExportedType'  					Table.ManifestResource' Table.GenericParam  				};  				break;  			case CodedIndex.HasFieldMarshal:  				bits = 1;  				tables = new [] { Table.Field' Table.Param };  				break;  			case CodedIndex.HasDeclSecurity:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.Method' Table.Assembly };  				break;  			case CodedIndex.MemberRefParent:  				bits = 3;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.ModuleRef' Table.Method' Table.TypeSpec };  				break;  			case CodedIndex.HasSemantics:  				bits = 1;  				tables = new [] { Table.Event' Table.Property };  				break;  			case CodedIndex.MethodDefOrRef:  				bits = 1;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.MemberForwarded:  				bits = 1;  				tables = new [] { Table.Field' Table.Method };  				break;  			case CodedIndex.Implementation:  				bits = 2;  				tables = new [] { Table.File' Table.AssemblyRef' Table.ExportedType };  				break;  			case CodedIndex.CustomAttributeType:  				bits = 3;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.ResolutionScope:  				bits = 2;  				tables = new [] { Table.Module' Table.ModuleRef' Table.AssemblyRef' Table.TypeRef };  				break;  			case CodedIndex.TypeOrMethodDef:  				bits = 1;  				tables = new [] { Table.TypeDef' Table.Method };  				break;  			default:  				throw new ArgumentException ();  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetSize,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.TypeSpec };  				break;  			case CodedIndex.HasConstant:  				bits = 2;  				tables = new [] { Table.Field' Table.Param' Table.Property };  				break;  			case CodedIndex.HasCustomAttribute:  				bits = 5;  				tables = new [] {  					Table.Method' Table.Field' Table.TypeRef' Table.TypeDef' Table.Param' Table.InterfaceImpl' Table.MemberRef'  					Table.Module' Table.DeclSecurity' Table.Property' Table.Event' Table.StandAloneSig' Table.ModuleRef'  					Table.TypeSpec' Table.Assembly' Table.AssemblyRef' Table.File' Table.ExportedType'  					Table.ManifestResource' Table.GenericParam  				};  				break;  			case CodedIndex.HasFieldMarshal:  				bits = 1;  				tables = new [] { Table.Field' Table.Param };  				break;  			case CodedIndex.HasDeclSecurity:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.Method' Table.Assembly };  				break;  			case CodedIndex.MemberRefParent:  				bits = 3;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.ModuleRef' Table.Method' Table.TypeSpec };  				break;  			case CodedIndex.HasSemantics:  				bits = 1;  				tables = new [] { Table.Event' Table.Property };  				break;  			case CodedIndex.MethodDefOrRef:  				bits = 1;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.MemberForwarded:  				bits = 1;  				tables = new [] { Table.Field' Table.Method };  				break;  			case CodedIndex.Implementation:  				bits = 2;  				tables = new [] { Table.File' Table.AssemblyRef' Table.ExportedType };  				break;  			case CodedIndex.CustomAttributeType:  				bits = 3;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.ResolutionScope:  				bits = 2;  				tables = new [] { Table.Module' Table.ModuleRef' Table.AssemblyRef' Table.TypeRef };  				break;  			case CodedIndex.TypeOrMethodDef:  				bits = 1;  				tables = new [] { Table.TypeDef' Table.Method };  				break;  			default:  				throw new ArgumentException ();  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetSize,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.TypeSpec };  				break;  			case CodedIndex.HasConstant:  				bits = 2;  				tables = new [] { Table.Field' Table.Param' Table.Property };  				break;  			case CodedIndex.HasCustomAttribute:  				bits = 5;  				tables = new [] {  					Table.Method' Table.Field' Table.TypeRef' Table.TypeDef' Table.Param' Table.InterfaceImpl' Table.MemberRef'  					Table.Module' Table.DeclSecurity' Table.Property' Table.Event' Table.StandAloneSig' Table.ModuleRef'  					Table.TypeSpec' Table.Assembly' Table.AssemblyRef' Table.File' Table.ExportedType'  					Table.ManifestResource' Table.GenericParam  				};  				break;  			case CodedIndex.HasFieldMarshal:  				bits = 1;  				tables = new [] { Table.Field' Table.Param };  				break;  			case CodedIndex.HasDeclSecurity:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.Method' Table.Assembly };  				break;  			case CodedIndex.MemberRefParent:  				bits = 3;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.ModuleRef' Table.Method' Table.TypeSpec };  				break;  			case CodedIndex.HasSemantics:  				bits = 1;  				tables = new [] { Table.Event' Table.Property };  				break;  			case CodedIndex.MethodDefOrRef:  				bits = 1;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.MemberForwarded:  				bits = 1;  				tables = new [] { Table.Field' Table.Method };  				break;  			case CodedIndex.Implementation:  				bits = 2;  				tables = new [] { Table.File' Table.AssemblyRef' Table.ExportedType };  				break;  			case CodedIndex.CustomAttributeType:  				bits = 3;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.ResolutionScope:  				bits = 2;  				tables = new [] { Table.Module' Table.ModuleRef' Table.AssemblyRef' Table.TypeRef };  				break;  			case CodedIndex.TypeOrMethodDef:  				bits = 1;  				tables = new [] { Table.TypeDef' Table.Method };  				break;  			default:  				throw new ArgumentException ();  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetSize,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.TypeSpec };  				break;  			case CodedIndex.HasConstant:  				bits = 2;  				tables = new [] { Table.Field' Table.Param' Table.Property };  				break;  			case CodedIndex.HasCustomAttribute:  				bits = 5;  				tables = new [] {  					Table.Method' Table.Field' Table.TypeRef' Table.TypeDef' Table.Param' Table.InterfaceImpl' Table.MemberRef'  					Table.Module' Table.DeclSecurity' Table.Property' Table.Event' Table.StandAloneSig' Table.ModuleRef'  					Table.TypeSpec' Table.Assembly' Table.AssemblyRef' Table.File' Table.ExportedType'  					Table.ManifestResource' Table.GenericParam  				};  				break;  			case CodedIndex.HasFieldMarshal:  				bits = 1;  				tables = new [] { Table.Field' Table.Param };  				break;  			case CodedIndex.HasDeclSecurity:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.Method' Table.Assembly };  				break;  			case CodedIndex.MemberRefParent:  				bits = 3;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.ModuleRef' Table.Method' Table.TypeSpec };  				break;  			case CodedIndex.HasSemantics:  				bits = 1;  				tables = new [] { Table.Event' Table.Property };  				break;  			case CodedIndex.MethodDefOrRef:  				bits = 1;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.MemberForwarded:  				bits = 1;  				tables = new [] { Table.Field' Table.Method };  				break;  			case CodedIndex.Implementation:  				bits = 2;  				tables = new [] { Table.File' Table.AssemblyRef' Table.ExportedType };  				break;  			case CodedIndex.CustomAttributeType:  				bits = 3;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.ResolutionScope:  				bits = 2;  				tables = new [] { Table.Module' Table.ModuleRef' Table.AssemblyRef' Table.TypeRef };  				break;  			case CodedIndex.TypeOrMethodDef:  				bits = 1;  				tables = new [] { Table.TypeDef' Table.Method };  				break;  			default:  				throw new ArgumentException ();  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetSize,The following statement contains a magic number: switch (self) {  			case CodedIndex.TypeDefOrRef:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.TypeSpec };  				break;  			case CodedIndex.HasConstant:  				bits = 2;  				tables = new [] { Table.Field' Table.Param' Table.Property };  				break;  			case CodedIndex.HasCustomAttribute:  				bits = 5;  				tables = new [] {  					Table.Method' Table.Field' Table.TypeRef' Table.TypeDef' Table.Param' Table.InterfaceImpl' Table.MemberRef'  					Table.Module' Table.DeclSecurity' Table.Property' Table.Event' Table.StandAloneSig' Table.ModuleRef'  					Table.TypeSpec' Table.Assembly' Table.AssemblyRef' Table.File' Table.ExportedType'  					Table.ManifestResource' Table.GenericParam  				};  				break;  			case CodedIndex.HasFieldMarshal:  				bits = 1;  				tables = new [] { Table.Field' Table.Param };  				break;  			case CodedIndex.HasDeclSecurity:  				bits = 2;  				tables = new [] { Table.TypeDef' Table.Method' Table.Assembly };  				break;  			case CodedIndex.MemberRefParent:  				bits = 3;  				tables = new [] { Table.TypeDef' Table.TypeRef' Table.ModuleRef' Table.Method' Table.TypeSpec };  				break;  			case CodedIndex.HasSemantics:  				bits = 1;  				tables = new [] { Table.Event' Table.Property };  				break;  			case CodedIndex.MethodDefOrRef:  				bits = 1;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.MemberForwarded:  				bits = 1;  				tables = new [] { Table.Field' Table.Method };  				break;  			case CodedIndex.Implementation:  				bits = 2;  				tables = new [] { Table.File' Table.AssemblyRef' Table.ExportedType };  				break;  			case CodedIndex.CustomAttributeType:  				bits = 3;  				tables = new [] { Table.Method' Table.MemberRef };  				break;  			case CodedIndex.ResolutionScope:  				bits = 2;  				tables = new [] { Table.Module' Table.ModuleRef' Table.AssemblyRef' Table.TypeRef };  				break;  			case CodedIndex.TypeOrMethodDef:  				bits = 1;  				tables = new [] { Table.TypeDef' Table.Method };  				break;  			default:  				throw new ArgumentException ();  			}
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetSize,The following statement contains a magic number: return max < (1 << (16 - bits)) ? 2 : 4;
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetSize,The following statement contains a magic number: return max < (1 << (16 - bits)) ? 2 : 4;
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,GetSize,The following statement contains a magic number: return max < (1 << (16 - bits)) ? 2 : 4;
Magic Number,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,ParseRuntime,The following statement contains a magic number: switch (self [1]) {  			case '1':  				return self [3] == '0'  					? TargetRuntime.Net_1_0  					: TargetRuntime.Net_1_1;  			case '2':  				return TargetRuntime.Net_2_0;  			case '4':  			default:  				return TargetRuntime.Net_4_0;  			}
Magic Number,ScriptSharp.Importer.IL,MetadataSystem,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\MetadataSystem.cs,InitializePrimitives,The following statement contains a magic number: primitive_value_types = new Dictionary<string' Row<ElementType' bool>> (18) {  				{ "Void"' new Row<ElementType' bool> (ElementType.Void' false) }'  				{ "Boolean"' new Row<ElementType' bool> (ElementType.Boolean' true) }'  				{ "Char"' new Row<ElementType' bool> (ElementType.Char' true) }'  				{ "SByte"' new Row<ElementType' bool> (ElementType.I1' true) }'  				{ "Byte"' new Row<ElementType' bool> (ElementType.U1' true) }'  				{ "Int16"' new Row<ElementType' bool> (ElementType.I2' true) }'  				{ "UInt16"' new Row<ElementType' bool> (ElementType.U2' true) }'  				{ "Int32"' new Row<ElementType' bool> (ElementType.I4' true) }'  				{ "UInt32"' new Row<ElementType' bool> (ElementType.U4' true) }'  				{ "Int64"' new Row<ElementType' bool> (ElementType.I8' true) }'  				{ "UInt64"' new Row<ElementType' bool> (ElementType.U8' true) }'  				{ "Single"' new Row<ElementType' bool> (ElementType.R4' true) }'  				{ "Double"' new Row<ElementType' bool> (ElementType.R8' true) }'  				{ "String"' new Row<ElementType' bool> (ElementType.String' false) }'  				{ "TypedReference"' new Row<ElementType' bool> (ElementType.TypedByRef' false) }'  				{ "IntPtr"' new Row<ElementType' bool> (ElementType.I' true) }'  				{ "UIntPtr"' new Row<ElementType' bool> (ElementType.U' true) }'  				{ "Object"' new Row<ElementType' bool> (ElementType.Object' false) }'  			};
Magic Number,ScriptSharp.Importer.IL,MetadataSystem,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\MetadataSystem.cs,BinaryRangeSearch,The following statement contains a magic number: while (min <= max) {  				int mid = min + ((max - min) / 2);  				var type = types [mid];  				var range = field ? type.fields_range : type.methods_range;    				if (rid < range.Start)  					max = mid - 1;  				else if (rid >= range.Start + range.Length)  					min = mid + 1;  				else  					return type;  			}
Magic Number,ScriptSharp.Importer.IL,CommonTypeSystem,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\TypeSystem.cs,GetCorlibVersion,The following statement contains a magic number: switch (module.Runtime) {  				case TargetRuntime.Net_1_0:  				case TargetRuntime.Net_1_1:  					return new Version (1' 0' 0' 0);  				case TargetRuntime.Net_2_0:  					return new Version (2' 0' 0' 0);  				case TargetRuntime.Net_4_0:  					return new Version (4' 0' 0' 0);  				default:  					throw new NotSupportedException ();  				}
Magic Number,ScriptSharp.Importer.IL,CommonTypeSystem,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\TypeSystem.cs,GetCorlibVersion,The following statement contains a magic number: switch (module.Runtime) {  				case TargetRuntime.Net_1_0:  				case TargetRuntime.Net_1_1:  					return new Version (1' 0' 0' 0);  				case TargetRuntime.Net_2_0:  					return new Version (2' 0' 0' 0);  				case TargetRuntime.Net_4_0:  					return new Version (4' 0' 0' 0);  				default:  					throw new NotSupportedException ();  				}
Magic Number,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,ReadMethodBody,The following statement contains a magic number: switch (flags & 0x3) {  			case 0x2: // tiny  				body.code_size = flags >> 2;  				body.MaxStackSize = 8;  				ReadCode ();  				break;  			case 0x3: // fat  				base.position--;  				ReadFatMethod ();  				break;  			default:  				throw new InvalidOperationException ();  			}
Magic Number,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,ReadMethodBody,The following statement contains a magic number: switch (flags & 0x3) {  			case 0x2: // tiny  				body.code_size = flags >> 2;  				body.MaxStackSize = 8;  				ReadCode ();  				break;  			case 0x3: // fat  				base.position--;  				ReadFatMethod ();  				break;  			default:  				throw new InvalidOperationException ();  			}
Magic Number,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,ReadCode,The following statement contains a magic number: var instructions = body.instructions = new InstructionCollection (code_size / 3);
Magic Number,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,ReadOperand,The following statement contains a magic number: switch (instruction.opcode.OperandType) {  			case OperandType.InlineSwitch:  				var length = ReadInt32 ();  				var base_offset = Offset + (4 * length);  				var branches = new int [length];  				for (int i = 0; i < length; i++)  					branches [i] = base_offset + ReadInt32 ();  				return branches;  			case OperandType.ShortInlineBrTarget:  				return ReadSByte () + Offset;  			case OperandType.InlineBrTarget:  				return ReadInt32 () + Offset;  			case OperandType.ShortInlineI:  				if (instruction.opcode == OpCodes.Ldc_I4_S)  					return ReadSByte ();    				return ReadByte ();  			case OperandType.InlineI:  				return ReadInt32 ();  			case OperandType.ShortInlineR:  				return ReadSingle ();  			case OperandType.InlineR:  				return ReadDouble ();  			case OperandType.InlineI8:  				return ReadInt64 ();  			case OperandType.ShortInlineVar:  				return GetVariable (ReadByte ());  			case OperandType.InlineVar:  				return GetVariable (ReadUInt16 ());  			case OperandType.ShortInlineArg:  				return GetParameter (ReadByte ());  			case OperandType.InlineArg:  				return GetParameter (ReadUInt16 ());  			case OperandType.InlineSig:  				return GetCallSite (ReadToken ());  			case OperandType.InlineString:  				return GetString (ReadToken ());  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.InlineMethod:  			case OperandType.InlineField:  				return reader.LookupToken (ReadToken ());  			default:  				throw new NotSupportedException ();  			}
Magic Number,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,GetInstruction,The following statement contains a magic number: while (min <= max) {  				int mid = min + ((max - min) / 2);  				var instruction = items [mid];  				var instruction_offset = instruction.offset;    				if (offset == instruction_offset)  					return instruction;    				if (offset < instruction_offset)  					max = mid - 1;  				else  					min = mid + 1;  			}
Magic Number,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,ReadSection,The following statement contains a magic number: Align (4);
Magic Number,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,ReadSmallSection,The following statement contains a magic number: var count = ReadByte () / 12;
Magic Number,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,ReadSmallSection,The following statement contains a magic number: Advance (2);
Magic Number,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,ReadFatSection,The following statement contains a magic number: var count = (ReadInt32 () >> 8) / 24;
Magic Number,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,ReadFatSection,The following statement contains a magic number: var count = (ReadInt32 () >> 8) / 24;
Magic Number,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,ReadExceptionHandlerSpecific,The following statement contains a magic number: switch (handler.HandlerType) {  			case ExceptionHandlerType.Catch:  				handler.CatchType = (TypeReference) reader.LookupToken (ReadToken ());  				break;  			case ExceptionHandlerType.Filter:  				handler.FilterStart = GetInstruction (ReadInt32 ());  				break;  			default:  				Advance (4);  				break;  			}
Magic Number,ScriptSharp.Importer.IL.Cil,Instruction,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  			case OperandType.InlineSwitch:  				return size + (1 + ((Instruction []) operand).Length) * 4;  			case OperandType.InlineI8:  			case OperandType.InlineR:  				return size + 8;  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  			case OperandType.InlineSig:  				return size + 4;  			case OperandType.InlineArg:  			case OperandType.InlineVar:  				return size + 2;  			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineArg:  			case OperandType.ShortInlineVar:  				return size + 1;  			default:  				return size;  			}
Magic Number,ScriptSharp.Importer.IL.Cil,Instruction,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  			case OperandType.InlineSwitch:  				return size + (1 + ((Instruction []) operand).Length) * 4;  			case OperandType.InlineI8:  			case OperandType.InlineR:  				return size + 8;  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  			case OperandType.InlineSig:  				return size + 4;  			case OperandType.InlineArg:  			case OperandType.InlineVar:  				return size + 2;  			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineArg:  			case OperandType.ShortInlineVar:  				return size + 1;  			default:  				return size;  			}
Magic Number,ScriptSharp.Importer.IL.Cil,Instruction,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  			case OperandType.InlineSwitch:  				return size + (1 + ((Instruction []) operand).Length) * 4;  			case OperandType.InlineI8:  			case OperandType.InlineR:  				return size + 8;  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  			case OperandType.InlineSig:  				return size + 4;  			case OperandType.InlineArg:  			case OperandType.InlineVar:  				return size + 2;  			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineArg:  			case OperandType.ShortInlineVar:  				return size + 1;  			default:  				return size;  			}
Magic Number,ScriptSharp.Importer.IL.Cil,Instruction,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  			case OperandType.InlineSwitch:  				return size + (1 + ((Instruction []) operand).Length) * 4;  			case OperandType.InlineI8:  			case OperandType.InlineR:  				return size + 8;  			case OperandType.InlineBrTarget:  			case OperandType.InlineField:  			case OperandType.InlineI:  			case OperandType.InlineMethod:  			case OperandType.InlineString:  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.ShortInlineR:  			case OperandType.InlineSig:  				return size + 4;  			case OperandType.InlineArg:  			case OperandType.InlineVar:  				return size + 2;  			case OperandType.ShortInlineBrTarget:  			case OperandType.ShortInlineI:  			case OperandType.ShortInlineArg:  			case OperandType.ShortInlineVar:  				return size + 1;  			default:  				return size;  			}
Magic Number,ScriptSharp.Importer.IL.Cil,OpCode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.op2 = (byte) ((x >> 8) & 0xff);
Magic Number,ScriptSharp.Importer.IL.Cil,OpCode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.code = (byte) ((x >> 16) & 0xff);
Magic Number,ScriptSharp.Importer.IL.Cil,OpCode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.flow_control = (byte) ((x >> 24) & 0xff);
Magic Number,ScriptSharp.Importer.IL.Cil,OpCode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.operand_type = (byte) ((y >> 8) & 0xff);
Magic Number,ScriptSharp.Importer.IL.Cil,OpCode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.stack_behavior_pop = (byte) ((y >> 16) & 0xff);
Magic Number,ScriptSharp.Importer.IL.Cil,OpCode,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.stack_behavior_push = (byte) ((y >> 24) & 0xff);
Magic Number,ScriptSharp.Importer.IL.Metadata,GuidHeap,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Metadata\GuidHeap.cs,Read,The following statement contains a magic number: const int guid_size = 16;
Magic Number,ScriptSharp.Importer.IL.Metadata,UserStringHeap,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Metadata\UserStringHeap.cs,ReadStringAt,The following statement contains a magic number: var chars = new char [length / 2];
Magic Number,ScriptSharp.Importer.IL.Metadata,UserStringHeap,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Metadata\UserStringHeap.cs,ReadStringAt,The following statement contains a magic number: for (int i = start' j = 0; i < start + length; i += 2)  				chars [j++] = (char) (data [i] | (data [i + 1] << 8));
Magic Number,ScriptSharp.Importer.IL.Metadata,UserStringHeap,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Metadata\UserStringHeap.cs,ReadStringAt,The following statement contains a magic number: for (int i = start' j = 0; i < start + length; i += 2)  				chars [j++] = (char) (data [i] | (data [i + 1] << 8));
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadUInt16,The following statement contains a magic number: ushort value = (ushort) (buffer [position]  				| (buffer [position + 1] << 8));
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadUInt16,The following statement contains a magic number: position += 2;
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadUInt32,The following statement contains a magic number: uint value = (uint) (buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24));
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadUInt32,The following statement contains a magic number: uint value = (uint) (buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24));
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadUInt32,The following statement contains a magic number: uint value = (uint) (buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24));
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadUInt32,The following statement contains a magic number: uint value = (uint) (buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24));
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadUInt32,The following statement contains a magic number: uint value = (uint) (buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24));
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadUInt32,The following statement contains a magic number: position += 4;
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadUInt64,The following statement contains a magic number: return (((ulong) high) << 32) | low;
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((first & 0x40) == 0)  				return ((uint) (first & ~0x80) << 8)  					| ReadByte ();
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint) (first & ~0xc0) << 24)  				| (uint) ReadByte () << 16  				| (uint) ReadByte () << 8  				| ReadByte ();
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint) (first & ~0xc0) << 24)  				| (uint) ReadByte () << 16  				| (uint) ReadByte () << 8  				| ReadByte ();
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint) (first & ~0xc0) << 24)  				| (uint) ReadByte () << 16  				| (uint) ReadByte () << 8  				| ReadByte ();
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadSingle,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {  				var bytes = ReadBytes (4);  				Array.Reverse (bytes);  				return BitConverter.ToSingle (bytes' 0);  			}
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadSingle,The following statement contains a magic number: position += 4;
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadDouble,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {  				var bytes = ReadBytes (8);  				Array.Reverse (bytes);  				return BitConverter.ToDouble (bytes' 0);  			}
Magic Number,ScriptSharp.Importer.IL.PE,ByteBuffer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBuffer.cs,ReadDouble,The following statement contains a magic number: position += 8;
Magic Number,ScriptSharp.Importer.IL.PE,ByteBufferEqualityComparer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ByteBufferEqualityComparer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < buffer.length; i++)  				hash = (hash * 37) ^ bytes [i];
Magic Number,ScriptSharp.Importer.IL.PE,Image,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\Image.cs,GetTableIndexSize,The following statement contains a magic number: return GetTableLength (table) < 65536 ? 2 : 4;
Magic Number,ScriptSharp.Importer.IL.PE,Image,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\Image.cs,GetTableIndexSize,The following statement contains a magic number: return GetTableLength (table) < 65536 ? 2 : 4;
Magic Number,ScriptSharp.Importer.IL.PE,Image,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\Image.cs,GetTableIndexSize,The following statement contains a magic number: return GetTableLength (table) < 65536 ? 2 : 4;
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadImage,The following statement contains a magic number: if (BaseStream.Length < 128)  				throw new BadImageFormatException ();
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadImage,The following statement contains a magic number: Advance (58);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadImage,The following statement contains a magic number: Advance (14);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (66);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (pe64 ? 90 : 74);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (pe64 ? 90 : 74);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (56);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (8);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadAlignedString,The following statement contains a magic number: Advance (-1 + ((read + 4) & ~3) - read);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadAlignedString,The following statement contains a magic number: Advance (-1 + ((read + 4) & ~3) - read);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadSections,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				var section = new Section ();    				// Name  				section.Name = ReadZeroTerminatedString (8);    				// VirtualSize		4  				Advance (4);    				// VirtualAddress	4  				section.VirtualAddress = ReadUInt32 ();  				// SizeOfRawData	4  				section.SizeOfRawData = ReadUInt32 ();  				// PointerToRawData	4  				section.PointerToRawData = ReadUInt32 ();    				// PointerToRelocations		4  				// PointerToLineNumbers		4  				// NumberOfRelocations		2  				// NumberOfLineNumbers		2  				// Characteristics			4  				Advance (16);    				sections [i] = section;    				if (section.Name == ".reloc")  					continue;    				ReadSectionData (section);  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadSections,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				var section = new Section ();    				// Name  				section.Name = ReadZeroTerminatedString (8);    				// VirtualSize		4  				Advance (4);    				// VirtualAddress	4  				section.VirtualAddress = ReadUInt32 ();  				// SizeOfRawData	4  				section.SizeOfRawData = ReadUInt32 ();  				// PointerToRawData	4  				section.PointerToRawData = ReadUInt32 ();    				// PointerToRelocations		4  				// PointerToLineNumbers		4  				// NumberOfRelocations		2  				// NumberOfLineNumbers		2  				// Characteristics			4  				Advance (16);    				sections [i] = section;    				if (section.Name == ".reloc")  					continue;    				ReadSectionData (section);  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadSections,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				var section = new Section ();    				// Name  				section.Name = ReadZeroTerminatedString (8);    				// VirtualSize		4  				Advance (4);    				// VirtualAddress	4  				section.VirtualAddress = ReadUInt32 ();  				// SizeOfRawData	4  				section.SizeOfRawData = ReadUInt32 ();  				// PointerToRawData	4  				section.PointerToRawData = ReadUInt32 ();    				// PointerToRelocations		4  				// PointerToLineNumbers		4  				// NumberOfRelocations		2  				// NumberOfLineNumbers		2  				// Characteristics			4  				Advance (16);    				sections [i] = section;    				if (section.Name == ".reloc")  					continue;    				ReadSectionData (section);  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadCLIHeader,The following statement contains a magic number: Advance (8);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadMetadata,The following statement contains a magic number: Advance (8);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadMetadata,The following statement contains a magic number: Advance (2);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadMetadataStream,The following statement contains a magic number: var name = ReadAlignedString (16);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadTableHeap,The following statement contains a magic number: Advance (6);
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,SetIndexSize,The following statement contains a magic number: heap.IndexSize = (sizes & flag) > 0 ? 4 : 2;
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,SetIndexSize,The following statement contains a magic number: heap.IndexSize = (sizes & flag) > 0 ? 4 : 2;
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: int blobidx_size = image.BlobHeap != null ? image.BlobHeap.IndexSize : 2;
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < TableHeap.TableIdentifiers.Length; i++) {  				var table = TableHeap.TableIdentifiers [i];  				if (!heap.HasTable (table))  					continue;    				int size;  				switch (table) {  				case Table.Module:  					size = 2	// Generation  						+ stridx_size	// Name  						+ (image.GuidHeap.IndexSize * 3);	// Mvid' EncId' EncBaseId  					break;  				case Table.TypeRef:  					size = GetCodedIndexSize (CodedIndex.ResolutionScope)	// ResolutionScope  						+ (stridx_size * 2);	// Name' Namespace  					break;  				case Table.TypeDef:  					size = 4	// Flags  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)	// BaseType  						+ GetTableIndexSize (Table.Field)	// FieldList  						+ GetTableIndexSize (Table.Method);	// MethodList  					break;  				case Table.FieldPtr:  					size = GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Field:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.MethodPtr:  					size = GetTableIndexSize (Table.Method);	// Method  					break;  				case Table.Method:  					size = 8	// Rva 4' ImplFlags 2' Flags 2  						+ stridx_size	// Name  						+ blobidx_size	// Signature  						+ GetTableIndexSize (Table.Param); // ParamList  					break;  				case Table.ParamPtr:  					size = GetTableIndexSize (Table.Param); // Param  					break;  				case Table.Param:  					size = 4	// Flags 2' Sequence 2  						+ stridx_size;	// Name  					break;  				case Table.InterfaceImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Interface  					break;  				case Table.MemberRef:  					size = GetCodedIndexSize (CodedIndex.MemberRefParent)	// Class  						+ stridx_size	// Name  						+ blobidx_size;	// Signature  					break;  				case Table.Constant:  					size = 2	// Type  						+ GetCodedIndexSize (CodedIndex.HasConstant)	// Parent  						+ blobidx_size;	// Value  					break;  				case Table.CustomAttribute:  					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)	// Parent  						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)	// Type  						+ blobidx_size;	// Value  					break;  				case Table.FieldMarshal:  					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)	// Parent  						+ blobidx_size;	// NativeType  					break;  				case Table.DeclSecurity:  					size = 2	// Action  						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)	// Parent  						+ blobidx_size;	// PermissionSet  					break;  				case Table.ClassLayout:  					size = 6	// PackingSize 2' ClassSize 4  						+ GetTableIndexSize (Table.TypeDef);	// Parent  					break;  				case Table.FieldLayout:  					size = 4	// Offset  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.StandAloneSig:  					size = blobidx_size;	// Signature  					break;  				case Table.EventMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Event);	// EventList  					break;  				case Table.EventPtr:  					size = GetTableIndexSize (Table.Event);	// Event  					break;  				case Table.Event:  					size = 2	// Flags  						+ stridx_size // Name  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// EventType  					break;  				case Table.PropertyMap:  					size = GetTableIndexSize (Table.TypeDef)	// Parent  						+ GetTableIndexSize (Table.Property);	// PropertyList  					break;  				case Table.PropertyPtr:  					size = GetTableIndexSize (Table.Property);	// Property  					break;  				case Table.Property:  					size = 2	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// Type  					break;  				case Table.MethodSemantics:  					size = 2	// Semantics  						+ GetTableIndexSize (Table.Method)	// Method  						+ GetCodedIndexSize (CodedIndex.HasSemantics);	// Association  					break;  				case Table.MethodImpl:  					size = GetTableIndexSize (Table.TypeDef)	// Class  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// MethodBody  						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);	// MethodDeclaration  					break;  				case Table.ModuleRef:  					size = stridx_size;	// Name  					break;  				case Table.TypeSpec:  					size = blobidx_size;	// Signature  					break;  				case Table.ImplMap:  					size = 2	// MappingFlags  						+ GetCodedIndexSize (CodedIndex.MemberForwarded)	// MemberForwarded  						+ stridx_size	// ImportName  						+ GetTableIndexSize (Table.ModuleRef);	// ImportScope  					break;  				case Table.FieldRVA:  					size = 4	// RVA  						+ GetTableIndexSize (Table.Field);	// Field  					break;  				case Table.Assembly:  					size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  						+ blobidx_size	// PublicKey  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyProcessor:  					size = 4;	// Processor  					break;  				case Table.AssemblyOS:  					size = 12;	// Platform 4' Version 2 * 4  					break;  				case Table.AssemblyRef:  					size = 12	// Version 2 * 4 + Flags 4  						+ (blobidx_size * 2)	// PublicKeyOrToken' HashValue  						+ (stridx_size * 2);	// Name' Culture  					break;  				case Table.AssemblyRefProcessor:  					size = 4	// Processor  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.AssemblyRefOS:  					size = 12	// Platform 4' Version 2 * 4  						+ GetTableIndexSize (Table.AssemblyRef);	// AssemblyRef  					break;  				case Table.File:  					size = 4	// Flags  						+ stridx_size	// Name  						+ blobidx_size;	// HashValue  					break;  				case Table.ExportedType:  					size = 8	// Flags 4' TypeDefId 4  						+ (stridx_size * 2)	// Name' Namespace  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.ManifestResource:  					size = 8	// Offset' Flags  						+ stridx_size	// Name  						+ GetCodedIndexSize (CodedIndex.Implementation);	// Implementation  					break;  				case Table.NestedClass:  					size = GetTableIndexSize (Table.TypeDef)	// NestedClass  						+ GetTableIndexSize (Table.TypeDef);	// EnclosingClass  					break;  				case Table.GenericParam:  					size = 4	// Number' Flags  						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)	// Owner  						+ stridx_size;	// Name  					break;  				case Table.MethodSpec:  					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)	// Method  						+ blobidx_size;	// Instantiation  					break;  				case Table.GenericParamConstraint:  					size = GetTableIndexSize (Table.GenericParam)	// Owner  						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);	// Constraint  					break;  				default:  					throw new NotSupportedException ();  				}    				int index = (int) table;    				tables [index].RowSize = (uint) size;  				tables [index].Offset = offset;    				offset += (uint) size * tables [index].Length;  			}
Magic Number,ScriptSharp.Collections.Generic,Collection<T>,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Utility\Collection.cs,Grow,The following statement contains a magic number: const int default_capacity = 4;
Magic Number,ScriptSharp.Collections.Generic,Collection<T>,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Utility\Collection.cs,Grow,The following statement contains a magic number: new_size = System.Math.Max (  				System.Math.Max (items.Length * 2' default_capacity)'  				new_size);
Magic Number,ScriptSharp.ScriptModel,SymbolObfuscator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\SymbolObfuscator.cs,TransformMember,The following statement contains a magic number: if ((memberSymbol.InterfaceMember != null) ||                  (memberSymbol.Name.Length < 3) ||                  (memberSymbol.IsTransformAllowed == false)) {                  // Interface members do get obfuscated                    // Also members with already short names do not get                  // obfuscated' as doing so might infact increase the name size                  return null;              }
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.CodeModel,Token,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\CodeModel\Tokens\Token.cs,Token,The following statement contains a magic number: infos = new TokenInfo[] {                  new TokenInfo("abstract"      ' TokenFlags.None)'                  new TokenInfo("as"            ' TokenFlags.None'      4)'                  new TokenInfo("base"          ' TokenFlags.None)'                  new TokenInfo("bool"          ' TokenFlags.PredefinedType)'                  new TokenInfo("break"         ' TokenFlags.None)'                  new TokenInfo("byte"          ' TokenFlags.PredefinedType)'                  new TokenInfo("case"          ' TokenFlags.None)'                  new TokenInfo("catch"         ' TokenFlags.None)'                  new TokenInfo("char"          ' TokenFlags.PredefinedType)'                  new TokenInfo("checked"       ' TokenFlags.None)'                  new TokenInfo("class"         ' TokenFlags.None)'                  new TokenInfo("const"         ' TokenFlags.None)'                  new TokenInfo("continue"      ' TokenFlags.None)'                  new TokenInfo("decimal"       ' TokenFlags.PredefinedType)'                  new TokenInfo("default"       ' TokenFlags.None)'                  new TokenInfo("delegate"      ' TokenFlags.None)'                  new TokenInfo("do"            ' TokenFlags.None)'                  new TokenInfo("double"        ' TokenFlags.PredefinedType)'                  new TokenInfo("else"          ' TokenFlags.None)'                  new TokenInfo("enum"          ' TokenFlags.None)'                  new TokenInfo("event"         ' TokenFlags.None)'                  new TokenInfo("explicit"      ' TokenFlags.None)'                  new TokenInfo("extern"        ' TokenFlags.None)'                  new TokenInfo("false"         ' TokenFlags.OverloadableOperator)'                  new TokenInfo("finally"       ' TokenFlags.None)'                  new TokenInfo("fixed"         ' TokenFlags.None)'                  new TokenInfo("float"         ' TokenFlags.PredefinedType)'                  new TokenInfo("for"           ' TokenFlags.None)'                  new TokenInfo("foreach"       ' TokenFlags.None)'                  new TokenInfo("goto"          ' TokenFlags.None)'                  new TokenInfo("if"            ' TokenFlags.None)'                  new TokenInfo("in"            ' TokenFlags.None)'                  new TokenInfo("implicit"      ' TokenFlags.None)'                  new TokenInfo("int"           ' TokenFlags.PredefinedType)'                  new TokenInfo("interface"     ' TokenFlags.None)'                  new TokenInfo("internal"      ' TokenFlags.None)'                  new TokenInfo("is"            ' TokenFlags.None'      4)'                  new TokenInfo("lock"          ' TokenFlags.None)'                  new TokenInfo("long"          ' TokenFlags.PredefinedType)'                  new TokenInfo("namespace"     ' TokenFlags.None)'                  new TokenInfo("new"           ' TokenFlags.None)'                  new TokenInfo("null"          ' TokenFlags.None)'                  new TokenInfo("object"        ' TokenFlags.PredefinedType)'                  new TokenInfo("operator"      ' TokenFlags.None)'                  new TokenInfo("out"           ' TokenFlags.None)'                  new TokenInfo("override"      ' TokenFlags.None)'                  new TokenInfo("params"        ' TokenFlags.None)'                  new TokenInfo("private"       ' TokenFlags.None)'                  new TokenInfo("protected"     ' TokenFlags.None)'                  new TokenInfo("public"        ' TokenFlags.None)'                  new TokenInfo("readonly"      ' TokenFlags.None)'                  new TokenInfo("ref"           ' TokenFlags.None)'                  new TokenInfo("return"        ' TokenFlags.None)'                  new TokenInfo("sbyte"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sealed"        ' TokenFlags.None)'                  new TokenInfo("short"         ' TokenFlags.PredefinedType)'                  new TokenInfo("sizeof"        ' TokenFlags.None)'                  new TokenInfo("stackalloc"    ' TokenFlags.None)'                  new TokenInfo("static"        ' TokenFlags.None)'                  new TokenInfo("string"        ' TokenFlags.PredefinedType)'                  new TokenInfo("struct"        ' TokenFlags.None)'                  new TokenInfo("switch"        ' TokenFlags.None)'                  new TokenInfo("this"          ' TokenFlags.None)'                  new TokenInfo("throw"         ' TokenFlags.None)'                  new TokenInfo("true"          ' TokenFlags.OverloadableOperator)'                  new TokenInfo("try"           ' TokenFlags.None)'                  new TokenInfo("typeof"        ' TokenFlags.None)'                  new TokenInfo("uint"          ' TokenFlags.PredefinedType)'                  new TokenInfo("ulong"         ' TokenFlags.PredefinedType)'                  new TokenInfo("unchecked"     ' TokenFlags.None)'                  new TokenInfo("unsafe"        ' TokenFlags.None)'                  new TokenInfo("ushort"        ' TokenFlags.PredefinedType)'                  new TokenInfo("using"         ' TokenFlags.None)'                  new TokenInfo("virtual"       ' TokenFlags.None)'                  new TokenInfo("void"          ' TokenFlags.PredefinedType)'                  new TokenInfo("volatile"      ' TokenFlags.None)'                  new TokenInfo("while"         ' TokenFlags.None)'                  new TokenInfo("Identifier"    ' TokenFlags.None)'                  new TokenInfo("Literal"       ' TokenFlags.None)'                  new TokenInfo(";"             ' TokenFlags.None)'                  new TokenInfo(")"             ' TokenFlags.None)'                  new TokenInfo("]"             ' TokenFlags.None)'                  new TokenInfo("{"             ' TokenFlags.None)'                  new TokenInfo("}"             ' TokenFlags.None)'                  new TokenInfo("'"             ' TokenFlags.None)'                  new TokenInfo("="             ' TokenFlags.AssignmentOperator)'                  new TokenInfo("+="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("-="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("*="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("/="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("%="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("&="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("^="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("|="            ' TokenFlags.AssignmentOperator)'                  new TokenInfo("<<="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo(">>="           ' TokenFlags.AssignmentOperator)'                  new TokenInfo("?"             ' TokenFlags.None)'                  new TokenInfo(":"             ' TokenFlags.None)'                  new TokenInfo("::"            ' TokenFlags.None)'                  new TokenInfo("||"            ' TokenFlags.None'                      10)'                  new TokenInfo("&&"            ' TokenFlags.None'                      9)'                  new TokenInfo("|"             ' TokenFlags.OverloadableOperator'      8)'                  new TokenInfo("^"             ' TokenFlags.OverloadableOperator'      7)'                  new TokenInfo("&"             ' TokenFlags.OverloadableOperator'      6)'                  new TokenInfo("=="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("!="            ' TokenFlags.OverloadableOperator'      5)'                  new TokenInfo("<"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">"             ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo(">="            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("??"            ' TokenFlags.OverloadableOperator'      4)'                  new TokenInfo("<<"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo(">>"            ' TokenFlags.OverloadableOperator'      3)'                  new TokenInfo("+"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("-"             ' TokenFlags.OverloadableOperator'      2)'                  new TokenInfo("*"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("/"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("%"             ' TokenFlags.OverloadableOperator'      1)'                  new TokenInfo("~"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("!"             ' TokenFlags.OverloadableOperator)'                  new TokenInfo("++"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("--"            ' TokenFlags.OverloadableOperator)'                  new TokenInfo("("             ' TokenFlags.None)'                  new TokenInfo("["             ' TokenFlags.None)'                  new TokenInfo("."             ' TokenFlags.None)'                  new TokenInfo("->"            ' TokenFlags.None)'                  new TokenInfo("BOF"           ' TokenFlags.None)'                  new TokenInfo("EOF"           ' TokenFlags.None)'                  new TokenInfo("Comment"       ' TokenFlags.None)'                  new TokenInfo("Error"         ' TokenFlags.None)'                  new TokenInfo("Invalid"       ' TokenFlags.None)'              };
Magic Number,ScriptSharp.Parser,BufferPosition,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\BufferPosition.cs,GetHashCode,The following statement contains a magic number: return (_line * 64) + _column;
Magic Number,ScriptSharp.Parser,FileLexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\FileLexer.cs,LexFile,The following statement contains a magic number: _tokens = new ArrayList(_text.Length / 8);
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,NextToken,The following statement contains a magic number: switch (ch) {                  case '\0':                      Debug.Fail("Checked for EOF above");                      return null;                    case '#':                      if (_text.Line == _lastLine) {                          ReportError(LexError.UnexpectedCharacter' ch.ToString());                          return ErrorToken();                      }                      else {                          ClearPosition();                          _text.Reverse();                          return null;                      }                    // operators                  case '{': return NewToken(TokenType.OpenCurly);                  case '}': return NewToken(TokenType.CloseCurly);                  case '[': return NewToken(TokenType.OpenSquare);                  case ']': return NewToken(TokenType.CloseSquare);                  case '(': return NewToken(TokenType.OpenParen);                  case ')': return NewToken(TokenType.CloseParen);                  case ''': return NewToken(TokenType.Comma);                  case ':':                      ch = PeekChar();                      if (ch == ':') {                          NextChar();                          return NewToken(TokenType.ColonColon);                      }                      return NewToken(TokenType.Colon);                    case ';': return NewToken(TokenType.Semicolon);                  case '~': return NewToken(TokenType.Tilde);                    case '?':                      ch = PeekChar();                      if (ch == '?') {                          NextChar();                          return NewToken(TokenType.Coalesce);                      }                      return NewToken(TokenType.Question);                    case '+':                      ch = PeekChar();                      if (ch == '+') {                          NextChar();                          return NewToken(TokenType.PlusPlus);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.PlusEqual);                      }                      return NewToken(TokenType.Plus);                    case '-':                      ch = PeekChar();                      if (ch == '-') {                          NextChar();                          return NewToken(TokenType.MinusMinus);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.MinusEqual);                      }                      else if (ch == '>') {                          NextChar();                          return NewToken(TokenType.Arrow);                      }                      return NewToken(TokenType.Minus);                    case '*':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.StarEqual);                      }                      return NewToken(TokenType.Star);                    case '/':                      ch = PeekChar();                      if (ch == '=') {                          NextChar();                          return NewToken(TokenType.SlashEqual);                      }                      else if (ch == '/') {                          NextChar();                            CommentTokenType commentType;                          if (!EOF && PeekChar() == '/') {                              commentType = CommentTokenType.TripleSlash;                              NextChar();                          }                          else {                              commentType = CommentTokenType.DoubleSlash;                          }                            _value.Length = 0;                          while (!EOF && !IsLineSeparator(PeekChar())) {                              _value.Append(NextChar());                          }                            if (_includeComments) {                              return new CommentToken(commentType' _value.ToString()' _path' TakePosition());                          }                          else {                              TakePosition();                              return NextToken();                          }                      }                      else if (ch == '*') {                          NextChar();                            _value.Length = 0;                          while (!EOF && (PeekChar() != '*' || PeekChar(1) != '/')) {                              _value.Append(NextChar());                          }                          if (EOF) {                              ReportError(LexError.UnexpectedEndOfFileStarSlash);                              return ErrorToken();                          }                            NextChar();                          NextChar();                            _lastLine = _text.Line;                            if (_includeComments) {                              return new CommentToken(CommentTokenType.SlashStar' _value.ToString()' _path' TakePosition());                          }                          else {                              TakePosition();                              return NextToken();                          }                      }                        return NewToken(TokenType.Slash);                    case '%':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.PercentEqual);                      }                      return NewToken(TokenType.Percent);                    case '&':                      ch = PeekChar();                      if (ch == '&') {                          NextChar();                          return NewToken(TokenType.LogAnd);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.AndEqual);                      }                      return NewToken(TokenType.Ampersand);                    case '|':                      ch = PeekChar();                      if (ch == '|') {                          NextChar();                          return NewToken(TokenType.LogOr);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.BarEqual);                      }                      return NewToken(TokenType.Bar);                    case '^':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.HatEqual);                      }                      return NewToken(TokenType.Hat);                    case '!':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.NotEqual);                      }                      return NewToken(TokenType.Bang);                    case '=':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.EqualEqual);                      }                      return NewToken(TokenType.Equal);                    case '<':                      ch = PeekChar();                      if (ch == '=') {                          NextChar();                          return NewToken(TokenType.LessEqual);                      }                      else if (ch == '<') {                          NextChar();                          if (PeekChar() == '=') {                              NextChar();                              return NewToken(TokenType.ShiftLeftEqual);                          }                          return NewToken(TokenType.ShiftLeft);                      }                      return NewToken(TokenType.Less);                    case '>':                      ch = PeekChar();                      if (ch == '=') {                          NextChar();                          return NewToken(TokenType.GreaterEqual);                      }                      return NewToken(TokenType.Greater);                    // literals                  case '\'':                      // char literal                      {                          char ch2;                          if (ScanCharValue('\''' false' out ch' out ch2)) {                              if (PeekChar() != '\'') {                                  ReportError(LexError.BadCharConstant);                              }                              else {                                  NextChar();                              }                              return new CharToken(ch' _path' TakePosition());                          }                          else {                              return ErrorToken();                          }                      }                    case '"':                      // string literal                      {                          char ch2;                          _value.Length = 0;                          while (!EOF && ScanCharValue('"'' true' out ch' out ch2)) {                              _value.Append(ch);                              if (ch2 != 0)                                  _value.Append(ch2);                          }                          if (EOF) {                              ReportError(LexError.UnexpectedEndOfFileString);                              return ErrorToken();                          }                          return new StringToken(_value.ToString()' _path' TakePosition());                      }                    case '@':                      ch = PeekChar();                      if (ch == '"') {                          // verbatim string literal                          NextChar();                          _value.Length = 0;                          while (!EOF && (PeekChar() != '"' || PeekChar(1) == '"')) {                              // this is the one place where a CR/LF pair is significant                              bool wasCRLF;                              ch = NextChar(out wasCRLF);                              _value.Append(ch);                              if (wasCRLF) {                                  _value.Append('\xA');                              }                              else if (ch == '"') {                                  NextChar();                              }                          }                          if (EOF) {                              ReportError(LexError.UnexpectedEndOfFileString);                              return ErrorToken();                          }                          NextChar();                          return new StringToken(_value.ToString()' _path' TakePosition());                      }                      atIdentifier = true;                      goto default;                    case '0':                      if (PeekChar() == 'x' || PeekChar() == 'X') {                          NextChar();                            // hexadecimal constant                          ulong value = 0;                          while (IsHexDigit(PeekChar())) {                              if ((value & 0xF000000000000000) != 0) {                                  ReportError(LexError.NumericConstantOverflow);                                  return ErrorToken();                              }                              value = (value << 4) | (uint)HexValue(NextChar());                          }                            return CreateIntegerConstant(value' ScanIntegerSuffixOpt());                      }                      goto case '1';                    case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  DoNumber: {                          bool foundDecimalPoint = (ch == '.');                          bool foundExponent = false;                          NumericSuffix suffix = NumericSuffix.None;                            _value.Length = 0;                          _value.Append(ch);                          while (true) {                              ch = PeekChar();                              if (ch == '.') {                                  if (foundDecimalPoint || !IsDigit(PeekChar(1))) {                                      break;                                  }                                  foundDecimalPoint = true;                              }                              else if (ch == 'e' || ch == 'E') {                                  char nextChar = PeekChar(1);                                  if (IsDigit(nextChar) || ((nextChar == '+' || nextChar == '-') && IsDigit(PeekChar(2)))) {                                      foundExponent = true;                                        _value.Append(NextChar());                                      _value.Append(NextChar());                                      while (IsDigit(PeekChar())) {                                          _value.Append(NextChar());                                      }                                  }                                  break;                              }                              else if (!IsDigit(ch)) {                                  break;                              }                              _value.Append(NextChar());                          }                            if (!foundDecimalPoint && !foundExponent) {                              suffix = ScanIntegerSuffixOpt();                          }                            if (suffix == NumericSuffix.None) {                              suffix = ScanRealSuffixOpt();                          }                            if (suffix < NumericSuffix.F && !foundDecimalPoint && !foundExponent) {                              // decimal integer constant                              ulong numericValue = 0;                              foreach (char digit in _value.ToString().ToCharArray()) {                                  ulong value10 = numericValue * 10;                                  if (value10 < numericValue) {                                      ReportError(LexError.NumericConstantOverflow);                                      return ErrorToken();                                  }                                  numericValue = value10 + (uint)(digit - '0');                              }                                return CreateIntegerConstant(numericValue' suffix);                          }                          else {                              try {                                  // real constant                                  switch (suffix) {                                      case NumericSuffix.F: {                                              float f = float.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new FloatToken(f' _path' TakePosition());                                          }                                        case NumericSuffix.D:                                      case NumericSuffix.None: {                                              double d = double.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new DoubleToken(d' _path' TakePosition());                                          }                                        case NumericSuffix.M: {                                              decimal dec = decimal.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new DecimalToken(dec' _path' TakePosition());                                          }                                  }                              }                              catch (Exception) {                                  // catch overflow exceptions from the numeric parse                              }                              ReportError(LexError.NumericConstantOverflow);                              return ErrorToken();                          }                      }                    case '.':                      if (IsDigit(PeekChar())) {                          goto DoNumber;                      }                      return NewToken(TokenType.Dot);                    default: {                          _value.Length = 0;                          if (!IsIdentifierChar(ch)) {                              ReportError(LexError.UnexpectedCharacter' ch.ToString());                              return ErrorToken();                          }                          _value.Append(ch);                            while (ScanIdentifierChar(out ch)) {                              _value.Append(ch);                          }                            Debug.Assert(_value.Length > 0);                            if (_value.Length > IdentifierToken.MaxIdentifierLength) {                              ReportError(LexError.IdentifierTooLong);                              return ErrorToken();                          }                            Name name = _nameTable.Add(_value);                          if (!atIdentifier) {                              // check for keywords                              TokenType keyword = _keywords.IsKeyword(name);                              if (Token.IsKeyword(keyword)) {                                  return new Token(keyword' _path' TakePosition());                              }                          }                            return new IdentifierToken(name' atIdentifier' _path' TakePosition());                      }              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,NextToken,The following statement contains a magic number: switch (ch) {                  case '\0':                      Debug.Fail("Checked for EOF above");                      return null;                    case '#':                      if (_text.Line == _lastLine) {                          ReportError(LexError.UnexpectedCharacter' ch.ToString());                          return ErrorToken();                      }                      else {                          ClearPosition();                          _text.Reverse();                          return null;                      }                    // operators                  case '{': return NewToken(TokenType.OpenCurly);                  case '}': return NewToken(TokenType.CloseCurly);                  case '[': return NewToken(TokenType.OpenSquare);                  case ']': return NewToken(TokenType.CloseSquare);                  case '(': return NewToken(TokenType.OpenParen);                  case ')': return NewToken(TokenType.CloseParen);                  case ''': return NewToken(TokenType.Comma);                  case ':':                      ch = PeekChar();                      if (ch == ':') {                          NextChar();                          return NewToken(TokenType.ColonColon);                      }                      return NewToken(TokenType.Colon);                    case ';': return NewToken(TokenType.Semicolon);                  case '~': return NewToken(TokenType.Tilde);                    case '?':                      ch = PeekChar();                      if (ch == '?') {                          NextChar();                          return NewToken(TokenType.Coalesce);                      }                      return NewToken(TokenType.Question);                    case '+':                      ch = PeekChar();                      if (ch == '+') {                          NextChar();                          return NewToken(TokenType.PlusPlus);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.PlusEqual);                      }                      return NewToken(TokenType.Plus);                    case '-':                      ch = PeekChar();                      if (ch == '-') {                          NextChar();                          return NewToken(TokenType.MinusMinus);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.MinusEqual);                      }                      else if (ch == '>') {                          NextChar();                          return NewToken(TokenType.Arrow);                      }                      return NewToken(TokenType.Minus);                    case '*':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.StarEqual);                      }                      return NewToken(TokenType.Star);                    case '/':                      ch = PeekChar();                      if (ch == '=') {                          NextChar();                          return NewToken(TokenType.SlashEqual);                      }                      else if (ch == '/') {                          NextChar();                            CommentTokenType commentType;                          if (!EOF && PeekChar() == '/') {                              commentType = CommentTokenType.TripleSlash;                              NextChar();                          }                          else {                              commentType = CommentTokenType.DoubleSlash;                          }                            _value.Length = 0;                          while (!EOF && !IsLineSeparator(PeekChar())) {                              _value.Append(NextChar());                          }                            if (_includeComments) {                              return new CommentToken(commentType' _value.ToString()' _path' TakePosition());                          }                          else {                              TakePosition();                              return NextToken();                          }                      }                      else if (ch == '*') {                          NextChar();                            _value.Length = 0;                          while (!EOF && (PeekChar() != '*' || PeekChar(1) != '/')) {                              _value.Append(NextChar());                          }                          if (EOF) {                              ReportError(LexError.UnexpectedEndOfFileStarSlash);                              return ErrorToken();                          }                            NextChar();                          NextChar();                            _lastLine = _text.Line;                            if (_includeComments) {                              return new CommentToken(CommentTokenType.SlashStar' _value.ToString()' _path' TakePosition());                          }                          else {                              TakePosition();                              return NextToken();                          }                      }                        return NewToken(TokenType.Slash);                    case '%':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.PercentEqual);                      }                      return NewToken(TokenType.Percent);                    case '&':                      ch = PeekChar();                      if (ch == '&') {                          NextChar();                          return NewToken(TokenType.LogAnd);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.AndEqual);                      }                      return NewToken(TokenType.Ampersand);                    case '|':                      ch = PeekChar();                      if (ch == '|') {                          NextChar();                          return NewToken(TokenType.LogOr);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.BarEqual);                      }                      return NewToken(TokenType.Bar);                    case '^':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.HatEqual);                      }                      return NewToken(TokenType.Hat);                    case '!':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.NotEqual);                      }                      return NewToken(TokenType.Bang);                    case '=':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.EqualEqual);                      }                      return NewToken(TokenType.Equal);                    case '<':                      ch = PeekChar();                      if (ch == '=') {                          NextChar();                          return NewToken(TokenType.LessEqual);                      }                      else if (ch == '<') {                          NextChar();                          if (PeekChar() == '=') {                              NextChar();                              return NewToken(TokenType.ShiftLeftEqual);                          }                          return NewToken(TokenType.ShiftLeft);                      }                      return NewToken(TokenType.Less);                    case '>':                      ch = PeekChar();                      if (ch == '=') {                          NextChar();                          return NewToken(TokenType.GreaterEqual);                      }                      return NewToken(TokenType.Greater);                    // literals                  case '\'':                      // char literal                      {                          char ch2;                          if (ScanCharValue('\''' false' out ch' out ch2)) {                              if (PeekChar() != '\'') {                                  ReportError(LexError.BadCharConstant);                              }                              else {                                  NextChar();                              }                              return new CharToken(ch' _path' TakePosition());                          }                          else {                              return ErrorToken();                          }                      }                    case '"':                      // string literal                      {                          char ch2;                          _value.Length = 0;                          while (!EOF && ScanCharValue('"'' true' out ch' out ch2)) {                              _value.Append(ch);                              if (ch2 != 0)                                  _value.Append(ch2);                          }                          if (EOF) {                              ReportError(LexError.UnexpectedEndOfFileString);                              return ErrorToken();                          }                          return new StringToken(_value.ToString()' _path' TakePosition());                      }                    case '@':                      ch = PeekChar();                      if (ch == '"') {                          // verbatim string literal                          NextChar();                          _value.Length = 0;                          while (!EOF && (PeekChar() != '"' || PeekChar(1) == '"')) {                              // this is the one place where a CR/LF pair is significant                              bool wasCRLF;                              ch = NextChar(out wasCRLF);                              _value.Append(ch);                              if (wasCRLF) {                                  _value.Append('\xA');                              }                              else if (ch == '"') {                                  NextChar();                              }                          }                          if (EOF) {                              ReportError(LexError.UnexpectedEndOfFileString);                              return ErrorToken();                          }                          NextChar();                          return new StringToken(_value.ToString()' _path' TakePosition());                      }                      atIdentifier = true;                      goto default;                    case '0':                      if (PeekChar() == 'x' || PeekChar() == 'X') {                          NextChar();                            // hexadecimal constant                          ulong value = 0;                          while (IsHexDigit(PeekChar())) {                              if ((value & 0xF000000000000000) != 0) {                                  ReportError(LexError.NumericConstantOverflow);                                  return ErrorToken();                              }                              value = (value << 4) | (uint)HexValue(NextChar());                          }                            return CreateIntegerConstant(value' ScanIntegerSuffixOpt());                      }                      goto case '1';                    case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  DoNumber: {                          bool foundDecimalPoint = (ch == '.');                          bool foundExponent = false;                          NumericSuffix suffix = NumericSuffix.None;                            _value.Length = 0;                          _value.Append(ch);                          while (true) {                              ch = PeekChar();                              if (ch == '.') {                                  if (foundDecimalPoint || !IsDigit(PeekChar(1))) {                                      break;                                  }                                  foundDecimalPoint = true;                              }                              else if (ch == 'e' || ch == 'E') {                                  char nextChar = PeekChar(1);                                  if (IsDigit(nextChar) || ((nextChar == '+' || nextChar == '-') && IsDigit(PeekChar(2)))) {                                      foundExponent = true;                                        _value.Append(NextChar());                                      _value.Append(NextChar());                                      while (IsDigit(PeekChar())) {                                          _value.Append(NextChar());                                      }                                  }                                  break;                              }                              else if (!IsDigit(ch)) {                                  break;                              }                              _value.Append(NextChar());                          }                            if (!foundDecimalPoint && !foundExponent) {                              suffix = ScanIntegerSuffixOpt();                          }                            if (suffix == NumericSuffix.None) {                              suffix = ScanRealSuffixOpt();                          }                            if (suffix < NumericSuffix.F && !foundDecimalPoint && !foundExponent) {                              // decimal integer constant                              ulong numericValue = 0;                              foreach (char digit in _value.ToString().ToCharArray()) {                                  ulong value10 = numericValue * 10;                                  if (value10 < numericValue) {                                      ReportError(LexError.NumericConstantOverflow);                                      return ErrorToken();                                  }                                  numericValue = value10 + (uint)(digit - '0');                              }                                return CreateIntegerConstant(numericValue' suffix);                          }                          else {                              try {                                  // real constant                                  switch (suffix) {                                      case NumericSuffix.F: {                                              float f = float.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new FloatToken(f' _path' TakePosition());                                          }                                        case NumericSuffix.D:                                      case NumericSuffix.None: {                                              double d = double.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new DoubleToken(d' _path' TakePosition());                                          }                                        case NumericSuffix.M: {                                              decimal dec = decimal.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new DecimalToken(dec' _path' TakePosition());                                          }                                  }                              }                              catch (Exception) {                                  // catch overflow exceptions from the numeric parse                              }                              ReportError(LexError.NumericConstantOverflow);                              return ErrorToken();                          }                      }                    case '.':                      if (IsDigit(PeekChar())) {                          goto DoNumber;                      }                      return NewToken(TokenType.Dot);                    default: {                          _value.Length = 0;                          if (!IsIdentifierChar(ch)) {                              ReportError(LexError.UnexpectedCharacter' ch.ToString());                              return ErrorToken();                          }                          _value.Append(ch);                            while (ScanIdentifierChar(out ch)) {                              _value.Append(ch);                          }                            Debug.Assert(_value.Length > 0);                            if (_value.Length > IdentifierToken.MaxIdentifierLength) {                              ReportError(LexError.IdentifierTooLong);                              return ErrorToken();                          }                            Name name = _nameTable.Add(_value);                          if (!atIdentifier) {                              // check for keywords                              TokenType keyword = _keywords.IsKeyword(name);                              if (Token.IsKeyword(keyword)) {                                  return new Token(keyword' _path' TakePosition());                              }                          }                            return new IdentifierToken(name' atIdentifier' _path' TakePosition());                      }              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,NextToken,The following statement contains a magic number: switch (ch) {                  case '\0':                      Debug.Fail("Checked for EOF above");                      return null;                    case '#':                      if (_text.Line == _lastLine) {                          ReportError(LexError.UnexpectedCharacter' ch.ToString());                          return ErrorToken();                      }                      else {                          ClearPosition();                          _text.Reverse();                          return null;                      }                    // operators                  case '{': return NewToken(TokenType.OpenCurly);                  case '}': return NewToken(TokenType.CloseCurly);                  case '[': return NewToken(TokenType.OpenSquare);                  case ']': return NewToken(TokenType.CloseSquare);                  case '(': return NewToken(TokenType.OpenParen);                  case ')': return NewToken(TokenType.CloseParen);                  case ''': return NewToken(TokenType.Comma);                  case ':':                      ch = PeekChar();                      if (ch == ':') {                          NextChar();                          return NewToken(TokenType.ColonColon);                      }                      return NewToken(TokenType.Colon);                    case ';': return NewToken(TokenType.Semicolon);                  case '~': return NewToken(TokenType.Tilde);                    case '?':                      ch = PeekChar();                      if (ch == '?') {                          NextChar();                          return NewToken(TokenType.Coalesce);                      }                      return NewToken(TokenType.Question);                    case '+':                      ch = PeekChar();                      if (ch == '+') {                          NextChar();                          return NewToken(TokenType.PlusPlus);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.PlusEqual);                      }                      return NewToken(TokenType.Plus);                    case '-':                      ch = PeekChar();                      if (ch == '-') {                          NextChar();                          return NewToken(TokenType.MinusMinus);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.MinusEqual);                      }                      else if (ch == '>') {                          NextChar();                          return NewToken(TokenType.Arrow);                      }                      return NewToken(TokenType.Minus);                    case '*':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.StarEqual);                      }                      return NewToken(TokenType.Star);                    case '/':                      ch = PeekChar();                      if (ch == '=') {                          NextChar();                          return NewToken(TokenType.SlashEqual);                      }                      else if (ch == '/') {                          NextChar();                            CommentTokenType commentType;                          if (!EOF && PeekChar() == '/') {                              commentType = CommentTokenType.TripleSlash;                              NextChar();                          }                          else {                              commentType = CommentTokenType.DoubleSlash;                          }                            _value.Length = 0;                          while (!EOF && !IsLineSeparator(PeekChar())) {                              _value.Append(NextChar());                          }                            if (_includeComments) {                              return new CommentToken(commentType' _value.ToString()' _path' TakePosition());                          }                          else {                              TakePosition();                              return NextToken();                          }                      }                      else if (ch == '*') {                          NextChar();                            _value.Length = 0;                          while (!EOF && (PeekChar() != '*' || PeekChar(1) != '/')) {                              _value.Append(NextChar());                          }                          if (EOF) {                              ReportError(LexError.UnexpectedEndOfFileStarSlash);                              return ErrorToken();                          }                            NextChar();                          NextChar();                            _lastLine = _text.Line;                            if (_includeComments) {                              return new CommentToken(CommentTokenType.SlashStar' _value.ToString()' _path' TakePosition());                          }                          else {                              TakePosition();                              return NextToken();                          }                      }                        return NewToken(TokenType.Slash);                    case '%':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.PercentEqual);                      }                      return NewToken(TokenType.Percent);                    case '&':                      ch = PeekChar();                      if (ch == '&') {                          NextChar();                          return NewToken(TokenType.LogAnd);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.AndEqual);                      }                      return NewToken(TokenType.Ampersand);                    case '|':                      ch = PeekChar();                      if (ch == '|') {                          NextChar();                          return NewToken(TokenType.LogOr);                      }                      else if (ch == '=') {                          NextChar();                          return NewToken(TokenType.BarEqual);                      }                      return NewToken(TokenType.Bar);                    case '^':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.HatEqual);                      }                      return NewToken(TokenType.Hat);                    case '!':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.NotEqual);                      }                      return NewToken(TokenType.Bang);                    case '=':                      if (PeekChar() == '=') {                          NextChar();                          return NewToken(TokenType.EqualEqual);                      }                      return NewToken(TokenType.Equal);                    case '<':                      ch = PeekChar();                      if (ch == '=') {                          NextChar();                          return NewToken(TokenType.LessEqual);                      }                      else if (ch == '<') {                          NextChar();                          if (PeekChar() == '=') {                              NextChar();                              return NewToken(TokenType.ShiftLeftEqual);                          }                          return NewToken(TokenType.ShiftLeft);                      }                      return NewToken(TokenType.Less);                    case '>':                      ch = PeekChar();                      if (ch == '=') {                          NextChar();                          return NewToken(TokenType.GreaterEqual);                      }                      return NewToken(TokenType.Greater);                    // literals                  case '\'':                      // char literal                      {                          char ch2;                          if (ScanCharValue('\''' false' out ch' out ch2)) {                              if (PeekChar() != '\'') {                                  ReportError(LexError.BadCharConstant);                              }                              else {                                  NextChar();                              }                              return new CharToken(ch' _path' TakePosition());                          }                          else {                              return ErrorToken();                          }                      }                    case '"':                      // string literal                      {                          char ch2;                          _value.Length = 0;                          while (!EOF && ScanCharValue('"'' true' out ch' out ch2)) {                              _value.Append(ch);                              if (ch2 != 0)                                  _value.Append(ch2);                          }                          if (EOF) {                              ReportError(LexError.UnexpectedEndOfFileString);                              return ErrorToken();                          }                          return new StringToken(_value.ToString()' _path' TakePosition());                      }                    case '@':                      ch = PeekChar();                      if (ch == '"') {                          // verbatim string literal                          NextChar();                          _value.Length = 0;                          while (!EOF && (PeekChar() != '"' || PeekChar(1) == '"')) {                              // this is the one place where a CR/LF pair is significant                              bool wasCRLF;                              ch = NextChar(out wasCRLF);                              _value.Append(ch);                              if (wasCRLF) {                                  _value.Append('\xA');                              }                              else if (ch == '"') {                                  NextChar();                              }                          }                          if (EOF) {                              ReportError(LexError.UnexpectedEndOfFileString);                              return ErrorToken();                          }                          NextChar();                          return new StringToken(_value.ToString()' _path' TakePosition());                      }                      atIdentifier = true;                      goto default;                    case '0':                      if (PeekChar() == 'x' || PeekChar() == 'X') {                          NextChar();                            // hexadecimal constant                          ulong value = 0;                          while (IsHexDigit(PeekChar())) {                              if ((value & 0xF000000000000000) != 0) {                                  ReportError(LexError.NumericConstantOverflow);                                  return ErrorToken();                              }                              value = (value << 4) | (uint)HexValue(NextChar());                          }                            return CreateIntegerConstant(value' ScanIntegerSuffixOpt());                      }                      goto case '1';                    case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  DoNumber: {                          bool foundDecimalPoint = (ch == '.');                          bool foundExponent = false;                          NumericSuffix suffix = NumericSuffix.None;                            _value.Length = 0;                          _value.Append(ch);                          while (true) {                              ch = PeekChar();                              if (ch == '.') {                                  if (foundDecimalPoint || !IsDigit(PeekChar(1))) {                                      break;                                  }                                  foundDecimalPoint = true;                              }                              else if (ch == 'e' || ch == 'E') {                                  char nextChar = PeekChar(1);                                  if (IsDigit(nextChar) || ((nextChar == '+' || nextChar == '-') && IsDigit(PeekChar(2)))) {                                      foundExponent = true;                                        _value.Append(NextChar());                                      _value.Append(NextChar());                                      while (IsDigit(PeekChar())) {                                          _value.Append(NextChar());                                      }                                  }                                  break;                              }                              else if (!IsDigit(ch)) {                                  break;                              }                              _value.Append(NextChar());                          }                            if (!foundDecimalPoint && !foundExponent) {                              suffix = ScanIntegerSuffixOpt();                          }                            if (suffix == NumericSuffix.None) {                              suffix = ScanRealSuffixOpt();                          }                            if (suffix < NumericSuffix.F && !foundDecimalPoint && !foundExponent) {                              // decimal integer constant                              ulong numericValue = 0;                              foreach (char digit in _value.ToString().ToCharArray()) {                                  ulong value10 = numericValue * 10;                                  if (value10 < numericValue) {                                      ReportError(LexError.NumericConstantOverflow);                                      return ErrorToken();                                  }                                  numericValue = value10 + (uint)(digit - '0');                              }                                return CreateIntegerConstant(numericValue' suffix);                          }                          else {                              try {                                  // real constant                                  switch (suffix) {                                      case NumericSuffix.F: {                                              float f = float.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new FloatToken(f' _path' TakePosition());                                          }                                        case NumericSuffix.D:                                      case NumericSuffix.None: {                                              double d = double.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new DoubleToken(d' _path' TakePosition());                                          }                                        case NumericSuffix.M: {                                              decimal dec = decimal.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new DecimalToken(dec' _path' TakePosition());                                          }                                  }                              }                              catch (Exception) {                                  // catch overflow exceptions from the numeric parse                              }                              ReportError(LexError.NumericConstantOverflow);                              return ErrorToken();                          }                      }                    case '.':                      if (IsDigit(PeekChar())) {                          goto DoNumber;                      }                      return NewToken(TokenType.Dot);                    default: {                          _value.Length = 0;                          if (!IsIdentifierChar(ch)) {                              ReportError(LexError.UnexpectedCharacter' ch.ToString());                              return ErrorToken();                          }                          _value.Append(ch);                            while (ScanIdentifierChar(out ch)) {                              _value.Append(ch);                          }                            Debug.Assert(_value.Length > 0);                            if (_value.Length > IdentifierToken.MaxIdentifierLength) {                              ReportError(LexError.IdentifierTooLong);                              return ErrorToken();                          }                            Name name = _nameTable.Add(_value);                          if (!atIdentifier) {                              // check for keywords                              TokenType keyword = _keywords.IsKeyword(name);                              if (Token.IsKeyword(keyword)) {                                  return new Token(keyword' _path' TakePosition());                              }                          }                            return new IdentifierToken(name' atIdentifier' _path' TakePosition());                      }              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,ScanIdentifierChar,The following statement contains a magic number: if (IsIdentifierChar(value)) {                  ch = NextChar();                  return true;              }              else if (value == '\\' && PeekChar(1) == 'u') {                  // unicode esape                  NextChar();                  NextChar();                  value = '\0';                  int i = 0;                  while (i < 4 && IsHexDigit(PeekChar())) {                      value = (char)(value << 4 + HexValue(NextChar()));                      i += 1;                  }                  if (i != 4) {                      ReportError(LexError.BadEscapeSequence);                      return false;                  }                  ch = value;                  return true;              }              else {                  return false;              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,ScanIdentifierChar,The following statement contains a magic number: if (IsIdentifierChar(value)) {                  ch = NextChar();                  return true;              }              else if (value == '\\' && PeekChar(1) == 'u') {                  // unicode esape                  NextChar();                  NextChar();                  value = '\0';                  int i = 0;                  while (i < 4 && IsHexDigit(PeekChar())) {                      value = (char)(value << 4 + HexValue(NextChar()));                      i += 1;                  }                  if (i != 4) {                      ReportError(LexError.BadEscapeSequence);                      return false;                  }                  ch = value;                  return true;              }              else {                  return false;              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,ScanIdentifierChar,The following statement contains a magic number: if (IsIdentifierChar(value)) {                  ch = NextChar();                  return true;              }              else if (value == '\\' && PeekChar(1) == 'u') {                  // unicode esape                  NextChar();                  NextChar();                  value = '\0';                  int i = 0;                  while (i < 4 && IsHexDigit(PeekChar())) {                      value = (char)(value << 4 + HexValue(NextChar()));                      i += 1;                  }                  if (i != 4) {                      ReportError(LexError.BadEscapeSequence);                      return false;                  }                  ch = value;                  return true;              }              else {                  return false;              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,ScanCharValue,The following statement contains a magic number: if ('\\' == value) {                  NextChar();                  switch (PeekChar()) {                      case '\'': value = '\''; break;                      case '\"': value = '\"'; break;                      case '\\': value = '\\'; break;                      case '0': value = '\0'; break;                      case 'a': value = '\a'; break;                      case 'b': value = '\b'; break;                      case 'f': value = '\f'; break;                      case 'n': value = '\n'; break;                      case 'r': value = '\r'; break;                      case 't': value = '\t'; break;                      case 'v': value = '\v'; break;                      case 'x':                      case 'u': {                              // hex digits                              NextChar();                              value = '\0';                              int i = 0;                              while (i < 4 && IsHexDigit(PeekChar())) {                                    value = (char)((value << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i == 0 || (ch == 'u' && i != 4)) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              ch = value;                              return true;                          }                        case 'U': {                              // unicode surrogates                              NextChar();                              uint surrogateValue = 0;                              int i = 0;                              while (i < 8 && IsHexDigit(PeekChar())) {                                    surrogateValue = (char)((surrogateValue << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i != 8 || (!allowSurrogates && surrogateValue > 0xFFFF) || surrogateValue > 0x10FFFF) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              if (surrogateValue < 0x10000) {                                  ch = (char)surrogateValue;                                  return true;                              }                                ch = (char)((surrogateValue - 0x10000) / 0x400 + 0xD800);                              ch2 = (char)((surrogateValue - 0x10000) % 0x400 + 0xDC00);                                return true;                          }                        default:                          ReportError(LexError.BadEscapeSequence);                          return false;                  }                  NextChar();                  ch = value;                  return true;              }              else if (value == terminator) {                  NextChar();                  if (terminator == '\'') {                      ReportError(LexError.EmptyCharConstant);                  }                    return false;              }              else if (IsLineSeparator(value)) {                  ReportError(LexError.WhiteSpaceInConstant);                  return false;              }              else {                  NextChar();                  ch = value;                  return true;              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,ScanCharValue,The following statement contains a magic number: if ('\\' == value) {                  NextChar();                  switch (PeekChar()) {                      case '\'': value = '\''; break;                      case '\"': value = '\"'; break;                      case '\\': value = '\\'; break;                      case '0': value = '\0'; break;                      case 'a': value = '\a'; break;                      case 'b': value = '\b'; break;                      case 'f': value = '\f'; break;                      case 'n': value = '\n'; break;                      case 'r': value = '\r'; break;                      case 't': value = '\t'; break;                      case 'v': value = '\v'; break;                      case 'x':                      case 'u': {                              // hex digits                              NextChar();                              value = '\0';                              int i = 0;                              while (i < 4 && IsHexDigit(PeekChar())) {                                    value = (char)((value << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i == 0 || (ch == 'u' && i != 4)) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              ch = value;                              return true;                          }                        case 'U': {                              // unicode surrogates                              NextChar();                              uint surrogateValue = 0;                              int i = 0;                              while (i < 8 && IsHexDigit(PeekChar())) {                                    surrogateValue = (char)((surrogateValue << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i != 8 || (!allowSurrogates && surrogateValue > 0xFFFF) || surrogateValue > 0x10FFFF) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              if (surrogateValue < 0x10000) {                                  ch = (char)surrogateValue;                                  return true;                              }                                ch = (char)((surrogateValue - 0x10000) / 0x400 + 0xD800);                              ch2 = (char)((surrogateValue - 0x10000) % 0x400 + 0xDC00);                                return true;                          }                        default:                          ReportError(LexError.BadEscapeSequence);                          return false;                  }                  NextChar();                  ch = value;                  return true;              }              else if (value == terminator) {                  NextChar();                  if (terminator == '\'') {                      ReportError(LexError.EmptyCharConstant);                  }                    return false;              }              else if (IsLineSeparator(value)) {                  ReportError(LexError.WhiteSpaceInConstant);                  return false;              }              else {                  NextChar();                  ch = value;                  return true;              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,ScanCharValue,The following statement contains a magic number: if ('\\' == value) {                  NextChar();                  switch (PeekChar()) {                      case '\'': value = '\''; break;                      case '\"': value = '\"'; break;                      case '\\': value = '\\'; break;                      case '0': value = '\0'; break;                      case 'a': value = '\a'; break;                      case 'b': value = '\b'; break;                      case 'f': value = '\f'; break;                      case 'n': value = '\n'; break;                      case 'r': value = '\r'; break;                      case 't': value = '\t'; break;                      case 'v': value = '\v'; break;                      case 'x':                      case 'u': {                              // hex digits                              NextChar();                              value = '\0';                              int i = 0;                              while (i < 4 && IsHexDigit(PeekChar())) {                                    value = (char)((value << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i == 0 || (ch == 'u' && i != 4)) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              ch = value;                              return true;                          }                        case 'U': {                              // unicode surrogates                              NextChar();                              uint surrogateValue = 0;                              int i = 0;                              while (i < 8 && IsHexDigit(PeekChar())) {                                    surrogateValue = (char)((surrogateValue << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i != 8 || (!allowSurrogates && surrogateValue > 0xFFFF) || surrogateValue > 0x10FFFF) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              if (surrogateValue < 0x10000) {                                  ch = (char)surrogateValue;                                  return true;                              }                                ch = (char)((surrogateValue - 0x10000) / 0x400 + 0xD800);                              ch2 = (char)((surrogateValue - 0x10000) % 0x400 + 0xDC00);                                return true;                          }                        default:                          ReportError(LexError.BadEscapeSequence);                          return false;                  }                  NextChar();                  ch = value;                  return true;              }              else if (value == terminator) {                  NextChar();                  if (terminator == '\'') {                      ReportError(LexError.EmptyCharConstant);                  }                    return false;              }              else if (IsLineSeparator(value)) {                  ReportError(LexError.WhiteSpaceInConstant);                  return false;              }              else {                  NextChar();                  ch = value;                  return true;              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,ScanCharValue,The following statement contains a magic number: if ('\\' == value) {                  NextChar();                  switch (PeekChar()) {                      case '\'': value = '\''; break;                      case '\"': value = '\"'; break;                      case '\\': value = '\\'; break;                      case '0': value = '\0'; break;                      case 'a': value = '\a'; break;                      case 'b': value = '\b'; break;                      case 'f': value = '\f'; break;                      case 'n': value = '\n'; break;                      case 'r': value = '\r'; break;                      case 't': value = '\t'; break;                      case 'v': value = '\v'; break;                      case 'x':                      case 'u': {                              // hex digits                              NextChar();                              value = '\0';                              int i = 0;                              while (i < 4 && IsHexDigit(PeekChar())) {                                    value = (char)((value << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i == 0 || (ch == 'u' && i != 4)) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              ch = value;                              return true;                          }                        case 'U': {                              // unicode surrogates                              NextChar();                              uint surrogateValue = 0;                              int i = 0;                              while (i < 8 && IsHexDigit(PeekChar())) {                                    surrogateValue = (char)((surrogateValue << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i != 8 || (!allowSurrogates && surrogateValue > 0xFFFF) || surrogateValue > 0x10FFFF) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              if (surrogateValue < 0x10000) {                                  ch = (char)surrogateValue;                                  return true;                              }                                ch = (char)((surrogateValue - 0x10000) / 0x400 + 0xD800);                              ch2 = (char)((surrogateValue - 0x10000) % 0x400 + 0xDC00);                                return true;                          }                        default:                          ReportError(LexError.BadEscapeSequence);                          return false;                  }                  NextChar();                  ch = value;                  return true;              }              else if (value == terminator) {                  NextChar();                  if (terminator == '\'') {                      ReportError(LexError.EmptyCharConstant);                  }                    return false;              }              else if (IsLineSeparator(value)) {                  ReportError(LexError.WhiteSpaceInConstant);                  return false;              }              else {                  NextChar();                  ch = value;                  return true;              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,ScanCharValue,The following statement contains a magic number: if ('\\' == value) {                  NextChar();                  switch (PeekChar()) {                      case '\'': value = '\''; break;                      case '\"': value = '\"'; break;                      case '\\': value = '\\'; break;                      case '0': value = '\0'; break;                      case 'a': value = '\a'; break;                      case 'b': value = '\b'; break;                      case 'f': value = '\f'; break;                      case 'n': value = '\n'; break;                      case 'r': value = '\r'; break;                      case 't': value = '\t'; break;                      case 'v': value = '\v'; break;                      case 'x':                      case 'u': {                              // hex digits                              NextChar();                              value = '\0';                              int i = 0;                              while (i < 4 && IsHexDigit(PeekChar())) {                                    value = (char)((value << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i == 0 || (ch == 'u' && i != 4)) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              ch = value;                              return true;                          }                        case 'U': {                              // unicode surrogates                              NextChar();                              uint surrogateValue = 0;                              int i = 0;                              while (i < 8 && IsHexDigit(PeekChar())) {                                    surrogateValue = (char)((surrogateValue << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i != 8 || (!allowSurrogates && surrogateValue > 0xFFFF) || surrogateValue > 0x10FFFF) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              if (surrogateValue < 0x10000) {                                  ch = (char)surrogateValue;                                  return true;                              }                                ch = (char)((surrogateValue - 0x10000) / 0x400 + 0xD800);                              ch2 = (char)((surrogateValue - 0x10000) % 0x400 + 0xDC00);                                return true;                          }                        default:                          ReportError(LexError.BadEscapeSequence);                          return false;                  }                  NextChar();                  ch = value;                  return true;              }              else if (value == terminator) {                  NextChar();                  if (terminator == '\'') {                      ReportError(LexError.EmptyCharConstant);                  }                    return false;              }              else if (IsLineSeparator(value)) {                  ReportError(LexError.WhiteSpaceInConstant);                  return false;              }              else {                  NextChar();                  ch = value;                  return true;              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,ScanCharValue,The following statement contains a magic number: if ('\\' == value) {                  NextChar();                  switch (PeekChar()) {                      case '\'': value = '\''; break;                      case '\"': value = '\"'; break;                      case '\\': value = '\\'; break;                      case '0': value = '\0'; break;                      case 'a': value = '\a'; break;                      case 'b': value = '\b'; break;                      case 'f': value = '\f'; break;                      case 'n': value = '\n'; break;                      case 'r': value = '\r'; break;                      case 't': value = '\t'; break;                      case 'v': value = '\v'; break;                      case 'x':                      case 'u': {                              // hex digits                              NextChar();                              value = '\0';                              int i = 0;                              while (i < 4 && IsHexDigit(PeekChar())) {                                    value = (char)((value << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i == 0 || (ch == 'u' && i != 4)) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              ch = value;                              return true;                          }                        case 'U': {                              // unicode surrogates                              NextChar();                              uint surrogateValue = 0;                              int i = 0;                              while (i < 8 && IsHexDigit(PeekChar())) {                                    surrogateValue = (char)((surrogateValue << 4) + HexValue(NextChar()));                                  i += 1;                              }                              if (i != 8 || (!allowSurrogates && surrogateValue > 0xFFFF) || surrogateValue > 0x10FFFF) {                                  ReportError(LexError.BadEscapeSequence);                                  return false;                              }                              if (surrogateValue < 0x10000) {                                  ch = (char)surrogateValue;                                  return true;                              }                                ch = (char)((surrogateValue - 0x10000) / 0x400 + 0xD800);                              ch2 = (char)((surrogateValue - 0x10000) % 0x400 + 0xDC00);                                return true;                          }                        default:                          ReportError(LexError.BadEscapeSequence);                          return false;                  }                  NextChar();                  ch = value;                  return true;              }              else if (value == terminator) {                  NextChar();                  if (terminator == '\'') {                      ReportError(LexError.EmptyCharConstant);                  }                    return false;              }              else if (IsLineSeparator(value)) {                  ReportError(LexError.WhiteSpaceInConstant);                  return false;              }              else {                  NextChar();                  ch = value;                  return true;              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,IsWhiteSpace,The following statement contains a magic number: switch (ch) {                  // line separators are whitespace                  case '\xD':                  case '\xA':                  case '\x2028':                  case '\x2029':                    // regular whitespace                  case '\f':                  case '\v':                  case ' ':                  case '\t':                      return true;                    // handle odd unicode whitespace                  default:                      return (ch > 127 && char.IsWhiteSpace(ch));              }
Magic Number,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,HexValue,The following statement contains a magic number: return IsDigit(ch) ? ch - '0' : (ch & 0xdf) - 'A' + 10;
Magic Number,ScriptSharp.Parser,LineMap,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\LineMap.cs,FindEntry,The following statement contains a magic number: while (lowIndex < highIndex) {                  int midIndex = (lowIndex + highIndex) / 2;                  MapEntry midEntry = (MapEntry)_entries[midIndex];                  if (midEntry.from < from) {                      lowIndex = midIndex + 1;                  }                  else if (midEntry.from == from) {                      return midEntry;                  }                  else {                      highIndex = midIndex;                  }              }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: while (index < length2) {                      hash += (uint)(value[index + 1] << 16) | value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                      index += 2;                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: while (index < length2) {                      hash += (uint)(value[index + 1] << 16) | value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                      index += 2;                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: while (index < length2) {                      hash += (uint)(value[index + 1] << 16) | value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                      index += 2;                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: while (index < length2) {                      hash += (uint)(value[index + 1] << 16) | value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                      index += 2;                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: if (index < length) {                      hash += value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: if (index < length) {                      hash += value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: hash += (hash << 3);
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: hash ^= (hash >> 11);
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: hash += (hash << 15);
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: while (index < length2) {                      hash += (uint)(value[index + 1] << 16) | value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                      index += 2;                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: while (index < length2) {                      hash += (uint)(value[index + 1] << 16) | value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                      index += 2;                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: while (index < length2) {                      hash += (uint)(value[index + 1] << 16) | value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                      index += 2;                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: while (index < length2) {                      hash += (uint)(value[index + 1] << 16) | value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                      index += 2;                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: if (index < length) {                      hash += value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: if (index < length) {                      hash += value[index];                      hash += (hash << 10);                      hash ^= (hash >> 6);                  }
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: hash += (hash << 3);
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: hash ^= (hash >> 11);
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,Hash,The following statement contains a magic number: hash += (hash << 15);
Magic Number,ScriptSharp.Parser,NameHasher,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\NameTable.cs,HashUInt,The following statement contains a magic number: return (uint)l + (uint)(l >> 32);
Magic Number,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseGlobalAttributes,The following statement contains a magic number: while (PeekType() == TokenType.OpenSquare &&                     PeekType(1) == TokenType.Identifier &&                     PeekType(2) == TokenType.Colon &&                     (((IdentifierToken)PeekToken(1)).Symbol == assemblyName ||                      ((IdentifierToken)PeekToken(1)).Symbol == moduleName)) {                  list.Append(ParseAttributeBlock());              }
Magic Number,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseOperator,The following statement contains a magic number: switch (tree.operatorTokenType) {                  // unary or binary operators                  case TokenType.Plus:                  case TokenType.Minus:                      if (tree.Parameters.Count != 1 && tree.Parameters.Count != 2) {                          ReportError(ParseError.WrongNumberOfArgsToOperator' tree.token);                      }                      break;                    // unary operators                  case TokenType.Bang:                  case TokenType.Tilde:                  case TokenType.PlusPlus:                  case TokenType.MinusMinus:                  case TokenType.True:                  case TokenType.False:                      if (tree.Parameters.Count != 1) {                          ReportError(ParseError.WrongNumberOfArgsToUnaryOperator' tree.token);                      }                      break;                    // binary operators                  case TokenType.Star:                  case TokenType.Slash:                  case TokenType.Percent:                  case TokenType.Ampersand:                  case TokenType.Bar:                  case TokenType.Hat:                  case TokenType.ShiftLeft:                  case TokenType.ShiftRight:                  case TokenType.EqualEqual:                  case TokenType.NotEqual:                  case TokenType.Greater:                  case TokenType.GreaterEqual:                  case TokenType.Less:                  case TokenType.LessEqual:                      if (tree.Parameters.Count != 2) {                          ReportError(ParseError.WrongNumberOfArgsToBinnaryOperator' tree.token);                      }                      break;                    default:                      break;              }
Magic Number,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseOperator,The following statement contains a magic number: switch (tree.operatorTokenType) {                  // unary or binary operators                  case TokenType.Plus:                  case TokenType.Minus:                      if (tree.Parameters.Count != 1 && tree.Parameters.Count != 2) {                          ReportError(ParseError.WrongNumberOfArgsToOperator' tree.token);                      }                      break;                    // unary operators                  case TokenType.Bang:                  case TokenType.Tilde:                  case TokenType.PlusPlus:                  case TokenType.MinusMinus:                  case TokenType.True:                  case TokenType.False:                      if (tree.Parameters.Count != 1) {                          ReportError(ParseError.WrongNumberOfArgsToUnaryOperator' tree.token);                      }                      break;                    // binary operators                  case TokenType.Star:                  case TokenType.Slash:                  case TokenType.Percent:                  case TokenType.Ampersand:                  case TokenType.Bar:                  case TokenType.Hat:                  case TokenType.ShiftLeft:                  case TokenType.ShiftRight:                  case TokenType.EqualEqual:                  case TokenType.NotEqual:                  case TokenType.Greater:                  case TokenType.GreaterEqual:                  case TokenType.Less:                  case TokenType.LessEqual:                      if (tree.Parameters.Count != 2) {                          ReportError(ParseError.WrongNumberOfArgsToBinnaryOperator' tree.token);                      }                      break;                    default:                      break;              }
Magic Number,ScriptSharp.Parser,PreprocessorLexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\PreprocessorLexer.cs,NextToken,The following statement contains a magic number: switch (ch) {                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9': {                          int intValue = (ch - '0');                          while (IsDigit(PeekChar())) {                              int value10 = intValue * 10;                              if (value10 < intValue) {                                  ReportError(LexError.NumericConstantOverflow);                              }                              else {                                  intValue = value10 + (NextChar() - '0');                              }                          }                            return new PreprocessorIntToken(intValue' position);                      }                    case '=':                      if (PeekChar() == '=') {                          NextChar();                          return NewPPToken(PreprocessorTokenType.EqualEqual' position);                      }                      break;                    case '!':                      if (PeekChar() == '=') {                          NextChar();                          return NewPPToken(PreprocessorTokenType.NotEqual' position);                      }                      else {                          return NewPPToken(PreprocessorTokenType.Not' position);                      }                    case '&':                      if (PeekChar() == '&') {                          NextChar();                          return NewPPToken(PreprocessorTokenType.And' position);                      }                      break;                    case '|':                      if (PeekChar() == '|') {                          NextChar();                          return NewPPToken(PreprocessorTokenType.Or' position);                      }                      break;                    case '(':                      return NewPPToken(PreprocessorTokenType.OpenParen' position);                    case ')':                      return NewPPToken(PreprocessorTokenType.CloseParen' position);                    case '"':                      _value.Length = 0;                      while ((ch = PeekChar()) != '"') {                          if (EOF) {                              ReportError(LexError.UnexpectedEndOfFileString);                              break;                          }                          else if (IsLineSeparator(ch)) {                              ReportError(LexError.WhiteSpaceInConstant);                              break;                          }                          _value.Append(ch);                          NextChar();                      }                      NextChar();                      return new PreprocessorStringToken(_value.ToString()' position);                    case '/':                      if (PeekChar() == '/') {                          IgnoreRestOfLine();                          return NewPPToken(PreprocessorTokenType.EndOfLine' position);                      }                      break;                    default:                      if (IsLineSeparator(ch)) {                          return NewPPToken(PreprocessorTokenType.EndOfLine' position);                      }                        if (!IsIdentifierChar(ch)) {                          break;                      }                        _value.Length = 0;                      _value.Append(ch);                      while (IsIdentifierChar(PeekChar())) {                          _value.Append(NextChar());                      }                      Name id = _nameTable.Add(_value);                      PreprocessorTokenType type = _keywords.IsKeyword(id);                      if (type != PreprocessorTokenType.Invalid) {                          return NewPPToken(type' position);                      }                      else {                          return new PreprocessorIdentifierToken(id' position);                      }              }
Magic Number,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildEvent,The following statement contains a magic number: if (handlerType != null) {                  EventSymbol eventSymbol = new EventSymbol(eventNode.Name' typeSymbol' handlerType);                  BuildMemberDetails(eventSymbol' typeSymbol' eventNode' eventNode.Attributes);                    if (eventNode.IsField) {                      eventSymbol.SetImplementationState(SymbolImplementationFlags.Generated);                  }                  else {                      if ((eventNode.Modifiers & Modifiers.Abstract) != 0) {                          eventSymbol.SetImplementationState(SymbolImplementationFlags.Abstract);                      }                      else if ((eventNode.Modifiers & Modifiers.Override) != 0) {                          eventSymbol.SetImplementationState(SymbolImplementationFlags.Override);                      }                  }                    if (typeSymbol.IsApplicationType == false) {                      AttributeNode eventAttribute = AttributeNode.FindAttribute(eventNode.Attributes' "ScriptEvent");                      if ((eventAttribute != null) && (eventAttribute.Arguments != null) && (eventAttribute.Arguments.Count == 2)) {                          string addAccessor = (string)((LiteralNode)eventAttribute.Arguments[0]).Value;                          string removeAccessor = (string)((LiteralNode)eventAttribute.Arguments[1]).Value;                            eventSymbol.SetAccessors(addAccessor' removeAccessor);                      }                  }                    return eventSymbol;              }
Magic Number,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildMetadata,The following statement contains a magic number: foreach (CompilationUnitNode compilationUnit in compilationUnits) {                  foreach (NamespaceNode namespaceNode in compilationUnit.Members) {                      string namespaceName = namespaceNode.Name;                        NamespaceSymbol namespaceSymbol = symbols.GetNamespace(namespaceName);                        List<string> imports = null;                      Dictionary<string' string> aliases = null;                        ParseNodeList usingClauses = namespaceNode.UsingClauses;                      if ((usingClauses != null) && (usingClauses.Count != 0)) {                          foreach (ParseNode usingNode in namespaceNode.UsingClauses) {                              if (usingNode is UsingNamespaceNode) {                                  if (imports == null) {                                      imports = new List<string>(usingClauses.Count);                                  }                                    string referencedNamespace = ((UsingNamespaceNode)usingNode).ReferencedNamespace;                                  if (imports.Contains(referencedNamespace) == false) {                                      imports.Add(referencedNamespace);                                  }                              }                              else {                                  Debug.Assert(usingNode is UsingAliasNode);                                  if (aliases == null) {                                      aliases = new Dictionary<string' string>();                                  }                                  UsingAliasNode aliasNode = (UsingAliasNode)usingNode;                                  aliases[aliasNode.Alias] = aliasNode.TypeName;                              }                          }                      }                        // Add parent namespaces as imports in reverse order since they                      // are searched in that fashion.                      string[] namespaceParts = namespaceName.Split('.');                      for (int i = namespaceParts.Length - 2; i >= 0; i--) {                          string partialNamespace;                          if (i == 0) {                              partialNamespace = namespaceParts[0];                          }                          else {                              partialNamespace = String.Join("."' namespaceParts' 0' i + 1);                          }                            if (imports == null) {                              imports = new List<string>();                          }                            if (imports.Contains(partialNamespace) == false) {                              imports.Add(partialNamespace);                          }                      }                        // Build type symbols for all user-defined types                      foreach (TypeNode typeNode in namespaceNode.Members) {                          UserTypeNode userTypeNode = typeNode as UserTypeNode;                          if (userTypeNode == null) {                              continue;                          }                            ClassSymbol partialTypeSymbol = null;                          bool isPartial = false;                            if ((userTypeNode.Modifiers & Modifiers.Partial) != 0) {                              partialTypeSymbol = (ClassSymbol)((ISymbolTable)namespaceSymbol).FindSymbol(userTypeNode.Name' /* context */ null' SymbolFilter.Types);                              if ((partialTypeSymbol != null) && partialTypeSymbol.IsApplicationType) {                                  // This class will be considered as a partial class                                  isPartial = true;                                    // Merge code model information for the partial class onto the code model node                                  // for the primary partial class. Interesting bits of information include things                                  // such as base class etc. that is yet to be processed.                                  CustomTypeNode partialTypeNode = (CustomTypeNode)partialTypeSymbol.ParseContext;                                  partialTypeNode.MergePartialType((CustomTypeNode)userTypeNode);                                    // Merge interesting bits of information onto the primary type symbol as well                                  // representing this partial class                                  BuildType(partialTypeSymbol' userTypeNode);                              }                          }                            TypeSymbol typeSymbol = BuildType(userTypeNode' namespaceSymbol);                          if (typeSymbol != null) {                              typeSymbol.SetParseContext(userTypeNode);                              typeSymbol.SetParentSymbolTable(symbols);                              if (imports != null) {                                  typeSymbol.SetImports(imports);                              }                              if (aliases != null) {                                  typeSymbol.SetAliases(aliases);                              }                                if (isPartial == false) {                                  namespaceSymbol.AddType(typeSymbol);                              }                              else {                                  // Partial types don't get added to the namespace' so we don't have                                  // duplicated named items. However' they still do get instantiated                                  // and processed as usual.                                  //                                  // The members within partial classes refer to the partial type as their parent'                                  // and hence derive context such as the list of imports scoped to the                                  // particular type.                                  // However' the members will get added to the primary partial type's list of                                  // members so they can be found.                                  // Effectively the partial class here gets created just to hold                                  // context of type-symbol level bits of information such as the list of                                  // imports' that are consumed when generating code for the members defined                                  // within a specific partial class.                                  ((ClassSymbol)typeSymbol).SetPrimaryPartialClass(partialTypeSymbol);                              }                                types.Add(typeSymbol);                          }                      }                  }              }
Magic Number,ScriptSharp.Compiler,StatementBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\StatementBuilder.cs,ProcessTryCatchFinallyStatement,The following statement contains a magic number: Debug.Assert(node.CatchClauses.Count < 2);
Magic Number,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessBinaryExpressionNode,The following statement contains a magic number: if (operatorType != Operator.Invalid) {                  if ((operatorType == Operator.BitwiseAnd) ||                      (operatorType == Operator.BitwiseAndEquals) ||                      (operatorType == Operator.BitwiseOr) ||                      (operatorType == Operator.BitwiseOrEquals) ||                      (operatorType == Operator.BitwiseXor) ||                      (operatorType == Operator.BitwiseXorEquals)) {                      TypeSymbol leftExpressionType = leftExpression.EvaluatedType;                        if (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.Boolean)) {                          // For bitwise operators involving boolean expressions' we perform                          // a type coercion due to behavioral differences between C# and JavaScript.                          // Example:                          //     var result = true & true;                          //     actual: result === 1                          //     expected: result === true                          Operator baseOperatorType = operatorType;                            switch (operatorType) {                              case Operator.BitwiseAndEquals:                                  baseOperatorType = Operator.BitwiseAnd;                                  break;                              case Operator.BitwiseOrEquals:                                  baseOperatorType = Operator.BitwiseOr;                                  break;                              case Operator.BitwiseXorEquals:                                  baseOperatorType = Operator.BitwiseXor;                                  break;                          }                            // Map "x op y" to "(x op y) === 1"                          // Map "x op= y" to "x = (x op y) === 1"                          Expression bitwiseExpression =                              new BinaryExpression(baseOperatorType' leftExpression' rightExpression);                          bitwiseExpression.AddParenthesisHint();                            Expression coerceExpression =                              new BinaryExpression(Operator.EqualEqualEqual' bitwiseExpression'                                  new LiteralExpression(_symbolSet.ResolveIntrinsicType(IntrinsicType.Integer)' 1));                            if (operatorType == baseOperatorType) {                              return coerceExpression;                          }                          else {                              // Since y above can be a complex expression' add parentheses around it to ensure                              // proper operator precedence.                              rightExpression.AddParenthesisHint();                                return new BinaryExpression(Operator.Equals' TransformGetPropertyExpression(leftExpression)' coerceExpression);                          }                      }                  }                    if ((operatorType == Operator.EqualEqualEqual) ||                      (operatorType == Operator.NotEqualEqual)) {                      LiteralExpression literalExpression = rightExpression as LiteralExpression;                      if (literalExpression != null) {                          // Comparisons with null are mapped to the less-strict comparison operator                          // to handle undefined as well.                          if (literalExpression.Value == null) {                              if (operatorType == Operator.EqualEqualEqual) {                                  return new BinaryExpression(Operator.EqualEqual' leftExpression' rightExpression' resultType);                              }                              else {                                  return new BinaryExpression(Operator.NotEqual' leftExpression' rightExpression' resultType);                              }                          }                      }                        if ((leftExpression.EvaluatedType == rightExpression.EvaluatedType) &&                          (leftExpression.EvaluatedType == _symbolSet.ResolveIntrinsicType(IntrinsicType.Date))) {                          // Map equality comparison between Date objects to a call to                          // Script.CompareDates                            TypeSymbol scriptType = _symbolSet.ResolveIntrinsicType(IntrinsicType.Script);                          Debug.Assert(scriptType != null);                            MethodSymbol compareMethod = (MethodSymbol)scriptType.GetMember("CompareDates");                          Debug.Assert(compareMethod != null);                            MethodExpression compareExpression =                              new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                   compareMethod);                          compareExpression.AddParameterValue(leftExpression);                          compareExpression.AddParameterValue(rightExpression);                            if (operatorType == Operator.NotEqualEqual) {                              return new UnaryExpression(Operator.LogicalNot' compareExpression);                          }                          return compareExpression;                      }                  }                    if ((operatorType == Operator.ShiftRight) ||                      (operatorType == Operator.ShiftRightEquals)) {                      TypeSymbol leftExpressionType = leftExpression.EvaluatedType;                        if ((leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.Byte)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedShort)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedInteger)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedLong))) {                          // Switch to unsigned shift operator for unsigned types (which happens                          // to be set up to follow the signed operator in the enumeration offset by 1)                          Debug.Assert(((int)Operator.UnsignedShiftRight - (int)Operator.ShiftRight) == 2);                          Debug.Assert(((int)Operator.UnsignedShiftRightEquals - (int)Operator.ShiftRightEquals) == 2);                            operatorType = (Operator)((int)(operatorType) + 2);                      }                  }                    if (resultType == null) {                      return new BinaryExpression(operatorType' leftExpression' rightExpression);                  }                  else {                      return new BinaryExpression(operatorType' leftExpression' rightExpression' resultType);                  }              }
Magic Number,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessBinaryExpressionNode,The following statement contains a magic number: if (operatorType != Operator.Invalid) {                  if ((operatorType == Operator.BitwiseAnd) ||                      (operatorType == Operator.BitwiseAndEquals) ||                      (operatorType == Operator.BitwiseOr) ||                      (operatorType == Operator.BitwiseOrEquals) ||                      (operatorType == Operator.BitwiseXor) ||                      (operatorType == Operator.BitwiseXorEquals)) {                      TypeSymbol leftExpressionType = leftExpression.EvaluatedType;                        if (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.Boolean)) {                          // For bitwise operators involving boolean expressions' we perform                          // a type coercion due to behavioral differences between C# and JavaScript.                          // Example:                          //     var result = true & true;                          //     actual: result === 1                          //     expected: result === true                          Operator baseOperatorType = operatorType;                            switch (operatorType) {                              case Operator.BitwiseAndEquals:                                  baseOperatorType = Operator.BitwiseAnd;                                  break;                              case Operator.BitwiseOrEquals:                                  baseOperatorType = Operator.BitwiseOr;                                  break;                              case Operator.BitwiseXorEquals:                                  baseOperatorType = Operator.BitwiseXor;                                  break;                          }                            // Map "x op y" to "(x op y) === 1"                          // Map "x op= y" to "x = (x op y) === 1"                          Expression bitwiseExpression =                              new BinaryExpression(baseOperatorType' leftExpression' rightExpression);                          bitwiseExpression.AddParenthesisHint();                            Expression coerceExpression =                              new BinaryExpression(Operator.EqualEqualEqual' bitwiseExpression'                                  new LiteralExpression(_symbolSet.ResolveIntrinsicType(IntrinsicType.Integer)' 1));                            if (operatorType == baseOperatorType) {                              return coerceExpression;                          }                          else {                              // Since y above can be a complex expression' add parentheses around it to ensure                              // proper operator precedence.                              rightExpression.AddParenthesisHint();                                return new BinaryExpression(Operator.Equals' TransformGetPropertyExpression(leftExpression)' coerceExpression);                          }                      }                  }                    if ((operatorType == Operator.EqualEqualEqual) ||                      (operatorType == Operator.NotEqualEqual)) {                      LiteralExpression literalExpression = rightExpression as LiteralExpression;                      if (literalExpression != null) {                          // Comparisons with null are mapped to the less-strict comparison operator                          // to handle undefined as well.                          if (literalExpression.Value == null) {                              if (operatorType == Operator.EqualEqualEqual) {                                  return new BinaryExpression(Operator.EqualEqual' leftExpression' rightExpression' resultType);                              }                              else {                                  return new BinaryExpression(Operator.NotEqual' leftExpression' rightExpression' resultType);                              }                          }                      }                        if ((leftExpression.EvaluatedType == rightExpression.EvaluatedType) &&                          (leftExpression.EvaluatedType == _symbolSet.ResolveIntrinsicType(IntrinsicType.Date))) {                          // Map equality comparison between Date objects to a call to                          // Script.CompareDates                            TypeSymbol scriptType = _symbolSet.ResolveIntrinsicType(IntrinsicType.Script);                          Debug.Assert(scriptType != null);                            MethodSymbol compareMethod = (MethodSymbol)scriptType.GetMember("CompareDates");                          Debug.Assert(compareMethod != null);                            MethodExpression compareExpression =                              new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                   compareMethod);                          compareExpression.AddParameterValue(leftExpression);                          compareExpression.AddParameterValue(rightExpression);                            if (operatorType == Operator.NotEqualEqual) {                              return new UnaryExpression(Operator.LogicalNot' compareExpression);                          }                          return compareExpression;                      }                  }                    if ((operatorType == Operator.ShiftRight) ||                      (operatorType == Operator.ShiftRightEquals)) {                      TypeSymbol leftExpressionType = leftExpression.EvaluatedType;                        if ((leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.Byte)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedShort)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedInteger)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedLong))) {                          // Switch to unsigned shift operator for unsigned types (which happens                          // to be set up to follow the signed operator in the enumeration offset by 1)                          Debug.Assert(((int)Operator.UnsignedShiftRight - (int)Operator.ShiftRight) == 2);                          Debug.Assert(((int)Operator.UnsignedShiftRightEquals - (int)Operator.ShiftRightEquals) == 2);                            operatorType = (Operator)((int)(operatorType) + 2);                      }                  }                    if (resultType == null) {                      return new BinaryExpression(operatorType' leftExpression' rightExpression);                  }                  else {                      return new BinaryExpression(operatorType' leftExpression' rightExpression' resultType);                  }              }
Magic Number,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessBinaryExpressionNode,The following statement contains a magic number: if (operatorType != Operator.Invalid) {                  if ((operatorType == Operator.BitwiseAnd) ||                      (operatorType == Operator.BitwiseAndEquals) ||                      (operatorType == Operator.BitwiseOr) ||                      (operatorType == Operator.BitwiseOrEquals) ||                      (operatorType == Operator.BitwiseXor) ||                      (operatorType == Operator.BitwiseXorEquals)) {                      TypeSymbol leftExpressionType = leftExpression.EvaluatedType;                        if (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.Boolean)) {                          // For bitwise operators involving boolean expressions' we perform                          // a type coercion due to behavioral differences between C# and JavaScript.                          // Example:                          //     var result = true & true;                          //     actual: result === 1                          //     expected: result === true                          Operator baseOperatorType = operatorType;                            switch (operatorType) {                              case Operator.BitwiseAndEquals:                                  baseOperatorType = Operator.BitwiseAnd;                                  break;                              case Operator.BitwiseOrEquals:                                  baseOperatorType = Operator.BitwiseOr;                                  break;                              case Operator.BitwiseXorEquals:                                  baseOperatorType = Operator.BitwiseXor;                                  break;                          }                            // Map "x op y" to "(x op y) === 1"                          // Map "x op= y" to "x = (x op y) === 1"                          Expression bitwiseExpression =                              new BinaryExpression(baseOperatorType' leftExpression' rightExpression);                          bitwiseExpression.AddParenthesisHint();                            Expression coerceExpression =                              new BinaryExpression(Operator.EqualEqualEqual' bitwiseExpression'                                  new LiteralExpression(_symbolSet.ResolveIntrinsicType(IntrinsicType.Integer)' 1));                            if (operatorType == baseOperatorType) {                              return coerceExpression;                          }                          else {                              // Since y above can be a complex expression' add parentheses around it to ensure                              // proper operator precedence.                              rightExpression.AddParenthesisHint();                                return new BinaryExpression(Operator.Equals' TransformGetPropertyExpression(leftExpression)' coerceExpression);                          }                      }                  }                    if ((operatorType == Operator.EqualEqualEqual) ||                      (operatorType == Operator.NotEqualEqual)) {                      LiteralExpression literalExpression = rightExpression as LiteralExpression;                      if (literalExpression != null) {                          // Comparisons with null are mapped to the less-strict comparison operator                          // to handle undefined as well.                          if (literalExpression.Value == null) {                              if (operatorType == Operator.EqualEqualEqual) {                                  return new BinaryExpression(Operator.EqualEqual' leftExpression' rightExpression' resultType);                              }                              else {                                  return new BinaryExpression(Operator.NotEqual' leftExpression' rightExpression' resultType);                              }                          }                      }                        if ((leftExpression.EvaluatedType == rightExpression.EvaluatedType) &&                          (leftExpression.EvaluatedType == _symbolSet.ResolveIntrinsicType(IntrinsicType.Date))) {                          // Map equality comparison between Date objects to a call to                          // Script.CompareDates                            TypeSymbol scriptType = _symbolSet.ResolveIntrinsicType(IntrinsicType.Script);                          Debug.Assert(scriptType != null);                            MethodSymbol compareMethod = (MethodSymbol)scriptType.GetMember("CompareDates");                          Debug.Assert(compareMethod != null);                            MethodExpression compareExpression =                              new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                   compareMethod);                          compareExpression.AddParameterValue(leftExpression);                          compareExpression.AddParameterValue(rightExpression);                            if (operatorType == Operator.NotEqualEqual) {                              return new UnaryExpression(Operator.LogicalNot' compareExpression);                          }                          return compareExpression;                      }                  }                    if ((operatorType == Operator.ShiftRight) ||                      (operatorType == Operator.ShiftRightEquals)) {                      TypeSymbol leftExpressionType = leftExpression.EvaluatedType;                        if ((leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.Byte)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedShort)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedInteger)) ||                          (leftExpressionType == _symbolSet.ResolveIntrinsicType(IntrinsicType.UnsignedLong))) {                          // Switch to unsigned shift operator for unsigned types (which happens                          // to be set up to follow the signed operator in the enumeration offset by 1)                          Debug.Assert(((int)Operator.UnsignedShiftRight - (int)Operator.ShiftRight) == 2);                          Debug.Assert(((int)Operator.UnsignedShiftRightEquals - (int)Operator.ShiftRightEquals) == 2);                            operatorType = (Operator)((int)(operatorType) + 2);                      }                  }                    if (resultType == null) {                      return new BinaryExpression(operatorType' leftExpression' rightExpression);                  }                  else {                      return new BinaryExpression(operatorType' leftExpression' rightExpression' resultType);                  }              }
Magic Number,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessOpenParenExpressionNode,The following statement contains a magic number: if (memberExpression.Member.Type != SymbolType.Method) {                  // A non-method member is being used in a method call; the member must be                  // a delegate...                  Debug.Assert(memberExpression.EvaluatedType.Type == SymbolType.Delegate);                  Expression instanceExpression = TransformMemberExpression(memberExpression);                    MethodSymbol invokeMethod =                      (MethodSymbol)memberExpression.EvaluatedType.GetMember("Invoke");                  Debug.Assert(invokeMethod != null);                    methodExpression = new MethodExpression(instanceExpression' invokeMethod);                  isDelegateInvoke = true;              }              else {                  // The member being accessed is a method...                    MethodSymbol method = (MethodSymbol)memberExpression.Member;                  if (!method.MatchesConditions(_options.Defines)) {                      return null;                  }                    if (method.Name.Equals("GetEnumerator"' StringComparison.Ordinal)) {                      // This is a bit dangerous - GetEnumerator on any type gets mapped to                      // Script.Enumerate. This actually somewhat matches c# semantics' where you                      // can perform a foreach on any type that has a GetEnumerator method' rather                      // than only types that implement IEnumerable.                        MethodSymbol enumerateMethod = (MethodSymbol)scriptType.GetMember("Enumerate");                      Debug.Assert(enumerateMethod != null);                        methodExpression = new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                              enumerateMethod);                      methodExpression.AddParameterValue(memberExpression.ObjectReference);                      methodExpression.Reevaluate(memberExpression.EvaluatedType);                        return methodExpression;                  }                    if ((method.Parent == objectType) &&                      (method.Name.Equals("ToString"' StringComparison.Ordinal) ||                      method.Name.Equals("ToLocaleString"' StringComparison.Ordinal))) {                      if (memberExpression.ObjectReference.EvaluatedType == stringType) {                          // No-op ToString calls on strings (this happens when performing a ToString                          // on a named enum value.                          return memberExpression.ObjectReference;                      }                      if (memberExpression.ObjectReference.EvaluatedType.Type == SymbolType.Enumeration) {                          EnumerationSymbol enumSymbol = (EnumerationSymbol)memberExpression.ObjectReference.EvaluatedType;                            if (enumSymbol.UseNamedValues) {                              // If the enum value is a named enum' then it is already a string.                              return memberExpression.ObjectReference;                          }                            return new MethodExpression(memberExpression.ObjectReference' method);                      }                  }                  else if ((method.Parent == dictionaryType) || (method.Parent == genericDictionaryType)) {                      if (method.Name.Equals("Remove"' StringComparison.Ordinal)) {                          // Switch the instance Remove method on Dictionary to                          // calls to the delete operator.                          Debug.Assert(args.Count == 1);                            return new LateBoundExpression(memberExpression.ObjectReference'                                                         args[0]' LateBoundOperation.DeleteField'                                                         objectType);                      }                      else if (method.Name.Equals("GetDictionary"' StringComparison.Ordinal)) {                          // Dictionary.GetDictionary is a no-op method; we're just interested                          // in the object being passed in.                          // However we'll re-evaluate the argument to be of dictionary type                          // so that subsequent use of this expression sees it as a dictionary.                          Debug.Assert(args.Count == 1);                          args[0].Reevaluate((TypeSymbol)method.Parent);                            return args[0];                      }                  }                  else if (method.Parent == scriptType) {                      if (method.Name.Equals("Literal"' StringComparison.Ordinal)) {                          // Convert a call to Script.Literal into a literal expression                            Debug.Assert(args.Count >= 1);                          string script = null;                            if (args[0].Type == ExpressionType.Field) {                              Debug.Assert(args[0].EvaluatedType == stringType);                                FieldSymbol field = ((FieldExpression)args[0]).Field;                              if (field.IsConstant) {                                  Debug.Assert(field.Value is string);                                  script = (string)field.Value;                              }                          }                          else if (args[0].Type == ExpressionType.Literal) {                              Debug.Assert(((LiteralExpression)args[0]).Value is string);                              script = (string)((LiteralExpression)args[0]).Value;                          }                            if (script == null) {                              // TODO: When we start raising errors at the expression level instead of the statement                              //       level' we should return an ErrorExpression instead of a dummy expression.                              Token argToken = argNodes.Expressions[0].Token;                                _errorHandler.ReportError("The argument to Script.Literal must be a constant string."'                                                        argToken.Location);                              return new InlineScriptExpression(""' objectType);                          }                            if (args.Count > 1) {                              // Check whether the script is a valid string format string                              try {                                  object[] argValues = new object[args.Count - 1];                                  String.Format(CultureInfo.InvariantCulture' script' argValues);                              }                              catch {                                  _errorHandler.ReportError("The argument to Script.Literal must be a valid String.Format string."'                                                            argNodes.Expressions[0].Token.Location);                                  return new InlineScriptExpression(""' objectType);                              }                          }                            InlineScriptExpression scriptExpression = new InlineScriptExpression(script' objectType);                          for (int i = 1; i < args.Count; i++) {                              scriptExpression.AddParameterValue(args[i]);                          }                            return scriptExpression;                      }                      else if (method.Name.Equals("Boolean"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' new UnaryExpression(Operator.LogicalNot' args[0]));                      }                      else if (method.Name.Equals("IsTruthy"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' new UnaryExpression(Operator.LogicalNot' args[0]));                      }                      else if (method.Name.Equals("IsFalsey"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' args[0]);                      }                      else if (method.Name.Equals("Or"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 2);                            Expression expr = args[0];                          for (int i = 1; i < args.Count; i++) {                              expr = new BinaryExpression(Operator.LogicalOr' expr' args[i]);                          }                            expr.Reevaluate(args[0].EvaluatedType);                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsNull"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            Expression expr = new BinaryExpression(Operator.EqualEqualEqual' args[0]'                                                                 new LiteralExpression(objectType' null));                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsUndefined"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            MemberSymbol undefinedMember = scriptType.GetMember("Undefined");                          Debug.Assert(undefinedMember != null);                            MemberExpression undefinedExpression =                              new MemberExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                   undefinedMember);                            Expression expr = new BinaryExpression(Operator.EqualEqualEqual' args[0]' TransformMemberExpression(undefinedExpression));                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsNullOrUndefined"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            MethodSymbol isValueMethod = (MethodSymbol)scriptType.GetMember("IsValue");                          Debug.Assert(isValueMethod != null);                            methodExpression = new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                                  isValueMethod);                          methodExpression.AddParameterValue(args[0]);                            return new UnaryExpression(Operator.LogicalNot' methodExpression);                      }                      else if (method.Name.Equals("CreateInstance"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 1);                            if ((args[0].Type == ExpressionType.MethodInvoke) ||                              (args[0].Type == ExpressionType.PropertyGet)) {                              // When using the result of a method call/property access directly                              // with Type.CreateInstance' the following script would be generated:                              //                              // new method()()                              // which is invalid. Instead we need to generate the following:                              // var type = method();                              // new type()                                _errorHandler.ReportError("You must store the type returned from a method or property into a local variable to use with Type.CreateInstance."'                                                        node.Token.Location);                          }                            NewExpression newExpression = new NewExpression(args[0]' objectType);                          if (args.Count > 1) {                              bool first = true;                              foreach (Expression paramExpr in args) {                                  if (first) {                                      first = false;                                      continue;                                  }                                  newExpression.AddParameterValue(paramExpr);                              }                          }                          return newExpression;                      }                        bool lateBound = false;                      LateBoundOperation lateBoundOperation = LateBoundOperation.InvokeMethod;                        if (method.Name.Equals("InvokeMethod"' StringComparison.Ordinal)) {                          lateBound = true;                      }                      else if (method.Name.Equals("DeleteField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.DeleteField;                      }                      else if (method.Name.Equals("GetField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.GetField;                      }                      else if (method.Name.Equals("SetField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.SetField;                      }                      else if (method.Name.Equals("GetScriptType"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.GetScriptType;                      }                      else if (method.Name.Equals("HasField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.HasField;                      }                      else if (method.Name.Equals("HasMethod"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.HasMethod;                      }                        if (lateBound) {                          // Switch explicit late-bound calls into implicit late-bound expressions                          // in script                          Debug.Assert((args != null) &&                                       (((lateBoundOperation == LateBoundOperation.GetScriptType) && (args.Count == 1)) ||                                       (args.Count >= 2)));                            LateBoundExpression lateBoundExpression = null;                          Expression instanceExpression = null;                          Expression nameExpression = null;                            foreach (Expression paramExpr in args) {                              if (instanceExpression == null) {                                  instanceExpression = paramExpr;                                    if (lateBoundOperation == LateBoundOperation.GetScriptType) {                                      // GetScriptType only takes an instance                                      return new LateBoundExpression(instanceExpression' null'                                                                      lateBoundOperation' objectType);                                  }                                  continue;                              }                              if (nameExpression == null) {                                  nameExpression = paramExpr;                                    Expression objectExpression = instanceExpression;                                  if (lateBoundOperation == LateBoundOperation.InvokeMethod) {                                      if ((instanceExpression.Type == ExpressionType.Literal) &&                                          (((LiteralExpression)instanceExpression).Value == null)) {                                          objectExpression = null;                                            LiteralExpression literalExpression = nameExpression as LiteralExpression;                                          if (literalExpression == null) {                                              _errorHandler.ReportError("The name of a global method must be a constant string known at compile time."'                                                                          argNodes.Expressions[0].Token.Location);                                          }                                          else if (!Utility.IsValidIdentifier((string)literalExpression.Value)) {                                              _errorHandler.ReportError("The name of a global method must be a valid identifer."'                                                                          argNodes.Expressions[0].Token.Location);                                          }                                      }                                  }                                    lateBoundExpression = new LateBoundExpression(objectExpression' nameExpression'                                                                                  lateBoundOperation' objectType);                                  continue;                              }                                lateBoundExpression.AddParameterValue(paramExpr);                          }                            Debug.Assert(lateBoundExpression != null);                          return lateBoundExpression;                      }                  }                  else if (method.Parent == argsType) {                      if (method.Name.Equals("GetArgument"' StringComparison.Ordinal)) {                          // Switch Arguments.GetArgument into Arguments[]                          Debug.Assert(args.Count == 1);                            IndexerExpression indexExpression =                              new IndexerExpression(new LiteralExpression(typeType' method.Parent)'                                                    ((ClassSymbol)method.Parent).GetIndexer());                          indexExpression.AddIndexParameterValue(args[0]);                            return indexExpression;                      }                      else if (method.Name.Equals("ToArray"' StringComparison.Ordinal)) {                          // Switch Arguments.ToArray into Array.ToArray(arguments)                            TypeSymbol arrayType = _symbolSet.ResolveIntrinsicType(IntrinsicType.Array);                          MethodSymbol toArrayMethod = (MethodSymbol)arrayType.GetMember("ToArray");                            InlineScriptExpression argsExpression =                              new InlineScriptExpression("arguments"' objectType' /* parenthesize */ false);                          MethodExpression toArrayExpression =                              new MethodExpression(new TypeExpression(arrayType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                   toArrayMethod);                          toArrayExpression.AddParameterValue(argsExpression);                            return toArrayExpression;                      }                  }                  else if ((method.Parent.Type == SymbolType.Class) && ((ClassSymbol)method.Parent).IsArray) {                      ClassSymbol arraySymbol = (ClassSymbol)method.Parent;                        if (method.Name.Equals("Clear"' StringComparison.Ordinal)) {                          // array.Clear() becomes array.length = 0 in generated code                            MemberSymbol lengthMember = arraySymbol.GetMember("Length");                          if (lengthMember == null) {                              lengthMember = arraySymbol.GetMember("Count");                          }                          Debug.Assert((lengthMember != null) && (lengthMember.Type == SymbolType.Field));                            MemberExpression lengthExpression =                              new MemberExpression(memberExpression.ObjectReference' lengthMember);                          return new BinaryExpression(Operator.Equals' TransformMemberExpression(lengthExpression)'                                                      new LiteralExpression(intType' 0));                      }                      if (method.Name.Equals("Contains"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            // array.Contains(item) becomes array.indexOf(item) >= 0                            MemberSymbol indexOfSymbol = arraySymbol.GetMember("IndexOf");                          Debug.Assert((indexOfSymbol != null) && (indexOfSymbol.Type == SymbolType.Method));                            MethodExpression indexOfExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)indexOfSymbol);                          indexOfExpression.AddParameterValue(args[0]);                            BinaryExpression compareExpression =                              new BinaryExpression(Operator.GreaterEqual' indexOfExpression' new LiteralExpression(intType' 0));                          compareExpression.AddParenthesisHint();                            return compareExpression;                      }                      if (method.Name.Equals("Insert"' StringComparison.Ordinal) ||                          method.Name.Equals("InsertRange"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 1);                            // array.Insert(index' item) becomes array.splice(index' 0' item);                            MemberSymbol spliceSymbol = arraySymbol.GetMember("Splice");                          Debug.Assert((spliceSymbol != null) && (spliceSymbol.Type == SymbolType.Method));                            MethodExpression spliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)spliceSymbol);                          spliceExpression.AddParameterValue(args[0]);                          spliceExpression.AddParameterValue(new LiteralExpression(intType' 0));                            for (int i = 1; i < args.Count; i++) {                              spliceExpression.AddParameterValue(args[i]);                          }                            return spliceExpression;                      }                      if (method.Name.Equals("RemoveAt"' StringComparison.Ordinal) ||                          method.Name.Equals("RemoveRange"' StringComparison.Ordinal)) {                          Debug.Assert((args.Count >= 1) && (args.Count <= 2));                            // array.RemoveAt(index) becomes array.splice(index' 1)                          // array.RemoveRange(index' count) becomes array.splice(index' count)                            MemberSymbol spliceSymbol = arraySymbol.GetMember("Splice");                          Debug.Assert((spliceSymbol != null) && (spliceSymbol.Type == SymbolType.Method));                            MethodExpression spliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)spliceSymbol);                          spliceExpression.AddParameterValue(args[0]);                          if (args.Count == 1) {                              spliceExpression.AddParameterValue(new LiteralExpression(intType' 1));                          }                          else {                              spliceExpression.AddParameterValue(args[1]);                          }                            return spliceExpression;                      }                      if (method.Name.Equals("GetRange"' StringComparison.Ordinal)) {                          Debug.Assert((args.Count == 2));                            // array.GetRange(index' count) becomes array.slice(index' index + count)                            MemberSymbol sliceSymbol = arraySymbol.GetMember("Slice");                          Debug.Assert((sliceSymbol != null) && (sliceSymbol.Type == SymbolType.Method));                            MethodExpression sliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)sliceSymbol);                          sliceExpression.AddParameterValue(args[0]);                            if ((args[0].Type == ExpressionType.Literal) &&                              (args[1].Type == ExpressionType.Literal)) {                              int endValue = (int)((LiteralExpression)args[0]).Value +                                              (int)((LiteralExpression)args[1]).Value;                              sliceExpression.AddParameterValue(new LiteralExpression(intType' endValue));                          }                          else {                              sliceExpression.AddParameterValue(new BinaryExpression(Operator.Plus' args[0]' args[1]));                          }                            return sliceExpression;                      }                  }                    methodExpression = new MethodExpression(memberExpression.ObjectReference' method);              }
Magic Number,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessOpenParenExpressionNode,The following statement contains a magic number: if (memberExpression.Member.Type != SymbolType.Method) {                  // A non-method member is being used in a method call; the member must be                  // a delegate...                  Debug.Assert(memberExpression.EvaluatedType.Type == SymbolType.Delegate);                  Expression instanceExpression = TransformMemberExpression(memberExpression);                    MethodSymbol invokeMethod =                      (MethodSymbol)memberExpression.EvaluatedType.GetMember("Invoke");                  Debug.Assert(invokeMethod != null);                    methodExpression = new MethodExpression(instanceExpression' invokeMethod);                  isDelegateInvoke = true;              }              else {                  // The member being accessed is a method...                    MethodSymbol method = (MethodSymbol)memberExpression.Member;                  if (!method.MatchesConditions(_options.Defines)) {                      return null;                  }                    if (method.Name.Equals("GetEnumerator"' StringComparison.Ordinal)) {                      // This is a bit dangerous - GetEnumerator on any type gets mapped to                      // Script.Enumerate. This actually somewhat matches c# semantics' where you                      // can perform a foreach on any type that has a GetEnumerator method' rather                      // than only types that implement IEnumerable.                        MethodSymbol enumerateMethod = (MethodSymbol)scriptType.GetMember("Enumerate");                      Debug.Assert(enumerateMethod != null);                        methodExpression = new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                              enumerateMethod);                      methodExpression.AddParameterValue(memberExpression.ObjectReference);                      methodExpression.Reevaluate(memberExpression.EvaluatedType);                        return methodExpression;                  }                    if ((method.Parent == objectType) &&                      (method.Name.Equals("ToString"' StringComparison.Ordinal) ||                      method.Name.Equals("ToLocaleString"' StringComparison.Ordinal))) {                      if (memberExpression.ObjectReference.EvaluatedType == stringType) {                          // No-op ToString calls on strings (this happens when performing a ToString                          // on a named enum value.                          return memberExpression.ObjectReference;                      }                      if (memberExpression.ObjectReference.EvaluatedType.Type == SymbolType.Enumeration) {                          EnumerationSymbol enumSymbol = (EnumerationSymbol)memberExpression.ObjectReference.EvaluatedType;                            if (enumSymbol.UseNamedValues) {                              // If the enum value is a named enum' then it is already a string.                              return memberExpression.ObjectReference;                          }                            return new MethodExpression(memberExpression.ObjectReference' method);                      }                  }                  else if ((method.Parent == dictionaryType) || (method.Parent == genericDictionaryType)) {                      if (method.Name.Equals("Remove"' StringComparison.Ordinal)) {                          // Switch the instance Remove method on Dictionary to                          // calls to the delete operator.                          Debug.Assert(args.Count == 1);                            return new LateBoundExpression(memberExpression.ObjectReference'                                                         args[0]' LateBoundOperation.DeleteField'                                                         objectType);                      }                      else if (method.Name.Equals("GetDictionary"' StringComparison.Ordinal)) {                          // Dictionary.GetDictionary is a no-op method; we're just interested                          // in the object being passed in.                          // However we'll re-evaluate the argument to be of dictionary type                          // so that subsequent use of this expression sees it as a dictionary.                          Debug.Assert(args.Count == 1);                          args[0].Reevaluate((TypeSymbol)method.Parent);                            return args[0];                      }                  }                  else if (method.Parent == scriptType) {                      if (method.Name.Equals("Literal"' StringComparison.Ordinal)) {                          // Convert a call to Script.Literal into a literal expression                            Debug.Assert(args.Count >= 1);                          string script = null;                            if (args[0].Type == ExpressionType.Field) {                              Debug.Assert(args[0].EvaluatedType == stringType);                                FieldSymbol field = ((FieldExpression)args[0]).Field;                              if (field.IsConstant) {                                  Debug.Assert(field.Value is string);                                  script = (string)field.Value;                              }                          }                          else if (args[0].Type == ExpressionType.Literal) {                              Debug.Assert(((LiteralExpression)args[0]).Value is string);                              script = (string)((LiteralExpression)args[0]).Value;                          }                            if (script == null) {                              // TODO: When we start raising errors at the expression level instead of the statement                              //       level' we should return an ErrorExpression instead of a dummy expression.                              Token argToken = argNodes.Expressions[0].Token;                                _errorHandler.ReportError("The argument to Script.Literal must be a constant string."'                                                        argToken.Location);                              return new InlineScriptExpression(""' objectType);                          }                            if (args.Count > 1) {                              // Check whether the script is a valid string format string                              try {                                  object[] argValues = new object[args.Count - 1];                                  String.Format(CultureInfo.InvariantCulture' script' argValues);                              }                              catch {                                  _errorHandler.ReportError("The argument to Script.Literal must be a valid String.Format string."'                                                            argNodes.Expressions[0].Token.Location);                                  return new InlineScriptExpression(""' objectType);                              }                          }                            InlineScriptExpression scriptExpression = new InlineScriptExpression(script' objectType);                          for (int i = 1; i < args.Count; i++) {                              scriptExpression.AddParameterValue(args[i]);                          }                            return scriptExpression;                      }                      else if (method.Name.Equals("Boolean"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' new UnaryExpression(Operator.LogicalNot' args[0]));                      }                      else if (method.Name.Equals("IsTruthy"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' new UnaryExpression(Operator.LogicalNot' args[0]));                      }                      else if (method.Name.Equals("IsFalsey"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' args[0]);                      }                      else if (method.Name.Equals("Or"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 2);                            Expression expr = args[0];                          for (int i = 1; i < args.Count; i++) {                              expr = new BinaryExpression(Operator.LogicalOr' expr' args[i]);                          }                            expr.Reevaluate(args[0].EvaluatedType);                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsNull"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            Expression expr = new BinaryExpression(Operator.EqualEqualEqual' args[0]'                                                                 new LiteralExpression(objectType' null));                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsUndefined"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            MemberSymbol undefinedMember = scriptType.GetMember("Undefined");                          Debug.Assert(undefinedMember != null);                            MemberExpression undefinedExpression =                              new MemberExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                   undefinedMember);                            Expression expr = new BinaryExpression(Operator.EqualEqualEqual' args[0]' TransformMemberExpression(undefinedExpression));                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsNullOrUndefined"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            MethodSymbol isValueMethod = (MethodSymbol)scriptType.GetMember("IsValue");                          Debug.Assert(isValueMethod != null);                            methodExpression = new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                                  isValueMethod);                          methodExpression.AddParameterValue(args[0]);                            return new UnaryExpression(Operator.LogicalNot' methodExpression);                      }                      else if (method.Name.Equals("CreateInstance"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 1);                            if ((args[0].Type == ExpressionType.MethodInvoke) ||                              (args[0].Type == ExpressionType.PropertyGet)) {                              // When using the result of a method call/property access directly                              // with Type.CreateInstance' the following script would be generated:                              //                              // new method()()                              // which is invalid. Instead we need to generate the following:                              // var type = method();                              // new type()                                _errorHandler.ReportError("You must store the type returned from a method or property into a local variable to use with Type.CreateInstance."'                                                        node.Token.Location);                          }                            NewExpression newExpression = new NewExpression(args[0]' objectType);                          if (args.Count > 1) {                              bool first = true;                              foreach (Expression paramExpr in args) {                                  if (first) {                                      first = false;                                      continue;                                  }                                  newExpression.AddParameterValue(paramExpr);                              }                          }                          return newExpression;                      }                        bool lateBound = false;                      LateBoundOperation lateBoundOperation = LateBoundOperation.InvokeMethod;                        if (method.Name.Equals("InvokeMethod"' StringComparison.Ordinal)) {                          lateBound = true;                      }                      else if (method.Name.Equals("DeleteField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.DeleteField;                      }                      else if (method.Name.Equals("GetField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.GetField;                      }                      else if (method.Name.Equals("SetField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.SetField;                      }                      else if (method.Name.Equals("GetScriptType"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.GetScriptType;                      }                      else if (method.Name.Equals("HasField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.HasField;                      }                      else if (method.Name.Equals("HasMethod"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.HasMethod;                      }                        if (lateBound) {                          // Switch explicit late-bound calls into implicit late-bound expressions                          // in script                          Debug.Assert((args != null) &&                                       (((lateBoundOperation == LateBoundOperation.GetScriptType) && (args.Count == 1)) ||                                       (args.Count >= 2)));                            LateBoundExpression lateBoundExpression = null;                          Expression instanceExpression = null;                          Expression nameExpression = null;                            foreach (Expression paramExpr in args) {                              if (instanceExpression == null) {                                  instanceExpression = paramExpr;                                    if (lateBoundOperation == LateBoundOperation.GetScriptType) {                                      // GetScriptType only takes an instance                                      return new LateBoundExpression(instanceExpression' null'                                                                      lateBoundOperation' objectType);                                  }                                  continue;                              }                              if (nameExpression == null) {                                  nameExpression = paramExpr;                                    Expression objectExpression = instanceExpression;                                  if (lateBoundOperation == LateBoundOperation.InvokeMethod) {                                      if ((instanceExpression.Type == ExpressionType.Literal) &&                                          (((LiteralExpression)instanceExpression).Value == null)) {                                          objectExpression = null;                                            LiteralExpression literalExpression = nameExpression as LiteralExpression;                                          if (literalExpression == null) {                                              _errorHandler.ReportError("The name of a global method must be a constant string known at compile time."'                                                                          argNodes.Expressions[0].Token.Location);                                          }                                          else if (!Utility.IsValidIdentifier((string)literalExpression.Value)) {                                              _errorHandler.ReportError("The name of a global method must be a valid identifer."'                                                                          argNodes.Expressions[0].Token.Location);                                          }                                      }                                  }                                    lateBoundExpression = new LateBoundExpression(objectExpression' nameExpression'                                                                                  lateBoundOperation' objectType);                                  continue;                              }                                lateBoundExpression.AddParameterValue(paramExpr);                          }                            Debug.Assert(lateBoundExpression != null);                          return lateBoundExpression;                      }                  }                  else if (method.Parent == argsType) {                      if (method.Name.Equals("GetArgument"' StringComparison.Ordinal)) {                          // Switch Arguments.GetArgument into Arguments[]                          Debug.Assert(args.Count == 1);                            IndexerExpression indexExpression =                              new IndexerExpression(new LiteralExpression(typeType' method.Parent)'                                                    ((ClassSymbol)method.Parent).GetIndexer());                          indexExpression.AddIndexParameterValue(args[0]);                            return indexExpression;                      }                      else if (method.Name.Equals("ToArray"' StringComparison.Ordinal)) {                          // Switch Arguments.ToArray into Array.ToArray(arguments)                            TypeSymbol arrayType = _symbolSet.ResolveIntrinsicType(IntrinsicType.Array);                          MethodSymbol toArrayMethod = (MethodSymbol)arrayType.GetMember("ToArray");                            InlineScriptExpression argsExpression =                              new InlineScriptExpression("arguments"' objectType' /* parenthesize */ false);                          MethodExpression toArrayExpression =                              new MethodExpression(new TypeExpression(arrayType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                   toArrayMethod);                          toArrayExpression.AddParameterValue(argsExpression);                            return toArrayExpression;                      }                  }                  else if ((method.Parent.Type == SymbolType.Class) && ((ClassSymbol)method.Parent).IsArray) {                      ClassSymbol arraySymbol = (ClassSymbol)method.Parent;                        if (method.Name.Equals("Clear"' StringComparison.Ordinal)) {                          // array.Clear() becomes array.length = 0 in generated code                            MemberSymbol lengthMember = arraySymbol.GetMember("Length");                          if (lengthMember == null) {                              lengthMember = arraySymbol.GetMember("Count");                          }                          Debug.Assert((lengthMember != null) && (lengthMember.Type == SymbolType.Field));                            MemberExpression lengthExpression =                              new MemberExpression(memberExpression.ObjectReference' lengthMember);                          return new BinaryExpression(Operator.Equals' TransformMemberExpression(lengthExpression)'                                                      new LiteralExpression(intType' 0));                      }                      if (method.Name.Equals("Contains"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            // array.Contains(item) becomes array.indexOf(item) >= 0                            MemberSymbol indexOfSymbol = arraySymbol.GetMember("IndexOf");                          Debug.Assert((indexOfSymbol != null) && (indexOfSymbol.Type == SymbolType.Method));                            MethodExpression indexOfExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)indexOfSymbol);                          indexOfExpression.AddParameterValue(args[0]);                            BinaryExpression compareExpression =                              new BinaryExpression(Operator.GreaterEqual' indexOfExpression' new LiteralExpression(intType' 0));                          compareExpression.AddParenthesisHint();                            return compareExpression;                      }                      if (method.Name.Equals("Insert"' StringComparison.Ordinal) ||                          method.Name.Equals("InsertRange"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 1);                            // array.Insert(index' item) becomes array.splice(index' 0' item);                            MemberSymbol spliceSymbol = arraySymbol.GetMember("Splice");                          Debug.Assert((spliceSymbol != null) && (spliceSymbol.Type == SymbolType.Method));                            MethodExpression spliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)spliceSymbol);                          spliceExpression.AddParameterValue(args[0]);                          spliceExpression.AddParameterValue(new LiteralExpression(intType' 0));                            for (int i = 1; i < args.Count; i++) {                              spliceExpression.AddParameterValue(args[i]);                          }                            return spliceExpression;                      }                      if (method.Name.Equals("RemoveAt"' StringComparison.Ordinal) ||                          method.Name.Equals("RemoveRange"' StringComparison.Ordinal)) {                          Debug.Assert((args.Count >= 1) && (args.Count <= 2));                            // array.RemoveAt(index) becomes array.splice(index' 1)                          // array.RemoveRange(index' count) becomes array.splice(index' count)                            MemberSymbol spliceSymbol = arraySymbol.GetMember("Splice");                          Debug.Assert((spliceSymbol != null) && (spliceSymbol.Type == SymbolType.Method));                            MethodExpression spliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)spliceSymbol);                          spliceExpression.AddParameterValue(args[0]);                          if (args.Count == 1) {                              spliceExpression.AddParameterValue(new LiteralExpression(intType' 1));                          }                          else {                              spliceExpression.AddParameterValue(args[1]);                          }                            return spliceExpression;                      }                      if (method.Name.Equals("GetRange"' StringComparison.Ordinal)) {                          Debug.Assert((args.Count == 2));                            // array.GetRange(index' count) becomes array.slice(index' index + count)                            MemberSymbol sliceSymbol = arraySymbol.GetMember("Slice");                          Debug.Assert((sliceSymbol != null) && (sliceSymbol.Type == SymbolType.Method));                            MethodExpression sliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)sliceSymbol);                          sliceExpression.AddParameterValue(args[0]);                            if ((args[0].Type == ExpressionType.Literal) &&                              (args[1].Type == ExpressionType.Literal)) {                              int endValue = (int)((LiteralExpression)args[0]).Value +                                              (int)((LiteralExpression)args[1]).Value;                              sliceExpression.AddParameterValue(new LiteralExpression(intType' endValue));                          }                          else {                              sliceExpression.AddParameterValue(new BinaryExpression(Operator.Plus' args[0]' args[1]));                          }                            return sliceExpression;                      }                  }                    methodExpression = new MethodExpression(memberExpression.ObjectReference' method);              }
Magic Number,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessOpenParenExpressionNode,The following statement contains a magic number: if (memberExpression.Member.Type != SymbolType.Method) {                  // A non-method member is being used in a method call; the member must be                  // a delegate...                  Debug.Assert(memberExpression.EvaluatedType.Type == SymbolType.Delegate);                  Expression instanceExpression = TransformMemberExpression(memberExpression);                    MethodSymbol invokeMethod =                      (MethodSymbol)memberExpression.EvaluatedType.GetMember("Invoke");                  Debug.Assert(invokeMethod != null);                    methodExpression = new MethodExpression(instanceExpression' invokeMethod);                  isDelegateInvoke = true;              }              else {                  // The member being accessed is a method...                    MethodSymbol method = (MethodSymbol)memberExpression.Member;                  if (!method.MatchesConditions(_options.Defines)) {                      return null;                  }                    if (method.Name.Equals("GetEnumerator"' StringComparison.Ordinal)) {                      // This is a bit dangerous - GetEnumerator on any type gets mapped to                      // Script.Enumerate. This actually somewhat matches c# semantics' where you                      // can perform a foreach on any type that has a GetEnumerator method' rather                      // than only types that implement IEnumerable.                        MethodSymbol enumerateMethod = (MethodSymbol)scriptType.GetMember("Enumerate");                      Debug.Assert(enumerateMethod != null);                        methodExpression = new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                              enumerateMethod);                      methodExpression.AddParameterValue(memberExpression.ObjectReference);                      methodExpression.Reevaluate(memberExpression.EvaluatedType);                        return methodExpression;                  }                    if ((method.Parent == objectType) &&                      (method.Name.Equals("ToString"' StringComparison.Ordinal) ||                      method.Name.Equals("ToLocaleString"' StringComparison.Ordinal))) {                      if (memberExpression.ObjectReference.EvaluatedType == stringType) {                          // No-op ToString calls on strings (this happens when performing a ToString                          // on a named enum value.                          return memberExpression.ObjectReference;                      }                      if (memberExpression.ObjectReference.EvaluatedType.Type == SymbolType.Enumeration) {                          EnumerationSymbol enumSymbol = (EnumerationSymbol)memberExpression.ObjectReference.EvaluatedType;                            if (enumSymbol.UseNamedValues) {                              // If the enum value is a named enum' then it is already a string.                              return memberExpression.ObjectReference;                          }                            return new MethodExpression(memberExpression.ObjectReference' method);                      }                  }                  else if ((method.Parent == dictionaryType) || (method.Parent == genericDictionaryType)) {                      if (method.Name.Equals("Remove"' StringComparison.Ordinal)) {                          // Switch the instance Remove method on Dictionary to                          // calls to the delete operator.                          Debug.Assert(args.Count == 1);                            return new LateBoundExpression(memberExpression.ObjectReference'                                                         args[0]' LateBoundOperation.DeleteField'                                                         objectType);                      }                      else if (method.Name.Equals("GetDictionary"' StringComparison.Ordinal)) {                          // Dictionary.GetDictionary is a no-op method; we're just interested                          // in the object being passed in.                          // However we'll re-evaluate the argument to be of dictionary type                          // so that subsequent use of this expression sees it as a dictionary.                          Debug.Assert(args.Count == 1);                          args[0].Reevaluate((TypeSymbol)method.Parent);                            return args[0];                      }                  }                  else if (method.Parent == scriptType) {                      if (method.Name.Equals("Literal"' StringComparison.Ordinal)) {                          // Convert a call to Script.Literal into a literal expression                            Debug.Assert(args.Count >= 1);                          string script = null;                            if (args[0].Type == ExpressionType.Field) {                              Debug.Assert(args[0].EvaluatedType == stringType);                                FieldSymbol field = ((FieldExpression)args[0]).Field;                              if (field.IsConstant) {                                  Debug.Assert(field.Value is string);                                  script = (string)field.Value;                              }                          }                          else if (args[0].Type == ExpressionType.Literal) {                              Debug.Assert(((LiteralExpression)args[0]).Value is string);                              script = (string)((LiteralExpression)args[0]).Value;                          }                            if (script == null) {                              // TODO: When we start raising errors at the expression level instead of the statement                              //       level' we should return an ErrorExpression instead of a dummy expression.                              Token argToken = argNodes.Expressions[0].Token;                                _errorHandler.ReportError("The argument to Script.Literal must be a constant string."'                                                        argToken.Location);                              return new InlineScriptExpression(""' objectType);                          }                            if (args.Count > 1) {                              // Check whether the script is a valid string format string                              try {                                  object[] argValues = new object[args.Count - 1];                                  String.Format(CultureInfo.InvariantCulture' script' argValues);                              }                              catch {                                  _errorHandler.ReportError("The argument to Script.Literal must be a valid String.Format string."'                                                            argNodes.Expressions[0].Token.Location);                                  return new InlineScriptExpression(""' objectType);                              }                          }                            InlineScriptExpression scriptExpression = new InlineScriptExpression(script' objectType);                          for (int i = 1; i < args.Count; i++) {                              scriptExpression.AddParameterValue(args[i]);                          }                            return scriptExpression;                      }                      else if (method.Name.Equals("Boolean"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' new UnaryExpression(Operator.LogicalNot' args[0]));                      }                      else if (method.Name.Equals("IsTruthy"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' new UnaryExpression(Operator.LogicalNot' args[0]));                      }                      else if (method.Name.Equals("IsFalsey"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' args[0]);                      }                      else if (method.Name.Equals("Or"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 2);                            Expression expr = args[0];                          for (int i = 1; i < args.Count; i++) {                              expr = new BinaryExpression(Operator.LogicalOr' expr' args[i]);                          }                            expr.Reevaluate(args[0].EvaluatedType);                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsNull"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            Expression expr = new BinaryExpression(Operator.EqualEqualEqual' args[0]'                                                                 new LiteralExpression(objectType' null));                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsUndefined"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            MemberSymbol undefinedMember = scriptType.GetMember("Undefined");                          Debug.Assert(undefinedMember != null);                            MemberExpression undefinedExpression =                              new MemberExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                   undefinedMember);                            Expression expr = new BinaryExpression(Operator.EqualEqualEqual' args[0]' TransformMemberExpression(undefinedExpression));                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsNullOrUndefined"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            MethodSymbol isValueMethod = (MethodSymbol)scriptType.GetMember("IsValue");                          Debug.Assert(isValueMethod != null);                            methodExpression = new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                                  isValueMethod);                          methodExpression.AddParameterValue(args[0]);                            return new UnaryExpression(Operator.LogicalNot' methodExpression);                      }                      else if (method.Name.Equals("CreateInstance"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 1);                            if ((args[0].Type == ExpressionType.MethodInvoke) ||                              (args[0].Type == ExpressionType.PropertyGet)) {                              // When using the result of a method call/property access directly                              // with Type.CreateInstance' the following script would be generated:                              //                              // new method()()                              // which is invalid. Instead we need to generate the following:                              // var type = method();                              // new type()                                _errorHandler.ReportError("You must store the type returned from a method or property into a local variable to use with Type.CreateInstance."'                                                        node.Token.Location);                          }                            NewExpression newExpression = new NewExpression(args[0]' objectType);                          if (args.Count > 1) {                              bool first = true;                              foreach (Expression paramExpr in args) {                                  if (first) {                                      first = false;                                      continue;                                  }                                  newExpression.AddParameterValue(paramExpr);                              }                          }                          return newExpression;                      }                        bool lateBound = false;                      LateBoundOperation lateBoundOperation = LateBoundOperation.InvokeMethod;                        if (method.Name.Equals("InvokeMethod"' StringComparison.Ordinal)) {                          lateBound = true;                      }                      else if (method.Name.Equals("DeleteField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.DeleteField;                      }                      else if (method.Name.Equals("GetField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.GetField;                      }                      else if (method.Name.Equals("SetField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.SetField;                      }                      else if (method.Name.Equals("GetScriptType"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.GetScriptType;                      }                      else if (method.Name.Equals("HasField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.HasField;                      }                      else if (method.Name.Equals("HasMethod"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.HasMethod;                      }                        if (lateBound) {                          // Switch explicit late-bound calls into implicit late-bound expressions                          // in script                          Debug.Assert((args != null) &&                                       (((lateBoundOperation == LateBoundOperation.GetScriptType) && (args.Count == 1)) ||                                       (args.Count >= 2)));                            LateBoundExpression lateBoundExpression = null;                          Expression instanceExpression = null;                          Expression nameExpression = null;                            foreach (Expression paramExpr in args) {                              if (instanceExpression == null) {                                  instanceExpression = paramExpr;                                    if (lateBoundOperation == LateBoundOperation.GetScriptType) {                                      // GetScriptType only takes an instance                                      return new LateBoundExpression(instanceExpression' null'                                                                      lateBoundOperation' objectType);                                  }                                  continue;                              }                              if (nameExpression == null) {                                  nameExpression = paramExpr;                                    Expression objectExpression = instanceExpression;                                  if (lateBoundOperation == LateBoundOperation.InvokeMethod) {                                      if ((instanceExpression.Type == ExpressionType.Literal) &&                                          (((LiteralExpression)instanceExpression).Value == null)) {                                          objectExpression = null;                                            LiteralExpression literalExpression = nameExpression as LiteralExpression;                                          if (literalExpression == null) {                                              _errorHandler.ReportError("The name of a global method must be a constant string known at compile time."'                                                                          argNodes.Expressions[0].Token.Location);                                          }                                          else if (!Utility.IsValidIdentifier((string)literalExpression.Value)) {                                              _errorHandler.ReportError("The name of a global method must be a valid identifer."'                                                                          argNodes.Expressions[0].Token.Location);                                          }                                      }                                  }                                    lateBoundExpression = new LateBoundExpression(objectExpression' nameExpression'                                                                                  lateBoundOperation' objectType);                                  continue;                              }                                lateBoundExpression.AddParameterValue(paramExpr);                          }                            Debug.Assert(lateBoundExpression != null);                          return lateBoundExpression;                      }                  }                  else if (method.Parent == argsType) {                      if (method.Name.Equals("GetArgument"' StringComparison.Ordinal)) {                          // Switch Arguments.GetArgument into Arguments[]                          Debug.Assert(args.Count == 1);                            IndexerExpression indexExpression =                              new IndexerExpression(new LiteralExpression(typeType' method.Parent)'                                                    ((ClassSymbol)method.Parent).GetIndexer());                          indexExpression.AddIndexParameterValue(args[0]);                            return indexExpression;                      }                      else if (method.Name.Equals("ToArray"' StringComparison.Ordinal)) {                          // Switch Arguments.ToArray into Array.ToArray(arguments)                            TypeSymbol arrayType = _symbolSet.ResolveIntrinsicType(IntrinsicType.Array);                          MethodSymbol toArrayMethod = (MethodSymbol)arrayType.GetMember("ToArray");                            InlineScriptExpression argsExpression =                              new InlineScriptExpression("arguments"' objectType' /* parenthesize */ false);                          MethodExpression toArrayExpression =                              new MethodExpression(new TypeExpression(arrayType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                   toArrayMethod);                          toArrayExpression.AddParameterValue(argsExpression);                            return toArrayExpression;                      }                  }                  else if ((method.Parent.Type == SymbolType.Class) && ((ClassSymbol)method.Parent).IsArray) {                      ClassSymbol arraySymbol = (ClassSymbol)method.Parent;                        if (method.Name.Equals("Clear"' StringComparison.Ordinal)) {                          // array.Clear() becomes array.length = 0 in generated code                            MemberSymbol lengthMember = arraySymbol.GetMember("Length");                          if (lengthMember == null) {                              lengthMember = arraySymbol.GetMember("Count");                          }                          Debug.Assert((lengthMember != null) && (lengthMember.Type == SymbolType.Field));                            MemberExpression lengthExpression =                              new MemberExpression(memberExpression.ObjectReference' lengthMember);                          return new BinaryExpression(Operator.Equals' TransformMemberExpression(lengthExpression)'                                                      new LiteralExpression(intType' 0));                      }                      if (method.Name.Equals("Contains"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            // array.Contains(item) becomes array.indexOf(item) >= 0                            MemberSymbol indexOfSymbol = arraySymbol.GetMember("IndexOf");                          Debug.Assert((indexOfSymbol != null) && (indexOfSymbol.Type == SymbolType.Method));                            MethodExpression indexOfExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)indexOfSymbol);                          indexOfExpression.AddParameterValue(args[0]);                            BinaryExpression compareExpression =                              new BinaryExpression(Operator.GreaterEqual' indexOfExpression' new LiteralExpression(intType' 0));                          compareExpression.AddParenthesisHint();                            return compareExpression;                      }                      if (method.Name.Equals("Insert"' StringComparison.Ordinal) ||                          method.Name.Equals("InsertRange"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 1);                            // array.Insert(index' item) becomes array.splice(index' 0' item);                            MemberSymbol spliceSymbol = arraySymbol.GetMember("Splice");                          Debug.Assert((spliceSymbol != null) && (spliceSymbol.Type == SymbolType.Method));                            MethodExpression spliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)spliceSymbol);                          spliceExpression.AddParameterValue(args[0]);                          spliceExpression.AddParameterValue(new LiteralExpression(intType' 0));                            for (int i = 1; i < args.Count; i++) {                              spliceExpression.AddParameterValue(args[i]);                          }                            return spliceExpression;                      }                      if (method.Name.Equals("RemoveAt"' StringComparison.Ordinal) ||                          method.Name.Equals("RemoveRange"' StringComparison.Ordinal)) {                          Debug.Assert((args.Count >= 1) && (args.Count <= 2));                            // array.RemoveAt(index) becomes array.splice(index' 1)                          // array.RemoveRange(index' count) becomes array.splice(index' count)                            MemberSymbol spliceSymbol = arraySymbol.GetMember("Splice");                          Debug.Assert((spliceSymbol != null) && (spliceSymbol.Type == SymbolType.Method));                            MethodExpression spliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)spliceSymbol);                          spliceExpression.AddParameterValue(args[0]);                          if (args.Count == 1) {                              spliceExpression.AddParameterValue(new LiteralExpression(intType' 1));                          }                          else {                              spliceExpression.AddParameterValue(args[1]);                          }                            return spliceExpression;                      }                      if (method.Name.Equals("GetRange"' StringComparison.Ordinal)) {                          Debug.Assert((args.Count == 2));                            // array.GetRange(index' count) becomes array.slice(index' index + count)                            MemberSymbol sliceSymbol = arraySymbol.GetMember("Slice");                          Debug.Assert((sliceSymbol != null) && (sliceSymbol.Type == SymbolType.Method));                            MethodExpression sliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)sliceSymbol);                          sliceExpression.AddParameterValue(args[0]);                            if ((args[0].Type == ExpressionType.Literal) &&                              (args[1].Type == ExpressionType.Literal)) {                              int endValue = (int)((LiteralExpression)args[0]).Value +                                              (int)((LiteralExpression)args[1]).Value;                              sliceExpression.AddParameterValue(new LiteralExpression(intType' endValue));                          }                          else {                              sliceExpression.AddParameterValue(new BinaryExpression(Operator.Plus' args[0]' args[1]));                          }                            return sliceExpression;                      }                  }                    methodExpression = new MethodExpression(memberExpression.ObjectReference' method);              }
Magic Number,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessOpenParenExpressionNode,The following statement contains a magic number: if (memberExpression.Member.Type != SymbolType.Method) {                  // A non-method member is being used in a method call; the member must be                  // a delegate...                  Debug.Assert(memberExpression.EvaluatedType.Type == SymbolType.Delegate);                  Expression instanceExpression = TransformMemberExpression(memberExpression);                    MethodSymbol invokeMethod =                      (MethodSymbol)memberExpression.EvaluatedType.GetMember("Invoke");                  Debug.Assert(invokeMethod != null);                    methodExpression = new MethodExpression(instanceExpression' invokeMethod);                  isDelegateInvoke = true;              }              else {                  // The member being accessed is a method...                    MethodSymbol method = (MethodSymbol)memberExpression.Member;                  if (!method.MatchesConditions(_options.Defines)) {                      return null;                  }                    if (method.Name.Equals("GetEnumerator"' StringComparison.Ordinal)) {                      // This is a bit dangerous - GetEnumerator on any type gets mapped to                      // Script.Enumerate. This actually somewhat matches c# semantics' where you                      // can perform a foreach on any type that has a GetEnumerator method' rather                      // than only types that implement IEnumerable.                        MethodSymbol enumerateMethod = (MethodSymbol)scriptType.GetMember("Enumerate");                      Debug.Assert(enumerateMethod != null);                        methodExpression = new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                              enumerateMethod);                      methodExpression.AddParameterValue(memberExpression.ObjectReference);                      methodExpression.Reevaluate(memberExpression.EvaluatedType);                        return methodExpression;                  }                    if ((method.Parent == objectType) &&                      (method.Name.Equals("ToString"' StringComparison.Ordinal) ||                      method.Name.Equals("ToLocaleString"' StringComparison.Ordinal))) {                      if (memberExpression.ObjectReference.EvaluatedType == stringType) {                          // No-op ToString calls on strings (this happens when performing a ToString                          // on a named enum value.                          return memberExpression.ObjectReference;                      }                      if (memberExpression.ObjectReference.EvaluatedType.Type == SymbolType.Enumeration) {                          EnumerationSymbol enumSymbol = (EnumerationSymbol)memberExpression.ObjectReference.EvaluatedType;                            if (enumSymbol.UseNamedValues) {                              // If the enum value is a named enum' then it is already a string.                              return memberExpression.ObjectReference;                          }                            return new MethodExpression(memberExpression.ObjectReference' method);                      }                  }                  else if ((method.Parent == dictionaryType) || (method.Parent == genericDictionaryType)) {                      if (method.Name.Equals("Remove"' StringComparison.Ordinal)) {                          // Switch the instance Remove method on Dictionary to                          // calls to the delete operator.                          Debug.Assert(args.Count == 1);                            return new LateBoundExpression(memberExpression.ObjectReference'                                                         args[0]' LateBoundOperation.DeleteField'                                                         objectType);                      }                      else if (method.Name.Equals("GetDictionary"' StringComparison.Ordinal)) {                          // Dictionary.GetDictionary is a no-op method; we're just interested                          // in the object being passed in.                          // However we'll re-evaluate the argument to be of dictionary type                          // so that subsequent use of this expression sees it as a dictionary.                          Debug.Assert(args.Count == 1);                          args[0].Reevaluate((TypeSymbol)method.Parent);                            return args[0];                      }                  }                  else if (method.Parent == scriptType) {                      if (method.Name.Equals("Literal"' StringComparison.Ordinal)) {                          // Convert a call to Script.Literal into a literal expression                            Debug.Assert(args.Count >= 1);                          string script = null;                            if (args[0].Type == ExpressionType.Field) {                              Debug.Assert(args[0].EvaluatedType == stringType);                                FieldSymbol field = ((FieldExpression)args[0]).Field;                              if (field.IsConstant) {                                  Debug.Assert(field.Value is string);                                  script = (string)field.Value;                              }                          }                          else if (args[0].Type == ExpressionType.Literal) {                              Debug.Assert(((LiteralExpression)args[0]).Value is string);                              script = (string)((LiteralExpression)args[0]).Value;                          }                            if (script == null) {                              // TODO: When we start raising errors at the expression level instead of the statement                              //       level' we should return an ErrorExpression instead of a dummy expression.                              Token argToken = argNodes.Expressions[0].Token;                                _errorHandler.ReportError("The argument to Script.Literal must be a constant string."'                                                        argToken.Location);                              return new InlineScriptExpression(""' objectType);                          }                            if (args.Count > 1) {                              // Check whether the script is a valid string format string                              try {                                  object[] argValues = new object[args.Count - 1];                                  String.Format(CultureInfo.InvariantCulture' script' argValues);                              }                              catch {                                  _errorHandler.ReportError("The argument to Script.Literal must be a valid String.Format string."'                                                            argNodes.Expressions[0].Token.Location);                                  return new InlineScriptExpression(""' objectType);                              }                          }                            InlineScriptExpression scriptExpression = new InlineScriptExpression(script' objectType);                          for (int i = 1; i < args.Count; i++) {                              scriptExpression.AddParameterValue(args[i]);                          }                            return scriptExpression;                      }                      else if (method.Name.Equals("Boolean"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' new UnaryExpression(Operator.LogicalNot' args[0]));                      }                      else if (method.Name.Equals("IsTruthy"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' new UnaryExpression(Operator.LogicalNot' args[0]));                      }                      else if (method.Name.Equals("IsFalsey"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            args[0].AddParenthesisHint();                          return new UnaryExpression(Operator.LogicalNot' args[0]);                      }                      else if (method.Name.Equals("Or"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 2);                            Expression expr = args[0];                          for (int i = 1; i < args.Count; i++) {                              expr = new BinaryExpression(Operator.LogicalOr' expr' args[i]);                          }                            expr.Reevaluate(args[0].EvaluatedType);                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsNull"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            Expression expr = new BinaryExpression(Operator.EqualEqualEqual' args[0]'                                                                 new LiteralExpression(objectType' null));                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsUndefined"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            MemberSymbol undefinedMember = scriptType.GetMember("Undefined");                          Debug.Assert(undefinedMember != null);                            MemberExpression undefinedExpression =                              new MemberExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                   undefinedMember);                            Expression expr = new BinaryExpression(Operator.EqualEqualEqual' args[0]' TransformMemberExpression(undefinedExpression));                          expr.AddParenthesisHint();                            return expr;                      }                      else if (method.Name.Equals("IsNullOrUndefined"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            MethodSymbol isValueMethod = (MethodSymbol)scriptType.GetMember("IsValue");                          Debug.Assert(isValueMethod != null);                            methodExpression = new MethodExpression(new TypeExpression(scriptType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                                  isValueMethod);                          methodExpression.AddParameterValue(args[0]);                            return new UnaryExpression(Operator.LogicalNot' methodExpression);                      }                      else if (method.Name.Equals("CreateInstance"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 1);                            if ((args[0].Type == ExpressionType.MethodInvoke) ||                              (args[0].Type == ExpressionType.PropertyGet)) {                              // When using the result of a method call/property access directly                              // with Type.CreateInstance' the following script would be generated:                              //                              // new method()()                              // which is invalid. Instead we need to generate the following:                              // var type = method();                              // new type()                                _errorHandler.ReportError("You must store the type returned from a method or property into a local variable to use with Type.CreateInstance."'                                                        node.Token.Location);                          }                            NewExpression newExpression = new NewExpression(args[0]' objectType);                          if (args.Count > 1) {                              bool first = true;                              foreach (Expression paramExpr in args) {                                  if (first) {                                      first = false;                                      continue;                                  }                                  newExpression.AddParameterValue(paramExpr);                              }                          }                          return newExpression;                      }                        bool lateBound = false;                      LateBoundOperation lateBoundOperation = LateBoundOperation.InvokeMethod;                        if (method.Name.Equals("InvokeMethod"' StringComparison.Ordinal)) {                          lateBound = true;                      }                      else if (method.Name.Equals("DeleteField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.DeleteField;                      }                      else if (method.Name.Equals("GetField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.GetField;                      }                      else if (method.Name.Equals("SetField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.SetField;                      }                      else if (method.Name.Equals("GetScriptType"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.GetScriptType;                      }                      else if (method.Name.Equals("HasField"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.HasField;                      }                      else if (method.Name.Equals("HasMethod"' StringComparison.Ordinal)) {                          lateBound = true;                          lateBoundOperation = LateBoundOperation.HasMethod;                      }                        if (lateBound) {                          // Switch explicit late-bound calls into implicit late-bound expressions                          // in script                          Debug.Assert((args != null) &&                                       (((lateBoundOperation == LateBoundOperation.GetScriptType) && (args.Count == 1)) ||                                       (args.Count >= 2)));                            LateBoundExpression lateBoundExpression = null;                          Expression instanceExpression = null;                          Expression nameExpression = null;                            foreach (Expression paramExpr in args) {                              if (instanceExpression == null) {                                  instanceExpression = paramExpr;                                    if (lateBoundOperation == LateBoundOperation.GetScriptType) {                                      // GetScriptType only takes an instance                                      return new LateBoundExpression(instanceExpression' null'                                                                      lateBoundOperation' objectType);                                  }                                  continue;                              }                              if (nameExpression == null) {                                  nameExpression = paramExpr;                                    Expression objectExpression = instanceExpression;                                  if (lateBoundOperation == LateBoundOperation.InvokeMethod) {                                      if ((instanceExpression.Type == ExpressionType.Literal) &&                                          (((LiteralExpression)instanceExpression).Value == null)) {                                          objectExpression = null;                                            LiteralExpression literalExpression = nameExpression as LiteralExpression;                                          if (literalExpression == null) {                                              _errorHandler.ReportError("The name of a global method must be a constant string known at compile time."'                                                                          argNodes.Expressions[0].Token.Location);                                          }                                          else if (!Utility.IsValidIdentifier((string)literalExpression.Value)) {                                              _errorHandler.ReportError("The name of a global method must be a valid identifer."'                                                                          argNodes.Expressions[0].Token.Location);                                          }                                      }                                  }                                    lateBoundExpression = new LateBoundExpression(objectExpression' nameExpression'                                                                                  lateBoundOperation' objectType);                                  continue;                              }                                lateBoundExpression.AddParameterValue(paramExpr);                          }                            Debug.Assert(lateBoundExpression != null);                          return lateBoundExpression;                      }                  }                  else if (method.Parent == argsType) {                      if (method.Name.Equals("GetArgument"' StringComparison.Ordinal)) {                          // Switch Arguments.GetArgument into Arguments[]                          Debug.Assert(args.Count == 1);                            IndexerExpression indexExpression =                              new IndexerExpression(new LiteralExpression(typeType' method.Parent)'                                                    ((ClassSymbol)method.Parent).GetIndexer());                          indexExpression.AddIndexParameterValue(args[0]);                            return indexExpression;                      }                      else if (method.Name.Equals("ToArray"' StringComparison.Ordinal)) {                          // Switch Arguments.ToArray into Array.ToArray(arguments)                            TypeSymbol arrayType = _symbolSet.ResolveIntrinsicType(IntrinsicType.Array);                          MethodSymbol toArrayMethod = (MethodSymbol)arrayType.GetMember("ToArray");                            InlineScriptExpression argsExpression =                              new InlineScriptExpression("arguments"' objectType' /* parenthesize */ false);                          MethodExpression toArrayExpression =                              new MethodExpression(new TypeExpression(arrayType' SymbolFilter.Public | SymbolFilter.StaticMembers)'                                                   toArrayMethod);                          toArrayExpression.AddParameterValue(argsExpression);                            return toArrayExpression;                      }                  }                  else if ((method.Parent.Type == SymbolType.Class) && ((ClassSymbol)method.Parent).IsArray) {                      ClassSymbol arraySymbol = (ClassSymbol)method.Parent;                        if (method.Name.Equals("Clear"' StringComparison.Ordinal)) {                          // array.Clear() becomes array.length = 0 in generated code                            MemberSymbol lengthMember = arraySymbol.GetMember("Length");                          if (lengthMember == null) {                              lengthMember = arraySymbol.GetMember("Count");                          }                          Debug.Assert((lengthMember != null) && (lengthMember.Type == SymbolType.Field));                            MemberExpression lengthExpression =                              new MemberExpression(memberExpression.ObjectReference' lengthMember);                          return new BinaryExpression(Operator.Equals' TransformMemberExpression(lengthExpression)'                                                      new LiteralExpression(intType' 0));                      }                      if (method.Name.Equals("Contains"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count == 1);                            // array.Contains(item) becomes array.indexOf(item) >= 0                            MemberSymbol indexOfSymbol = arraySymbol.GetMember("IndexOf");                          Debug.Assert((indexOfSymbol != null) && (indexOfSymbol.Type == SymbolType.Method));                            MethodExpression indexOfExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)indexOfSymbol);                          indexOfExpression.AddParameterValue(args[0]);                            BinaryExpression compareExpression =                              new BinaryExpression(Operator.GreaterEqual' indexOfExpression' new LiteralExpression(intType' 0));                          compareExpression.AddParenthesisHint();                            return compareExpression;                      }                      if (method.Name.Equals("Insert"' StringComparison.Ordinal) ||                          method.Name.Equals("InsertRange"' StringComparison.Ordinal)) {                          Debug.Assert(args.Count >= 1);                            // array.Insert(index' item) becomes array.splice(index' 0' item);                            MemberSymbol spliceSymbol = arraySymbol.GetMember("Splice");                          Debug.Assert((spliceSymbol != null) && (spliceSymbol.Type == SymbolType.Method));                            MethodExpression spliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)spliceSymbol);                          spliceExpression.AddParameterValue(args[0]);                          spliceExpression.AddParameterValue(new LiteralExpression(intType' 0));                            for (int i = 1; i < args.Count; i++) {                              spliceExpression.AddParameterValue(args[i]);                          }                            return spliceExpression;                      }                      if (method.Name.Equals("RemoveAt"' StringComparison.Ordinal) ||                          method.Name.Equals("RemoveRange"' StringComparison.Ordinal)) {                          Debug.Assert((args.Count >= 1) && (args.Count <= 2));                            // array.RemoveAt(index) becomes array.splice(index' 1)                          // array.RemoveRange(index' count) becomes array.splice(index' count)                            MemberSymbol spliceSymbol = arraySymbol.GetMember("Splice");                          Debug.Assert((spliceSymbol != null) && (spliceSymbol.Type == SymbolType.Method));                            MethodExpression spliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)spliceSymbol);                          spliceExpression.AddParameterValue(args[0]);                          if (args.Count == 1) {                              spliceExpression.AddParameterValue(new LiteralExpression(intType' 1));                          }                          else {                              spliceExpression.AddParameterValue(args[1]);                          }                            return spliceExpression;                      }                      if (method.Name.Equals("GetRange"' StringComparison.Ordinal)) {                          Debug.Assert((args.Count == 2));                            // array.GetRange(index' count) becomes array.slice(index' index + count)                            MemberSymbol sliceSymbol = arraySymbol.GetMember("Slice");                          Debug.Assert((sliceSymbol != null) && (sliceSymbol.Type == SymbolType.Method));                            MethodExpression sliceExpression =                              new MethodExpression(memberExpression.ObjectReference' (MethodSymbol)sliceSymbol);                          sliceExpression.AddParameterValue(args[0]);                            if ((args[0].Type == ExpressionType.Literal) &&                              (args[1].Type == ExpressionType.Literal)) {                              int endValue = (int)((LiteralExpression)args[0]).Value +                                              (int)((LiteralExpression)args[1]).Value;                              sliceExpression.AddParameterValue(new LiteralExpression(intType' endValue));                          }                          else {                              sliceExpression.AddParameterValue(new BinaryExpression(Operator.Plus' args[0]' args[1]));                          }                            return sliceExpression;                      }                  }                    methodExpression = new MethodExpression(memberExpression.ObjectReference' method);              }
Magic Number,ScriptSharp.Validator,NewNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\NewNodeValidator.cs,Validate,The following statement contains a magic number: if ((typeNode != null) && (typeNode.Name.Equals("Dictionary"))) {                  if (newNode.Arguments != null) {                      Debug.Assert(newNode.Arguments is ExpressionListNode);                      ParseNodeList arguments = ((ExpressionListNode)newNode.Arguments).Expressions;                        if (arguments.Count != 0) {                          if (arguments.Count % 2 != 0) {                              errorHandler.ReportError("Missing value parameter for the last name parameter in Dictionary instantiation."'                                                       newNode.Token.Location);                          }                            for (int i = 0; i < arguments.Count; i += 2) {                              ParseNode nameArgumentNode = arguments[i];                              if ((nameArgumentNode.NodeType != ParseNodeType.Literal) ||                                  (((LiteralNode)nameArgumentNode).Literal.LiteralType != LiteralTokenType.String)) {                                  errorHandler.ReportError("Name parameters in Dictionary instantiation must be string literals."'                                                           nameArgumentNode.Token.Location);                              }                          }                      }                  }              }
Magic Number,ScriptSharp.Validator,NewNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\NewNodeValidator.cs,Validate,The following statement contains a magic number: if ((typeNode != null) && (typeNode.Name.Equals("Dictionary"))) {                  if (newNode.Arguments != null) {                      Debug.Assert(newNode.Arguments is ExpressionListNode);                      ParseNodeList arguments = ((ExpressionListNode)newNode.Arguments).Expressions;                        if (arguments.Count != 0) {                          if (arguments.Count % 2 != 0) {                              errorHandler.ReportError("Missing value parameter for the last name parameter in Dictionary instantiation."'                                                       newNode.Token.Location);                          }                            for (int i = 0; i < arguments.Count; i += 2) {                              ParseNode nameArgumentNode = arguments[i];                              if ((nameArgumentNode.NodeType != ParseNodeType.Literal) ||                                  (((LiteralNode)nameArgumentNode).Literal.LiteralType != LiteralTokenType.String)) {                                  errorHandler.ReportError("Name parameters in Dictionary instantiation must be string literals."'                                                           nameArgumentNode.Token.Location);                              }                          }                      }                  }              }
Magic Number,ScriptSharp.Generator,ExpressionGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\ExpressionGenerator.cs,GenerateExpressionListAsNameValuePairs,The following statement contains a magic number: Debug.Assert(expressions.Count % 2 == 0);
Magic Number,ScriptSharp.ResourceModel,ResourcesBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ResourcesBuilder.cs,BuildResources,The following statement contains a magic number: foreach (IStreamSource source in sources) {                  string locale = Utility.GetResourceFileLocale(source.Name);                    if (locale.Length == 2) {                      BuildResources(source);                  }              }
Magic Number,ScriptSharp.ResourceModel,ResourcesBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ResourcesBuilder.cs,BuildResources,The following statement contains a magic number: foreach (IStreamSource source in sources) {                  string locale = Utility.GetResourceFileLocale(source.Name);                    if (locale.Length > 2) {                      BuildResources(source);                  }              }
Missing Default,ScriptSharp.Importer.IL,AssemblyNameReference,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyNameReference.cs,Parse,The following switch statement is missing a default case: switch (parts [0]) {  				case "Version":  					name.Version = new Version (parts [1]);  					break;  				case "Culture":  					name.Culture = parts [1];  					break;  				case "PublicKeyToken":  					string pk_token = parts [1];  					if (pk_token == "null")  						break;    					name.PublicKeyToken = new byte [pk_token.Length / 2];  					for (int j = 0; j < name.PublicKeyToken.Length; j++) {  						name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  					}  					break;  				}
Missing Default,ScriptSharp.Importer.IL,MetadataReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\AssemblyReader.cs,ReadExportedTypes,The following switch statement is missing a default case: switch (implementation.TokenType) {  				case TokenType.AssemblyRef:  				case TokenType.File:  					scope = GetExportedTypeScope (implementation);  					break;  				case TokenType.ExportedType:  					// FIXME: if the table is not properly sorted  					declaring_type = exported_types [(int) implementation.RID - 1];  					break;  				}
Missing Default,ScriptSharp.Importer.IL,Mixin,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\CustomAttribute.cs,IsTypeSpecification,The following switch statement is missing a default case: switch (type.etype) {  			case ElementType.Array:  			case ElementType.ByRef:  			case ElementType.CModOpt:  			case ElementType.CModReqD:  			case ElementType.FnPtr:  			case ElementType.GenericInst:  			case ElementType.MVar:  			case ElementType.Pinned:  			case ElementType.Ptr:  			case ElementType.SzArray:  			case ElementType.Sentinel:  			case ElementType.Var:  				return true;  			}
Missing Default,ScriptSharp.Importer.IL,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Import.cs,ImportScope,The following switch statement is missing a default case: switch (scope.MetadataScopeType) {  			case MetadataScopeType.AssemblyNameReference:  				return ImportAssemblyName ((AssemblyNameReference) scope);  			case MetadataScopeType.ModuleDefinition:  				return ImportAssemblyName (((ModuleDefinition) scope).Assembly.Name);  			case MetadataScopeType.ModuleReference:  				throw new NotImplementedException ();  			}
Missing Default,ScriptSharp.Importer.IL,MetadataImporter,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Import.cs,ImportTypeSpecification,The following switch statement is missing a default case: switch (type.etype) {  			case ElementType.SzArray:  				var vector = (ArrayType) type;  				return new ArrayType (ImportType (vector.ElementType' context));  			case ElementType.Ptr:  				var pointer = (PointerType) type;  				return new PointerType (ImportType (pointer.ElementType' context));  			case ElementType.ByRef:  				var byref = (ByReferenceType) type;  				return new ByReferenceType (ImportType (byref.ElementType' context));  			case ElementType.Pinned:  				var pinned = (PinnedType) type;  				return new PinnedType (ImportType (pinned.ElementType' context));  			case ElementType.Sentinel:  				var sentinel = (SentinelType) type;  				return new SentinelType (ImportType (sentinel.ElementType' context));  			case ElementType.CModOpt:  				var modopt = (OptionalModifierType) type;  				return new OptionalModifierType (  					ImportType (modopt.ModifierType' context)'  					ImportType (modopt.ElementType' context));  			case ElementType.CModReqD:  				var modreq = (RequiredModifierType) type;  				return new RequiredModifierType (  					ImportType (modreq.ModifierType' context)'  					ImportType (modreq.ElementType' context));  			case ElementType.Array:  				var array = (ArrayType) type;  				var imported_array = new ArrayType (ImportType (array.ElementType' context));  				if (array.IsVector)  					return imported_array;    				var dimensions = array.Dimensions;  				var imported_dimensions = imported_array.Dimensions;    				imported_dimensions.Clear ();    				for (int i = 0; i < dimensions.Count; i++) {  					var dimension = dimensions [i];    					imported_dimensions.Add (new ArrayDimension (dimension.LowerBound' dimension.UpperBound));  				}    				return imported_array;  			case ElementType.GenericInst:  				var instance = (GenericInstanceType) type;  				var element_type = ImportType (instance.ElementType' context);  				var imported_instance = new GenericInstanceType (element_type);    				var arguments = instance.GenericArguments;  				var imported_arguments = imported_instance.GenericArguments;    				for (int i = 0; i < arguments.Count; i++)  					imported_arguments.Add (ImportType (arguments [i]' context));    				return imported_instance;  			case ElementType.Var:  				if (context == null || context.Type == null)  					throw new InvalidOperationException ();    				return ((TypeReference) context.Type).GetElementType ().GenericParameters [((GenericParameter) type).Position];  			case ElementType.MVar:  				if (context == null || context.Method == null)  					throw new InvalidOperationException ();    				return context.Method.GenericParameters [((GenericParameter) type).Position];  			}
Missing Default,ScriptSharp.Importer.IL,MetadataResolver,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\MetadataResolver.cs,Resolve,The following switch statement is missing a default case: switch (scope.MetadataScopeType) {  			case MetadataScopeType.AssemblyNameReference:  				var assembly = resolver.Resolve ((AssemblyNameReference) scope);  				if (assembly == null)  					return null;    				return GetType (resolver' assembly.MainModule' type);  			case MetadataScopeType.ModuleDefinition:  				return GetType (resolver' (ModuleDefinition) scope' type);  			case MetadataScopeType.ModuleReference:  				var modules = type.Module.Assembly.Modules;  				var module_ref = (ModuleReference) scope;  				for (int i = 0; i < modules.Count; i++) {  					var netmodule = modules [i];  					if (netmodule.Name == module_ref.Name)  						return GetType (resolver' netmodule' type);  				}  				break;  			}
Missing Default,ScriptSharp.Importer.IL,TypeParser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\TypeParser.cs,GetScopeFullName,The following switch statement is missing a default case: switch (scope.MetadataScopeType) {  			case MetadataScopeType.AssemblyNameReference:  				return ((AssemblyNameReference) scope).FullName;  			case MetadataScopeType.ModuleDefinition:  				return ((ModuleDefinition) scope).Assembly.Name.FullName;  			}
Missing Default,ScriptSharp.Importer.IL.Cil,CodeReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\Cil\CodeReader.cs,ResolveBranches,The following switch statement is missing a default case: switch (instruction.opcode.OperandType) {  				case OperandType.ShortInlineBrTarget:  				case OperandType.InlineBrTarget:  					instruction.operand = GetInstruction ((int) instruction.operand);  					break;  				case OperandType.InlineSwitch:  					var offsets = (int []) instruction.operand;  					var branches = new Instruction [offsets.Length];  					for (int j = 0; j < offsets.Length; j++)  						branches [j] = GetInstruction (offsets [j]);    					instruction.operand = branches;  					break;  				}
Missing Default,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadArchitecture,The following switch statement is missing a default case: switch (machine) {  			case 0x014c:  				return TargetArchitecture.I386;  			case 0x8664:  				return TargetArchitecture.AMD64;  			case 0x0200:  				return TargetArchitecture.IA64;  			}
Missing Default,ScriptSharp.Importer.IL.PE,ImageReader,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Importer\IL\PE\ImageReader.cs,ReadMetadataStream,The following switch statement is missing a default case: switch (name) {  			case "#~":  			case "#-":  				image.TableHeap = new TableHeap (section' start' size);  				break;  			case "#Strings":  				image.StringHeap = new StringHeap (section' start' size);  				break;  			case "#Blob":  				image.BlobHeap = new BlobHeap (section' start' size);  				break;  			case "#GUID":  				image.GuidHeap = new GuidHeap (section' start' size);  				break;  			case "#US":  				image.UserStringHeap = new UserStringHeap (section' start' size);  				break;  			}
Missing Default,ScriptSharp.ScriptModel,SymbolSetDumper,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\SymbolSetDumper.cs,DumpMember,The following switch statement is missing a default case: switch (memberSymbol.Type) {                  case SymbolType.Field:                      DumpField((FieldSymbol)memberSymbol);                      break;                  case SymbolType.EnumerationField:                      DumpEnumerationField((EnumerationFieldSymbol)memberSymbol);                      break;                  case SymbolType.Constructor:                      DumpConstructor((ConstructorSymbol)memberSymbol);                      break;                  case SymbolType.Property:                      DumpProperty((PropertySymbol)memberSymbol);                      break;                  case SymbolType.Indexer:                      DumpIndexer((IndexerSymbol)memberSymbol);                      break;                  case SymbolType.Event:                      DumpEvent((EventSymbol)memberSymbol);                      break;                  case SymbolType.Method:                      DumpMethod((MethodSymbol)memberSymbol);                      break;              }
Missing Default,ScriptSharp.ScriptModel,SymbolSetDumper,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\SymbolSetDumper.cs,DumpSymbol,The following switch statement is missing a default case: switch (symbol.Type) {                  case SymbolType.Namespace:                      DumpNamespace((NamespaceSymbol)symbol);                      break;                  case SymbolType.Class:                  case SymbolType.Interface:                  case SymbolType.Enumeration:                  case SymbolType.Delegate:                  case SymbolType.Record:                      DumpType((TypeSymbol)symbol);                      break;                  case SymbolType.Field:                  case SymbolType.EnumerationField:                  case SymbolType.Constructor:                  case SymbolType.Property:                  case SymbolType.Indexer:                  case SymbolType.Event:                  case SymbolType.Method:                      DumpMember((MemberSymbol)symbol);                      break;                  case SymbolType.Parameter:                      DumpParameter((ParameterSymbol)symbol);                      break;              }
Missing Default,ScriptSharp.ScriptModel,SymbolSetDumper,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\SymbolSetDumper.cs,DumpType,The following switch statement is missing a default case: switch (typeSymbol.Type) {                  case SymbolType.Class:                  case SymbolType.Record:                      DumpClass((ClassSymbol)typeSymbol);                      break;                  case SymbolType.Interface:                      DumpInterface((InterfaceSymbol)typeSymbol);                      break;                  case SymbolType.Enumeration:                      DumpEnumeration((EnumerationSymbol)typeSymbol);                      break;                  case SymbolType.Delegate:                      DumpDelegate((DelegateSymbol)typeSymbol);                      break;              }
Missing Default,ScriptSharp.ScriptModel,SymbolSet,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\ScriptModel\Symbols\SymbolSet.cs,ResolveType,The following switch statement is missing a default case: switch (intrinsicTypeNode.Type) {                      case TokenType.Object:                          intrinsicType = IntrinsicType.Object;                          break;                      case TokenType.Bool:                          intrinsicType = IntrinsicType.Boolean;                          break;                      case TokenType.String:                      case TokenType.Char:                          intrinsicType = IntrinsicType.String;                          break;                      case TokenType.Int:                          intrinsicType = IntrinsicType.Integer;                          break;                      case TokenType.UInt:                          intrinsicType = IntrinsicType.UnsignedInteger;                          break;                      case TokenType.Long:                          intrinsicType = IntrinsicType.Long;                          break;                      case TokenType.ULong:                          intrinsicType = IntrinsicType.UnsignedLong;                          break;                      case TokenType.Short:                          intrinsicType = IntrinsicType.Short;                          break;                      case TokenType.UShort:                          intrinsicType = IntrinsicType.UnsignedShort;                          break;                      case TokenType.Byte:                          intrinsicType = IntrinsicType.Byte;                          break;                      case TokenType.SByte:                          intrinsicType = IntrinsicType.SignedByte;                          break;                      case TokenType.Float:                          intrinsicType = IntrinsicType.Single;                          break;                      case TokenType.Decimal:                          intrinsicType = IntrinsicType.Decimal;                          break;                      case TokenType.Double:                          intrinsicType = IntrinsicType.Double;                          break;                      case TokenType.Delegate:                          intrinsicType = IntrinsicType.Delegate;                          break;                      case TokenType.Void:                          intrinsicType = IntrinsicType.Void;                          break;                  }
Missing Default,ScriptSharp.Parser,FileLexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\FileLexer.cs,LexBlock,The following switch statement is missing a default case: switch (line.Type) {                          case PreprocessorTokenType.Define:                          case PreprocessorTokenType.Undef:                          case PreprocessorTokenType.Warning:                          case PreprocessorTokenType.Error:                          case PreprocessorTokenType.Line:                          case PreprocessorTokenType.Default:                          case PreprocessorTokenType.Hidden:                          case PreprocessorTokenType.Pragma:                              DoSimpleLine(line);                              break;                            case PreprocessorTokenType.Region:                              line = LexBlock();                              if (line.Type == PreprocessorTokenType.EndRegion) {                                  break;                              }                              else {                                  ReportError(PreprocessorError.EndRegionExpected);                                  goto DoLine;                              }                            case PreprocessorTokenType.If:                              line = DoIf((PreprocessorIfLine)line);                              if (line != null) {                                  goto DoLine;                              }                              break;                            case PreprocessorTokenType.EndRegion:                          case PreprocessorTokenType.Elif:                          case PreprocessorTokenType.Else:                          case PreprocessorTokenType.Endif:                          case PreprocessorTokenType.EndOfLine:                              return line;                      }
Missing Default,ScriptSharp.Parser,FileLexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\FileLexer.cs,SkipBlock,The following switch statement is missing a default case: switch (line.Type) {                      case PreprocessorTokenType.Define:                      case PreprocessorTokenType.Undef:                      case PreprocessorTokenType.Warning:                      case PreprocessorTokenType.Error:                      case PreprocessorTokenType.Line:                          line = null;                          break;                        case PreprocessorTokenType.Region:                          line = SkipBlock();                          if (line.Type != PreprocessorTokenType.EndRegion) {                              ReportError(PreprocessorError.EndRegionExpected);                              goto DoLine;                          }                          else {                              line = null;                              break;                          }                        case PreprocessorTokenType.If:                          line = SkipElifBlock();                          if (line != null) {                              goto DoLine;                          }                          break;                        case PreprocessorTokenType.EndRegion:                      case PreprocessorTokenType.Endif:                      case PreprocessorTokenType.Else:                      case PreprocessorTokenType.Elif:                      case PreprocessorTokenType.EndOfLine:                          break;                  }
Missing Default,ScriptSharp.Parser,Lexer,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Lexer.cs,NextToken,The following switch statement is missing a default case: switch (suffix) {                                      case NumericSuffix.F: {                                              float f = float.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new FloatToken(f' _path' TakePosition());                                          }                                        case NumericSuffix.D:                                      case NumericSuffix.None: {                                              double d = double.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new DoubleToken(d' _path' TakePosition());                                          }                                        case NumericSuffix.M: {                                              decimal dec = decimal.Parse(_value.ToString()' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture);                                              return new DecimalToken(dec' _path' TakePosition());                                          }                                  }
Missing Default,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseTypeDeclaration,The following switch statement is missing a default case: switch (PeekType()) {                  case TokenType.Class:                      return ParseTypeDeclaration(token' attributes' CheckModifiers(Modifiers.ClassModifiers' modifiers));                  case TokenType.Struct:                      return ParseTypeDeclaration(token' attributes' CheckModifiers(Modifiers.StructModifiers' modifiers));                  case TokenType.Interface:                      return ParseTypeDeclaration(token' attributes' CheckModifiers(Modifiers.InterfaceModifiers' modifiers));                  case TokenType.Enum:                      return ParseTypeDeclaration(token' attributes' CheckModifiers(Modifiers.EnumModifiers' modifiers));                    case TokenType.Delegate:                      NextToken();                      return ParseDelegate(token' attributes' CheckModifiers(Modifiers.DelegateModifiers' modifiers));              }
Missing Default,ScriptSharp.Parser,Parser,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Parser\Parser.cs,ParseUnaryExpression,The following switch statement is missing a default case: switch (PeekType()) {                  case TokenType.Plus:                  case TokenType.Minus:                  case TokenType.Bang:                  case TokenType.Tilde:                  case TokenType.PlusPlus:                  case TokenType.MinusMinus:                  case TokenType.Star:                  case TokenType.Ampersand:                      return new UnaryExpressionNode(NextToken()' ParseUnaryExpression());                    case TokenType.OpenParen:                      // check for cast expression                      if (ScanCast()) {                          return ParseCastExpression();                      }                      break;              }
Missing Default,ScriptSharp.Compiler,CodeBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\CodeBuilder.cs,BuildCode,The following switch statement is missing a default case: switch (type.Type) {                          case SymbolType.Class:                              BuildCode((ClassSymbol)type);                              break;                          case SymbolType.Record:                              if (((RecordSymbol)type).Constructor != null) {                                  BuildCode(((RecordSymbol)type).Constructor);                              }                              break;                      }
Missing Default,ScriptSharp.Compiler,CodeBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\CodeBuilder.cs,BuildCode,The following switch statement is missing a default case: switch (memberSymbol.Type) {                      case SymbolType.Event:                          BuildCode((EventSymbol)memberSymbol);                          break;                      case SymbolType.Field:                          BuildCode((FieldSymbol)memberSymbol);                          break;                      case SymbolType.Method:                          BuildCode((MethodSymbol)memberSymbol);                          break;                      case SymbolType.Property:                          BuildCode((PropertySymbol)memberSymbol);                          break;                  }
Missing Default,ScriptSharp.Compiler,MetadataBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\MetadataBuilder.cs,BuildMembers,The following switch statement is missing a default case: switch (member.NodeType) {                      case ParseNodeType.FieldDeclaration:                      case ParseNodeType.ConstFieldDeclaration:                          memberSymbol = BuildField((FieldDeclarationNode)member' typeSymbol);                          break;                      case ParseNodeType.PropertyDeclaration:                          memberSymbol = BuildPropertyAsField((PropertyDeclarationNode)member' typeSymbol);                          if (memberSymbol == null) {                              memberSymbol = BuildProperty((PropertyDeclarationNode)member' typeSymbol);                          }                          break;                      case ParseNodeType.IndexerDeclaration:                          memberSymbol = BuildIndexer((IndexerDeclarationNode)member' typeSymbol);                          break;                      case ParseNodeType.ConstructorDeclaration:                      case ParseNodeType.MethodDeclaration:                          if ((member.Modifiers & Modifiers.Extern) != 0) {                              // Extern methods are there for defining overload signatures' so                              // we just skip them as far as metadata goes. The validator has                              // taken care of the requirements/constraints around use of extern methods.                              continue;                          }                          memberSymbol = BuildMethod((MethodDeclarationNode)member' typeSymbol);                          break;                      case ParseNodeType.EventDeclaration:                          memberSymbol = BuildEvent((EventDeclarationNode)member' typeSymbol);                          break;                      case ParseNodeType.EnumerationFieldDeclaration:                          memberSymbol = BuildEnumField((EnumerationFieldNode)member' typeSymbol);                          break;                  }
Missing Default,ScriptSharp.Compiler,StatementBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\StatementBuilder.cs,BuildStatementCore,The following switch statement is missing a default case: switch (statementNode.NodeType) {                  case ParseNodeType.Block:                      statement = ProcessBlockStatement((BlockStatementNode)statementNode);                      break;                  case ParseNodeType.EmptyStatement:                      statement = new EmptyStatement();                      break;                  case ParseNodeType.VariableDeclaration:                  case ParseNodeType.ConstDeclaration:                      statement = ProcessVariableDeclarationStatement((VariableDeclarationNode)statementNode);                      break;                  case ParseNodeType.Return:                      statement = ProcessReturnStatement((ReturnNode)statementNode);                      break;                  case ParseNodeType.ExpressionStatement:                      statement = ProcessExpressionStatement((ExpressionStatementNode)statementNode);                      break;                  case ParseNodeType.IfElse:                      statement = ProcessIfElseStatement((IfElseNode)statementNode);                      break;                  case ParseNodeType.While:                      statement = ProcessWhileStatement((WhileNode)statementNode);                      break;                  case ParseNodeType.DoWhile:                      statement = ProcessDoWhileStatement((DoWhileNode)statementNode);                      break;                  case ParseNodeType.For:                      statement = ProcessForStatement((ForNode)statementNode);                      break;                  case ParseNodeType.Foreach:                      statement = ProcessForeachStatement((ForeachNode)statementNode);                      break;                  case ParseNodeType.Switch:                      statement = ProcessSwitchStatement((SwitchNode)statementNode);                      break;                  case ParseNodeType.Break:                      statement = new BreakStatement();                      break;                  case ParseNodeType.Continue:                      statement = new ContinueStatement();                      break;                  case ParseNodeType.Throw:                      statement = ProcessThrowStatement((ThrowNode)statementNode);                      break;                  case ParseNodeType.Try:                      statement = ProcessTryCatchFinallyStatement((TryNode)statementNode);                      break;              }
Missing Default,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessBinaryExpressionNode,The following switch statement is missing a default case: switch (node.Operator) {                  case TokenType.EqualEqual:                  case TokenType.NotEqual:                  case TokenType.Less:                  case TokenType.LessEqual:                  case TokenType.Greater:                  case TokenType.GreaterEqual:                  case TokenType.Is:                      resultType = _symbolSet.ResolveIntrinsicType(IntrinsicType.Boolean);                      break;                  case TokenType.As:                      resultType = rightExpression.EvaluatedType;                      break;                  case TokenType.Plus:                      if (rightExpression.EvaluatedType == _symbolSet.ResolveIntrinsicType(IntrinsicType.String)) {                          resultType = rightExpression.EvaluatedType;                      }                      break;                  case TokenType.Slash:                      resultType = _symbolSet.ResolveIntrinsicType(IntrinsicType.Double);                      break;              }
Missing Default,ScriptSharp.Compiler,ExpressionBuilder,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Compiler\ExpressionBuilder.cs,ProcessBinaryExpressionNode,The following switch statement is missing a default case: switch (operatorType) {                              case Operator.BitwiseAndEquals:                                  baseOperatorType = Operator.BitwiseAnd;                                  break;                              case Operator.BitwiseOrEquals:                                  baseOperatorType = Operator.BitwiseOr;                                  break;                              case Operator.BitwiseXorEquals:                                  baseOperatorType = Operator.BitwiseXor;                                  break;                          }
Missing Default,ScriptSharp.Validator,UnsupportedParseNodeValidator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Validator\UnsupportedParseNodeValidator.cs,Validate,The following switch statement is missing a default case: switch (node.NodeType) {                  case ParseNodeType.PointerType:                      message = "Pointer types";                      break;                  case ParseNodeType.OperatorDeclaration:                      message = "Operator overloads";                      break;                  case ParseNodeType.DestructorDeclaration:                      message = "Type destructors";                      break;                  case ParseNodeType.Goto:                      message = "Goto statements";                      break;                  case ParseNodeType.Using:                      message = "Using statements";                      break;                  case ParseNodeType.Lock:                      message = "Lock statements";                      break;                  case ParseNodeType.UnsafeStatement:                      message = "Unsafe statements";                      break;                  case ParseNodeType.LabeledStatement:                      message = "Labeled statements";                      break;                  case ParseNodeType.YieldReturn:                      message = "Yield return statements";                      break;                  case ParseNodeType.YieldBreak:                      message = "Yield break statements";                      break;                  case ParseNodeType.Checked:                      message = "Checked expressions";                      break;                  case ParseNodeType.Unchecked:                      message = "Unchecked expressions";                      break;                  case ParseNodeType.Sizeof:                      message = "Sizeof expressions";                      break;                  case ParseNodeType.Fixed:                      message = "Fixed expressions";                      break;                  case ParseNodeType.StackAlloc:                      message = "Stackalloc expressions";                      break;                  case ParseNodeType.DefaultValueExpression:                      message = "Default value expressions";                      break;                  case ParseNodeType.ExternAlias:                      message = "Extern aliases";                      break;                  case ParseNodeType.AliasQualifiedName:                      message = "Alias-qualified identifiers";                      break;                  case ParseNodeType.TypeParameter:                      message = "Generic type parameters";                      break;                  case ParseNodeType.ConstraintClause:                      message = "Generic type constraints";                      break;                  case ParseNodeType.GenericName:                      message = "Generic types";                      break;              }
Missing Default,ScriptSharp.Generator,ExpressionGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\ExpressionGenerator.cs,GenerateLateBoundExpression,The following switch statement is missing a default case: switch (expression.Operation) {                  case LateBoundOperation.InvokeMethod:                      if (Utility.IsValidIdentifier(name)) {                          if (expression.ObjectReference != null) {                              writer.Write(".");                          }                          writer.Write(name);                      }                      else {                          writer.Write("[");                          GenerateExpression(generator' symbol' expression.NameExpression);                          writer.Write("]");                      }                        writer.Write("(");                      if (expression.Parameters.Count != 0) {                          GenerateExpressionList(generator' symbol' expression.Parameters);                      }                      writer.Write(")");                        break;                  case LateBoundOperation.GetField:                      if (Utility.IsValidIdentifier(name)) {                          writer.Write(".");                          writer.Write(name);                      }                      else {                          writer.Write("[");                          GenerateExpression(generator' symbol' expression.NameExpression);                          writer.Write("]");                      }                      break;                  case LateBoundOperation.SetField:                      if (Utility.IsValidIdentifier(name)) {                          writer.Write(".");                          writer.Write(name);                      }                      else {                          writer.Write("[");                          GenerateExpression(generator' symbol' expression.NameExpression);                          writer.Write("]");                      }                        writer.Write(" = ");                      GenerateExpressionList(generator' symbol' expression.Parameters);                      break;                  case LateBoundOperation.DeleteField:                      if (Utility.IsValidIdentifier(name)) {                          writer.Write(".");                          writer.Write(name);                      }                      else {                          writer.Write("[");                          GenerateExpression(generator' symbol' expression.NameExpression);                          writer.Write("]");                      }                      break;                  case LateBoundOperation.GetScriptType:                      writer.Write(")");                      break;                  case LateBoundOperation.HasField:                      writer.Write(")");                      break;                  case LateBoundOperation.HasMethod:                      if (Utility.IsValidIdentifier(name)) {                          if (expression.ObjectReference != null) {                              writer.Write(".");                          }                          writer.Write(name);                      }                      else {                          writer.Write("[");                          GenerateExpression(generator' symbol' expression.NameExpression);                          writer.Write("]");                      }                        writer.Write(") === 'function')");                      break;              }
Missing Default,ScriptSharp.Generator,MemberGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\MemberGenerator.cs,GenerateScript,The following switch statement is missing a default case: switch (memberSymbol.Type) {                  case SymbolType.Field:                      GenerateField(generator' typeName' (FieldSymbol)memberSymbol);                      break;                  case SymbolType.Indexer:                      GenerateIndexer(generator' typeName' (IndexerSymbol)memberSymbol);                      break;                  case SymbolType.Property:                      GenerateProperty(generator' typeName' (PropertySymbol)memberSymbol);                      break;                  case SymbolType.Method:                      GenerateMethod(generator' typeName' (MethodSymbol)memberSymbol);                      break;                  case SymbolType.Event:                      GenerateEvent(generator' typeName' (EventSymbol)memberSymbol);                      break;              }
Missing Default,ScriptSharp.Generator,TypeGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\TypeGenerator.cs,GenerateRegistrationScript,The following switch statement is missing a default case: switch (typeSymbol.Type) {                  case SymbolType.Class:                      writer.Write("[ ");                      writer.Write(typeSymbol.FullGeneratedName);                      writer.Write("' ");                      if (((ClassSymbol)typeSymbol).IsStaticClass == false) {                          writer.Write(typeSymbol.FullGeneratedName);                          writer.Write("$' ");                      }                      else {                          writer.Write("null' ");                      }                      if ((classSymbol.BaseClass == null) || classSymbol.IsTestClass) {                          // TODO: We need to introduce the notion of a base class that only exists in the metadata                          //       and not at runtime. At that point this check of IsTestClass can be generalized.                            writer.Write("null");                      }                      else {                          writer.Write(classSymbol.BaseClass.FullGeneratedName);                      }                      if (classSymbol.Interfaces != null) {                          foreach (InterfaceSymbol interfaceSymbol in classSymbol.Interfaces) {                              writer.Write("' ");                              writer.Write(interfaceSymbol.FullGeneratedName);                          }                      }                      writer.Write(" ]");                      break;                  case SymbolType.Interface:                      writer.Write("[ ");                      writer.Write(typeSymbol.FullGeneratedName);                      writer.Write(" ]");                      break;                  case SymbolType.Record:                  case SymbolType.Resources:                  case SymbolType.Enumeration:                      writer.Write(typeSymbol.FullGeneratedName);                      break;              }
Missing Default,ScriptSharp.Generator,TypeGenerator,C:\repos\nikhilk_scriptsharp\src\Core\Compiler\Generator\TypeGenerator.cs,GenerateScript,The following switch statement is missing a default case: switch (typeSymbol.Type) {                  case SymbolType.Class:                      if (((ClassSymbol)typeSymbol).IsExtenderClass) {                          GenerateExtensionMethods(generator' (ClassSymbol)typeSymbol);                      }                      else {                          GenerateClass(generator' (ClassSymbol)typeSymbol);                      }                      break;                  case SymbolType.Interface:                      GenerateInterface(generator' (InterfaceSymbol)typeSymbol);                      break;                  case SymbolType.Enumeration:                      GenerateEnumeration(generator' (EnumerationSymbol)typeSymbol);                      break;                  case SymbolType.Record:                      GenerateRecord(generator' (RecordSymbol)typeSymbol);                      break;                  case SymbolType.Resources:                      GenerateResources(generator' (ResourcesSymbol)typeSymbol);                      break;              }
