Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,ActivateFragment,Cyclomatic complexity of the method is 9
Long Statement,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,DetachBehaviors,The length of the statement  "            Dictionary<string' Behavior> behaviors = Script.GetField<Dictionary<string' Behavior>>(element' Application.BehaviorsKey); " is 122.
Long Statement,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,RegisterBehavior,The length of the statement  "            Debug.Assert(_registeredBehaviors.ContainsKey(name) == false' "A behavior with name '" + name + "' was already registered."); " is 125.
Long Statement,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,RegisterBinder,The length of the statement  "            Debug.Assert(_registeredBinders.ContainsKey(name) == false' "A binder with name '" + name + "' was already registered."); " is 121.
Long Statement,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,RegisterExpression,The length of the statement  "            Debug.Assert(_registeredExpressions.ContainsKey(name) == false' "An expression factory with name '" + name + "' was already registered."); " is 138.
Long Statement,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,SetupBindings,The length of the statement  "            bindings.ReplaceRegex(Application.BindingsRegex' delegate(string match /*' string binderType' string expressionType' string expressionValue */) { " is 145.
Long Statement,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,RegisterService,The length of the statement  "            Debug.Assert(_registeredServices.ContainsKey(name) == false' "A service with name '" + name + "' was already registered."); " is 123.
Long Statement,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,CompileTemplate,The length of the statement  "            Debug.Assert(templateEngine != null' "No template engine was found to be able to process the template typed '" + type + "'."); " is 126.
Long Statement,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,RegisterTemplate,The length of the statement  "            Debug.Assert(_registeredTemplates.ContainsKey(name) == false' "A template with name '" + name + "' was already registered."); " is 125.
Long Statement,Sharpen,Behavior,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Behavior.cs,Dispose,The length of the statement  "            Dictionary<string' Behavior> behaviors = Script.GetField<Dictionary<string' Behavior>>(_element' Application.BehaviorsKey); " is 123.
Long Statement,Sharpen,Behavior,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Behavior.cs,GetBehavior,The length of the statement  "            Dictionary<string' Behavior> behaviors = Script.GetField<Dictionary<string' Behavior>>(element' Application.BehaviorsKey); " is 122.
Long Statement,Sharpen,Behavior,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Behavior.cs,Initialize,The length of the statement  "            Dictionary<string' Behavior> behaviors = Script.GetField<Dictionary<string' Behavior>>(element' Application.BehaviorsKey); " is 122.
Long Statement,Sharpen,OptionsParser,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\OptionsParser.cs,Parse,The length of the statement  "                delegate(string match /*' string simpleValue' string stringValue' string elementReference' string separator' string name */) { " is 126.
Empty Catch Block,Sharpen.Bindings,BindExpression,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Bindings\BindExpression.cs,RetrieveValue,The method has an empty catch block.
Empty Catch Block,Sharpen.Bindings,BindExpression,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Bindings\BindExpression.cs,SetValue,The method has an empty catch block.
Magic Number,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,SetupBindings,The following statement contains a magic number: bindings.ReplaceRegex(Application.BindingsRegex' delegate(string match /*' string binderType' string expressionType' string expressionValue */) {                  string binderType = (string)Arguments.GetArgument(1);                  string expressionType = (string)Arguments.GetArgument(2);                  string expressionValue = (string)Arguments.GetArgument(3);                    ExpressionFactory expressionFactory = _registeredExpressions[expressionType];                  Debug.Assert(expressionFactory != null' "Unknown expression of type '" + expressionType + "' found.");                    if (expressionFactory != null) {                      Expression expression = expressionFactory(model' expressionType' expressionValue);                      Binder binder = null;                        // TODO: Add support for binding attributes - @xxx                        if (binderType.StartsWith("on.")) {                          Debug.Assert(expression.CanChange == false' "Events cannot be bound to dynamic expressions.");                          Debug.Assert(expression.GetValue() is Action);                            binder = new EventBinder(element' binderType.Substr(3)' (ElementEventListener)expression.GetValue());                      }                      else if (binderType.StartsWith("style.")) {                          object style = element.Style;                          binder = new PropertyBinder(style' binderType.Substr(6)' expression);                      }                      else {                          BinderFactory binderFactory = _registeredBinders[binderType];                          if (binderFactory == null) {                              binder = new PropertyBinder(element' binderType' expression);                          }                          else {                              binder = binderFactory(element' binderType' expression);                          }                      }                        if (binder != null) {                          binder.Update();                          if (expression.CanChange == false) {                              // Since the expression value cannot change' there isn't a whole lot of need                              // to keep the binder alive and manage it.                              binder = null;                          }                      }                        if (binder != null) {                          // The binder is managed using a behavior that is attached to the element.                          // This allows stashing the model for later retrieval' as well as a way to                          // dispose bindings (the behavior disposes all binders it is managing).                            BinderManager binderManager = (BinderManager)Behavior.GetBehavior(element' typeof(BinderManager));                          if (binderManager == null) {                              binderManager = new BinderManager();                              binderManager.Initialize(element' null);                              binderManager.Model = model;                          }                            binderManager.AddBinder(binder);                      }                  }                    return String.Empty;              });
Magic Number,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,SetupBindings,The following statement contains a magic number: bindings.ReplaceRegex(Application.BindingsRegex' delegate(string match /*' string binderType' string expressionType' string expressionValue */) {                  string binderType = (string)Arguments.GetArgument(1);                  string expressionType = (string)Arguments.GetArgument(2);                  string expressionValue = (string)Arguments.GetArgument(3);                    ExpressionFactory expressionFactory = _registeredExpressions[expressionType];                  Debug.Assert(expressionFactory != null' "Unknown expression of type '" + expressionType + "' found.");                    if (expressionFactory != null) {                      Expression expression = expressionFactory(model' expressionType' expressionValue);                      Binder binder = null;                        // TODO: Add support for binding attributes - @xxx                        if (binderType.StartsWith("on.")) {                          Debug.Assert(expression.CanChange == false' "Events cannot be bound to dynamic expressions.");                          Debug.Assert(expression.GetValue() is Action);                            binder = new EventBinder(element' binderType.Substr(3)' (ElementEventListener)expression.GetValue());                      }                      else if (binderType.StartsWith("style.")) {                          object style = element.Style;                          binder = new PropertyBinder(style' binderType.Substr(6)' expression);                      }                      else {                          BinderFactory binderFactory = _registeredBinders[binderType];                          if (binderFactory == null) {                              binder = new PropertyBinder(element' binderType' expression);                          }                          else {                              binder = binderFactory(element' binderType' expression);                          }                      }                        if (binder != null) {                          binder.Update();                          if (expression.CanChange == false) {                              // Since the expression value cannot change' there isn't a whole lot of need                              // to keep the binder alive and manage it.                              binder = null;                          }                      }                        if (binder != null) {                          // The binder is managed using a behavior that is attached to the element.                          // This allows stashing the model for later retrieval' as well as a way to                          // dispose bindings (the behavior disposes all binders it is managing).                            BinderManager binderManager = (BinderManager)Behavior.GetBehavior(element' typeof(BinderManager));                          if (binderManager == null) {                              binderManager = new BinderManager();                              binderManager.Initialize(element' null);                              binderManager.Model = model;                          }                            binderManager.AddBinder(binder);                      }                  }                    return String.Empty;              });
Magic Number,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,SetupBindings,The following statement contains a magic number: bindings.ReplaceRegex(Application.BindingsRegex' delegate(string match /*' string binderType' string expressionType' string expressionValue */) {                  string binderType = (string)Arguments.GetArgument(1);                  string expressionType = (string)Arguments.GetArgument(2);                  string expressionValue = (string)Arguments.GetArgument(3);                    ExpressionFactory expressionFactory = _registeredExpressions[expressionType];                  Debug.Assert(expressionFactory != null' "Unknown expression of type '" + expressionType + "' found.");                    if (expressionFactory != null) {                      Expression expression = expressionFactory(model' expressionType' expressionValue);                      Binder binder = null;                        // TODO: Add support for binding attributes - @xxx                        if (binderType.StartsWith("on.")) {                          Debug.Assert(expression.CanChange == false' "Events cannot be bound to dynamic expressions.");                          Debug.Assert(expression.GetValue() is Action);                            binder = new EventBinder(element' binderType.Substr(3)' (ElementEventListener)expression.GetValue());                      }                      else if (binderType.StartsWith("style.")) {                          object style = element.Style;                          binder = new PropertyBinder(style' binderType.Substr(6)' expression);                      }                      else {                          BinderFactory binderFactory = _registeredBinders[binderType];                          if (binderFactory == null) {                              binder = new PropertyBinder(element' binderType' expression);                          }                          else {                              binder = binderFactory(element' binderType' expression);                          }                      }                        if (binder != null) {                          binder.Update();                          if (expression.CanChange == false) {                              // Since the expression value cannot change' there isn't a whole lot of need                              // to keep the binder alive and manage it.                              binder = null;                          }                      }                        if (binder != null) {                          // The binder is managed using a behavior that is attached to the element.                          // This allows stashing the model for later retrieval' as well as a way to                          // dispose bindings (the behavior disposes all binders it is managing).                            BinderManager binderManager = (BinderManager)Behavior.GetBehavior(element' typeof(BinderManager));                          if (binderManager == null) {                              binderManager = new BinderManager();                              binderManager.Initialize(element' null);                              binderManager.Model = model;                          }                            binderManager.AddBinder(binder);                      }                  }                    return String.Empty;              });
Magic Number,Sharpen,Application,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\Application.cs,SetupBindings,The following statement contains a magic number: bindings.ReplaceRegex(Application.BindingsRegex' delegate(string match /*' string binderType' string expressionType' string expressionValue */) {                  string binderType = (string)Arguments.GetArgument(1);                  string expressionType = (string)Arguments.GetArgument(2);                  string expressionValue = (string)Arguments.GetArgument(3);                    ExpressionFactory expressionFactory = _registeredExpressions[expressionType];                  Debug.Assert(expressionFactory != null' "Unknown expression of type '" + expressionType + "' found.");                    if (expressionFactory != null) {                      Expression expression = expressionFactory(model' expressionType' expressionValue);                      Binder binder = null;                        // TODO: Add support for binding attributes - @xxx                        if (binderType.StartsWith("on.")) {                          Debug.Assert(expression.CanChange == false' "Events cannot be bound to dynamic expressions.");                          Debug.Assert(expression.GetValue() is Action);                            binder = new EventBinder(element' binderType.Substr(3)' (ElementEventListener)expression.GetValue());                      }                      else if (binderType.StartsWith("style.")) {                          object style = element.Style;                          binder = new PropertyBinder(style' binderType.Substr(6)' expression);                      }                      else {                          BinderFactory binderFactory = _registeredBinders[binderType];                          if (binderFactory == null) {                              binder = new PropertyBinder(element' binderType' expression);                          }                          else {                              binder = binderFactory(element' binderType' expression);                          }                      }                        if (binder != null) {                          binder.Update();                          if (expression.CanChange == false) {                              // Since the expression value cannot change' there isn't a whole lot of need                              // to keep the binder alive and manage it.                              binder = null;                          }                      }                        if (binder != null) {                          // The binder is managed using a behavior that is attached to the element.                          // This allows stashing the model for later retrieval' as well as a way to                          // dispose bindings (the behavior disposes all binders it is managing).                            BinderManager binderManager = (BinderManager)Behavior.GetBehavior(element' typeof(BinderManager));                          if (binderManager == null) {                              binderManager = new BinderManager();                              binderManager.Initialize(element' null);                              binderManager.Model = model;                          }                            binderManager.AddBinder(binder);                      }                  }                    return String.Empty;              });
Magic Number,Sharpen,OptionsParser,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\OptionsParser.cs,Parse,The following statement contains a magic number: optionsText = optionsText.ReplaceRegex(_optionsParserRegex'                  delegate(string match /*' string simpleValue' string stringValue' string elementReference' string separator' string name */) {                      string stringValue = (string)Arguments.GetArgument(2);                      string elementReference = (string)Arguments.GetArgument(3);                      string nameValue = (string)Arguments.GetArgument(5);                      if (Script.IsValue(stringValue)) {                          // Matches single and double quoted strings                          // JSON strings are always double quoted' and additionally                          // escape any double quotes within.                            return '"' + stringValue.Substr(1' stringValue.Length - 2).Replace("\""' "\\\"") + '"';                      }                      else if (Script.IsValue(elementReference)) {                          // ID references require resolution at JSON parse time                          // Convert them to strings' so they can be parsed as valid JSON first.                            resolveElements = true;                          return '"' + elementReference + '"';                      }                      else if (Script.IsValue(nameValue)) {                          // Matches a name followed by ":"                          // In JSON' names must be double quoted                            return '"' + nameValue.Substr(0' nameValue.Length - 1) + "\":";                      }                      return match;                  });
Magic Number,Sharpen,OptionsParser,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\OptionsParser.cs,Parse,The following statement contains a magic number: optionsText = optionsText.ReplaceRegex(_optionsParserRegex'                  delegate(string match /*' string simpleValue' string stringValue' string elementReference' string separator' string name */) {                      string stringValue = (string)Arguments.GetArgument(2);                      string elementReference = (string)Arguments.GetArgument(3);                      string nameValue = (string)Arguments.GetArgument(5);                      if (Script.IsValue(stringValue)) {                          // Matches single and double quoted strings                          // JSON strings are always double quoted' and additionally                          // escape any double quotes within.                            return '"' + stringValue.Substr(1' stringValue.Length - 2).Replace("\""' "\\\"") + '"';                      }                      else if (Script.IsValue(elementReference)) {                          // ID references require resolution at JSON parse time                          // Convert them to strings' so they can be parsed as valid JSON first.                            resolveElements = true;                          return '"' + elementReference + '"';                      }                      else if (Script.IsValue(nameValue)) {                          // Matches a name followed by ":"                          // In JSON' names must be double quoted                            return '"' + nameValue.Substr(0' nameValue.Length - 1) + "\":";                      }                      return match;                  });
Magic Number,Sharpen,OptionsParser,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\OptionsParser.cs,Parse,The following statement contains a magic number: optionsText = optionsText.ReplaceRegex(_optionsParserRegex'                  delegate(string match /*' string simpleValue' string stringValue' string elementReference' string separator' string name */) {                      string stringValue = (string)Arguments.GetArgument(2);                      string elementReference = (string)Arguments.GetArgument(3);                      string nameValue = (string)Arguments.GetArgument(5);                      if (Script.IsValue(stringValue)) {                          // Matches single and double quoted strings                          // JSON strings are always double quoted' and additionally                          // escape any double quotes within.                            return '"' + stringValue.Substr(1' stringValue.Length - 2).Replace("\""' "\\\"") + '"';                      }                      else if (Script.IsValue(elementReference)) {                          // ID references require resolution at JSON parse time                          // Convert them to strings' so they can be parsed as valid JSON first.                            resolveElements = true;                          return '"' + elementReference + '"';                      }                      else if (Script.IsValue(nameValue)) {                          // Matches a name followed by ":"                          // In JSON' names must be double quoted                            return '"' + nameValue.Substr(0' nameValue.Length - 1) + "\":";                      }                      return match;                  });
Magic Number,Sharpen,OptionsParser,C:\research\architectureSmells\repos\nikhilk_scriptsharp\fx\Sharpen\Core\OptionsParser.cs,Parse,The following statement contains a magic number: optionsText = optionsText.ReplaceRegex(_optionsParserRegex'                  delegate(string match /*' string simpleValue' string stringValue' string elementReference' string separator' string name */) {                      string stringValue = (string)Arguments.GetArgument(2);                      string elementReference = (string)Arguments.GetArgument(3);                      string nameValue = (string)Arguments.GetArgument(5);                      if (Script.IsValue(stringValue)) {                          // Matches single and double quoted strings                          // JSON strings are always double quoted' and additionally                          // escape any double quotes within.                            return '"' + stringValue.Substr(1' stringValue.Length - 2).Replace("\""' "\\\"") + '"';                      }                      else if (Script.IsValue(elementReference)) {                          // ID references require resolution at JSON parse time                          // Convert them to strings' so they can be parsed as valid JSON first.                            resolveElements = true;                          return '"' + elementReference + '"';                      }                      else if (Script.IsValue(nameValue)) {                          // Matches a name followed by ":"                          // In JSON' names must be double quoted                            return '"' + nameValue.Substr(0' nameValue.Length - 1) + "\":";                      }                      return match;                  });
