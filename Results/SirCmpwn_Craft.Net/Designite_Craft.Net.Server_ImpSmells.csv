Implementation smell,Namespace,Class,File,Method,Description
Long Method,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The method has 148 lines of code.
Complex Method,Craft.Net.Server,EntityManager,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,Cyclomatic complexity of the method is 13
Complex Method,Craft.Net.Server.Handlers,InteractionHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,RightClick,Cyclomatic complexity of the method is 10
Long Identifier,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,,The length of the parameter _millisecondsBetweenPhysicsUpdates is 34.
Long Statement,Craft.Net.Server,EntityManager,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The length of the statement  "                    var newClients = Server.Clients.Where(c => c.Entity != entity && c.IsLoggedIn && !c.KnownEntities.Contains(entity.EntityId) " is 123.
Long Statement,Craft.Net.Server,EntityManager,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The length of the statement  "                        var toForget = client.KnownEntities.Where(id => !IsInRange(GetEntityById(id).Position' player.Position' MaxClientDistance)).ToArray(); " is 134.
Long Statement,Craft.Net.Server,EntityManager,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The length of the statement  "            if (e.PropertyName == "Position" || e.PropertyName == "Yaw" || e.PropertyName == "Pitch" || e.PropertyName == "HeadYaw") " is 120.
Long Statement,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,MoveClientToWorld,The length of the statement  "            client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height' " is 129.
Long Statement,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,LogInPlayer,The length of the statement  "            client.SendPacket(new SpawnPositionPacket((int)client.Entity.SpawnPoint.X' (int)client.Entity.SpawnPoint.Y' (int)client.Entity.SpawnPoint.Z)); " is 142.
Long Statement,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,LogInPlayer,The length of the statement  "            client.SendPacket(new PlayerAbilitiesPacket(client.Entity.Abilities.AsFlags()' client.Entity.Abilities.FlyingSpeed' client.Entity.Abilities.WalkingSpeed)); " is 155.
Long Statement,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,LogInPlayer,The length of the statement  "            client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height' " is 129.
Long Statement,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,DoClientUpdates,The length of the statement  "                byte progress = (byte)((DateTime.Now - client.BlockBreakStartTime.Value).TotalMilliseconds / client.BlockBreakStageTime); " is 121.
Long Statement,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,WorldBlockChange,The length of the statement  "                    client.SendPacket(new BlockChangePacket(e.Coordinates.X' (byte)e.Coordinates.Y' e.Coordinates.Z' block.BlockId' block.Metadata)); " is 129.
Long Statement,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,TrackEntity,The length of the statement  "                    SendPacket(new SpawnPlayerPacket(player.EntityId' UUID' player.Username' MathHelper.CreateAbsoluteInt(player.Position.X)' " is 121.
Long Statement,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,TrackEntity,The length of the statement  "                        MathHelper.CreateRotationByte(player.Yaw)' MathHelper.CreateRotationByte(player.Pitch)' selectedItem' player.Metadata)); " is 120.
Long Statement,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,TrackEntity,The length of the statement  "                        SendPacket(new EntityEquipmentPacket(entity.EntityId' EntityEquipmentPacket.EntityEquipmentSlot.HeldItem' player.SelectedItem)); " is 128.
Long Statement,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,TrackEntity,The length of the statement  "                    SendPacket(new SpawnObjectPacket(objectEntity.EntityId' objectEntity.EntityType' MathHelper.CreateAbsoluteInt(objectEntity.Position.X)' " is 135.
Long Statement,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,TrackEntity,The length of the statement  "                        MathHelper.CreateAbsoluteInt(objectEntity.Position.Y)' MathHelper.CreateAbsoluteInt(objectEntity.Position.Z)' MathHelper.CreateRotationByte(objectEntity.Yaw)' " is 158.
Long Statement,Craft.Net.Server.Handlers,InteractionHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,The length of the statement  "                        if (client.GameMode == GameMode.Creative || client.Entity.Abilities.InstantMine)// || Block.GetBlockHardness(block.BlockId) == 0) " is 129.
Long Statement,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,CreativeInventoryAction,The length of the statement  "                        _client.SendPacket(new EntityEquipmentPacket(client.Entity.EntityId' EntityEquipmentPacket.EntityEquipmentSlot.HeldItem' " is 120.
Long Statement,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,HeldItemChange,The length of the statement  "                    _client.SendPacket(new EntityEquipmentPacket(client.Entity.EntityId' EntityEquipmentPacket.EntityEquipmentSlot.HeldItem' " is 120.
Long Statement,Craft.Net.Server.Handlers,LoginHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientStatus,The length of the statement  "                client.SendPacket(new RespawnPacket(Dimension.Overworld' server.Settings.Difficulty' client.GameMode' world.WorldGenerator.GeneratorName)); " is 139.
Long Statement,Craft.Net.Server.Handlers,LoginHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientStatus,The length of the statement  "                client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y' client.Entity.Position.Z' " is 127.
Complex Conditional,Craft.Net.Server,EntityManager,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The conditional expression  "e.PropertyName == "Position" || e.PropertyName == "Yaw" || e.PropertyName == "Pitch" || e.PropertyName == "HeadYaw""  is complex.
Empty Catch Block,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,DisconnectPlayer,The method has an empty catch block.
Empty Catch Block,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,DisconnectPlayer,The method has an empty catch block.
Empty Catch Block,Craft.Net.Server,ExtensionMethods,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\ExtensionMethods.cs,SavePlayer,The method has an empty catch block.
Magic Number,Craft.Net.Server,ChunkHelper,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\ChunkHelper.cs,CreatePacket,The following statement contains a magic number: for (int i = 15; i >= 0; i--)              {                  Section s = chunk.Sections[chunkY++];                    if (s.IsAir)                      nonAir = false;                  if (nonAir)                      totalSections++;              }
Magic Number,Craft.Net.Server,ChunkHelper,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\ChunkHelper.cs,CreatePacket,The following statement contains a magic number: for (int i = 15; i >= 0; i--)              {                  Section s = chunk.Sections[chunkY++];                    if (s.IsAir)                      nonAir = false;                  if (nonAir)                  {                      Array.Copy(s.Blocks' 0' blockData' (chunkY - 1) * BlockDataLength' BlockDataLength);                      Array.Copy(s.Metadata.Data' 0' metadata' (chunkY - 1) * NibbleDataLength' NibbleDataLength);                      Array.Copy(s.BlockLight.Data' 0' blockLight' (chunkY - 1) * NibbleDataLength' NibbleDataLength);                      Array.Copy(s.SkyLight.Data' 0' skyLight' (chunkY - 1) * NibbleDataLength' NibbleDataLength);                        PrimaryBitMap |= mask;                  }                    mask <<= 1;              }
Magic Number,Craft.Net.Server,ClientSettings,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\ClientSettings.cs,ClientSettings,The following statement contains a magic number: MaxViewDistance = 10;
Magic Number,Craft.Net.Server,ClientSettings,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\ClientSettings.cs,ClientSettings,The following statement contains a magic number: ViewDistance = 3;
Magic Number,Craft.Net.Server,EntityManager,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,Update,The following statement contains a magic number: lock (Entities)              {                  foreach (var entity in Entities)                  {                      if (!MarkedForDespawn.Contains(entity.EntityId))                          entity.Update(GetEntitiesInRange(entity' 2));                  }                  while (MarkedForDespawn.Count != 0)                  {                      int id;                      while (!MarkedForDespawn.TryDequeue(out id));                      var entity = GetEntityById(id);                      if (entity == null)                          return; // What?                      foreach (var client in GetKnownClients(entity))                          client.ForgetEntity(entity);                      Entities.Remove(entity);                      if (entity is IPhysicsEntity)                      {                          // Remove from physics engine                          var engine = Server.GetPhysicsForWorld(entity.World);                          engine.RemoveEntity((IPhysicsEntity)entity);                      }                      if (entity != null)                          entity.PropertyChanged -= EntityPropertyChanged;                  }              }
Magic Number,Craft.Net.Server,EntityManager,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The following statement contains a magic number: if (e.PropertyName == "Position")              {                  if ((int)(entity.Position.X) >> 4 != (int)(entity.OldPosition.X) >> 4 ||                      (int)(entity.Position.Z) >> 4 != (int)(entity.OldPosition.Z) >> 4)                  {                      // Handle moving between chunks                      if (diskEntity != null)                      {                          var oldChunk = GetEntityChunk(entity.World' entity.OldPosition);                          if (oldChunk.Entities.Contains(diskEntity))                              oldChunk.Entities.Remove(diskEntity);                          oldChunk.IsModified = true;                            var chunk = GetEntityChunk(entity.World' entity.Position);                          chunk.Entities.Add(diskEntity);                          chunk.IsModified = true;                      }                      var oldClients = GetKnownClients(entity).Where(c => c.IsLoggedIn && c.KnownEntities.Contains(entity.EntityId)                          && !IsInRange(c.Entity.Position' entity.Position' MaxClientDistance)).ToArray();                      var newClients = Server.Clients.Where(c => c.Entity != entity && c.IsLoggedIn && !c.KnownEntities.Contains(entity.EntityId)                          && IsInRange(c.Entity.Position' entity.Position' MaxClientDistance)).ToArray();                      foreach (var client in oldClients)                          client.ForgetEntity(entity);                      foreach (var client in newClients)                          client.TrackEntity(entity);                      if (entity is PlayerEntity)                      {                          // Update which entities this *player* can see                          var player = entity as PlayerEntity;                          var client = GetClient(player);                          // TODO: Switch to per-client view distance' not a global constant                          var toForget = client.KnownEntities.Where(id => !IsInRange(GetEntityById(id).Position' player.Position' MaxClientDistance)).ToArray();                          var toTrack = GetEntitiesInRange(player' MaxClientDistance);                          foreach (var forget in toForget)                              client.ForgetEntity(GetEntityById(forget));                          foreach (var track in toTrack)                              client.TrackEntity(track);                      }                  }              }
Magic Number,Craft.Net.Server,EntityManager,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The following statement contains a magic number: if (e.PropertyName == "Position")              {                  if ((int)(entity.Position.X) >> 4 != (int)(entity.OldPosition.X) >> 4 ||                      (int)(entity.Position.Z) >> 4 != (int)(entity.OldPosition.Z) >> 4)                  {                      // Handle moving between chunks                      if (diskEntity != null)                      {                          var oldChunk = GetEntityChunk(entity.World' entity.OldPosition);                          if (oldChunk.Entities.Contains(diskEntity))                              oldChunk.Entities.Remove(diskEntity);                          oldChunk.IsModified = true;                            var chunk = GetEntityChunk(entity.World' entity.Position);                          chunk.Entities.Add(diskEntity);                          chunk.IsModified = true;                      }                      var oldClients = GetKnownClients(entity).Where(c => c.IsLoggedIn && c.KnownEntities.Contains(entity.EntityId)                          && !IsInRange(c.Entity.Position' entity.Position' MaxClientDistance)).ToArray();                      var newClients = Server.Clients.Where(c => c.Entity != entity && c.IsLoggedIn && !c.KnownEntities.Contains(entity.EntityId)                          && IsInRange(c.Entity.Position' entity.Position' MaxClientDistance)).ToArray();                      foreach (var client in oldClients)                          client.ForgetEntity(entity);                      foreach (var client in newClients)                          client.TrackEntity(entity);                      if (entity is PlayerEntity)                      {                          // Update which entities this *player* can see                          var player = entity as PlayerEntity;                          var client = GetClient(player);                          // TODO: Switch to per-client view distance' not a global constant                          var toForget = client.KnownEntities.Where(id => !IsInRange(GetEntityById(id).Position' player.Position' MaxClientDistance)).ToArray();                          var toTrack = GetEntitiesInRange(player' MaxClientDistance);                          foreach (var forget in toForget)                              client.ForgetEntity(GetEntityById(forget));                          foreach (var track in toTrack)                              client.TrackEntity(track);                      }                  }              }
Magic Number,Craft.Net.Server,EntityManager,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The following statement contains a magic number: if (e.PropertyName == "Position")              {                  if ((int)(entity.Position.X) >> 4 != (int)(entity.OldPosition.X) >> 4 ||                      (int)(entity.Position.Z) >> 4 != (int)(entity.OldPosition.Z) >> 4)                  {                      // Handle moving between chunks                      if (diskEntity != null)                      {                          var oldChunk = GetEntityChunk(entity.World' entity.OldPosition);                          if (oldChunk.Entities.Contains(diskEntity))                              oldChunk.Entities.Remove(diskEntity);                          oldChunk.IsModified = true;                            var chunk = GetEntityChunk(entity.World' entity.Position);                          chunk.Entities.Add(diskEntity);                          chunk.IsModified = true;                      }                      var oldClients = GetKnownClients(entity).Where(c => c.IsLoggedIn && c.KnownEntities.Contains(entity.EntityId)                          && !IsInRange(c.Entity.Position' entity.Position' MaxClientDistance)).ToArray();                      var newClients = Server.Clients.Where(c => c.Entity != entity && c.IsLoggedIn && !c.KnownEntities.Contains(entity.EntityId)                          && IsInRange(c.Entity.Position' entity.Position' MaxClientDistance)).ToArray();                      foreach (var client in oldClients)                          client.ForgetEntity(entity);                      foreach (var client in newClients)                          client.TrackEntity(entity);                      if (entity is PlayerEntity)                      {                          // Update which entities this *player* can see                          var player = entity as PlayerEntity;                          var client = GetClient(player);                          // TODO: Switch to per-client view distance' not a global constant                          var toForget = client.KnownEntities.Where(id => !IsInRange(GetEntityById(id).Position' player.Position' MaxClientDistance)).ToArray();                          var toTrack = GetEntitiesInRange(player' MaxClientDistance);                          foreach (var forget in toForget)                              client.ForgetEntity(GetEntityById(forget));                          foreach (var track in toTrack)                              client.TrackEntity(track);                      }                  }              }
Magic Number,Craft.Net.Server,EntityManager,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The following statement contains a magic number: if (e.PropertyName == "Position")              {                  if ((int)(entity.Position.X) >> 4 != (int)(entity.OldPosition.X) >> 4 ||                      (int)(entity.Position.Z) >> 4 != (int)(entity.OldPosition.Z) >> 4)                  {                      // Handle moving between chunks                      if (diskEntity != null)                      {                          var oldChunk = GetEntityChunk(entity.World' entity.OldPosition);                          if (oldChunk.Entities.Contains(diskEntity))                              oldChunk.Entities.Remove(diskEntity);                          oldChunk.IsModified = true;                            var chunk = GetEntityChunk(entity.World' entity.Position);                          chunk.Entities.Add(diskEntity);                          chunk.IsModified = true;                      }                      var oldClients = GetKnownClients(entity).Where(c => c.IsLoggedIn && c.KnownEntities.Contains(entity.EntityId)                          && !IsInRange(c.Entity.Position' entity.Position' MaxClientDistance)).ToArray();                      var newClients = Server.Clients.Where(c => c.Entity != entity && c.IsLoggedIn && !c.KnownEntities.Contains(entity.EntityId)                          && IsInRange(c.Entity.Position' entity.Position' MaxClientDistance)).ToArray();                      foreach (var client in oldClients)                          client.ForgetEntity(entity);                      foreach (var client in newClients)                          client.TrackEntity(entity);                      if (entity is PlayerEntity)                      {                          // Update which entities this *player* can see                          var player = entity as PlayerEntity;                          var client = GetClient(player);                          // TODO: Switch to per-client view distance' not a global constant                          var toForget = client.KnownEntities.Where(id => !IsInRange(GetEntityById(id).Position' player.Position' MaxClientDistance)).ToArray();                          var toTrack = GetEntitiesInRange(player' MaxClientDistance);                          foreach (var forget in toForget)                              client.ForgetEntity(GetEntityById(forget));                          foreach (var track in toTrack)                              client.TrackEntity(track);                      }                  }              }
Magic Number,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,Start,The following statement contains a magic number: CryptoServiceProvider = new RSACryptoServiceProvider(1024);
Magic Number,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,MoveClientToWorld,The following statement contains a magic number: client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height'                  client.Entity.Position.Z' client.Entity.Position.Y + 0.1' client.Entity.Yaw' client.Entity.Pitch' false));
Magic Number,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,MoveClientToWorld,The following statement contains a magic number: client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height'                  client.Entity.Position.Z' client.Entity.Position.Y + 0.1' client.Entity.Yaw' client.Entity.Pitch' false));
Magic Number,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,LogInPlayer,The following statement contains a magic number: client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height'                  client.Entity.Position.Z' client.Entity.Position.Y + 0.1' client.Entity.Yaw' client.Entity.Pitch' false));
Magic Number,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,LogInPlayer,The following statement contains a magic number: client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height'                  client.Entity.Position.Z' client.Entity.Position.Y + 0.1' client.Entity.Yaw' client.Entity.Pitch' false));
Magic Number,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,NetworkWorker,The following statement contains a magic number: while (true)              {                  UpdateScheduledEvents();                  lock (NetworkLock)                  {                      for (int i = 0; i < Clients.Count; i++)                      {                          var client = Clients[i];                          bool disconnect = false;                          while (client.PacketQueue.Count != 0)                          {                              IPacket nextPacket;                              if (client.PacketQueue.TryDequeue(out nextPacket))                              {                                  try                                  {                                      client.NetworkManager.WritePacket(nextPacket' PacketDirection.Clientbound);                                  }                                  catch (System.IO.IOException)                                  {                                      disconnect = true;                                      continue;                                  }                                  if (nextPacket is DisconnectPacket // TODO: This could be cleaner                                      || (nextPacket is StatusPingPacket && client.NetworkManager.NetworkMode == NetworkMode.Status))                                  {                                      disconnect = true;                                  }                              }                          }                          if (disconnect)                          {                              DisconnectPlayer(client);                              i--;                              continue;                          }                          // Read packets                          var timeout = DateTime.Now.AddMilliseconds(10);                          while (client.NetworkClient.Available != 0 && DateTime.Now < timeout)                          {                              try                              {                                  var packet = client.NetworkManager.ReadPacket(PacketDirection.Serverbound);                                  if (packet is DisconnectPacket)                                  {                                      DisconnectPlayer(client);                                      i--;                                      break;                                  }                                  HandlePacket(client' packet);                              }                              catch (SocketException)                              {                                  DisconnectPlayer(client);                                  i--;                                  break;                              }  //                            catch (Exception e)  //                            {  //                                DisconnectPlayer(client' e.Message);  //                                i--;  //                                break;  //                            }                          }                          if (client.IsLoggedIn)                              DoClientUpdates(client);                      }                  }                  if (LastTimeUpdate != DateTime.MinValue)                  {                      if ((DateTime.Now - LastTimeUpdate).TotalMilliseconds >= 50)                      {                          Level.Time += (long)((DateTime.Now - LastTimeUpdate).TotalMilliseconds / 50);                          LastTimeUpdate = DateTime.Now;                      }                  }                  if (NextChunkUpdate < DateTime.Now)                      NextChunkUpdate = DateTime.Now.AddSeconds(1);                  Thread.Sleep(10);              }
Magic Number,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,NetworkWorker,The following statement contains a magic number: while (true)              {                  UpdateScheduledEvents();                  lock (NetworkLock)                  {                      for (int i = 0; i < Clients.Count; i++)                      {                          var client = Clients[i];                          bool disconnect = false;                          while (client.PacketQueue.Count != 0)                          {                              IPacket nextPacket;                              if (client.PacketQueue.TryDequeue(out nextPacket))                              {                                  try                                  {                                      client.NetworkManager.WritePacket(nextPacket' PacketDirection.Clientbound);                                  }                                  catch (System.IO.IOException)                                  {                                      disconnect = true;                                      continue;                                  }                                  if (nextPacket is DisconnectPacket // TODO: This could be cleaner                                      || (nextPacket is StatusPingPacket && client.NetworkManager.NetworkMode == NetworkMode.Status))                                  {                                      disconnect = true;                                  }                              }                          }                          if (disconnect)                          {                              DisconnectPlayer(client);                              i--;                              continue;                          }                          // Read packets                          var timeout = DateTime.Now.AddMilliseconds(10);                          while (client.NetworkClient.Available != 0 && DateTime.Now < timeout)                          {                              try                              {                                  var packet = client.NetworkManager.ReadPacket(PacketDirection.Serverbound);                                  if (packet is DisconnectPacket)                                  {                                      DisconnectPlayer(client);                                      i--;                                      break;                                  }                                  HandlePacket(client' packet);                              }                              catch (SocketException)                              {                                  DisconnectPlayer(client);                                  i--;                                  break;                              }  //                            catch (Exception e)  //                            {  //                                DisconnectPlayer(client' e.Message);  //                                i--;  //                                break;  //                            }                          }                          if (client.IsLoggedIn)                              DoClientUpdates(client);                      }                  }                  if (LastTimeUpdate != DateTime.MinValue)                  {                      if ((DateTime.Now - LastTimeUpdate).TotalMilliseconds >= 50)                      {                          Level.Time += (long)((DateTime.Now - LastTimeUpdate).TotalMilliseconds / 50);                          LastTimeUpdate = DateTime.Now;                      }                  }                  if (NextChunkUpdate < DateTime.Now)                      NextChunkUpdate = DateTime.Now.AddSeconds(1);                  Thread.Sleep(10);              }
Magic Number,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,NetworkWorker,The following statement contains a magic number: while (true)              {                  UpdateScheduledEvents();                  lock (NetworkLock)                  {                      for (int i = 0; i < Clients.Count; i++)                      {                          var client = Clients[i];                          bool disconnect = false;                          while (client.PacketQueue.Count != 0)                          {                              IPacket nextPacket;                              if (client.PacketQueue.TryDequeue(out nextPacket))                              {                                  try                                  {                                      client.NetworkManager.WritePacket(nextPacket' PacketDirection.Clientbound);                                  }                                  catch (System.IO.IOException)                                  {                                      disconnect = true;                                      continue;                                  }                                  if (nextPacket is DisconnectPacket // TODO: This could be cleaner                                      || (nextPacket is StatusPingPacket && client.NetworkManager.NetworkMode == NetworkMode.Status))                                  {                                      disconnect = true;                                  }                              }                          }                          if (disconnect)                          {                              DisconnectPlayer(client);                              i--;                              continue;                          }                          // Read packets                          var timeout = DateTime.Now.AddMilliseconds(10);                          while (client.NetworkClient.Available != 0 && DateTime.Now < timeout)                          {                              try                              {                                  var packet = client.NetworkManager.ReadPacket(PacketDirection.Serverbound);                                  if (packet is DisconnectPacket)                                  {                                      DisconnectPlayer(client);                                      i--;                                      break;                                  }                                  HandlePacket(client' packet);                              }                              catch (SocketException)                              {                                  DisconnectPlayer(client);                                  i--;                                  break;                              }  //                            catch (Exception e)  //                            {  //                                DisconnectPlayer(client' e.Message);  //                                i--;  //                                break;  //                            }                          }                          if (client.IsLoggedIn)                              DoClientUpdates(client);                      }                  }                  if (LastTimeUpdate != DateTime.MinValue)                  {                      if ((DateTime.Now - LastTimeUpdate).TotalMilliseconds >= 50)                      {                          Level.Time += (long)((DateTime.Now - LastTimeUpdate).TotalMilliseconds / 50);                          LastTimeUpdate = DateTime.Now;                      }                  }                  if (NextChunkUpdate < DateTime.Now)                      NextChunkUpdate = DateTime.Now.AddSeconds(1);                  Thread.Sleep(10);              }
Magic Number,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,NetworkWorker,The following statement contains a magic number: while (true)              {                  UpdateScheduledEvents();                  lock (NetworkLock)                  {                      for (int i = 0; i < Clients.Count; i++)                      {                          var client = Clients[i];                          bool disconnect = false;                          while (client.PacketQueue.Count != 0)                          {                              IPacket nextPacket;                              if (client.PacketQueue.TryDequeue(out nextPacket))                              {                                  try                                  {                                      client.NetworkManager.WritePacket(nextPacket' PacketDirection.Clientbound);                                  }                                  catch (System.IO.IOException)                                  {                                      disconnect = true;                                      continue;                                  }                                  if (nextPacket is DisconnectPacket // TODO: This could be cleaner                                      || (nextPacket is StatusPingPacket && client.NetworkManager.NetworkMode == NetworkMode.Status))                                  {                                      disconnect = true;                                  }                              }                          }                          if (disconnect)                          {                              DisconnectPlayer(client);                              i--;                              continue;                          }                          // Read packets                          var timeout = DateTime.Now.AddMilliseconds(10);                          while (client.NetworkClient.Available != 0 && DateTime.Now < timeout)                          {                              try                              {                                  var packet = client.NetworkManager.ReadPacket(PacketDirection.Serverbound);                                  if (packet is DisconnectPacket)                                  {                                      DisconnectPlayer(client);                                      i--;                                      break;                                  }                                  HandlePacket(client' packet);                              }                              catch (SocketException)                              {                                  DisconnectPlayer(client);                                  i--;                                  break;                              }  //                            catch (Exception e)  //                            {  //                                DisconnectPlayer(client' e.Message);  //                                i--;  //                                break;  //                            }                          }                          if (client.IsLoggedIn)                              DoClientUpdates(client);                      }                  }                  if (LastTimeUpdate != DateTime.MinValue)                  {                      if ((DateTime.Now - LastTimeUpdate).TotalMilliseconds >= 50)                      {                          Level.Time += (long)((DateTime.Now - LastTimeUpdate).TotalMilliseconds / 50);                          LastTimeUpdate = DateTime.Now;                      }                  }                  if (NextChunkUpdate < DateTime.Now)                      NextChunkUpdate = DateTime.Now.AddSeconds(1);                  Thread.Sleep(10);              }
Magic Number,Craft.Net.Server,MinecraftServer,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,DoClientUpdates,The following statement contains a magic number: if (client.LastKeepAliveSent.AddSeconds(20) < DateTime.Now)              {                  client.SendPacket(new KeepAlivePacket(MathHelper.Random.Next()));                  client.LastKeepAliveSent = DateTime.Now;                  // TODO: Confirm keep alive              }
Magic Number,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,RemoteClient,The following statement contains a magic number: MaxDigDistance = 6;
Magic Number,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunksAsync,The following statement contains a magic number: if ((int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4)              {                  return Task.Factory.StartNew(() => UpdateChunks(true));              }
Magic Number,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunksAsync,The following statement contains a magic number: if ((int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4)              {                  return Task.Factory.StartNew(() => UpdateChunks(true));              }
Magic Number,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunksAsync,The following statement contains a magic number: if ((int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4)              {                  return Task.Factory.StartNew(() => UpdateChunks(true));              }
Magic Number,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunksAsync,The following statement contains a magic number: if ((int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4)              {                  return Task.Factory.StartNew(() => UpdateChunks(true));              }
Magic Number,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: if (forceUpdate ||                  (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4)              {                  var newChunks = new List<Coordinates2D>();                  for (int x = -Settings.ViewDistance; x < Settings.ViewDistance; x++)                      for (int z = -Settings.ViewDistance; z < Settings.ViewDistance; z++)                      {                          newChunks.Add(new Coordinates2D(                              ((int)Entity.Position.X >> 4) + x'                              ((int)Entity.Position.Z >> 4) + z));                      }                  // Unload extraneous columns                  lock (LoadedChunks)                  {                      var currentChunks = new List<Coordinates2D>(LoadedChunks);                      foreach (Coordinates2D chunk in currentChunks)                      {                          if (!newChunks.Contains(chunk))                              UnloadChunk(chunk);                      }                      // Load new columns                      foreach (Coordinates2D chunk in newChunks)                      {                          if (!LoadedChunks.Contains(chunk))                              LoadChunk(chunk);                      }                  }              }
Magic Number,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: if (forceUpdate ||                  (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4)              {                  var newChunks = new List<Coordinates2D>();                  for (int x = -Settings.ViewDistance; x < Settings.ViewDistance; x++)                      for (int z = -Settings.ViewDistance; z < Settings.ViewDistance; z++)                      {                          newChunks.Add(new Coordinates2D(                              ((int)Entity.Position.X >> 4) + x'                              ((int)Entity.Position.Z >> 4) + z));                      }                  // Unload extraneous columns                  lock (LoadedChunks)                  {                      var currentChunks = new List<Coordinates2D>(LoadedChunks);                      foreach (Coordinates2D chunk in currentChunks)                      {                          if (!newChunks.Contains(chunk))                              UnloadChunk(chunk);                      }                      // Load new columns                      foreach (Coordinates2D chunk in newChunks)                      {                          if (!LoadedChunks.Contains(chunk))                              LoadChunk(chunk);                      }                  }              }
Magic Number,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: if (forceUpdate ||                  (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4)              {                  var newChunks = new List<Coordinates2D>();                  for (int x = -Settings.ViewDistance; x < Settings.ViewDistance; x++)                      for (int z = -Settings.ViewDistance; z < Settings.ViewDistance; z++)                      {                          newChunks.Add(new Coordinates2D(                              ((int)Entity.Position.X >> 4) + x'                              ((int)Entity.Position.Z >> 4) + z));                      }                  // Unload extraneous columns                  lock (LoadedChunks)                  {                      var currentChunks = new List<Coordinates2D>(LoadedChunks);                      foreach (Coordinates2D chunk in currentChunks)                      {                          if (!newChunks.Contains(chunk))                              UnloadChunk(chunk);                      }                      // Load new columns                      foreach (Coordinates2D chunk in newChunks)                      {                          if (!LoadedChunks.Contains(chunk))                              LoadChunk(chunk);                      }                  }              }
Magic Number,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: if (forceUpdate ||                  (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4)              {                  var newChunks = new List<Coordinates2D>();                  for (int x = -Settings.ViewDistance; x < Settings.ViewDistance; x++)                      for (int z = -Settings.ViewDistance; z < Settings.ViewDistance; z++)                      {                          newChunks.Add(new Coordinates2D(                              ((int)Entity.Position.X >> 4) + x'                              ((int)Entity.Position.Z >> 4) + z));                      }                  // Unload extraneous columns                  lock (LoadedChunks)                  {                      var currentChunks = new List<Coordinates2D>(LoadedChunks);                      foreach (Coordinates2D chunk in currentChunks)                      {                          if (!newChunks.Contains(chunk))                              UnloadChunk(chunk);                      }                      // Load new columns                      foreach (Coordinates2D chunk in newChunks)                      {                          if (!LoadedChunks.Contains(chunk))                              LoadChunk(chunk);                      }                  }              }
Magic Number,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: if (forceUpdate ||                  (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4)              {                  var newChunks = new List<Coordinates2D>();                  for (int x = -Settings.ViewDistance; x < Settings.ViewDistance; x++)                      for (int z = -Settings.ViewDistance; z < Settings.ViewDistance; z++)                      {                          newChunks.Add(new Coordinates2D(                              ((int)Entity.Position.X >> 4) + x'                              ((int)Entity.Position.Z >> 4) + z));                      }                  // Unload extraneous columns                  lock (LoadedChunks)                  {                      var currentChunks = new List<Coordinates2D>(LoadedChunks);                      foreach (Coordinates2D chunk in currentChunks)                      {                          if (!newChunks.Contains(chunk))                              UnloadChunk(chunk);                      }                      // Load new columns                      foreach (Coordinates2D chunk in newChunks)                      {                          if (!LoadedChunks.Contains(chunk))                              LoadChunk(chunk);                      }                  }              }
Magic Number,Craft.Net.Server,RemoteClient,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: if (forceUpdate ||                  (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4)              {                  var newChunks = new List<Coordinates2D>();                  for (int x = -Settings.ViewDistance; x < Settings.ViewDistance; x++)                      for (int z = -Settings.ViewDistance; z < Settings.ViewDistance; z++)                      {                          newChunks.Add(new Coordinates2D(                              ((int)Entity.Position.X >> 4) + x'                              ((int)Entity.Position.Z >> 4) + z));                      }                  // Unload extraneous columns                  lock (LoadedChunks)                  {                      var currentChunks = new List<Coordinates2D>(LoadedChunks);                      foreach (Coordinates2D chunk in currentChunks)                      {                          if (!newChunks.Contains(chunk))                              UnloadChunk(chunk);                      }                      // Load new columns                      foreach (Coordinates2D chunk in newChunks)                      {                          if (!LoadedChunks.Contains(chunk))                              LoadChunk(chunk);                      }                  }              }
Magic Number,Craft.Net.Server,ExtensionMethods,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\ExtensionMethods.cs,LoadPlayer,The following statement contains a magic number: if (File.Exists(Path.Combine(level.BaseDirectory' "players"' client.Username + ".dat")))              {                  try                  {                      var file = new NbtFile(Path.Combine(level.BaseDirectory' "players"' client.Username + ".dat"));                      // TODO: Consder trying to serialize this' maybe use AutoMapper?                      client.Entity = new PlayerEntity(client.Username);                      client.GameMode = (GameMode)file.RootTag["playerGameType"].IntValue;                      client.Entity.SelectedSlot = file.RootTag["SelectedItemSlot"].ShortValue;                      client.Entity.SpawnPoint = new Vector3(                          file.RootTag["SpawnX"].IntValue'                          file.RootTag["SpawnY"].IntValue'                          file.RootTag["SpawnZ"].IntValue);                      client.Entity.Food = (short)file.RootTag["foodLevel"].IntValue;                      client.Entity.FoodExhaustion = file.RootTag["foodExhaustionLevel"].FloatValue;                      client.Entity.FoodSaturation = file.RootTag["foodSaturationLevel"].FloatValue;                      client.Entity.Health = file.RootTag["Health"].ShortValue;                      foreach (var tag in (NbtList)file.RootTag["Inventory"])                      {                          client.Entity.Inventory[Level.DataSlotToNetworkSlot(tag["Slot"].ByteValue)] =                               new ItemStack(                                  tag["id"].ShortValue'                                  (sbyte)tag["Count"].ByteValue'                                  tag["Damage"].ShortValue'                                  tag["tag"] as NbtCompound);                      }                      client.Entity.Position = new Vector3(                          file.RootTag["Pos"][0].DoubleValue'                          file.RootTag["Pos"][1].DoubleValue'                          file.RootTag["Pos"][2].DoubleValue);                      client.Entity.Yaw = file.RootTag["Rotation"][0].FloatValue;                      client.Entity.Pitch = file.RootTag["Rotation"][1].FloatValue;                      client.Entity.Velocity = new Vector3(                          file.RootTag["Motion"][0].DoubleValue'                          file.RootTag["Motion"][1].DoubleValue'                          file.RootTag["Motion"][2].DoubleValue);                  }                  catch                  {                      CreateNewPlayer(level' client);                  }              }              else                  CreateNewPlayer(level' client);
Magic Number,Craft.Net.Server,ExtensionMethods,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\ExtensionMethods.cs,LoadPlayer,The following statement contains a magic number: if (File.Exists(Path.Combine(level.BaseDirectory' "players"' client.Username + ".dat")))              {                  try                  {                      var file = new NbtFile(Path.Combine(level.BaseDirectory' "players"' client.Username + ".dat"));                      // TODO: Consder trying to serialize this' maybe use AutoMapper?                      client.Entity = new PlayerEntity(client.Username);                      client.GameMode = (GameMode)file.RootTag["playerGameType"].IntValue;                      client.Entity.SelectedSlot = file.RootTag["SelectedItemSlot"].ShortValue;                      client.Entity.SpawnPoint = new Vector3(                          file.RootTag["SpawnX"].IntValue'                          file.RootTag["SpawnY"].IntValue'                          file.RootTag["SpawnZ"].IntValue);                      client.Entity.Food = (short)file.RootTag["foodLevel"].IntValue;                      client.Entity.FoodExhaustion = file.RootTag["foodExhaustionLevel"].FloatValue;                      client.Entity.FoodSaturation = file.RootTag["foodSaturationLevel"].FloatValue;                      client.Entity.Health = file.RootTag["Health"].ShortValue;                      foreach (var tag in (NbtList)file.RootTag["Inventory"])                      {                          client.Entity.Inventory[Level.DataSlotToNetworkSlot(tag["Slot"].ByteValue)] =                               new ItemStack(                                  tag["id"].ShortValue'                                  (sbyte)tag["Count"].ByteValue'                                  tag["Damage"].ShortValue'                                  tag["tag"] as NbtCompound);                      }                      client.Entity.Position = new Vector3(                          file.RootTag["Pos"][0].DoubleValue'                          file.RootTag["Pos"][1].DoubleValue'                          file.RootTag["Pos"][2].DoubleValue);                      client.Entity.Yaw = file.RootTag["Rotation"][0].FloatValue;                      client.Entity.Pitch = file.RootTag["Rotation"][1].FloatValue;                      client.Entity.Velocity = new Vector3(                          file.RootTag["Motion"][0].DoubleValue'                          file.RootTag["Motion"][1].DoubleValue'                          file.RootTag["Motion"][2].DoubleValue);                  }                  catch                  {                      CreateNewPlayer(level' client);                  }              }              else                  CreateNewPlayer(level' client);
Magic Number,Craft.Net.Server.Handlers,InteractionHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,The following statement contains a magic number: switch (packet.Action)              {                  case PlayerBlockActionPacket.BlockAction.StartDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          // TODO: Block stuff                          if (client.GameMode == GameMode.Creative || client.Entity.Abilities.InstantMine)// || Block.GetBlockHardness(block.BlockId) == 0)                          {                              client.World.SetBlockId(position' 0);                              client.World.SetMetadata(position' 0);                          }                          else                          {                              int time = Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                              client.ExpectedMiningEnd = DateTime.Now.AddMilliseconds(time - (client.Ping + 100));                              client.ExpectedBlockToMine = position;                              var knownClients = server.EntityManager.GetKnownClients(client.Entity);                              client.BlockBreakStageTime = time / 8;                              client.BlockBreakStartTime = DateTime.Now;                              foreach (var c in knownClients)                                  c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0));                          }                      }                      break;                  case PlayerBlockActionPacket.BlockAction.CancelDigging:                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                      }                      break;                  case PlayerBlockActionPacket.BlockAction.FinishDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                          if (client.ExpectedMiningEnd > DateTime.Now || client.ExpectedBlockToMine != position)                              return;                          Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                          if (damage != 0)                          {                              var slot = client.Entity.Inventory[client.Entity.SelectedSlot];                              if (!slot.Empty)                              {                                  if (slot.AsItem() != null)                                  {                                      var item = slot.AsItem().Value;                                      if (Item.GetToolType(item.ItemId) != null)                                      {                                          bool destroyed = Item.Damage(ref item' damage);                                          slot.Metadata = item.Metadata;                                          if (destroyed)                                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                                          else                                              client.Entity.Inventory[client.Entity.SelectedSlot] = slot;                                      }                                  }                              }                          }                          client.World.MineBlock(position);                          client.Entity.FoodExhaustion += 0.025f;                      }                      break;                  case PlayerBlockActionPacket.BlockAction.DropItem:                  case PlayerBlockActionPacket.BlockAction.DropItemStack:                      var SlotItem = client.Entity.Inventory[client.Entity.SelectedSlot];                      if (!SlotItem.Empty)                      {                          var ItemCopy = (ItemStack)SlotItem.Clone();                          if (packet.Action == PlayerBlockActionPacket.BlockAction.DropItemStack)                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                          else                          {                              ItemCopy.Count = 1;                              SlotItem.Count--; // Decrease the player's item by 1                              if (SlotItem.Count == 0)                                  client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                              else                                  client.Entity.Inventory[client.Entity.SelectedSlot] = SlotItem;                          }                          var entity = new ItemEntity(client.Entity.Position +                              new Vector3(0' client.Entity.Size.Height' 0)' ItemCopy);                          entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                          server.EntityManager.SpawnEntity(client.World' entity);                      }                      break;              }
Magic Number,Craft.Net.Server.Handlers,InteractionHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,The following statement contains a magic number: switch (packet.Action)              {                  case PlayerBlockActionPacket.BlockAction.StartDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          // TODO: Block stuff                          if (client.GameMode == GameMode.Creative || client.Entity.Abilities.InstantMine)// || Block.GetBlockHardness(block.BlockId) == 0)                          {                              client.World.SetBlockId(position' 0);                              client.World.SetMetadata(position' 0);                          }                          else                          {                              int time = Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                              client.ExpectedMiningEnd = DateTime.Now.AddMilliseconds(time - (client.Ping + 100));                              client.ExpectedBlockToMine = position;                              var knownClients = server.EntityManager.GetKnownClients(client.Entity);                              client.BlockBreakStageTime = time / 8;                              client.BlockBreakStartTime = DateTime.Now;                              foreach (var c in knownClients)                                  c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0));                          }                      }                      break;                  case PlayerBlockActionPacket.BlockAction.CancelDigging:                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                      }                      break;                  case PlayerBlockActionPacket.BlockAction.FinishDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                          if (client.ExpectedMiningEnd > DateTime.Now || client.ExpectedBlockToMine != position)                              return;                          Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                          if (damage != 0)                          {                              var slot = client.Entity.Inventory[client.Entity.SelectedSlot];                              if (!slot.Empty)                              {                                  if (slot.AsItem() != null)                                  {                                      var item = slot.AsItem().Value;                                      if (Item.GetToolType(item.ItemId) != null)                                      {                                          bool destroyed = Item.Damage(ref item' damage);                                          slot.Metadata = item.Metadata;                                          if (destroyed)                                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                                          else                                              client.Entity.Inventory[client.Entity.SelectedSlot] = slot;                                      }                                  }                              }                          }                          client.World.MineBlock(position);                          client.Entity.FoodExhaustion += 0.025f;                      }                      break;                  case PlayerBlockActionPacket.BlockAction.DropItem:                  case PlayerBlockActionPacket.BlockAction.DropItemStack:                      var SlotItem = client.Entity.Inventory[client.Entity.SelectedSlot];                      if (!SlotItem.Empty)                      {                          var ItemCopy = (ItemStack)SlotItem.Clone();                          if (packet.Action == PlayerBlockActionPacket.BlockAction.DropItemStack)                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                          else                          {                              ItemCopy.Count = 1;                              SlotItem.Count--; // Decrease the player's item by 1                              if (SlotItem.Count == 0)                                  client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                              else                                  client.Entity.Inventory[client.Entity.SelectedSlot] = SlotItem;                          }                          var entity = new ItemEntity(client.Entity.Position +                              new Vector3(0' client.Entity.Size.Height' 0)' ItemCopy);                          entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                          server.EntityManager.SpawnEntity(client.World' entity);                      }                      break;              }
Magic Number,Craft.Net.Server.Handlers,InteractionHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,The following statement contains a magic number: switch (packet.Action)              {                  case PlayerBlockActionPacket.BlockAction.StartDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          // TODO: Block stuff                          if (client.GameMode == GameMode.Creative || client.Entity.Abilities.InstantMine)// || Block.GetBlockHardness(block.BlockId) == 0)                          {                              client.World.SetBlockId(position' 0);                              client.World.SetMetadata(position' 0);                          }                          else                          {                              int time = Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                              client.ExpectedMiningEnd = DateTime.Now.AddMilliseconds(time - (client.Ping + 100));                              client.ExpectedBlockToMine = position;                              var knownClients = server.EntityManager.GetKnownClients(client.Entity);                              client.BlockBreakStageTime = time / 8;                              client.BlockBreakStartTime = DateTime.Now;                              foreach (var c in knownClients)                                  c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0));                          }                      }                      break;                  case PlayerBlockActionPacket.BlockAction.CancelDigging:                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                      }                      break;                  case PlayerBlockActionPacket.BlockAction.FinishDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                          if (client.ExpectedMiningEnd > DateTime.Now || client.ExpectedBlockToMine != position)                              return;                          Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                          if (damage != 0)                          {                              var slot = client.Entity.Inventory[client.Entity.SelectedSlot];                              if (!slot.Empty)                              {                                  if (slot.AsItem() != null)                                  {                                      var item = slot.AsItem().Value;                                      if (Item.GetToolType(item.ItemId) != null)                                      {                                          bool destroyed = Item.Damage(ref item' damage);                                          slot.Metadata = item.Metadata;                                          if (destroyed)                                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                                          else                                              client.Entity.Inventory[client.Entity.SelectedSlot] = slot;                                      }                                  }                              }                          }                          client.World.MineBlock(position);                          client.Entity.FoodExhaustion += 0.025f;                      }                      break;                  case PlayerBlockActionPacket.BlockAction.DropItem:                  case PlayerBlockActionPacket.BlockAction.DropItemStack:                      var SlotItem = client.Entity.Inventory[client.Entity.SelectedSlot];                      if (!SlotItem.Empty)                      {                          var ItemCopy = (ItemStack)SlotItem.Clone();                          if (packet.Action == PlayerBlockActionPacket.BlockAction.DropItemStack)                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                          else                          {                              ItemCopy.Count = 1;                              SlotItem.Count--; // Decrease the player's item by 1                              if (SlotItem.Count == 0)                                  client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                              else                                  client.Entity.Inventory[client.Entity.SelectedSlot] = SlotItem;                          }                          var entity = new ItemEntity(client.Entity.Position +                              new Vector3(0' client.Entity.Size.Height' 0)' ItemCopy);                          entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                          server.EntityManager.SpawnEntity(client.World' entity);                      }                      break;              }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,CreativeInventoryAction,The following statement contains a magic number: if (packet.Slot == -1)              {                  var entity = new ItemEntity(client.Entity.Position +                      new Vector3(0' client.Entity.Size.Height' 0)' packet.Item);                  entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                  server.EntityManager.SpawnEntity(client.Entity.World' entity);              }              else if (packet.Slot < client.Entity.Inventory.Length && packet.Slot > 0)              {                  client.Entity.Inventory[packet.Slot] = packet.Item;                  if (packet.Slot == client.Entity.SelectedSlot)                  {                      var clients = server.EntityManager.GetKnownClients(client.Entity);                      foreach (var _client in clients)                      {                          _client.SendPacket(new EntityEquipmentPacket(client.Entity.EntityId' EntityEquipmentPacket.EntityEquipmentSlot.HeldItem'                              client.Entity.Inventory[packet.Slot]));                      }                  }              }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,HeldItemChange,The following statement contains a magic number: if (packet.Slot < 10 && packet.Slot >= 0)              {                  // TODO: Move the equipment update packet to an OnPropertyChanged event handler                  client.Entity.SelectedSlot = (short)(InventoryWindow.HotbarIndex + packet.Slot);                  var clients = server.EntityManager.GetKnownClients(client.Entity);                  foreach (var _client in clients)                  {                      _client.SendPacket(new EntityEquipmentPacket(client.Entity.EntityId' EntityEquipmentPacket.EntityEquipmentSlot.HeldItem'                          client.Entity.Inventory[client.Entity.SelectedSlot]));                  }              }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: try              {                  client.PlayerManager.SendInventoryUpdates = false;                  var packet = (ClickWindowPacket)_packet;                  Window window = null;                  if (packet.WindowId == 0)                      window = client.Entity.Inventory;                  // TODO: Fetch appropriate furnace/crafting bench/etc window                  if (window == null)                      return;                  var heldItem = client.Entity.ItemInMouse;                  ItemStack clickedItem = ItemStack.EmptyStack;                  if (packet.SlotIndex >= 0 && packet.SlotIndex < client.Entity.Inventory.Length)                      clickedItem = client.Entity.Inventory[packet.SlotIndex];                  switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }              }              finally              {                  client.PlayerManager.SendInventoryUpdates = true;              }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: try              {                  client.PlayerManager.SendInventoryUpdates = false;                  var packet = (ClickWindowPacket)_packet;                  Window window = null;                  if (packet.WindowId == 0)                      window = client.Entity.Inventory;                  // TODO: Fetch appropriate furnace/crafting bench/etc window                  if (window == null)                      return;                  var heldItem = client.Entity.ItemInMouse;                  ItemStack clickedItem = ItemStack.EmptyStack;                  if (packet.SlotIndex >= 0 && packet.SlotIndex < client.Entity.Inventory.Length)                      clickedItem = client.Entity.Inventory[packet.SlotIndex];                  switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }              }              finally              {                  client.PlayerManager.SendInventoryUpdates = true;              }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: try              {                  client.PlayerManager.SendInventoryUpdates = false;                  var packet = (ClickWindowPacket)_packet;                  Window window = null;                  if (packet.WindowId == 0)                      window = client.Entity.Inventory;                  // TODO: Fetch appropriate furnace/crafting bench/etc window                  if (window == null)                      return;                  var heldItem = client.Entity.ItemInMouse;                  ItemStack clickedItem = ItemStack.EmptyStack;                  if (packet.SlotIndex >= 0 && packet.SlotIndex < client.Entity.Inventory.Length)                      clickedItem = client.Entity.Inventory[packet.SlotIndex];                  switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }              }              finally              {                  client.PlayerManager.SendInventoryUpdates = true;              }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: try              {                  client.PlayerManager.SendInventoryUpdates = false;                  var packet = (ClickWindowPacket)_packet;                  Window window = null;                  if (packet.WindowId == 0)                      window = client.Entity.Inventory;                  // TODO: Fetch appropriate furnace/crafting bench/etc window                  if (window == null)                      return;                  var heldItem = client.Entity.ItemInMouse;                  ItemStack clickedItem = ItemStack.EmptyStack;                  if (packet.SlotIndex >= 0 && packet.SlotIndex < client.Entity.Inventory.Length)                      clickedItem = client.Entity.Inventory[packet.SlotIndex];                  switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }              }              finally              {                  client.PlayerManager.SendInventoryUpdates = true;              }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: try              {                  client.PlayerManager.SendInventoryUpdates = false;                  var packet = (ClickWindowPacket)_packet;                  Window window = null;                  if (packet.WindowId == 0)                      window = client.Entity.Inventory;                  // TODO: Fetch appropriate furnace/crafting bench/etc window                  if (window == null)                      return;                  var heldItem = client.Entity.ItemInMouse;                  ItemStack clickedItem = ItemStack.EmptyStack;                  if (packet.SlotIndex >= 0 && packet.SlotIndex < client.Entity.Inventory.Length)                      clickedItem = client.Entity.Inventory[packet.SlotIndex];                  switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }              }              finally              {                  client.PlayerManager.SendInventoryUpdates = true;              }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: try              {                  client.PlayerManager.SendInventoryUpdates = false;                  var packet = (ClickWindowPacket)_packet;                  Window window = null;                  if (packet.WindowId == 0)                      window = client.Entity.Inventory;                  // TODO: Fetch appropriate furnace/crafting bench/etc window                  if (window == null)                      return;                  var heldItem = client.Entity.ItemInMouse;                  ItemStack clickedItem = ItemStack.EmptyStack;                  if (packet.SlotIndex >= 0 && packet.SlotIndex < client.Entity.Inventory.Length)                      clickedItem = client.Entity.Inventory[packet.SlotIndex];                  switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }              }              finally              {                  client.PlayerManager.SendInventoryUpdates = true;              }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: try              {                  client.PlayerManager.SendInventoryUpdates = false;                  var packet = (ClickWindowPacket)_packet;                  Window window = null;                  if (packet.WindowId == 0)                      window = client.Entity.Inventory;                  // TODO: Fetch appropriate furnace/crafting bench/etc window                  if (window == null)                      return;                  var heldItem = client.Entity.ItemInMouse;                  ItemStack clickedItem = ItemStack.EmptyStack;                  if (packet.SlotIndex >= 0 && packet.SlotIndex < client.Entity.Inventory.Length)                      clickedItem = client.Entity.Inventory[packet.SlotIndex];                  switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }              }              finally              {                  client.PlayerManager.SendInventoryUpdates = true;              }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,FinishPaint,The following statement contains a magic number: sbyte maxStack = 64;
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientStatus,The following statement contains a magic number: if (packet.Change == ClientStatusPacket.StatusChange.Respawn)              {                  var world = client.Entity.World;                  client.Entity.Position = new Vector3(                      client.Entity.SpawnPoint.X'                      // FIXME: This seems to drop the player camera from half the height of a login spawn                      client.Entity.SpawnPoint.Y'                      client.Entity.SpawnPoint.Z);                  client.Entity.Health = client.Entity.MaxHealth;                  client.Entity.Food = 20;                  client.Entity.FoodSaturation = 20;                  server.EntityManager.SpawnEntity(world' client.Entity);                  client.SendPacket(new UpdateHealthPacket(client.Entity.Health' client.Entity.Food' client.Entity.FoodSaturation));                  client.SendPacket(new RespawnPacket(Dimension.Overworld' server.Settings.Difficulty' client.GameMode' world.WorldGenerator.GeneratorName));                  client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y' client.Entity.Position.Z'                      client.Entity.Position.Y + PlayerEntity.Height' client.Entity.Yaw' client.Entity.Pitch' true));              }
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientStatus,The following statement contains a magic number: if (packet.Change == ClientStatusPacket.StatusChange.Respawn)              {                  var world = client.Entity.World;                  client.Entity.Position = new Vector3(                      client.Entity.SpawnPoint.X'                      // FIXME: This seems to drop the player camera from half the height of a login spawn                      client.Entity.SpawnPoint.Y'                      client.Entity.SpawnPoint.Z);                  client.Entity.Health = client.Entity.MaxHealth;                  client.Entity.Food = 20;                  client.Entity.FoodSaturation = 20;                  server.EntityManager.SpawnEntity(world' client.Entity);                  client.SendPacket(new UpdateHealthPacket(client.Entity.Health' client.Entity.Food' client.Entity.FoodSaturation));                  client.SendPacket(new RespawnPacket(Dimension.Overworld' server.Settings.Difficulty' client.GameMode' world.WorldGenerator.GeneratorName));                  client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y' client.Entity.Position.Z'                      client.Entity.Position.Y + PlayerEntity.Height' client.Entity.Yaw' client.Entity.Pitch' true));              }
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientSettings,The following statement contains a magic number: client.Settings.MaxViewDistance = (32 << packet.ViewDistance) + 2;
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientSettings,The following statement contains a magic number: client.Settings.MaxViewDistance = (32 << packet.ViewDistance) + 2;
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,CreateEncryptionRequest,The following statement contains a magic number: var verifyToken = new byte[4];
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,CreateId,The following statement contains a magic number: byte[] data = new byte[8];
Magic Number,Craft.Net.Server.Handlers,PacketHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\PacketHandlers.cs,GetServerStatus,The following statement contains a magic number: return new ServerStatus(                  new ServerStatus.ServerVersion(NetworkManager.FriendlyVersion' NetworkManager.ProtocolVersion)'                  new ServerStatus.PlayerList(server.Settings.MaxPlayers' server.Clients.Count(c => c.IsLoggedIn)'                      server.Clients.Where(c => c.IsLoggedIn).Take(10).Select(p =>                      new ServerStatus.PlayerList.Player(p.Username' p.Entity.EntityId.ToString())).ToArray())'                  server.Settings.MotD'                  "");
Magic Number,Craft.Net.Server.Handlers,PlayerMovementHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\PlayerMovementHandlers.cs,PlayerAbilities,The following statement contains a magic number: if (client.GameMode == GameMode.Creative)                  client.Entity.Abilities.IsFlying = (packet.Flags & 2) == 2;
Magic Number,Craft.Net.Server.Handlers,PlayerMovementHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\PlayerMovementHandlers.cs,PlayerAbilities,The following statement contains a magic number: if (client.GameMode == GameMode.Creative)                  client.Entity.Abilities.IsFlying = (packet.Flags & 2) == 2;
Magic Number,Craft.Net.Server.Channels,TexturePackChannel,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Channels\TexturePackChannel.cs,TexturePackChannel,The following statement contains a magic number: Resolution = 16;
Missing Default,Craft.Net.Server,PlayerManager,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\PlayerManager.cs,client_PropertyChanged,The following switch statement is missing a default case: switch (e.PropertyName)              {                  case "GameMode":                      Client.SendPacket(new ChangeGameStatePacket(ChangeGameStatePacket.GameState.ChangeGameMode' (float)Client.GameMode));                      if (Client.GameMode == GameMode.Creative)                      {                          Client.Entity.Abilities.InstantMine = true;                          Client.Entity.Abilities.MayFly = true;                      }                      else                      {                          Client.Entity.Abilities.InstantMine = false;                          Client.Entity.Abilities.MayFly = false;                      }                      break;              }
Missing Default,Craft.Net.Server.Handlers,InteractionHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,The following switch statement is missing a default case: switch (packet.Action)              {                  case PlayerBlockActionPacket.BlockAction.StartDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          // TODO: Block stuff                          if (client.GameMode == GameMode.Creative || client.Entity.Abilities.InstantMine)// || Block.GetBlockHardness(block.BlockId) == 0)                          {                              client.World.SetBlockId(position' 0);                              client.World.SetMetadata(position' 0);                          }                          else                          {                              int time = Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                              client.ExpectedMiningEnd = DateTime.Now.AddMilliseconds(time - (client.Ping + 100));                              client.ExpectedBlockToMine = position;                              var knownClients = server.EntityManager.GetKnownClients(client.Entity);                              client.BlockBreakStageTime = time / 8;                              client.BlockBreakStartTime = DateTime.Now;                              foreach (var c in knownClients)                                  c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0));                          }                      }                      break;                  case PlayerBlockActionPacket.BlockAction.CancelDigging:                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                      }                      break;                  case PlayerBlockActionPacket.BlockAction.FinishDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                          if (client.ExpectedMiningEnd > DateTime.Now || client.ExpectedBlockToMine != position)                              return;                          Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                          if (damage != 0)                          {                              var slot = client.Entity.Inventory[client.Entity.SelectedSlot];                              if (!slot.Empty)                              {                                  if (slot.AsItem() != null)                                  {                                      var item = slot.AsItem().Value;                                      if (Item.GetToolType(item.ItemId) != null)                                      {                                          bool destroyed = Item.Damage(ref item' damage);                                          slot.Metadata = item.Metadata;                                          if (destroyed)                                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                                          else                                              client.Entity.Inventory[client.Entity.SelectedSlot] = slot;                                      }                                  }                              }                          }                          client.World.MineBlock(position);                          client.Entity.FoodExhaustion += 0.025f;                      }                      break;                  case PlayerBlockActionPacket.BlockAction.DropItem:                  case PlayerBlockActionPacket.BlockAction.DropItemStack:                      var SlotItem = client.Entity.Inventory[client.Entity.SelectedSlot];                      if (!SlotItem.Empty)                      {                          var ItemCopy = (ItemStack)SlotItem.Clone();                          if (packet.Action == PlayerBlockActionPacket.BlockAction.DropItemStack)                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                          else                          {                              ItemCopy.Count = 1;                              SlotItem.Count--; // Decrease the player's item by 1                              if (SlotItem.Count == 0)                                  client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                              else                                  client.Entity.Inventory[client.Entity.SelectedSlot] = SlotItem;                          }                          var entity = new ItemEntity(client.Entity.Position +                              new Vector3(0' client.Entity.Size.Height' 0)' ItemCopy);                          entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                          server.EntityManager.SpawnEntity(client.World' entity);                      }                      break;              }
Missing Default,Craft.Net.Server.Handlers,InventoryHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following switch statement is missing a default case: switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }
Missing Default,Craft.Net.Server.Handlers,PlayerMovementHandlers,C:\repos\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\PlayerMovementHandlers.cs,EntityAction,The following switch statement is missing a default case: switch (packet.Action)              {                  case EntityActionPacket.EntityAction.Crouch:                      client.Entity.IsCrouching = true;                      break;                  case EntityActionPacket.EntityAction.Uncrouch:                      client.Entity.IsCrouching = false;                      break;                  case EntityActionPacket.EntityAction.StartSprinting:                      client.Entity.IsSprinting = true;                      break;                  case EntityActionPacket.EntityAction.StopSprinting:                      client.Entity.IsSprinting = false;                      break;  //                case EntityActionPacket.EntityAction.LeaveBed:  //                    client.Entity.LeaveBed();  //                    break;              }
