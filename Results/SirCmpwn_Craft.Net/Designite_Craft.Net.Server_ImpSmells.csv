Implementation smell,Namespace,Class,File,Method,Description
Long Method,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The method has 148 lines of code.
Complex Method,Craft.Net.Server,EntityManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,Craft.Net.Server,EntityManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,Cyclomatic complexity of the method is 14
Complex Method,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,DisconnectPlayer,Cyclomatic complexity of the method is 9
Complex Method,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,NetworkWorker,Cyclomatic complexity of the method is 13
Complex Method,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,Cyclomatic complexity of the method is 9
Complex Method,Craft.Net.Server.Handlers,InteractionHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,Cyclomatic complexity of the method is 19
Complex Method,Craft.Net.Server.Handlers,InteractionHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,RightClick,Cyclomatic complexity of the method is 11
Complex Method,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,Cyclomatic complexity of the method is 23
Complex Method,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,FinishPaint,Cyclomatic complexity of the method is 8
Long Identifier,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,,The length of the parameter _millisecondsBetweenPhysicsUpdates is 34.
Long Statement,Craft.Net.Server,EntityManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The length of the statement  "                    var newClients = Server.Clients.Where(c => c.Entity != entity && c.IsLoggedIn && !c.KnownEntities.Contains(entity.EntityId) " is 123.
Long Statement,Craft.Net.Server,EntityManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The length of the statement  "                        var toForget = client.KnownEntities.Where(id => !IsInRange(GetEntityById(id).Position' player.Position' MaxClientDistance)).ToArray(); " is 134.
Long Statement,Craft.Net.Server,EntityManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The length of the statement  "            if (e.PropertyName == "Position" || e.PropertyName == "Yaw" || e.PropertyName == "Pitch" || e.PropertyName == "HeadYaw") " is 120.
Long Statement,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,MoveClientToWorld,The length of the statement  "            client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height' " is 129.
Long Statement,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,LogInPlayer,The length of the statement  "            client.SendPacket(new SpawnPositionPacket((int)client.Entity.SpawnPoint.X' (int)client.Entity.SpawnPoint.Y' (int)client.Entity.SpawnPoint.Z)); " is 142.
Long Statement,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,LogInPlayer,The length of the statement  "            client.SendPacket(new PlayerAbilitiesPacket(client.Entity.Abilities.AsFlags()' client.Entity.Abilities.FlyingSpeed' client.Entity.Abilities.WalkingSpeed)); " is 155.
Long Statement,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,LogInPlayer,The length of the statement  "            client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height' " is 129.
Long Statement,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,DoClientUpdates,The length of the statement  "                byte progress = (byte)((DateTime.Now - client.BlockBreakStartTime.Value).TotalMilliseconds / client.BlockBreakStageTime); " is 121.
Long Statement,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,WorldBlockChange,The length of the statement  "                    client.SendPacket(new BlockChangePacket(e.Coordinates.X' (byte)e.Coordinates.Y' e.Coordinates.Z' block.BlockId' block.Metadata)); " is 129.
Long Statement,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,TrackEntity,The length of the statement  "                    SendPacket(new SpawnPlayerPacket(player.EntityId' UUID' player.Username' MathHelper.CreateAbsoluteInt(player.Position.X)' " is 121.
Long Statement,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,TrackEntity,The length of the statement  "                        MathHelper.CreateRotationByte(player.Yaw)' MathHelper.CreateRotationByte(player.Pitch)' selectedItem' player.Metadata)); " is 120.
Long Statement,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,TrackEntity,The length of the statement  "                        SendPacket(new EntityEquipmentPacket(entity.EntityId' EntityEquipmentPacket.EntityEquipmentSlot.HeldItem' player.SelectedItem)); " is 128.
Long Statement,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,TrackEntity,The length of the statement  "                    SendPacket(new SpawnObjectPacket(objectEntity.EntityId' objectEntity.EntityType' MathHelper.CreateAbsoluteInt(objectEntity.Position.X)' " is 135.
Long Statement,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,TrackEntity,The length of the statement  "                        MathHelper.CreateAbsoluteInt(objectEntity.Position.Y)' MathHelper.CreateAbsoluteInt(objectEntity.Position.Z)' MathHelper.CreateRotationByte(objectEntity.Yaw)' " is 158.
Long Statement,Craft.Net.Server.Handlers,InteractionHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,The length of the statement  "                        if (client.GameMode == GameMode.Creative || client.Entity.Abilities.InstantMine)// || Block.GetBlockHardness(block.BlockId) == 0) " is 129.
Long Statement,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,CreativeInventoryAction,The length of the statement  "                        _client.SendPacket(new EntityEquipmentPacket(client.Entity.EntityId' EntityEquipmentPacket.EntityEquipmentSlot.HeldItem' " is 120.
Long Statement,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,HeldItemChange,The length of the statement  "                    _client.SendPacket(new EntityEquipmentPacket(client.Entity.EntityId' EntityEquipmentPacket.EntityEquipmentSlot.HeldItem' " is 120.
Long Statement,Craft.Net.Server.Handlers,LoginHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientStatus,The length of the statement  "                client.SendPacket(new RespawnPacket(Dimension.Overworld' server.Settings.Difficulty' client.GameMode' world.WorldGenerator.GeneratorName)); " is 139.
Long Statement,Craft.Net.Server.Handlers,LoginHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientStatus,The length of the statement  "                client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y' client.Entity.Position.Z' " is 127.
Complex Conditional,Craft.Net.Server,EntityManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The conditional expression  "e.PropertyName == "Position" || e.PropertyName == "Yaw" || e.PropertyName == "Pitch" || e.PropertyName == "HeadYaw""  is complex.
Empty Catch Block,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,DisconnectPlayer,The method has an empty catch block.
Empty Catch Block,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,DisconnectPlayer,The method has an empty catch block.
Empty Catch Block,Craft.Net.Server,ExtensionMethods,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\ExtensionMethods.cs,SavePlayer,The method has an empty catch block.
Magic Number,Craft.Net.Server,ClientSettings,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\ClientSettings.cs,ClientSettings,The following statement contains a magic number: MaxViewDistance = 10;
Magic Number,Craft.Net.Server,ClientSettings,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\ClientSettings.cs,ClientSettings,The following statement contains a magic number: ViewDistance = 3;
Magic Number,Craft.Net.Server,EntityManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,Update,The following statement contains a magic number: entity.Update(GetEntitiesInRange(entity' 2));
Magic Number,Craft.Net.Server,EntityManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The following statement contains a magic number: (int)(entity.Position.X) >> 4 != (int)(entity.OldPosition.X) >> 4 ||                      (int)(entity.Position.Z) >> 4 != (int)(entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,EntityManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The following statement contains a magic number: (int)(entity.Position.X) >> 4 != (int)(entity.OldPosition.X) >> 4 ||                      (int)(entity.Position.Z) >> 4 != (int)(entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,EntityManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The following statement contains a magic number: (int)(entity.Position.X) >> 4 != (int)(entity.OldPosition.X) >> 4 ||                      (int)(entity.Position.Z) >> 4 != (int)(entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,EntityManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\EntityManager.cs,EntityPropertyChanged,The following statement contains a magic number: (int)(entity.Position.X) >> 4 != (int)(entity.OldPosition.X) >> 4 ||                      (int)(entity.Position.Z) >> 4 != (int)(entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,Start,The following statement contains a magic number: CryptoServiceProvider = new RSACryptoServiceProvider(1024);
Magic Number,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,MoveClientToWorld,The following statement contains a magic number: client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height'                  client.Entity.Position.Z' client.Entity.Position.Y + 0.1' client.Entity.Yaw' client.Entity.Pitch' false));
Magic Number,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,MoveClientToWorld,The following statement contains a magic number: client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height'                  client.Entity.Position.Z' client.Entity.Position.Y + 0.1' client.Entity.Yaw' client.Entity.Pitch' false));
Magic Number,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,LogInPlayer,The following statement contains a magic number: client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height'                  client.Entity.Position.Z' client.Entity.Position.Y + 0.1' client.Entity.Yaw' client.Entity.Pitch' false));
Magic Number,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,LogInPlayer,The following statement contains a magic number: client.SendPacket(new PlayerPositionAndLookPacket(client.Entity.Position.X' client.Entity.Position.Y + 0.1 + PlayerEntity.Height'                  client.Entity.Position.Z' client.Entity.Position.Y + 0.1' client.Entity.Yaw' client.Entity.Pitch' false));
Magic Number,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,NetworkWorker,The following statement contains a magic number: var timeout = DateTime.Now.AddMilliseconds(10);
Magic Number,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,NetworkWorker,The following statement contains a magic number: Level.Time += (long)((DateTime.Now - LastTimeUpdate).TotalMilliseconds / 50);
Magic Number,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,NetworkWorker,The following statement contains a magic number: (DateTime.Now - LastTimeUpdate).TotalMilliseconds >= 50
Magic Number,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,NetworkWorker,The following statement contains a magic number: Thread.Sleep(10);
Magic Number,Craft.Net.Server,MinecraftServer,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\MinecraftServer.cs,DoClientUpdates,The following statement contains a magic number: client.LastKeepAliveSent.AddSeconds(20) < DateTime.Now
Magic Number,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,RemoteClient,The following statement contains a magic number: MaxDigDistance = 6;
Magic Number,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunksAsync,The following statement contains a magic number: (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunksAsync,The following statement contains a magic number: (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunksAsync,The following statement contains a magic number: (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunksAsync,The following statement contains a magic number: (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: newChunks.Add(new Coordinates2D(                              ((int)Entity.Position.X >> 4) + x'                              ((int)Entity.Position.Z >> 4) + z));
Magic Number,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: newChunks.Add(new Coordinates2D(                              ((int)Entity.Position.X >> 4) + x'                              ((int)Entity.Position.Z >> 4) + z));
Magic Number,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: forceUpdate ||                  (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: forceUpdate ||                  (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: forceUpdate ||                  (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,RemoteClient,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\RemoteClient.cs,UpdateChunks,The following statement contains a magic number: forceUpdate ||                  (int)(Entity.Position.X) >> 4 != (int)(Entity.OldPosition.X) >> 4 ||                  (int)(Entity.Position.Z) >> 4 != (int)(Entity.OldPosition.Z) >> 4
Magic Number,Craft.Net.Server,ExtensionMethods,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\ExtensionMethods.cs,LoadPlayer,The following statement contains a magic number: client.Entity.Position = new Vector3(                          file.RootTag["Pos"][0].DoubleValue'                          file.RootTag["Pos"][1].DoubleValue'                          file.RootTag["Pos"][2].DoubleValue);
Magic Number,Craft.Net.Server,ExtensionMethods,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\ExtensionMethods.cs,LoadPlayer,The following statement contains a magic number: client.Entity.Velocity = new Vector3(                          file.RootTag["Motion"][0].DoubleValue'                          file.RootTag["Motion"][1].DoubleValue'                          file.RootTag["Motion"][2].DoubleValue);
Magic Number,Craft.Net.Server.Handlers,InteractionHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,The following statement contains a magic number: switch (packet.Action)              {                  case PlayerBlockActionPacket.BlockAction.StartDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          // TODO: Block stuff                          if (client.GameMode == GameMode.Creative || client.Entity.Abilities.InstantMine)// || Block.GetBlockHardness(block.BlockId) == 0)                          {                              client.World.SetBlockId(position' 0);                              client.World.SetMetadata(position' 0);                          }                          else                          {                              int time = Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                              client.ExpectedMiningEnd = DateTime.Now.AddMilliseconds(time - (client.Ping + 100));                              client.ExpectedBlockToMine = position;                              var knownClients = server.EntityManager.GetKnownClients(client.Entity);                              client.BlockBreakStageTime = time / 8;                              client.BlockBreakStartTime = DateTime.Now;                              foreach (var c in knownClients)                                  c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0));                          }                      }                      break;                  case PlayerBlockActionPacket.BlockAction.CancelDigging:                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                      }                      break;                  case PlayerBlockActionPacket.BlockAction.FinishDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                          if (client.ExpectedMiningEnd > DateTime.Now || client.ExpectedBlockToMine != position)                              return;                          Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                          if (damage != 0)                          {                              var slot = client.Entity.Inventory[client.Entity.SelectedSlot];                              if (!slot.Empty)                              {                                  if (slot.AsItem() != null)                                  {                                      var item = slot.AsItem().Value;                                      if (Item.GetToolType(item.ItemId) != null)                                      {                                          bool destroyed = Item.Damage(ref item' damage);                                          slot.Metadata = item.Metadata;                                          if (destroyed)                                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                                          else                                              client.Entity.Inventory[client.Entity.SelectedSlot] = slot;                                      }                                  }                              }                          }                          client.World.MineBlock(position);                          client.Entity.FoodExhaustion += 0.025f;                      }                      break;                  case PlayerBlockActionPacket.BlockAction.DropItem:                  case PlayerBlockActionPacket.BlockAction.DropItemStack:                      var SlotItem = client.Entity.Inventory[client.Entity.SelectedSlot];                      if (!SlotItem.Empty)                      {                          var ItemCopy = (ItemStack)SlotItem.Clone();                          if (packet.Action == PlayerBlockActionPacket.BlockAction.DropItemStack)                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                          else                          {                              ItemCopy.Count = 1;                              SlotItem.Count--; // Decrease the player's item by 1                              if (SlotItem.Count == 0)                                  client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                              else                                  client.Entity.Inventory[client.Entity.SelectedSlot] = SlotItem;                          }                          var entity = new ItemEntity(client.Entity.Position +                              new Vector3(0' client.Entity.Size.Height' 0)' ItemCopy);                          entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                          server.EntityManager.SpawnEntity(client.World' entity);                      }                      break;              }
Magic Number,Craft.Net.Server.Handlers,InteractionHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,The following statement contains a magic number: switch (packet.Action)              {                  case PlayerBlockActionPacket.BlockAction.StartDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          // TODO: Block stuff                          if (client.GameMode == GameMode.Creative || client.Entity.Abilities.InstantMine)// || Block.GetBlockHardness(block.BlockId) == 0)                          {                              client.World.SetBlockId(position' 0);                              client.World.SetMetadata(position' 0);                          }                          else                          {                              int time = Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                              client.ExpectedMiningEnd = DateTime.Now.AddMilliseconds(time - (client.Ping + 100));                              client.ExpectedBlockToMine = position;                              var knownClients = server.EntityManager.GetKnownClients(client.Entity);                              client.BlockBreakStageTime = time / 8;                              client.BlockBreakStartTime = DateTime.Now;                              foreach (var c in knownClients)                                  c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0));                          }                      }                      break;                  case PlayerBlockActionPacket.BlockAction.CancelDigging:                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                      }                      break;                  case PlayerBlockActionPacket.BlockAction.FinishDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                          if (client.ExpectedMiningEnd > DateTime.Now || client.ExpectedBlockToMine != position)                              return;                          Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                          if (damage != 0)                          {                              var slot = client.Entity.Inventory[client.Entity.SelectedSlot];                              if (!slot.Empty)                              {                                  if (slot.AsItem() != null)                                  {                                      var item = slot.AsItem().Value;                                      if (Item.GetToolType(item.ItemId) != null)                                      {                                          bool destroyed = Item.Damage(ref item' damage);                                          slot.Metadata = item.Metadata;                                          if (destroyed)                                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                                          else                                              client.Entity.Inventory[client.Entity.SelectedSlot] = slot;                                      }                                  }                              }                          }                          client.World.MineBlock(position);                          client.Entity.FoodExhaustion += 0.025f;                      }                      break;                  case PlayerBlockActionPacket.BlockAction.DropItem:                  case PlayerBlockActionPacket.BlockAction.DropItemStack:                      var SlotItem = client.Entity.Inventory[client.Entity.SelectedSlot];                      if (!SlotItem.Empty)                      {                          var ItemCopy = (ItemStack)SlotItem.Clone();                          if (packet.Action == PlayerBlockActionPacket.BlockAction.DropItemStack)                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                          else                          {                              ItemCopy.Count = 1;                              SlotItem.Count--; // Decrease the player's item by 1                              if (SlotItem.Count == 0)                                  client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                              else                                  client.Entity.Inventory[client.Entity.SelectedSlot] = SlotItem;                          }                          var entity = new ItemEntity(client.Entity.Position +                              new Vector3(0' client.Entity.Size.Height' 0)' ItemCopy);                          entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                          server.EntityManager.SpawnEntity(client.World' entity);                      }                      break;              }
Magic Number,Craft.Net.Server.Handlers,InteractionHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,The following statement contains a magic number: switch (packet.Action)              {                  case PlayerBlockActionPacket.BlockAction.StartDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          // TODO: Block stuff                          if (client.GameMode == GameMode.Creative || client.Entity.Abilities.InstantMine)// || Block.GetBlockHardness(block.BlockId) == 0)                          {                              client.World.SetBlockId(position' 0);                              client.World.SetMetadata(position' 0);                          }                          else                          {                              int time = Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                              client.ExpectedMiningEnd = DateTime.Now.AddMilliseconds(time - (client.Ping + 100));                              client.ExpectedBlockToMine = position;                              var knownClients = server.EntityManager.GetKnownClients(client.Entity);                              client.BlockBreakStageTime = time / 8;                              client.BlockBreakStartTime = DateTime.Now;                              foreach (var c in knownClients)                                  c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0));                          }                      }                      break;                  case PlayerBlockActionPacket.BlockAction.CancelDigging:                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                      }                      break;                  case PlayerBlockActionPacket.BlockAction.FinishDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                          if (client.ExpectedMiningEnd > DateTime.Now || client.ExpectedBlockToMine != position)                              return;                          Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                          if (damage != 0)                          {                              var slot = client.Entity.Inventory[client.Entity.SelectedSlot];                              if (!slot.Empty)                              {                                  if (slot.AsItem() != null)                                  {                                      var item = slot.AsItem().Value;                                      if (Item.GetToolType(item.ItemId) != null)                                      {                                          bool destroyed = Item.Damage(ref item' damage);                                          slot.Metadata = item.Metadata;                                          if (destroyed)                                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                                          else                                              client.Entity.Inventory[client.Entity.SelectedSlot] = slot;                                      }                                  }                              }                          }                          client.World.MineBlock(position);                          client.Entity.FoodExhaustion += 0.025f;                      }                      break;                  case PlayerBlockActionPacket.BlockAction.DropItem:                  case PlayerBlockActionPacket.BlockAction.DropItemStack:                      var SlotItem = client.Entity.Inventory[client.Entity.SelectedSlot];                      if (!SlotItem.Empty)                      {                          var ItemCopy = (ItemStack)SlotItem.Clone();                          if (packet.Action == PlayerBlockActionPacket.BlockAction.DropItemStack)                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                          else                          {                              ItemCopy.Count = 1;                              SlotItem.Count--; // Decrease the player's item by 1                              if (SlotItem.Count == 0)                                  client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                              else                                  client.Entity.Inventory[client.Entity.SelectedSlot] = SlotItem;                          }                          var entity = new ItemEntity(client.Entity.Position +                              new Vector3(0' client.Entity.Size.Height' 0)' ItemCopy);                          entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                          server.EntityManager.SpawnEntity(client.World' entity);                      }                      break;              }
Magic Number,Craft.Net.Server.Handlers,InteractionHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,The following statement contains a magic number: switch (packet.Action)              {                  case PlayerBlockActionPacket.BlockAction.StartDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          // TODO: Block stuff                          if (client.GameMode == GameMode.Creative || client.Entity.Abilities.InstantMine)// || Block.GetBlockHardness(block.BlockId) == 0)                          {                              client.World.SetBlockId(position' 0);                              client.World.SetMetadata(position' 0);                          }                          else                          {                              int time = Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                              client.ExpectedMiningEnd = DateTime.Now.AddMilliseconds(time - (client.Ping + 100));                              client.ExpectedBlockToMine = position;                              var knownClients = server.EntityManager.GetKnownClients(client.Entity);                              client.BlockBreakStageTime = time / 8;                              client.BlockBreakStartTime = DateTime.Now;                              foreach (var c in knownClients)                                  c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0));                          }                      }                      break;                  case PlayerBlockActionPacket.BlockAction.CancelDigging:                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                      }                      break;                  case PlayerBlockActionPacket.BlockAction.FinishDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                          if (client.ExpectedMiningEnd > DateTime.Now || client.ExpectedBlockToMine != position)                              return;                          Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                          if (damage != 0)                          {                              var slot = client.Entity.Inventory[client.Entity.SelectedSlot];                              if (!slot.Empty)                              {                                  if (slot.AsItem() != null)                                  {                                      var item = slot.AsItem().Value;                                      if (Item.GetToolType(item.ItemId) != null)                                      {                                          bool destroyed = Item.Damage(ref item' damage);                                          slot.Metadata = item.Metadata;                                          if (destroyed)                                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                                          else                                              client.Entity.Inventory[client.Entity.SelectedSlot] = slot;                                      }                                  }                              }                          }                          client.World.MineBlock(position);                          client.Entity.FoodExhaustion += 0.025f;                      }                      break;                  case PlayerBlockActionPacket.BlockAction.DropItem:                  case PlayerBlockActionPacket.BlockAction.DropItemStack:                      var SlotItem = client.Entity.Inventory[client.Entity.SelectedSlot];                      if (!SlotItem.Empty)                      {                          var ItemCopy = (ItemStack)SlotItem.Clone();                          if (packet.Action == PlayerBlockActionPacket.BlockAction.DropItemStack)                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                          else                          {                              ItemCopy.Count = 1;                              SlotItem.Count--; // Decrease the player's item by 1                              if (SlotItem.Count == 0)                                  client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                              else                                  client.Entity.Inventory[client.Entity.SelectedSlot] = SlotItem;                          }                          var entity = new ItemEntity(client.Entity.Position +                              new Vector3(0' client.Entity.Size.Height' 0)' ItemCopy);                          entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                          server.EntityManager.SpawnEntity(client.World' entity);                      }                      break;              }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,CreativeInventoryAction,The following statement contains a magic number: entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,HeldItemChange,The following statement contains a magic number: packet.Slot < 10 && packet.Slot >= 0
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following statement contains a magic number: switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }
Magic Number,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,FinishPaint,The following statement contains a magic number: sbyte maxStack = 64;
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientStatus,The following statement contains a magic number: client.Entity.Food = 20;
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientStatus,The following statement contains a magic number: client.Entity.FoodSaturation = 20;
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientSettings,The following statement contains a magic number: client.Settings.MaxViewDistance = (32 << packet.ViewDistance) + 2;
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,ClientSettings,The following statement contains a magic number: client.Settings.MaxViewDistance = (32 << packet.ViewDistance) + 2;
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,CreateEncryptionRequest,The following statement contains a magic number: var verifyToken = new byte[4];
Magic Number,Craft.Net.Server.Handlers,LoginHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\LoginHandlers.cs,CreateId,The following statement contains a magic number: byte[] data = new byte[8];
Magic Number,Craft.Net.Server.Handlers,PacketHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\PacketHandlers.cs,GetServerStatus,The following statement contains a magic number: return new ServerStatus(                  new ServerStatus.ServerVersion(NetworkManager.FriendlyVersion' NetworkManager.ProtocolVersion)'                  new ServerStatus.PlayerList(server.Settings.MaxPlayers' server.Clients.Count(c => c.IsLoggedIn)'                      server.Clients.Where(c => c.IsLoggedIn).Take(10).Select(p =>                      new ServerStatus.PlayerList.Player(p.Username' p.Entity.EntityId.ToString())).ToArray())'                  server.Settings.MotD'                  "");
Magic Number,Craft.Net.Server.Handlers,PlayerMovementHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\PlayerMovementHandlers.cs,PlayerAbilities,The following statement contains a magic number: client.Entity.Abilities.IsFlying = (packet.Flags & 2) == 2;
Magic Number,Craft.Net.Server.Handlers,PlayerMovementHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\PlayerMovementHandlers.cs,PlayerAbilities,The following statement contains a magic number: client.Entity.Abilities.IsFlying = (packet.Flags & 2) == 2;
Magic Number,Craft.Net.Server.Channels,TexturePackChannel,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Channels\TexturePackChannel.cs,TexturePackChannel,The following statement contains a magic number: Resolution = 16;
Missing Default,Craft.Net.Server,PlayerManager,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\PlayerManager.cs,client_PropertyChanged,The following switch statement is missing a default case: switch (e.PropertyName)              {                  case "GameMode":                      Client.SendPacket(new ChangeGameStatePacket(ChangeGameStatePacket.GameState.ChangeGameMode' (float)Client.GameMode));                      if (Client.GameMode == GameMode.Creative)                      {                          Client.Entity.Abilities.InstantMine = true;                          Client.Entity.Abilities.MayFly = true;                      }                      else                      {                          Client.Entity.Abilities.InstantMine = false;                          Client.Entity.Abilities.MayFly = false;                      }                      break;              }
Missing Default,Craft.Net.Server.Handlers,InteractionHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InteractionHandlers.cs,PlayerDigging,The following switch statement is missing a default case: switch (packet.Action)              {                  case PlayerBlockActionPacket.BlockAction.StartDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          // TODO: Block stuff                          if (client.GameMode == GameMode.Creative || client.Entity.Abilities.InstantMine)// || Block.GetBlockHardness(block.BlockId) == 0)                          {                              client.World.SetBlockId(position' 0);                              client.World.SetMetadata(position' 0);                          }                          else                          {                              int time = Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                              client.ExpectedMiningEnd = DateTime.Now.AddMilliseconds(time - (client.Ping + 100));                              client.ExpectedBlockToMine = position;                              var knownClients = server.EntityManager.GetKnownClients(client.Entity);                              client.BlockBreakStageTime = time / 8;                              client.BlockBreakStartTime = DateTime.Now;                              foreach (var c in knownClients)                                  c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0));                          }                      }                      break;                  case PlayerBlockActionPacket.BlockAction.CancelDigging:                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                      }                      break;                  case PlayerBlockActionPacket.BlockAction.FinishDigging:                      if (client.Entity.Position.DistanceTo(position) <= client.MaxDigDistance)                      {                          client.BlockBreakStartTime = null;                          var knownClients = server.EntityManager.GetKnownClients(client.Entity);                          foreach (var c in knownClients)                              c.SendPacket(new BlockBreakAnimationPacket(client.Entity.EntityId' position.X' position.Y' position.Z' 0xFF)); // reset                          if (client.ExpectedMiningEnd > DateTime.Now || client.ExpectedBlockToMine != position)                              return;                          Block.GetHarvestTime(block.BlockId' client.Entity.SelectedItem.Id' client.World' client.Entity' out damage);                          if (damage != 0)                          {                              var slot = client.Entity.Inventory[client.Entity.SelectedSlot];                              if (!slot.Empty)                              {                                  if (slot.AsItem() != null)                                  {                                      var item = slot.AsItem().Value;                                      if (Item.GetToolType(item.ItemId) != null)                                      {                                          bool destroyed = Item.Damage(ref item' damage);                                          slot.Metadata = item.Metadata;                                          if (destroyed)                                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                                          else                                              client.Entity.Inventory[client.Entity.SelectedSlot] = slot;                                      }                                  }                              }                          }                          client.World.MineBlock(position);                          client.Entity.FoodExhaustion += 0.025f;                      }                      break;                  case PlayerBlockActionPacket.BlockAction.DropItem:                  case PlayerBlockActionPacket.BlockAction.DropItemStack:                      var SlotItem = client.Entity.Inventory[client.Entity.SelectedSlot];                      if (!SlotItem.Empty)                      {                          var ItemCopy = (ItemStack)SlotItem.Clone();                          if (packet.Action == PlayerBlockActionPacket.BlockAction.DropItemStack)                              client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                          else                          {                              ItemCopy.Count = 1;                              SlotItem.Count--; // Decrease the player's item by 1                              if (SlotItem.Count == 0)                                  client.Entity.Inventory[client.Entity.SelectedSlot] = ItemStack.EmptyStack;                              else                                  client.Entity.Inventory[client.Entity.SelectedSlot] = SlotItem;                          }                          var entity = new ItemEntity(client.Entity.Position +                              new Vector3(0' client.Entity.Size.Height' 0)' ItemCopy);                          entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                          server.EntityManager.SpawnEntity(client.World' entity);                      }                      break;              }
Missing Default,Craft.Net.Server.Handlers,InventoryHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\InventoryHandler.cs,ClickWindow,The following switch statement is missing a default case: switch (packet.Action)                  {                      case ClickWindowPacket.ClickAction.LeftClick:                          if (heldItem.Empty) // Pick up item                          {                              client.Entity.ItemInMouse = clickedItem;                              client.Entity.Inventory[packet.SlotIndex] = ItemStack.EmptyStack;                          }                          else                          {                              if (clickedItem.Empty)                              {                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                                  client.Entity.ItemInMouse = ItemStack.EmptyStack;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Attempt to combine stacks                                  var newSize = clickedItem.Count + heldItem.Count;                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (newSize < maxSize)                                  {                                      clickedItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = ItemStack.EmptyStack;                                  }                                  else                                  {                                      // Merge and leave a little left over                                      newSize = newSize - maxSize;                                      clickedItem.Count = (sbyte)maxSize;                                      heldItem.Count = (sbyte)newSize;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                      client.Entity.ItemInMouse = heldItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.RightClick:                          if (heldItem.Empty) // Pick up half a stack                          {                              var heldCount = (sbyte)(clickedItem.Count / 2 + (clickedItem.Count % 2));                              var leftCount = (sbyte)(clickedItem.Count / 2);                              client.Entity.ItemInMouse = new ItemStack(clickedItem.Id' heldCount' clickedItem.Metadata);                              var old = client.Entity.Inventory[packet.SlotIndex];                              client.Entity.Inventory[packet.SlotIndex] = new ItemStack(old.Id' leftCount' old.Metadata' old.Nbt);                          }                          else                          {                              // Drop one in' or attempt to merge                              if (clickedItem.Empty)                              {                                  clickedItem = (ItemStack)heldItem.Clone();                                  clickedItem.Count = 1;                                  client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  heldItem.Count--;                                  client.Entity.ItemInMouse = heldItem;                              }                              else if (heldItem.CanMerge(clickedItem))                              {                                  // Merge one item in                                  //var maxSize = Item.GetMaximumStackSize(new ItemDescriptor(clickedItem.Id' clickedItem.Metadata));                                  var maxSize = 64; // TODO                                  if (clickedItem.Count < maxSize)                                  {                                      clickedItem.Count++;                                      heldItem.Count--;                                      client.Entity.ItemInMouse = heldItem;                                      client.Entity.Inventory[packet.SlotIndex] = clickedItem;                                  }                              }                              else                              {                                  // Swap stacks with the mouse and the clicked slot                                  client.Entity.ItemInMouse = clickedItem;                                  client.Entity.Inventory[packet.SlotIndex] = heldItem;                              }                          }                          break;                      case ClickWindowPacket.ClickAction.ShiftLeftClick:                      case ClickWindowPacket.ClickAction.ShiftRightClick:                          window.MoveToAlternateArea(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.Drop:                          if (!heldItem.Empty)                          {                              var drop = (ItemStack)heldItem.Clone();                              drop.Count = 1;                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' drop);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              heldItem.Count--;                              client.Entity.ItemInMouse = heldItem;                          }                          break;                      case ClickWindowPacket.ClickAction.DropAll:                          if (!heldItem.Empty)                          {                              var entity = new ItemEntity(client.Entity.Position + new Vector3(0' client.Entity.Size.Height' 0)' heldItem);                              entity.Velocity = MathHelper.FowardVector(client.Entity.Yaw) * new Vector3(0.25);                              server.EntityManager.SpawnEntity(client.Entity.World' entity);                              client.Entity.ItemInMouse = ItemStack.EmptyStack;                          }                          break;                      case ClickWindowPacket.ClickAction.StartLeftClickPaint:                      case ClickWindowPacket.ClickAction.StartRightClickPaint:                          client.PaintedSlots = new List<short>();                          break;                      case ClickWindowPacket.ClickAction.LeftMousePaintProgress:                      case ClickWindowPacket.ClickAction.RightMousePaintProgress:                          if (!client.PaintedSlots.Contains(packet.SlotIndex))                              client.PaintedSlots.Add(packet.SlotIndex);                          break;                      case ClickWindowPacket.ClickAction.EndLeftMousePaint:                          FinishPaint(client' heldItem' false);                          break;                      case ClickWindowPacket.ClickAction.EndRightMousePaint:                          FinishPaint(client' heldItem' true);                          break;                  }
Missing Default,Craft.Net.Server.Handlers,PlayerMovementHandlers,D:\research\architectureSmells\repos1\SirCmpwn_Craft.Net\source\Craft.Net.Server\Handlers\PlayerMovementHandlers.cs,EntityAction,The following switch statement is missing a default case: switch (packet.Action)              {                  case EntityActionPacket.EntityAction.Crouch:                      client.Entity.IsCrouching = true;                      break;                  case EntityActionPacket.EntityAction.Uncrouch:                      client.Entity.IsCrouching = false;                      break;                  case EntityActionPacket.EntityAction.StartSprinting:                      client.Entity.IsSprinting = true;                      break;                  case EntityActionPacket.EntityAction.StopSprinting:                      client.Entity.IsSprinting = false;                      break;  //                case EntityActionPacket.EntityAction.LeaveBed:  //                    client.Entity.LeaveBed();  //                    break;              }
