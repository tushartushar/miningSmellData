Implementation smell,Namespace,Class,File,Method,Description
Magic Number,Gemini.Demo.Xna.Modules.PrimitiveList.Controls,RotatableCubeControl,C:\repos\tgjones_gemini\src\Gemini.Demo.Xna\Modules\PrimitiveList\Controls\RotatableCubeControl.cs,RaiseRenderXna,The following statement contains a magic number: if (Primitive != null)              {                  // Create the world-view-projection matrices for the cube and camera                  Matrix world = Matrix.CreateFromYawPitchRoll(_yaw' _pitch' 0f);                  Matrix view = Matrix.CreateLookAt(new Vector3(0' 0' 2.5f)' Vector3.Zero' Vector3.Up);                  Matrix projection = Matrix.CreatePerspectiveFieldOfView(1' args.GraphicsDevice.Viewport.AspectRatio' 1' 10);                    // Draw a cube                  Primitive.Draw(world' view' projection' Color);              }
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\tgjones_gemini\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals)              {                  // Get two vectors perpendicular to the face normal and to each other.                  var side1 = new Vector3(normal.Y' normal.Z' normal.X);                  var side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 1);                  AddIndex(CurrentVertex + 2);                    AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 2);                  AddIndex(CurrentVertex + 3);                    // Four vertices per face.                  AddVertex((normal - side1 - side2) * size / 2' normal);                  AddVertex((normal - side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 - side2) * size / 2' normal);              }
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\tgjones_gemini\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals)              {                  // Get two vectors perpendicular to the face normal and to each other.                  var side1 = new Vector3(normal.Y' normal.Z' normal.X);                  var side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 1);                  AddIndex(CurrentVertex + 2);                    AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 2);                  AddIndex(CurrentVertex + 3);                    // Four vertices per face.                  AddVertex((normal - side1 - side2) * size / 2' normal);                  AddVertex((normal - side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 - side2) * size / 2' normal);              }
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\tgjones_gemini\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals)              {                  // Get two vectors perpendicular to the face normal and to each other.                  var side1 = new Vector3(normal.Y' normal.Z' normal.X);                  var side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 1);                  AddIndex(CurrentVertex + 2);                    AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 2);                  AddIndex(CurrentVertex + 3);                    // Four vertices per face.                  AddVertex((normal - side1 - side2) * size / 2' normal);                  AddVertex((normal - side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 - side2) * size / 2' normal);              }
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\tgjones_gemini\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals)              {                  // Get two vectors perpendicular to the face normal and to each other.                  var side1 = new Vector3(normal.Y' normal.Z' normal.X);                  var side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 1);                  AddIndex(CurrentVertex + 2);                    AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 2);                  AddIndex(CurrentVertex + 3);                    // Four vertices per face.                  AddVertex((normal - side1 - side2) * size / 2' normal);                  AddVertex((normal - side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 - side2) * size / 2' normal);              }
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\tgjones_gemini\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals)              {                  // Get two vectors perpendicular to the face normal and to each other.                  var side1 = new Vector3(normal.Y' normal.Z' normal.X);                  var side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 1);                  AddIndex(CurrentVertex + 2);                    AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 2);                  AddIndex(CurrentVertex + 3);                    // Four vertices per face.                  AddVertex((normal - side1 - side2) * size / 2' normal);                  AddVertex((normal - side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 - side2) * size / 2' normal);              }
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\tgjones_gemini\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals)              {                  // Get two vectors perpendicular to the face normal and to each other.                  var side1 = new Vector3(normal.Y' normal.Z' normal.X);                  var side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 1);                  AddIndex(CurrentVertex + 2);                    AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 2);                  AddIndex(CurrentVertex + 3);                    // Four vertices per face.                  AddVertex((normal - side1 - side2) * size / 2' normal);                  AddVertex((normal - side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 - side2) * size / 2' normal);              }
Magic Number,Gemini.Demo.Xna.Primitives,CubePrimitive,C:\repos\tgjones_gemini\src\Gemini.Demo.Xna\Primitives\CubePrimitive.cs,CubePrimitive,The following statement contains a magic number: foreach (var normal in normals)              {                  // Get two vectors perpendicular to the face normal and to each other.                  var side1 = new Vector3(normal.Y' normal.Z' normal.X);                  var side2 = Vector3.Cross(normal' side1);                    // Six indices (two triangles) per face.                  AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 1);                  AddIndex(CurrentVertex + 2);                    AddIndex(CurrentVertex + 0);                  AddIndex(CurrentVertex + 2);                  AddIndex(CurrentVertex + 3);                    // Four vertices per face.                  AddVertex((normal - side1 - side2) * size / 2' normal);                  AddVertex((normal - side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 + side2) * size / 2' normal);                  AddVertex((normal + side1 - side2) * size / 2' normal);              }
Magic Number,Gemini.Demo.Xna.Primitives,GeometricPrimitive,C:\repos\tgjones_gemini\src\Gemini.Demo.Xna\Primitives\GeometricPrimitive.cs,Draw,The following statement contains a magic number: foreach (var effectPass in effect.CurrentTechnique.Passes)              {                  effectPass.Apply();                    int primitiveCount = _indices.Count / 3;                    graphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0'                      _vertices.Count' 0' primitiveCount);              }
Magic Number,Gemini.Demo.Xna.Primitives,GeometricPrimitive,C:\repos\tgjones_gemini\src\Gemini.Demo.Xna\Primitives\GeometricPrimitive.cs,Draw,The following statement contains a magic number: if (color.A < 255)              {                  // Set renderstates for alpha blended rendering.                  device.BlendState = BlendState.AlphaBlend;              }              else              {                  // Set renderstates for opaque rendering.                  device.BlendState = BlendState.Opaque;              }
Magic Number,Gemini.Demo.Xna.Modules.SceneViewer.Views,SceneView,C:\repos\tgjones_gemini\src\Gemini.Demo.Xna\Modules\SceneViewer\Views\SceneView.xaml.cs,OnGraphicsControlDraw,The following statement contains a magic number: Matrix projection = Matrix.CreatePerspectiveFieldOfView(1' e.GraphicsDevice.Viewport.AspectRatio' 1' 10);
