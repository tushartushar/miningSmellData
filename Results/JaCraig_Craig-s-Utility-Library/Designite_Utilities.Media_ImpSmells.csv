Implementation smell,Namespace,Class,File,Method,Description
Long Method,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The method has 139 lines of code.
Complex Method,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,GetMinMaxPixel,Cyclomatic complexity of the method is 9
Complex Method,Utilities.Media,ScreenExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,Cyclomatic complexity of the method is 8
Complex Method,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,Cyclomatic complexity of the method is 12
Complex Method,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,Cyclomatic complexity of the method is 46
Long Parameter List,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The method has 7 parameters.
Long Parameter List,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SinWave,The method has 5 parameters.
Long Parameter List,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Watermark,The method has 6 parameters.
Long Parameter List,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Distance,The method has 6 parameters.
Long Parameter List,Utilities.Media.Procedural,CellularTexture,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\CellularTexture.cs,GetHeight,The method has 5 parameters.
Long Parameter List,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The method has 6 parameters.
Long Parameter List,Utilities.Media.Procedural,MidpointDisplacement,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\MidpointDisplacement.cs,Generate,The method has 7 parameters.
Long Parameter List,Utilities.Media.Procedural,MidpointDisplacement,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\MidpointDisplacement.cs,GenerateLines,The method has 7 parameters.
Long Parameter List,Utilities.Media.Procedural,PerlinNoise,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,Generate,The method has 9 parameters.
Long Parameter List,Utilities.Media.Procedural,PerlinNoise,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,GetSmoothNoise,The method has 5 parameters.
Long Parameter List,Utilities.Media.Procedural,PerlinNoise,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,GetValue,The method has 9 parameters.
Long Statement,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The length of the statement  "			OriginalImage.SetPixel (x' y' Color.FromArgb (((int)Red).Clamp (255' 0)' ((int)Green).Clamp (255' 0)' ((int)Blue).Clamp (255' 0))); " is 131.
Long Statement,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The length of the statement  "			Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90); " is 137.
Long Statement,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The length of the statement  "			Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height); " is 120.
Long Statement,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The length of the statement  "					int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]); " is 124.
Long Statement,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The length of the statement  "								if (Distance (TempColor.R' TempColor2.R' TempColor.G' TempColor2.G' TempColor.B' TempColor2.B) < Distance (TempColor.R' TempColor3.R' TempColor.G' TempColor3.G' TempColor.B' TempColor3.B)) { " is 190.
Long Statement,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The length of the statement  "						NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0))); " is 157.
Long Statement,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,StretchContrast,The length of the statement  "				var TempValue = Color.FromArgb (Map (CurrentPixel.R' MinValue.R' MaxValue.R)' Map (CurrentPixel.G' MinValue.G' MaxValue.G)' Map (CurrentPixel.B' MinValue.B' MaxValue.B)); " is 170.
Long Statement,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Watermark,The length of the statement  "				NewGraphics.DrawImage (WatermarkImage.InternalBitmap' new Rectangle (X' Y' WatermarkImage.Width' WatermarkImage.Height)' 0' 0' WatermarkImage.Width' WatermarkImage.Height' GraphicsUnit.Pixel' Attributes); " is 204.
Long Statement,Utilities.Media,ScreenExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,The length of the statement  "	var TempSwiftBitmap = new Bitmap (Screen.Bounds.Width > 1 ? Screen.Bounds.Width : 1' Screen.Bounds.Height > 1 ? Screen.Bounds.Height : 1' PixelFormat.Format32bppArgb); " is 167.
Long Statement,Utilities.Media,ScreenExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,The length of the statement  "				TempGraphics.CopyFromScreen (Screen.Bounds.X' Screen.Bounds.Y' 0' 0' Screen.Bounds.Size' CopyPixelOperation.SourceCopy); " is 120.
Long Statement,Utilities.Media,ScreenExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,The length of the statement  "	var TempSwiftBitmap = new Bitmap (TotalScreenRect.Width > 1 ? TotalScreenRect.Width : 1' TotalScreenRect.Height > 1 ? TotalScreenRect.Width : 1' PixelFormat.Format32bppArgb); " is 174.
Long Statement,Utilities.Media,ScreenExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,The length of the statement  "				TempGraphics.CopyFromScreen (TotalScreenRect.X' TotalScreenRect.Y' 0' 0' TotalScreenRect.Size' CopyPixelOperation.SourceCopy); " is 126.
Long Statement,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyColorMatrix,The length of the statement  "			NewGraphics.DrawImage (InternalBitmap' new System.Drawing.Rectangle (0' 0' Width' Height)' 0' 0' Width' Height' GraphicsUnit.Pixel' Attributes); " is 144.
Long Statement,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The length of the statement  "	return (PixelSize == 3) ? Color.FromArgb (TempPointer [2]' TempPointer [1]' TempPointer [0]) : Color.FromArgb (TempPointer [3]' TempPointer [2]' TempPointer [1]' TempPointer [0]); " is 179.
Long Statement,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The length of the statement  "	return (PixelSize == 3) ? Color.FromArgb (TempPointer [2]' TempPointer [1]' TempPointer [0]) : Color.FromArgb (TempPointer [3]' TempPointer [2]' TempPointer [1]' TempPointer [0]); " is 179.
Long Statement,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,Lock,The length of the statement  "	Data = InternalBitmap.LockBits (new Rectangle (0' 0' InternalBitmap.Width' InternalBitmap.Height)' ImageLockMode.ReadWrite' InternalBitmap.PixelFormat); " is 152.
Long Statement,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,Rotate,The length of the statement  "		NewGraphics.DrawImage (InternalBitmap' new System.Drawing.Rectangle (0' 0' Width' Height)' new System.Drawing.Rectangle (0' 0' Width' Height)' GraphicsUnit.Pixel); " is 163.
Long Statement,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetImageFormat,The length of the statement  "	if (fileName.EndsWith ("jpg"' StringComparison.InvariantCultureIgnoreCase) || fileName.EndsWith ("jpeg"' StringComparison.InvariantCultureIgnoreCase)) " is 150.
Long Statement,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixelSize,The length of the statement  "	else if (Data.PixelFormat == PixelFormat.Format32bppArgb || Data.PixelFormat == PixelFormat.Format32bppPArgb || Data.PixelFormat == PixelFormat.Format32bppRgb) " is 159.
Long Statement,Utilities.Media.Procedural,CellularMap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\CellularMap.cs,FindClosestPoint,The length of the statement  "		var Distance = (float)System.Math.Sqrt (((Points [z].X - x) * (Points [z].X - x)) + ((Points [z].Y - y) * (Points [z].Y - y))); " is 127.
Long Statement,Utilities.Media.Procedural,MidpointDisplacement,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\MidpointDisplacement.cs,GenerateLines,The length of the statement  "			TempLine = new Line (Generator.Next (0' Width)' Generator.Next (0' Width)' Generator.Next (0' Height)' Generator.Next (0' Height)); " is 131.
Long Statement,Utilities.Media.Procedural,MidpointDisplacement,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\MidpointDisplacement.cs,GenerateLines,The length of the statement  "			LineLength = (int)System.Math.Sqrt ((double)((TempLine.X1 - TempLine.X2) * (TempLine.X1 - TempLine.X2)) + ((TempLine.Y1 - TempLine.Y2) * (TempLine.Y1 - TempLine.Y2))); " is 167.
Complex Conditional,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The conditional expression  "TempX1 >= 0 && TempX1 < Width && TempX2 >= 0 && TempX2 < Width"  is complex.
Complex Conditional,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The conditional expression  "TempY1 >= 0 && TempY1 < Height && TempY2 >= 0 && TempY2 < Height"  is complex.
Virtual Method Call from Constructor,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,RGBHistogram,The constructor "RGBHistogram" calls a virtual method "LoadImage".
Empty Catch Block,Utilities.Media,ScreenExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,The method has an empty catch block.
Empty Catch Block,Utilities.Media,ScreenExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,The method has an empty catch block.
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AddNoise,The following statement contains a magic number: Parallel.For (0' Image.Width' x => {  	for (int y = 0; y < Image.Height; ++y) {  		var CurrentPixel = Image.GetPixel (x' y);  		int R = CurrentPixel.R + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  		int G = CurrentPixel.G + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  		int B = CurrentPixel.B + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  		var TempValue = Color.FromArgb (R.Clamp (255' 0)' G.Clamp (255' 0)' B.Clamp (255' 0));  		Image.SetPixel (x' y' TempValue);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AddNoise,The following statement contains a magic number: Parallel.For (0' Image.Width' x => {  	for (int y = 0; y < Image.Height; ++y) {  		var CurrentPixel = Image.GetPixel (x' y);  		int R = CurrentPixel.R + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  		int G = CurrentPixel.G + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  		int B = CurrentPixel.B + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  		var TempValue = Color.FromArgb (R.Clamp (255' 0)' G.Clamp (255' 0)' B.Clamp (255' 0));  		Image.SetPixel (x' y' TempValue);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AddNoise,The following statement contains a magic number: Parallel.For (0' Image.Width' x => {  	for (int y = 0; y < Image.Height; ++y) {  		var CurrentPixel = Image.GetPixel (x' y);  		int R = CurrentPixel.R + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  		int G = CurrentPixel.G + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  		int B = CurrentPixel.B + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  		var TempValue = Color.FromArgb (R.Clamp (255' 0)' G.Clamp (255' 0)' B.Clamp (255' 0));  		Image.SetPixel (x' y' TempValue);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AddNoise,The following statement contains a magic number: for (int y = 0; y < Image.Height; ++y) {  	var CurrentPixel = Image.GetPixel (x' y);  	int R = CurrentPixel.R + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  	int G = CurrentPixel.G + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  	int B = CurrentPixel.B + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  	var TempValue = Color.FromArgb (R.Clamp (255' 0)' G.Clamp (255' 0)' B.Clamp (255' 0));  	Image.SetPixel (x' y' TempValue);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AddNoise,The following statement contains a magic number: for (int y = 0; y < Image.Height; ++y) {  	var CurrentPixel = Image.GetPixel (x' y);  	int R = CurrentPixel.R + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  	int G = CurrentPixel.G + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  	int B = CurrentPixel.B + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  	var TempValue = Color.FromArgb (R.Clamp (255' 0)' G.Clamp (255' 0)' B.Clamp (255' 0));  	Image.SetPixel (x' y' TempValue);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AddNoise,The following statement contains a magic number: for (int y = 0; y < Image.Height; ++y) {  	var CurrentPixel = Image.GetPixel (x' y);  	int R = CurrentPixel.R + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  	int G = CurrentPixel.G + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  	int B = CurrentPixel.B + Random.Random.ThreadSafeNext (-Amount' Amount + 1);  	var TempValue = Color.FromArgb (R.Clamp (255' 0)' G.Clamp (255' 0)' B.Clamp (255' 0));  	Image.SetPixel (x' y' TempValue);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For (0' OriginalImage.Width' x => {  	for (int y = 0; y < OriginalImage.Height; ++y) {  		var Pixel = OriginalImage.GetPixel (x' y);  		float Red = Pixel.R / 255.0f;  		float Green = Pixel.G / 255.0f;  		float Blue = Pixel.B / 255.0f;  		Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;  		Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;  		Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;  		OriginalImage.SetPixel (x' y' Color.FromArgb (((int)Red).Clamp (255' 0)' ((int)Green).Clamp (255' 0)' ((int)Blue).Clamp (255' 0)));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For (0' OriginalImage.Width' x => {  	for (int y = 0; y < OriginalImage.Height; ++y) {  		var Pixel = OriginalImage.GetPixel (x' y);  		float Red = Pixel.R / 255.0f;  		float Green = Pixel.G / 255.0f;  		float Blue = Pixel.B / 255.0f;  		Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;  		Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;  		Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;  		OriginalImage.SetPixel (x' y' Color.FromArgb (((int)Red).Clamp (255' 0)' ((int)Green).Clamp (255' 0)' ((int)Blue).Clamp (255' 0)));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For (0' OriginalImage.Width' x => {  	for (int y = 0; y < OriginalImage.Height; ++y) {  		var Pixel = OriginalImage.GetPixel (x' y);  		float Red = Pixel.R / 255.0f;  		float Green = Pixel.G / 255.0f;  		float Blue = Pixel.B / 255.0f;  		Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;  		Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;  		Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;  		OriginalImage.SetPixel (x' y' Color.FromArgb (((int)Red).Clamp (255' 0)' ((int)Green).Clamp (255' 0)' ((int)Blue).Clamp (255' 0)));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: for (int y = 0; y < OriginalImage.Height; ++y) {  	var Pixel = OriginalImage.GetPixel (x' y);  	float Red = Pixel.R / 255.0f;  	float Green = Pixel.G / 255.0f;  	float Blue = Pixel.B / 255.0f;  	Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;  	Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;  	Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;  	OriginalImage.SetPixel (x' y' Color.FromArgb (((int)Red).Clamp (255' 0)' ((int)Green).Clamp (255' 0)' ((int)Blue).Clamp (255' 0)));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: for (int y = 0; y < OriginalImage.Height; ++y) {  	var Pixel = OriginalImage.GetPixel (x' y);  	float Red = Pixel.R / 255.0f;  	float Green = Pixel.G / 255.0f;  	float Blue = Pixel.B / 255.0f;  	Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;  	Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;  	Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;  	OriginalImage.SetPixel (x' y' Color.FromArgb (((int)Red).Clamp (255' 0)' ((int)Green).Clamp (255' 0)' ((int)Blue).Clamp (255' 0)));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: for (int y = 0; y < OriginalImage.Height; ++y) {  	var Pixel = OriginalImage.GetPixel (x' y);  	float Red = Pixel.R / 255.0f;  	float Green = Pixel.G / 255.0f;  	float Blue = Pixel.B / 255.0f;  	Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;  	Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;  	Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;  	OriginalImage.SetPixel (x' y' Color.FromArgb (((int)Red).Clamp (255' 0)' ((int)Green).Clamp (255' 0)' ((int)Blue).Clamp (255' 0)));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: OriginalImage.SetPixel (x' y' Color.FromArgb (((int)Red).Clamp (255' 0)' ((int)Green).Clamp (255' 0)' ((int)Blue).Clamp (255' 0)));  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: OriginalImage.SetPixel (x' y' Color.FromArgb (((int)Red).Clamp (255' 0)' ((int)Green).Clamp (255' 0)' ((int)Blue).Clamp (255' 0)));  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: OriginalImage.SetPixel (x' y' Color.FromArgb (((int)Red).Clamp (255' 0)' ((int)Green).Clamp (255' 0)' ((int)Blue).Clamp (255' 0)));  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Parallel.For (0' 256' x => {  	Ramp [x] = ((int)((255.0 * System.Math.Pow (x / 255.0' 1.0 / Value)) + 0.5)).Clamp (255' 0);  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Parallel.For (0' 256' x => {  	Ramp [x] = ((int)((255.0 * System.Math.Pow (x / 255.0' 1.0 / Value)) + 0.5)).Clamp (255' 0);  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Parallel.For (0' 256' x => {  	Ramp [x] = ((int)((255.0 * System.Math.Pow (x / 255.0' 1.0 / Value)) + 0.5)).Clamp (255' 0);  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Parallel.For (0' 256' x => {  	Ramp [x] = ((int)((255.0 * System.Math.Pow (x / 255.0' 1.0 / Value)) + 0.5)).Clamp (255' 0);  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Parallel.For (0' 256' x => {  	Ramp [x] = ((int)((255.0 * System.Math.Pow (x / 255.0' 1.0 / Value)) + 0.5)).Clamp (255' 0);  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Ramp [x] = ((int)((255.0 * System.Math.Pow (x / 255.0' 1.0 / Value)) + 0.5)).Clamp (255' 0);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Ramp [x] = ((int)((255.0 * System.Math.Pow (x / 255.0' 1.0 / Value)) + 0.5)).Clamp (255' 0);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Ramp [x] = ((int)((255.0 * System.Math.Pow (x / 255.0' 1.0 / Value)) + 0.5)).Clamp (255' 0);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Ramp [x] = ((int)((255.0 * System.Math.Pow (x / 255.0' 1.0 / Value)) + 0.5)).Clamp (255' 0);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (Direction == Direction.TopBottom) {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				2'  				1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				-1'  				-2'  				-1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				-2'  				-1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				1'  				2'  				1  			}  		};  	}  } else {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				0'  				1  			}'  			new int[] {  				-2'  				0'  				2  			}'  			new int[] {  				-1'  				0'  				1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				0'  				-1  			}'  			new int[] {  				2'  				0'  				-2  			}'  			new int[] {  				1'  				0'  				-1  			}  		};  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (Direction == Direction.TopBottom) {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				2'  				1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				-1'  				-2'  				-1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				-2'  				-1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				1'  				2'  				1  			}  		};  	}  } else {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				0'  				1  			}'  			new int[] {  				-2'  				0'  				2  			}'  			new int[] {  				-1'  				0'  				1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				0'  				-1  			}'  			new int[] {  				2'  				0'  				-2  			}'  			new int[] {  				1'  				0'  				-1  			}  		};  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (Direction == Direction.TopBottom) {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				2'  				1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				-1'  				-2'  				-1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				-2'  				-1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				1'  				2'  				1  			}  		};  	}  } else {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				0'  				1  			}'  			new int[] {  				-2'  				0'  				2  			}'  			new int[] {  				-1'  				0'  				1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				0'  				-1  			}'  			new int[] {  				2'  				0'  				-2  			}'  			new int[] {  				1'  				0'  				-1  			}  		};  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (Direction == Direction.TopBottom) {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				2'  				1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				-1'  				-2'  				-1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				-2'  				-1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				1'  				2'  				1  			}  		};  	}  } else {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				0'  				1  			}'  			new int[] {  				-2'  				0'  				2  			}'  			new int[] {  				-1'  				0'  				1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				0'  				-1  			}'  			new int[] {  				2'  				0'  				-2  			}'  			new int[] {  				1'  				0'  				-1  			}  		};  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (Direction == Direction.TopBottom) {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				2'  				1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				-1'  				-2'  				-1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				-2'  				-1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				1'  				2'  				1  			}  		};  	}  } else {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				0'  				1  			}'  			new int[] {  				-2'  				0'  				2  			}'  			new int[] {  				-1'  				0'  				1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				0'  				-1  			}'  			new int[] {  				2'  				0'  				-2  			}'  			new int[] {  				1'  				0'  				-1  			}  		};  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (Direction == Direction.TopBottom) {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				2'  				1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				-1'  				-2'  				-1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				-2'  				-1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				1'  				2'  				1  			}  		};  	}  } else {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				0'  				1  			}'  			new int[] {  				-2'  				0'  				2  			}'  			new int[] {  				-1'  				0'  				1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				0'  				-1  			}'  			new int[] {  				2'  				0'  				-2  			}'  			new int[] {  				1'  				0'  				-1  			}  		};  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (Direction == Direction.TopBottom) {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				2'  				1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				-1'  				-2'  				-1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				-2'  				-1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				1'  				2'  				1  			}  		};  	}  } else {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				0'  				1  			}'  			new int[] {  				-2'  				0'  				2  			}'  			new int[] {  				-1'  				0'  				1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				0'  				-1  			}'  			new int[] {  				2'  				0'  				-2  			}'  			new int[] {  				1'  				0'  				-1  			}  		};  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (Direction == Direction.TopBottom) {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				2'  				1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				-1'  				-2'  				-1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				-2'  				-1  			}'  			new int[] {  				0'  				0'  				0  			}'  			new int[] {  				1'  				2'  				1  			}  		};  	}  } else {  	if (!Invert) {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				-1'  				0'  				1  			}'  			new int[] {  				-2'  				0'  				2  			}'  			new int[] {  				-1'  				0'  				1  			}  		};  	} else {  		EdgeDetectionFilter = new int[][] {  			new int[] {  				1'  				0'  				-1  			}'  			new int[] {  				2'  				0'  				-2  			}'  			new int[] {  				1'  				0'  				-1  			}  		};  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (!Invert) {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			1'  			2'  			1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			-1'  			-2'  			-1  		}  	};  } else {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			-1'  			-2'  			-1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			1'  			2'  			1  		}  	};  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (!Invert) {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			1'  			2'  			1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			-1'  			-2'  			-1  		}  	};  } else {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			-1'  			-2'  			-1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			1'  			2'  			1  		}  	};  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (!Invert) {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			1'  			2'  			1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			-1'  			-2'  			-1  		}  	};  } else {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			-1'  			-2'  			-1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			1'  			2'  			1  		}  	};  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (!Invert) {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			1'  			2'  			1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			-1'  			-2'  			-1  		}  	};  } else {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			-1'  			-2'  			-1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			1'  			2'  			1  		}  	};  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: EdgeDetectionFilter = new int[][] {  	new int[] {  		1'  		2'  		1  	}'  	new int[] {  		0'  		0'  		0  	}'  	new int[] {  		-1'  		-2'  		-1  	}  };  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: EdgeDetectionFilter = new int[][] {  	new int[] {  		1'  		2'  		1  	}'  	new int[] {  		0'  		0'  		0  	}'  	new int[] {  		-1'  		-2'  		-1  	}  };  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: EdgeDetectionFilter = new int[][] {  	new int[] {  		-1'  		-2'  		-1  	}'  	new int[] {  		0'  		0'  		0  	}'  	new int[] {  		1'  		2'  		1  	}  };  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: EdgeDetectionFilter = new int[][] {  	new int[] {  		-1'  		-2'  		-1  	}'  	new int[] {  		0'  		0'  		0  	}'  	new int[] {  		1'  		2'  		1  	}  };  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (!Invert) {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			-1'  			0'  			1  		}'  		new int[] {  			-2'  			0'  			2  		}'  		new int[] {  			-1'  			0'  			1  		}  	};  } else {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			1'  			0'  			-1  		}'  		new int[] {  			2'  			0'  			-2  		}'  		new int[] {  			1'  			0'  			-1  		}  	};  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (!Invert) {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			-1'  			0'  			1  		}'  		new int[] {  			-2'  			0'  			2  		}'  		new int[] {  			-1'  			0'  			1  		}  	};  } else {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			1'  			0'  			-1  		}'  		new int[] {  			2'  			0'  			-2  		}'  		new int[] {  			1'  			0'  			-1  		}  	};  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (!Invert) {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			-1'  			0'  			1  		}'  		new int[] {  			-2'  			0'  			2  		}'  		new int[] {  			-1'  			0'  			1  		}  	};  } else {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			1'  			0'  			-1  		}'  		new int[] {  			2'  			0'  			-2  		}'  		new int[] {  			1'  			0'  			-1  		}  	};  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: if (!Invert) {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			-1'  			0'  			1  		}'  		new int[] {  			-2'  			0'  			2  		}'  		new int[] {  			-1'  			0'  			1  		}  	};  } else {  	EdgeDetectionFilter = new int[][] {  		new int[] {  			1'  			0'  			-1  		}'  		new int[] {  			2'  			0'  			-2  		}'  		new int[] {  			1'  			0'  			-1  		}  	};  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: EdgeDetectionFilter = new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  };  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: EdgeDetectionFilter = new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  };  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: EdgeDetectionFilter = new int[][] {  	new int[] {  		1'  		0'  		-1  	}'  	new int[] {  		2'  		0'  		-2  	}'  	new int[] {  		1'  		0'  		-1  	}  };  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: EdgeDetectionFilter = new int[][] {  	new int[] {  		1'  		0'  		-1  	}'  	new int[] {  		2'  		0'  		-2  	}'  	new int[] {  		1'  		0'  		-1  	}  };  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: return Image.ApplyConvolutionFilter (EdgeDetectionFilter' false' 127).BlackAndWhite ();  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Colorize,The following statement contains a magic number: if (Colors.Length < 256)  	return new SwiftBitmap (1' 1);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Dilate,The following statement contains a magic number: using (SwiftBitmap TempImage = (SwiftBitmap)OriginalImage.Clone ()) {  	OriginalImage.Lock ();  	TempImage.Lock ();  	int ApetureMin = -(Size / 2);  	int ApetureMax = (Size / 2);  	Parallel.For (0' OriginalImage.Width' x => {  		for (int y = 0; y < OriginalImage.Height; ++y) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			for (int x2 = ApetureMin; x2 < ApetureMax; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < OriginalImage.Width) {  					for (int y2 = ApetureMin; y2 < ApetureMax; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < OriginalImage.Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValue = RValue.Max (TempColor.R);  							GValue = GValue.Max (TempColor.G);  							BValue = BValue.Max (TempColor.B);  						}  					}  				}  			}  			TempImage.SetPixel (x' y' Color.FromArgb (RValue' GValue' BValue));  		}  	});  	TempImage.Unlock ();  	return OriginalImage.Unlock ().Copy (TempImage);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Dilate,The following statement contains a magic number: using (SwiftBitmap TempImage = (SwiftBitmap)OriginalImage.Clone ()) {  	OriginalImage.Lock ();  	TempImage.Lock ();  	int ApetureMin = -(Size / 2);  	int ApetureMax = (Size / 2);  	Parallel.For (0' OriginalImage.Width' x => {  		for (int y = 0; y < OriginalImage.Height; ++y) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			for (int x2 = ApetureMin; x2 < ApetureMax; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < OriginalImage.Width) {  					for (int y2 = ApetureMin; y2 < ApetureMax; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < OriginalImage.Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValue = RValue.Max (TempColor.R);  							GValue = GValue.Max (TempColor.G);  							BValue = BValue.Max (TempColor.B);  						}  					}  				}  			}  			TempImage.SetPixel (x' y' Color.FromArgb (RValue' GValue' BValue));  		}  	});  	TempImage.Unlock ();  	return OriginalImage.Unlock ().Copy (TempImage);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (Pen BoxPen = new Pen (BoxColor)) {  	using (GraphicsPath Path = new GraphicsPath ()) {  		Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  		Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  		Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  		Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  		Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  		Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  		Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  		Path.CloseFigure ();  		Image.DrawPath (BoxPen' Path);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: using (GraphicsPath Path = new GraphicsPath ()) {  	Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  	Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  	Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  	Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  	Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  	Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  	Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  	Path.CloseFigure ();  	Image.DrawPath (BoxPen' Path);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddLine (XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddLine (XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddLine (XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddLine (XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc (XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Emboss,The following statement contains a magic number: return Image.ApplyConvolutionFilter (new int[][] {  	new int[] {  		-2'  		-1'  		0  	}'  	new int[] {  		-1'  		1'  		1  	}'  	new int[] {  		0'  		1'  		2  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Emboss,The following statement contains a magic number: return Image.ApplyConvolutionFilter (new int[][] {  	new int[] {  		-2'  		-1'  		0  	}'  	new int[] {  		-1'  		1'  		1  	}'  	new int[] {  		0'  		1'  		2  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	var TempHistogram = new RGBHistogram (OriginalImage);  	TempHistogram.Equalize ();  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	Parallel.For (0' OriginalImage.Width' x => {  		for (int y = 0; y < OriginalImage.Height; ++y) {  			var Current = OriginalImage.GetPixel (x' y);  			var NewR = (int)TempHistogram.R [Current.R];  			var NewG = (int)TempHistogram.G [Current.G];  			var NewB = (int)TempHistogram.B [Current.B];  			NewR = NewR.Clamp (255' 0);  			NewG = NewG.Clamp (255' 0);  			NewB = NewB.Clamp (255' 0);  			NewSwiftBitmap.SetPixel (x' y' Color.FromArgb (NewR' NewG' NewB));  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	var TempHistogram = new RGBHistogram (OriginalImage);  	TempHistogram.Equalize ();  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	Parallel.For (0' OriginalImage.Width' x => {  		for (int y = 0; y < OriginalImage.Height; ++y) {  			var Current = OriginalImage.GetPixel (x' y);  			var NewR = (int)TempHistogram.R [Current.R];  			var NewG = (int)TempHistogram.G [Current.G];  			var NewB = (int)TempHistogram.B [Current.B];  			NewR = NewR.Clamp (255' 0);  			NewG = NewG.Clamp (255' 0);  			NewB = NewB.Clamp (255' 0);  			NewSwiftBitmap.SetPixel (x' y' Color.FromArgb (NewR' NewG' NewB));  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	var TempHistogram = new RGBHistogram (OriginalImage);  	TempHistogram.Equalize ();  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	Parallel.For (0' OriginalImage.Width' x => {  		for (int y = 0; y < OriginalImage.Height; ++y) {  			var Current = OriginalImage.GetPixel (x' y);  			var NewR = (int)TempHistogram.R [Current.R];  			var NewG = (int)TempHistogram.G [Current.G];  			var NewB = (int)TempHistogram.B [Current.B];  			NewR = NewR.Clamp (255' 0);  			NewG = NewG.Clamp (255' 0);  			NewB = NewB.Clamp (255' 0);  			NewSwiftBitmap.SetPixel (x' y' Color.FromArgb (NewR' NewG' NewB));  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: Parallel.For (0' OriginalImage.Width' x => {  	for (int y = 0; y < OriginalImage.Height; ++y) {  		var Current = OriginalImage.GetPixel (x' y);  		var NewR = (int)TempHistogram.R [Current.R];  		var NewG = (int)TempHistogram.G [Current.G];  		var NewB = (int)TempHistogram.B [Current.B];  		NewR = NewR.Clamp (255' 0);  		NewG = NewG.Clamp (255' 0);  		NewB = NewB.Clamp (255' 0);  		NewSwiftBitmap.SetPixel (x' y' Color.FromArgb (NewR' NewG' NewB));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: Parallel.For (0' OriginalImage.Width' x => {  	for (int y = 0; y < OriginalImage.Height; ++y) {  		var Current = OriginalImage.GetPixel (x' y);  		var NewR = (int)TempHistogram.R [Current.R];  		var NewG = (int)TempHistogram.G [Current.G];  		var NewB = (int)TempHistogram.B [Current.B];  		NewR = NewR.Clamp (255' 0);  		NewG = NewG.Clamp (255' 0);  		NewB = NewB.Clamp (255' 0);  		NewSwiftBitmap.SetPixel (x' y' Color.FromArgb (NewR' NewG' NewB));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: Parallel.For (0' OriginalImage.Width' x => {  	for (int y = 0; y < OriginalImage.Height; ++y) {  		var Current = OriginalImage.GetPixel (x' y);  		var NewR = (int)TempHistogram.R [Current.R];  		var NewG = (int)TempHistogram.G [Current.G];  		var NewB = (int)TempHistogram.B [Current.B];  		NewR = NewR.Clamp (255' 0);  		NewG = NewG.Clamp (255' 0);  		NewB = NewB.Clamp (255' 0);  		NewSwiftBitmap.SetPixel (x' y' Color.FromArgb (NewR' NewG' NewB));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: for (int y = 0; y < OriginalImage.Height; ++y) {  	var Current = OriginalImage.GetPixel (x' y);  	var NewR = (int)TempHistogram.R [Current.R];  	var NewG = (int)TempHistogram.G [Current.G];  	var NewB = (int)TempHistogram.B [Current.B];  	NewR = NewR.Clamp (255' 0);  	NewG = NewG.Clamp (255' 0);  	NewB = NewB.Clamp (255' 0);  	NewSwiftBitmap.SetPixel (x' y' Color.FromArgb (NewR' NewG' NewB));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: for (int y = 0; y < OriginalImage.Height; ++y) {  	var Current = OriginalImage.GetPixel (x' y);  	var NewR = (int)TempHistogram.R [Current.R];  	var NewG = (int)TempHistogram.G [Current.G];  	var NewB = (int)TempHistogram.B [Current.B];  	NewR = NewR.Clamp (255' 0);  	NewG = NewG.Clamp (255' 0);  	NewB = NewB.Clamp (255' 0);  	NewSwiftBitmap.SetPixel (x' y' Color.FromArgb (NewR' NewG' NewB));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: for (int y = 0; y < OriginalImage.Height; ++y) {  	var Current = OriginalImage.GetPixel (x' y);  	var NewR = (int)TempHistogram.R [Current.R];  	var NewG = (int)TempHistogram.G [Current.G];  	var NewB = (int)TempHistogram.B [Current.B];  	NewR = NewR.Clamp (255' 0);  	NewG = NewG.Clamp (255' 0);  	NewB = NewB.Clamp (255' 0);  	NewSwiftBitmap.SetPixel (x' y' Color.FromArgb (NewR' NewG' NewB));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: NewR = NewR.Clamp (255' 0);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: NewG = NewG.Clamp (255' 0);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: NewB = NewB.Clamp (255' 0);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int[] ApetureMinX =  {  		-(Size / 2)'  		0'  		-(Size / 2)'  		0  	};  	int[] ApetureMaxX =  {  		0'  		(Size / 2)'  		0'  		(Size / 2)  	};  	int[] ApetureMinY =  {  		-(Size / 2)'  		-(Size / 2)'  		0'  		0  	};  	int[] ApetureMaxY =  {  		0'  		0'  		(Size / 2)'  		(Size / 2)  	};  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int[] RValues =  {  				0'  				0'  				0'  				0  			};  			int[] GValues =  {  				0'  				0'  				0'  				0  			};  			int[] BValues =  {  				0'  				0'  				0'  				0  			};  			int[] NumPixels =  {  				0'  				0'  				0'  				0  			};  			int[] MaxRValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxGValue =  {  				0'  				0'  				0'  				0  			};  			int[] MaxBValue =  {  				0'  				0'  				0'  				0  			};  			int[] MinRValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinGValue =  {  				255'  				255'  				255'  				255  			};  			int[] MinBValue =  {  				255'  				255'  				255'  				255  			};  			for (int i = 0; i < 4; ++i) {  				for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  					int TempX = x + x2;  					if (TempX >= 0 && TempX < Width) {  						for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  							int TempY = y + y2;  							if (TempY >= 0 && TempY < Height) {  								var TempColor = OriginalImage.GetPixel (TempX' TempY);  								RValues [i] += TempColor.R;  								GValues [i] += TempColor.G;  								BValues [i] += TempColor.B;  								if (TempColor.R > MaxRValue [i])  									MaxRValue [i] = TempColor.R;  								else if (TempColor.R < MinRValue [i])  									MinRValue [i] = TempColor.R;  								if (TempColor.G > MaxGValue [i])  									MaxGValue [i] = TempColor.G;  								else if (TempColor.G < MinGValue [i])  									MinGValue [i] = TempColor.G;  								if (TempColor.B > MaxBValue [i])  									MaxBValue [i] = TempColor.B;  								else if (TempColor.B < MinBValue [i])  									MinBValue [i] = TempColor.B;  								++NumPixels [i];  							}  						}  					}  				}  			}  			int j = 0;  			int MinDifference = 10000;  			for (int i = 0; i < 4; ++i) {  				int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  				if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  					j = i;  					MinDifference = CurrentDifference;  				}  			}  			var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int[] RValues =  {  			0'  			0'  			0'  			0  		};  		int[] GValues =  {  			0'  			0'  			0'  			0  		};  		int[] BValues =  {  			0'  			0'  			0'  			0  		};  		int[] NumPixels =  {  			0'  			0'  			0'  			0  		};  		int[] MaxRValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxGValue =  {  			0'  			0'  			0'  			0  		};  		int[] MaxBValue =  {  			0'  			0'  			0'  			0  		};  		int[] MinRValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinGValue =  {  			255'  			255'  			255'  			255  		};  		int[] MinBValue =  {  			255'  			255'  			255'  			255  		};  		for (int i = 0; i < 4; ++i) {  			for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues [i] += TempColor.R;  							GValues [i] += TempColor.G;  							BValues [i] += TempColor.B;  							if (TempColor.R > MaxRValue [i])  								MaxRValue [i] = TempColor.R;  							else if (TempColor.R < MinRValue [i])  								MinRValue [i] = TempColor.R;  							if (TempColor.G > MaxGValue [i])  								MaxGValue [i] = TempColor.G;  							else if (TempColor.G < MinGValue [i])  								MinGValue [i] = TempColor.G;  							if (TempColor.B > MaxBValue [i])  								MaxBValue [i] = TempColor.B;  							else if (TempColor.B < MinBValue [i])  								MinBValue [i] = TempColor.B;  							++NumPixels [i];  						}  					}  				}  			}  		}  		int j = 0;  		int MinDifference = 10000;  		for (int i = 0; i < 4; ++i) {  			int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  			if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  				j = i;  				MinDifference = CurrentDifference;  			}  		}  		var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  		NewSwiftBitmap.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int[] RValues =  {  		0'  		0'  		0'  		0  	};  	int[] GValues =  {  		0'  		0'  		0'  		0  	};  	int[] BValues =  {  		0'  		0'  		0'  		0  	};  	int[] NumPixels =  {  		0'  		0'  		0'  		0  	};  	int[] MaxRValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxGValue =  {  		0'  		0'  		0'  		0  	};  	int[] MaxBValue =  {  		0'  		0'  		0'  		0  	};  	int[] MinRValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinGValue =  {  		255'  		255'  		255'  		255  	};  	int[] MinBValue =  {  		255'  		255'  		255'  		255  	};  	for (int i = 0; i < 4; ++i) {  		for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  			int TempX = x + x2;  			if (TempX >= 0 && TempX < Width) {  				for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  					int TempY = y + y2;  					if (TempY >= 0 && TempY < Height) {  						var TempColor = OriginalImage.GetPixel (TempX' TempY);  						RValues [i] += TempColor.R;  						GValues [i] += TempColor.G;  						BValues [i] += TempColor.B;  						if (TempColor.R > MaxRValue [i])  							MaxRValue [i] = TempColor.R;  						else if (TempColor.R < MinRValue [i])  							MinRValue [i] = TempColor.R;  						if (TempColor.G > MaxGValue [i])  							MaxGValue [i] = TempColor.G;  						else if (TempColor.G < MinGValue [i])  							MinGValue [i] = TempColor.G;  						if (TempColor.B > MaxBValue [i])  							MaxBValue [i] = TempColor.B;  						else if (TempColor.B < MinBValue [i])  							MinBValue [i] = TempColor.B;  						++NumPixels [i];  					}  				}  			}  		}  	}  	int j = 0;  	int MinDifference = 10000;  	for (int i = 0; i < 4; ++i) {  		int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  		if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  			j = i;  			MinDifference = CurrentDifference;  		}  	}  	var MeanPixel = Color.FromArgb (RValues [j] / NumPixels [j]' GValues [j] / NumPixels [j]' BValues [j] / NumPixels [j]);  	NewSwiftBitmap.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	for (int x2 = ApetureMinX [i]; x2 < ApetureMaxX [i]; ++x2) {  		int TempX = x + x2;  		if (TempX >= 0 && TempX < Width) {  			for (int y2 = ApetureMinY [i]; y2 < ApetureMaxY [i]; ++y2) {  				int TempY = y + y2;  				if (TempY >= 0 && TempY < Height) {  					var TempColor = OriginalImage.GetPixel (TempX' TempY);  					RValues [i] += TempColor.R;  					GValues [i] += TempColor.G;  					BValues [i] += TempColor.B;  					if (TempColor.R > MaxRValue [i])  						MaxRValue [i] = TempColor.R;  					else if (TempColor.R < MinRValue [i])  						MinRValue [i] = TempColor.R;  					if (TempColor.G > MaxGValue [i])  						MaxGValue [i] = TempColor.G;  					else if (TempColor.G < MinGValue [i])  						MinGValue [i] = TempColor.G;  					if (TempColor.B > MaxBValue [i])  						MaxBValue [i] = TempColor.B;  					else if (TempColor.B < MinBValue [i])  						MinBValue [i] = TempColor.B;  					++NumPixels [i];  				}  			}  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	int CurrentDifference = (MaxRValue [i] - MinRValue [i]) + (MaxGValue [i] - MinGValue [i]) + (MaxBValue [i] - MinBValue [i]);  	if (CurrentDifference < MinDifference && NumPixels [i] > 0) {  		j = i;  		MinDifference = CurrentDifference;  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,LaplaceEdgeDetection,The following statement contains a magic number: return Image.BlackAndWhite ().ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		-1'  		-1'  		-1'  		-1  	}'  	new int[] {  		-1'  		-1'  		-1'  		-1'  		-1  	}'  	new int[] {  		-1'  		-1'  		24'  		-1'  		-1  	}'  	new int[] {  		-1'  		-1'  		-1'  		-1'  		-1  	}'  	new int[] {  		-1'  		-1'  		-1'  		-1'  		-1  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,MedianFilter,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int ApetureMin = -(Size / 2);  	int ApetureMax = (Size / 2);  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			var RValues = new List<int> ();  			var GValues = new List<int> ();  			var BValues = new List<int> ();  			for (int x2 = ApetureMin; x2 < ApetureMax; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMin; y2 < ApetureMax; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues.Add (TempColor.R);  							GValues.Add (TempColor.G);  							BValues.Add (TempColor.B);  						}  					}  				}  			}  			var MedianPixel = Color.FromArgb (RValues.Median ()' GValues.Median ()' BValues.Median ());  			NewSwiftBitmap.SetPixel (x' y' MedianPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,MedianFilter,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int ApetureMin = -(Size / 2);  	int ApetureMax = (Size / 2);  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			var RValues = new List<int> ();  			var GValues = new List<int> ();  			var BValues = new List<int> ();  			for (int x2 = ApetureMin; x2 < ApetureMax; ++x2) {  				int TempX = x + x2;  				if (TempX >= 0 && TempX < Width) {  					for (int y2 = ApetureMin; y2 < ApetureMax; ++y2) {  						int TempY = y + y2;  						if (TempY >= 0 && TempY < Height) {  							var TempColor = OriginalImage.GetPixel (TempX' TempY);  							RValues.Add (TempColor.R);  							GValues.Add (TempColor.G);  							BValues.Add (TempColor.B);  						}  					}  				}  			}  			var MedianPixel = Color.FromArgb (RValues.Median ()' GValues.Median ()' BValues.Median ());  			NewSwiftBitmap.SetPixel (x' y' MedianPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			var CurrentPixel = OriginalImage.GetPixel (x' y);  			var TempValue = Color.FromArgb (255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);  			NewSwiftBitmap.SetPixel (x' y' TempValue);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			var CurrentPixel = OriginalImage.GetPixel (x' y);  			var TempValue = Color.FromArgb (255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);  			NewSwiftBitmap.SetPixel (x' y' TempValue);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			var CurrentPixel = OriginalImage.GetPixel (x' y);  			var TempValue = Color.FromArgb (255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);  			NewSwiftBitmap.SetPixel (x' y' TempValue);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		var CurrentPixel = OriginalImage.GetPixel (x' y);  		var TempValue = Color.FromArgb (255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);  		NewSwiftBitmap.SetPixel (x' y' TempValue);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		var CurrentPixel = OriginalImage.GetPixel (x' y);  		var TempValue = Color.FromArgb (255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);  		NewSwiftBitmap.SetPixel (x' y' TempValue);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		var CurrentPixel = OriginalImage.GetPixel (x' y);  		var TempValue = Color.FromArgb (255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);  		NewSwiftBitmap.SetPixel (x' y' TempValue);  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	var CurrentPixel = OriginalImage.GetPixel (x' y);  	var TempValue = Color.FromArgb (255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);  	NewSwiftBitmap.SetPixel (x' y' TempValue);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	var CurrentPixel = OriginalImage.GetPixel (x' y);  	var TempValue = Color.FromArgb (255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);  	NewSwiftBitmap.SetPixel (x' y' TempValue);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	var CurrentPixel = OriginalImage.GetPixel (x' y);  	var TempValue = Color.FromArgb (255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);  	NewSwiftBitmap.SetPixel (x' y' TempValue);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.LeftRight' InvertX)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  		using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  			TempImageX.Lock ();  			TempImageY.Lock ();  			ReturnImage.Lock ();  			int Width = TempImageX.Width;  			int Height = TempImageX.Height;  			Parallel.For (0' Height' y => {  				var TempVector = new Vector3 (0.0' 0.0' 0.0);  				for (int x = 0; x < Width; ++x) {  					var TempPixelX = TempImageX.GetPixel (x' y);  					var TempPixelY = TempImageY.GetPixel (x' y);  					TempVector.X = (double)(TempPixelX.R) / 255.0;  					TempVector.Y = (double)(TempPixelY.R) / 255.0;  					TempVector.Z = 1.0;  					TempVector.Normalize ();  					TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  					TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  					TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  					ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  				}  			});  			TempImageX.Unlock ();  			TempImageY.Unlock ();  			ReturnImage.Unlock ();  			return ImageUsing.Copy (ReturnImage);  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.LeftRight' InvertX)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  		using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  			TempImageX.Lock ();  			TempImageY.Lock ();  			ReturnImage.Lock ();  			int Width = TempImageX.Width;  			int Height = TempImageX.Height;  			Parallel.For (0' Height' y => {  				var TempVector = new Vector3 (0.0' 0.0' 0.0);  				for (int x = 0; x < Width; ++x) {  					var TempPixelX = TempImageX.GetPixel (x' y);  					var TempPixelY = TempImageY.GetPixel (x' y);  					TempVector.X = (double)(TempPixelX.R) / 255.0;  					TempVector.Y = (double)(TempPixelY.R) / 255.0;  					TempVector.Z = 1.0;  					TempVector.Normalize ();  					TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  					TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  					TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  					ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  				}  			});  			TempImageX.Unlock ();  			TempImageY.Unlock ();  			ReturnImage.Unlock ();  			return ImageUsing.Copy (ReturnImage);  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.LeftRight' InvertX)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  		using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  			TempImageX.Lock ();  			TempImageY.Lock ();  			ReturnImage.Lock ();  			int Width = TempImageX.Width;  			int Height = TempImageX.Height;  			Parallel.For (0' Height' y => {  				var TempVector = new Vector3 (0.0' 0.0' 0.0);  				for (int x = 0; x < Width; ++x) {  					var TempPixelX = TempImageX.GetPixel (x' y);  					var TempPixelY = TempImageY.GetPixel (x' y);  					TempVector.X = (double)(TempPixelX.R) / 255.0;  					TempVector.Y = (double)(TempPixelY.R) / 255.0;  					TempVector.Z = 1.0;  					TempVector.Normalize ();  					TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  					TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  					TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  					ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  				}  			});  			TempImageX.Unlock ();  			TempImageY.Unlock ();  			ReturnImage.Unlock ();  			return ImageUsing.Copy (ReturnImage);  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.LeftRight' InvertX)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  		using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  			TempImageX.Lock ();  			TempImageY.Lock ();  			ReturnImage.Lock ();  			int Width = TempImageX.Width;  			int Height = TempImageX.Height;  			Parallel.For (0' Height' y => {  				var TempVector = new Vector3 (0.0' 0.0' 0.0);  				for (int x = 0; x < Width; ++x) {  					var TempPixelX = TempImageX.GetPixel (x' y);  					var TempPixelY = TempImageY.GetPixel (x' y);  					TempVector.X = (double)(TempPixelX.R) / 255.0;  					TempVector.Y = (double)(TempPixelY.R) / 255.0;  					TempVector.Z = 1.0;  					TempVector.Normalize ();  					TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  					TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  					TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  					ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  				}  			});  			TempImageX.Unlock ();  			TempImageY.Unlock ();  			ReturnImage.Unlock ();  			return ImageUsing.Copy (ReturnImage);  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.LeftRight' InvertX)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  		using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  			TempImageX.Lock ();  			TempImageY.Lock ();  			ReturnImage.Lock ();  			int Width = TempImageX.Width;  			int Height = TempImageX.Height;  			Parallel.For (0' Height' y => {  				var TempVector = new Vector3 (0.0' 0.0' 0.0);  				for (int x = 0; x < Width; ++x) {  					var TempPixelX = TempImageX.GetPixel (x' y);  					var TempPixelY = TempImageY.GetPixel (x' y);  					TempVector.X = (double)(TempPixelX.R) / 255.0;  					TempVector.Y = (double)(TempPixelY.R) / 255.0;  					TempVector.Z = 1.0;  					TempVector.Normalize ();  					TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  					TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  					TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  					ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  				}  			});  			TempImageX.Unlock ();  			TempImageY.Unlock ();  			ReturnImage.Unlock ();  			return ImageUsing.Copy (ReturnImage);  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.LeftRight' InvertX)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  		using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  			TempImageX.Lock ();  			TempImageY.Lock ();  			ReturnImage.Lock ();  			int Width = TempImageX.Width;  			int Height = TempImageX.Height;  			Parallel.For (0' Height' y => {  				var TempVector = new Vector3 (0.0' 0.0' 0.0);  				for (int x = 0; x < Width; ++x) {  					var TempPixelX = TempImageX.GetPixel (x' y);  					var TempPixelY = TempImageY.GetPixel (x' y);  					TempVector.X = (double)(TempPixelX.R) / 255.0;  					TempVector.Y = (double)(TempPixelY.R) / 255.0;  					TempVector.Z = 1.0;  					TempVector.Normalize ();  					TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  					TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  					TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  					ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  				}  			});  			TempImageX.Unlock ();  			TempImageY.Unlock ();  			ReturnImage.Unlock ();  			return ImageUsing.Copy (ReturnImage);  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.LeftRight' InvertX)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  		using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  			TempImageX.Lock ();  			TempImageY.Lock ();  			ReturnImage.Lock ();  			int Width = TempImageX.Width;  			int Height = TempImageX.Height;  			Parallel.For (0' Height' y => {  				var TempVector = new Vector3 (0.0' 0.0' 0.0);  				for (int x = 0; x < Width; ++x) {  					var TempPixelX = TempImageX.GetPixel (x' y);  					var TempPixelY = TempImageY.GetPixel (x' y);  					TempVector.X = (double)(TempPixelX.R) / 255.0;  					TempVector.Y = (double)(TempPixelY.R) / 255.0;  					TempVector.Z = 1.0;  					TempVector.Normalize ();  					TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  					TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  					TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  					ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  				}  			});  			TempImageX.Unlock ();  			TempImageY.Unlock ();  			ReturnImage.Unlock ();  			return ImageUsing.Copy (ReturnImage);  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.LeftRight' InvertX)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  		using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  			TempImageX.Lock ();  			TempImageY.Lock ();  			ReturnImage.Lock ();  			int Width = TempImageX.Width;  			int Height = TempImageX.Height;  			Parallel.For (0' Height' y => {  				var TempVector = new Vector3 (0.0' 0.0' 0.0);  				for (int x = 0; x < Width; ++x) {  					var TempPixelX = TempImageX.GetPixel (x' y);  					var TempPixelY = TempImageY.GetPixel (x' y);  					TempVector.X = (double)(TempPixelX.R) / 255.0;  					TempVector.Y = (double)(TempPixelY.R) / 255.0;  					TempVector.Z = 1.0;  					TempVector.Normalize ();  					TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  					TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  					TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  					ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  				}  			});  			TempImageX.Unlock ();  			TempImageY.Unlock ();  			ReturnImage.Unlock ();  			return ImageUsing.Copy (ReturnImage);  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  	using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  		TempImageX.Lock ();  		TempImageY.Lock ();  		ReturnImage.Lock ();  		int Width = TempImageX.Width;  		int Height = TempImageX.Height;  		Parallel.For (0' Height' y => {  			var TempVector = new Vector3 (0.0' 0.0' 0.0);  			for (int x = 0; x < Width; ++x) {  				var TempPixelX = TempImageX.GetPixel (x' y);  				var TempPixelY = TempImageY.GetPixel (x' y);  				TempVector.X = (double)(TempPixelX.R) / 255.0;  				TempVector.Y = (double)(TempPixelY.R) / 255.0;  				TempVector.Z = 1.0;  				TempVector.Normalize ();  				TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  				TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  				TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  				ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  			}  		});  		TempImageX.Unlock ();  		TempImageY.Unlock ();  		ReturnImage.Unlock ();  		return ImageUsing.Copy (ReturnImage);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  	using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  		TempImageX.Lock ();  		TempImageY.Lock ();  		ReturnImage.Lock ();  		int Width = TempImageX.Width;  		int Height = TempImageX.Height;  		Parallel.For (0' Height' y => {  			var TempVector = new Vector3 (0.0' 0.0' 0.0);  			for (int x = 0; x < Width; ++x) {  				var TempPixelX = TempImageX.GetPixel (x' y);  				var TempPixelY = TempImageY.GetPixel (x' y);  				TempVector.X = (double)(TempPixelX.R) / 255.0;  				TempVector.Y = (double)(TempPixelY.R) / 255.0;  				TempVector.Z = 1.0;  				TempVector.Normalize ();  				TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  				TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  				TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  				ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  			}  		});  		TempImageX.Unlock ();  		TempImageY.Unlock ();  		ReturnImage.Unlock ();  		return ImageUsing.Copy (ReturnImage);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  	using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  		TempImageX.Lock ();  		TempImageY.Lock ();  		ReturnImage.Lock ();  		int Width = TempImageX.Width;  		int Height = TempImageX.Height;  		Parallel.For (0' Height' y => {  			var TempVector = new Vector3 (0.0' 0.0' 0.0);  			for (int x = 0; x < Width; ++x) {  				var TempPixelX = TempImageX.GetPixel (x' y);  				var TempPixelY = TempImageY.GetPixel (x' y);  				TempVector.X = (double)(TempPixelX.R) / 255.0;  				TempVector.Y = (double)(TempPixelY.R) / 255.0;  				TempVector.Z = 1.0;  				TempVector.Normalize ();  				TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  				TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  				TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  				ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  			}  		});  		TempImageX.Unlock ();  		TempImageY.Unlock ();  		ReturnImage.Unlock ();  		return ImageUsing.Copy (ReturnImage);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  	using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  		TempImageX.Lock ();  		TempImageY.Lock ();  		ReturnImage.Lock ();  		int Width = TempImageX.Width;  		int Height = TempImageX.Height;  		Parallel.For (0' Height' y => {  			var TempVector = new Vector3 (0.0' 0.0' 0.0);  			for (int x = 0; x < Width; ++x) {  				var TempPixelX = TempImageX.GetPixel (x' y);  				var TempPixelY = TempImageY.GetPixel (x' y);  				TempVector.X = (double)(TempPixelX.R) / 255.0;  				TempVector.Y = (double)(TempPixelY.R) / 255.0;  				TempVector.Z = 1.0;  				TempVector.Normalize ();  				TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  				TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  				TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  				ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  			}  		});  		TempImageX.Unlock ();  		TempImageY.Unlock ();  		ReturnImage.Unlock ();  		return ImageUsing.Copy (ReturnImage);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  	using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  		TempImageX.Lock ();  		TempImageY.Lock ();  		ReturnImage.Lock ();  		int Width = TempImageX.Width;  		int Height = TempImageX.Height;  		Parallel.For (0' Height' y => {  			var TempVector = new Vector3 (0.0' 0.0' 0.0);  			for (int x = 0; x < Width; ++x) {  				var TempPixelX = TempImageX.GetPixel (x' y);  				var TempPixelY = TempImageY.GetPixel (x' y);  				TempVector.X = (double)(TempPixelX.R) / 255.0;  				TempVector.Y = (double)(TempPixelY.R) / 255.0;  				TempVector.Z = 1.0;  				TempVector.Normalize ();  				TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  				TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  				TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  				ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  			}  		});  		TempImageX.Unlock ();  		TempImageY.Unlock ();  		ReturnImage.Unlock ();  		return ImageUsing.Copy (ReturnImage);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  	using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  		TempImageX.Lock ();  		TempImageY.Lock ();  		ReturnImage.Lock ();  		int Width = TempImageX.Width;  		int Height = TempImageX.Height;  		Parallel.For (0' Height' y => {  			var TempVector = new Vector3 (0.0' 0.0' 0.0);  			for (int x = 0; x < Width; ++x) {  				var TempPixelX = TempImageX.GetPixel (x' y);  				var TempPixelY = TempImageY.GetPixel (x' y);  				TempVector.X = (double)(TempPixelX.R) / 255.0;  				TempVector.Y = (double)(TempPixelY.R) / 255.0;  				TempVector.Z = 1.0;  				TempVector.Normalize ();  				TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  				TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  				TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  				ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  			}  		});  		TempImageX.Unlock ();  		TempImageY.Unlock ();  		ReturnImage.Unlock ();  		return ImageUsing.Copy (ReturnImage);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  	using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  		TempImageX.Lock ();  		TempImageY.Lock ();  		ReturnImage.Lock ();  		int Width = TempImageX.Width;  		int Height = TempImageX.Height;  		Parallel.For (0' Height' y => {  			var TempVector = new Vector3 (0.0' 0.0' 0.0);  			for (int x = 0; x < Width; ++x) {  				var TempPixelX = TempImageX.GetPixel (x' y);  				var TempPixelY = TempImageY.GetPixel (x' y);  				TempVector.X = (double)(TempPixelX.R) / 255.0;  				TempVector.Y = (double)(TempPixelY.R) / 255.0;  				TempVector.Z = 1.0;  				TempVector.Normalize ();  				TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  				TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  				TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  				ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  			}  		});  		TempImageX.Unlock ();  		TempImageY.Unlock ();  		ReturnImage.Unlock ();  		return ImageUsing.Copy (ReturnImage);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)ImageUsing.Clone ()).BumpMap (Direction.TopBottom' InvertY)) {  	using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  		TempImageX.Lock ();  		TempImageY.Lock ();  		ReturnImage.Lock ();  		int Width = TempImageX.Width;  		int Height = TempImageX.Height;  		Parallel.For (0' Height' y => {  			var TempVector = new Vector3 (0.0' 0.0' 0.0);  			for (int x = 0; x < Width; ++x) {  				var TempPixelX = TempImageX.GetPixel (x' y);  				var TempPixelY = TempImageY.GetPixel (x' y);  				TempVector.X = (double)(TempPixelX.R) / 255.0;  				TempVector.Y = (double)(TempPixelY.R) / 255.0;  				TempVector.Z = 1.0;  				TempVector.Normalize ();  				TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  				TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  				TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  				ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  			}  		});  		TempImageX.Unlock ();  		TempImageY.Unlock ();  		ReturnImage.Unlock ();  		return ImageUsing.Copy (ReturnImage);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  	TempImageX.Lock ();  	TempImageY.Lock ();  	ReturnImage.Lock ();  	int Width = TempImageX.Width;  	int Height = TempImageX.Height;  	Parallel.For (0' Height' y => {  		var TempVector = new Vector3 (0.0' 0.0' 0.0);  		for (int x = 0; x < Width; ++x) {  			var TempPixelX = TempImageX.GetPixel (x' y);  			var TempPixelY = TempImageY.GetPixel (x' y);  			TempVector.X = (double)(TempPixelX.R) / 255.0;  			TempVector.Y = (double)(TempPixelY.R) / 255.0;  			TempVector.Z = 1.0;  			TempVector.Normalize ();  			TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  			TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  			TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  			ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  		}  	});  	TempImageX.Unlock ();  	TempImageY.Unlock ();  	ReturnImage.Unlock ();  	return ImageUsing.Copy (ReturnImage);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  	TempImageX.Lock ();  	TempImageY.Lock ();  	ReturnImage.Lock ();  	int Width = TempImageX.Width;  	int Height = TempImageX.Height;  	Parallel.For (0' Height' y => {  		var TempVector = new Vector3 (0.0' 0.0' 0.0);  		for (int x = 0; x < Width; ++x) {  			var TempPixelX = TempImageX.GetPixel (x' y);  			var TempPixelY = TempImageY.GetPixel (x' y);  			TempVector.X = (double)(TempPixelX.R) / 255.0;  			TempVector.Y = (double)(TempPixelY.R) / 255.0;  			TempVector.Z = 1.0;  			TempVector.Normalize ();  			TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  			TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  			TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  			ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  		}  	});  	TempImageX.Unlock ();  	TempImageY.Unlock ();  	ReturnImage.Unlock ();  	return ImageUsing.Copy (ReturnImage);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  	TempImageX.Lock ();  	TempImageY.Lock ();  	ReturnImage.Lock ();  	int Width = TempImageX.Width;  	int Height = TempImageX.Height;  	Parallel.For (0' Height' y => {  		var TempVector = new Vector3 (0.0' 0.0' 0.0);  		for (int x = 0; x < Width; ++x) {  			var TempPixelX = TempImageX.GetPixel (x' y);  			var TempPixelY = TempImageY.GetPixel (x' y);  			TempVector.X = (double)(TempPixelX.R) / 255.0;  			TempVector.Y = (double)(TempPixelY.R) / 255.0;  			TempVector.Z = 1.0;  			TempVector.Normalize ();  			TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  			TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  			TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  			ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  		}  	});  	TempImageX.Unlock ();  	TempImageY.Unlock ();  	ReturnImage.Unlock ();  	return ImageUsing.Copy (ReturnImage);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  	TempImageX.Lock ();  	TempImageY.Lock ();  	ReturnImage.Lock ();  	int Width = TempImageX.Width;  	int Height = TempImageX.Height;  	Parallel.For (0' Height' y => {  		var TempVector = new Vector3 (0.0' 0.0' 0.0);  		for (int x = 0; x < Width; ++x) {  			var TempPixelX = TempImageX.GetPixel (x' y);  			var TempPixelY = TempImageY.GetPixel (x' y);  			TempVector.X = (double)(TempPixelX.R) / 255.0;  			TempVector.Y = (double)(TempPixelY.R) / 255.0;  			TempVector.Z = 1.0;  			TempVector.Normalize ();  			TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  			TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  			TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  			ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  		}  	});  	TempImageX.Unlock ();  	TempImageY.Unlock ();  	ReturnImage.Unlock ();  	return ImageUsing.Copy (ReturnImage);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  	TempImageX.Lock ();  	TempImageY.Lock ();  	ReturnImage.Lock ();  	int Width = TempImageX.Width;  	int Height = TempImageX.Height;  	Parallel.For (0' Height' y => {  		var TempVector = new Vector3 (0.0' 0.0' 0.0);  		for (int x = 0; x < Width; ++x) {  			var TempPixelX = TempImageX.GetPixel (x' y);  			var TempPixelY = TempImageY.GetPixel (x' y);  			TempVector.X = (double)(TempPixelX.R) / 255.0;  			TempVector.Y = (double)(TempPixelY.R) / 255.0;  			TempVector.Z = 1.0;  			TempVector.Normalize ();  			TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  			TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  			TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  			ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  		}  	});  	TempImageX.Unlock ();  	TempImageY.Unlock ();  	ReturnImage.Unlock ();  	return ImageUsing.Copy (ReturnImage);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  	TempImageX.Lock ();  	TempImageY.Lock ();  	ReturnImage.Lock ();  	int Width = TempImageX.Width;  	int Height = TempImageX.Height;  	Parallel.For (0' Height' y => {  		var TempVector = new Vector3 (0.0' 0.0' 0.0);  		for (int x = 0; x < Width; ++x) {  			var TempPixelX = TempImageX.GetPixel (x' y);  			var TempPixelY = TempImageY.GetPixel (x' y);  			TempVector.X = (double)(TempPixelX.R) / 255.0;  			TempVector.Y = (double)(TempPixelY.R) / 255.0;  			TempVector.Z = 1.0;  			TempVector.Normalize ();  			TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  			TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  			TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  			ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  		}  	});  	TempImageX.Unlock ();  	TempImageY.Unlock ();  	ReturnImage.Unlock ();  	return ImageUsing.Copy (ReturnImage);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  	TempImageX.Lock ();  	TempImageY.Lock ();  	ReturnImage.Lock ();  	int Width = TempImageX.Width;  	int Height = TempImageX.Height;  	Parallel.For (0' Height' y => {  		var TempVector = new Vector3 (0.0' 0.0' 0.0);  		for (int x = 0; x < Width; ++x) {  			var TempPixelX = TempImageX.GetPixel (x' y);  			var TempPixelY = TempImageY.GetPixel (x' y);  			TempVector.X = (double)(TempPixelX.R) / 255.0;  			TempVector.Y = (double)(TempPixelY.R) / 255.0;  			TempVector.Z = 1.0;  			TempVector.Normalize ();  			TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  			TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  			TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  			ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  		}  	});  	TempImageX.Unlock ();  	TempImageY.Unlock ();  	ReturnImage.Unlock ();  	return ImageUsing.Copy (ReturnImage);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: using (SwiftBitmap ReturnImage = new SwiftBitmap (TempImageX.Width' TempImageX.Height)) {  	TempImageX.Lock ();  	TempImageY.Lock ();  	ReturnImage.Lock ();  	int Width = TempImageX.Width;  	int Height = TempImageX.Height;  	Parallel.For (0' Height' y => {  		var TempVector = new Vector3 (0.0' 0.0' 0.0);  		for (int x = 0; x < Width; ++x) {  			var TempPixelX = TempImageX.GetPixel (x' y);  			var TempPixelY = TempImageY.GetPixel (x' y);  			TempVector.X = (double)(TempPixelX.R) / 255.0;  			TempVector.Y = (double)(TempPixelY.R) / 255.0;  			TempVector.Z = 1.0;  			TempVector.Normalize ();  			TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  			TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  			TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  			ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  		}  	});  	TempImageX.Unlock ();  	TempImageY.Unlock ();  	ReturnImage.Unlock ();  	return ImageUsing.Copy (ReturnImage);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For (0' Height' y => {  	var TempVector = new Vector3 (0.0' 0.0' 0.0);  	for (int x = 0; x < Width; ++x) {  		var TempPixelX = TempImageX.GetPixel (x' y);  		var TempPixelY = TempImageY.GetPixel (x' y);  		TempVector.X = (double)(TempPixelX.R) / 255.0;  		TempVector.Y = (double)(TempPixelY.R) / 255.0;  		TempVector.Z = 1.0;  		TempVector.Normalize ();  		TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  		TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  		TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  		ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For (0' Height' y => {  	var TempVector = new Vector3 (0.0' 0.0' 0.0);  	for (int x = 0; x < Width; ++x) {  		var TempPixelX = TempImageX.GetPixel (x' y);  		var TempPixelY = TempImageY.GetPixel (x' y);  		TempVector.X = (double)(TempPixelX.R) / 255.0;  		TempVector.Y = (double)(TempPixelY.R) / 255.0;  		TempVector.Z = 1.0;  		TempVector.Normalize ();  		TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  		TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  		TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  		ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For (0' Height' y => {  	var TempVector = new Vector3 (0.0' 0.0' 0.0);  	for (int x = 0; x < Width; ++x) {  		var TempPixelX = TempImageX.GetPixel (x' y);  		var TempPixelY = TempImageY.GetPixel (x' y);  		TempVector.X = (double)(TempPixelX.R) / 255.0;  		TempVector.Y = (double)(TempPixelY.R) / 255.0;  		TempVector.Z = 1.0;  		TempVector.Normalize ();  		TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  		TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  		TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  		ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For (0' Height' y => {  	var TempVector = new Vector3 (0.0' 0.0' 0.0);  	for (int x = 0; x < Width; ++x) {  		var TempPixelX = TempImageX.GetPixel (x' y);  		var TempPixelY = TempImageY.GetPixel (x' y);  		TempVector.X = (double)(TempPixelX.R) / 255.0;  		TempVector.Y = (double)(TempPixelY.R) / 255.0;  		TempVector.Z = 1.0;  		TempVector.Normalize ();  		TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  		TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  		TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  		ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For (0' Height' y => {  	var TempVector = new Vector3 (0.0' 0.0' 0.0);  	for (int x = 0; x < Width; ++x) {  		var TempPixelX = TempImageX.GetPixel (x' y);  		var TempPixelY = TempImageY.GetPixel (x' y);  		TempVector.X = (double)(TempPixelX.R) / 255.0;  		TempVector.Y = (double)(TempPixelY.R) / 255.0;  		TempVector.Z = 1.0;  		TempVector.Normalize ();  		TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  		TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  		TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  		ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For (0' Height' y => {  	var TempVector = new Vector3 (0.0' 0.0' 0.0);  	for (int x = 0; x < Width; ++x) {  		var TempPixelX = TempImageX.GetPixel (x' y);  		var TempPixelY = TempImageY.GetPixel (x' y);  		TempVector.X = (double)(TempPixelX.R) / 255.0;  		TempVector.Y = (double)(TempPixelY.R) / 255.0;  		TempVector.Z = 1.0;  		TempVector.Normalize ();  		TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  		TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  		TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  		ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For (0' Height' y => {  	var TempVector = new Vector3 (0.0' 0.0' 0.0);  	for (int x = 0; x < Width; ++x) {  		var TempPixelX = TempImageX.GetPixel (x' y);  		var TempPixelY = TempImageY.GetPixel (x' y);  		TempVector.X = (double)(TempPixelX.R) / 255.0;  		TempVector.Y = (double)(TempPixelY.R) / 255.0;  		TempVector.Z = 1.0;  		TempVector.Normalize ();  		TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  		TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  		TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  		ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For (0' Height' y => {  	var TempVector = new Vector3 (0.0' 0.0' 0.0);  	for (int x = 0; x < Width; ++x) {  		var TempPixelX = TempImageX.GetPixel (x' y);  		var TempPixelY = TempImageY.GetPixel (x' y);  		TempVector.X = (double)(TempPixelX.R) / 255.0;  		TempVector.Y = (double)(TempPixelY.R) / 255.0;  		TempVector.Z = 1.0;  		TempVector.Normalize ();  		TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  		TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  		TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  		ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	var TempPixelX = TempImageX.GetPixel (x' y);  	var TempPixelY = TempImageY.GetPixel (x' y);  	TempVector.X = (double)(TempPixelX.R) / 255.0;  	TempVector.Y = (double)(TempPixelY.R) / 255.0;  	TempVector.Z = 1.0;  	TempVector.Normalize ();  	TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  	TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  	TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  	ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	var TempPixelX = TempImageX.GetPixel (x' y);  	var TempPixelY = TempImageY.GetPixel (x' y);  	TempVector.X = (double)(TempPixelX.R) / 255.0;  	TempVector.Y = (double)(TempPixelY.R) / 255.0;  	TempVector.Z = 1.0;  	TempVector.Normalize ();  	TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  	TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  	TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  	ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	var TempPixelX = TempImageX.GetPixel (x' y);  	var TempPixelY = TempImageY.GetPixel (x' y);  	TempVector.X = (double)(TempPixelX.R) / 255.0;  	TempVector.Y = (double)(TempPixelY.R) / 255.0;  	TempVector.Z = 1.0;  	TempVector.Normalize ();  	TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  	TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  	TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  	ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	var TempPixelX = TempImageX.GetPixel (x' y);  	var TempPixelY = TempImageY.GetPixel (x' y);  	TempVector.X = (double)(TempPixelX.R) / 255.0;  	TempVector.Y = (double)(TempPixelY.R) / 255.0;  	TempVector.Z = 1.0;  	TempVector.Normalize ();  	TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  	TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  	TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  	ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	var TempPixelX = TempImageX.GetPixel (x' y);  	var TempPixelY = TempImageY.GetPixel (x' y);  	TempVector.X = (double)(TempPixelX.R) / 255.0;  	TempVector.Y = (double)(TempPixelY.R) / 255.0;  	TempVector.Z = 1.0;  	TempVector.Normalize ();  	TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  	TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  	TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  	ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	var TempPixelX = TempImageX.GetPixel (x' y);  	var TempPixelY = TempImageY.GetPixel (x' y);  	TempVector.X = (double)(TempPixelX.R) / 255.0;  	TempVector.Y = (double)(TempPixelY.R) / 255.0;  	TempVector.Z = 1.0;  	TempVector.Normalize ();  	TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  	TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  	TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  	ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	var TempPixelX = TempImageX.GetPixel (x' y);  	var TempPixelY = TempImageY.GetPixel (x' y);  	TempVector.X = (double)(TempPixelX.R) / 255.0;  	TempVector.Y = (double)(TempPixelY.R) / 255.0;  	TempVector.Z = 1.0;  	TempVector.Normalize ();  	TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  	TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  	TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  	ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	var TempPixelX = TempImageX.GetPixel (x' y);  	var TempPixelY = TempImageY.GetPixel (x' y);  	TempVector.X = (double)(TempPixelX.R) / 255.0;  	TempVector.Y = (double)(TempPixelY.R) / 255.0;  	TempVector.Z = 1.0;  	TempVector.Normalize ();  	TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  	TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  	TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  	ReturnImage.SetPixel (x' y' Color.FromArgb ((int)TempVector.X' (int)TempVector.Y' (int)TempVector.Z));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: TempVector.X = (double)(TempPixelX.R) / 255.0;  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: TempVector.Y = (double)(TempPixelY.R) / 255.0;  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  		var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			for (int x2 = MinX; x2 < MaxX; ++x2) {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					var Pixel = OriginalImage.GetPixel (x2' y2);  					RValue += Pixel.R;  					GValue += Pixel.G;  					BValue += Pixel.B;  				}  			}  			RValue = RValue / (PixelSize * PixelSize);  			GValue = GValue / (PixelSize * PixelSize);  			BValue = BValue / (PixelSize * PixelSize);  			var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  			Parallel.For (MinX' MaxX' x2 => {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  				}  			});  		}  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  		var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			for (int x2 = MinX; x2 < MaxX; ++x2) {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					var Pixel = OriginalImage.GetPixel (x2' y2);  					RValue += Pixel.R;  					GValue += Pixel.G;  					BValue += Pixel.B;  				}  			}  			RValue = RValue / (PixelSize * PixelSize);  			GValue = GValue / (PixelSize * PixelSize);  			BValue = BValue / (PixelSize * PixelSize);  			var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  			Parallel.For (MinX' MaxX' x2 => {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  				}  			});  		}  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  		var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			for (int x2 = MinX; x2 < MaxX; ++x2) {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					var Pixel = OriginalImage.GetPixel (x2' y2);  					RValue += Pixel.R;  					GValue += Pixel.G;  					BValue += Pixel.B;  				}  			}  			RValue = RValue / (PixelSize * PixelSize);  			GValue = GValue / (PixelSize * PixelSize);  			BValue = BValue / (PixelSize * PixelSize);  			var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  			Parallel.For (MinX' MaxX' x2 => {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  				}  			});  		}  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  		var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			for (int x2 = MinX; x2 < MaxX; ++x2) {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					var Pixel = OriginalImage.GetPixel (x2' y2);  					RValue += Pixel.R;  					GValue += Pixel.G;  					BValue += Pixel.B;  				}  			}  			RValue = RValue / (PixelSize * PixelSize);  			GValue = GValue / (PixelSize * PixelSize);  			BValue = BValue / (PixelSize * PixelSize);  			var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  			Parallel.For (MinX' MaxX' x2 => {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  				}  			});  		}  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  		var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			for (int x2 = MinX; x2 < MaxX; ++x2) {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					var Pixel = OriginalImage.GetPixel (x2' y2);  					RValue += Pixel.R;  					GValue += Pixel.G;  					BValue += Pixel.B;  				}  			}  			RValue = RValue / (PixelSize * PixelSize);  			GValue = GValue / (PixelSize * PixelSize);  			BValue = BValue / (PixelSize * PixelSize);  			var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  			Parallel.For (MinX' MaxX' x2 => {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  				}  			});  		}  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  		var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			for (int x2 = MinX; x2 < MaxX; ++x2) {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					var Pixel = OriginalImage.GetPixel (x2' y2);  					RValue += Pixel.R;  					GValue += Pixel.G;  					BValue += Pixel.B;  				}  			}  			RValue = RValue / (PixelSize * PixelSize);  			GValue = GValue / (PixelSize * PixelSize);  			BValue = BValue / (PixelSize * PixelSize);  			var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  			Parallel.For (MinX' MaxX' x2 => {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  				}  			});  		}  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  		var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			for (int x2 = MinX; x2 < MaxX; ++x2) {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					var Pixel = OriginalImage.GetPixel (x2' y2);  					RValue += Pixel.R;  					GValue += Pixel.G;  					BValue += Pixel.B;  				}  			}  			RValue = RValue / (PixelSize * PixelSize);  			GValue = GValue / (PixelSize * PixelSize);  			BValue = BValue / (PixelSize * PixelSize);  			var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  			Parallel.For (MinX' MaxX' x2 => {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  				}  			});  		}  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  		var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			for (int x2 = MinX; x2 < MaxX; ++x2) {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					var Pixel = OriginalImage.GetPixel (x2' y2);  					RValue += Pixel.R;  					GValue += Pixel.G;  					BValue += Pixel.B;  				}  			}  			RValue = RValue / (PixelSize * PixelSize);  			GValue = GValue / (PixelSize * PixelSize);  			BValue = BValue / (PixelSize * PixelSize);  			var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  			Parallel.For (MinX' MaxX' x2 => {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  				}  			});  		}  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  		var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  		for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  			for (int x2 = MinX; x2 < MaxX; ++x2) {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					var Pixel = OriginalImage.GetPixel (x2' y2);  					RValue += Pixel.R;  					GValue += Pixel.G;  					BValue += Pixel.B;  				}  			}  			RValue = RValue / (PixelSize * PixelSize);  			GValue = GValue / (PixelSize * PixelSize);  			BValue = BValue / (PixelSize * PixelSize);  			var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  			Parallel.For (MinX' MaxX' x2 => {  				for (int y2 = MinY; y2 < MaxY; ++y2) {  					NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  				}  			});  		}  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  	var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		for (int x2 = MinX; x2 < MaxX; ++x2) {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				var Pixel = OriginalImage.GetPixel (x2' y2);  				RValue += Pixel.R;  				GValue += Pixel.G;  				BValue += Pixel.B;  			}  		}  		RValue = RValue / (PixelSize * PixelSize);  		GValue = GValue / (PixelSize * PixelSize);  		BValue = BValue / (PixelSize * PixelSize);  		var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  		Parallel.For (MinX' MaxX' x2 => {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  			}  		});  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  	var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		for (int x2 = MinX; x2 < MaxX; ++x2) {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				var Pixel = OriginalImage.GetPixel (x2' y2);  				RValue += Pixel.R;  				GValue += Pixel.G;  				BValue += Pixel.B;  			}  		}  		RValue = RValue / (PixelSize * PixelSize);  		GValue = GValue / (PixelSize * PixelSize);  		BValue = BValue / (PixelSize * PixelSize);  		var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  		Parallel.For (MinX' MaxX' x2 => {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  			}  		});  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  	var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		for (int x2 = MinX; x2 < MaxX; ++x2) {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				var Pixel = OriginalImage.GetPixel (x2' y2);  				RValue += Pixel.R;  				GValue += Pixel.G;  				BValue += Pixel.B;  			}  		}  		RValue = RValue / (PixelSize * PixelSize);  		GValue = GValue / (PixelSize * PixelSize);  		BValue = BValue / (PixelSize * PixelSize);  		var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  		Parallel.For (MinX' MaxX' x2 => {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  			}  		});  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  	var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		for (int x2 = MinX; x2 < MaxX; ++x2) {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				var Pixel = OriginalImage.GetPixel (x2' y2);  				RValue += Pixel.R;  				GValue += Pixel.G;  				BValue += Pixel.B;  			}  		}  		RValue = RValue / (PixelSize * PixelSize);  		GValue = GValue / (PixelSize * PixelSize);  		BValue = BValue / (PixelSize * PixelSize);  		var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  		Parallel.For (MinX' MaxX' x2 => {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  			}  		});  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  	var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		for (int x2 = MinX; x2 < MaxX; ++x2) {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				var Pixel = OriginalImage.GetPixel (x2' y2);  				RValue += Pixel.R;  				GValue += Pixel.G;  				BValue += Pixel.B;  			}  		}  		RValue = RValue / (PixelSize * PixelSize);  		GValue = GValue / (PixelSize * PixelSize);  		BValue = BValue / (PixelSize * PixelSize);  		var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  		Parallel.For (MinX' MaxX' x2 => {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  			}  		});  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  	var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		for (int x2 = MinX; x2 < MaxX; ++x2) {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				var Pixel = OriginalImage.GetPixel (x2' y2);  				RValue += Pixel.R;  				GValue += Pixel.G;  				BValue += Pixel.B;  			}  		}  		RValue = RValue / (PixelSize * PixelSize);  		GValue = GValue / (PixelSize * PixelSize);  		BValue = BValue / (PixelSize * PixelSize);  		var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  		Parallel.For (MinX' MaxX' x2 => {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  			}  		});  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  	var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		for (int x2 = MinX; x2 < MaxX; ++x2) {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				var Pixel = OriginalImage.GetPixel (x2' y2);  				RValue += Pixel.R;  				GValue += Pixel.G;  				BValue += Pixel.B;  			}  		}  		RValue = RValue / (PixelSize * PixelSize);  		GValue = GValue / (PixelSize * PixelSize);  		BValue = BValue / (PixelSize * PixelSize);  		var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  		Parallel.For (MinX' MaxX' x2 => {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  			}  		});  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  	var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		for (int x2 = MinX; x2 < MaxX; ++x2) {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				var Pixel = OriginalImage.GetPixel (x2' y2);  				RValue += Pixel.R;  				GValue += Pixel.G;  				BValue += Pixel.B;  			}  		}  		RValue = RValue / (PixelSize * PixelSize);  		GValue = GValue / (PixelSize * PixelSize);  		BValue = BValue / (PixelSize * PixelSize);  		var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  		Parallel.For (MinX' MaxX' x2 => {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  			}  		});  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int x = 0; x < NewSwiftBitmap.Width; x += (PixelSize / 2)) {  	var MinX = (x - (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	var MaxX = (x + (PixelSize / 2)).Clamp (NewSwiftBitmap.Width' 0);  	for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  		for (int x2 = MinX; x2 < MaxX; ++x2) {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				var Pixel = OriginalImage.GetPixel (x2' y2);  				RValue += Pixel.R;  				GValue += Pixel.G;  				BValue += Pixel.B;  			}  		}  		RValue = RValue / (PixelSize * PixelSize);  		GValue = GValue / (PixelSize * PixelSize);  		BValue = BValue / (PixelSize * PixelSize);  		var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  		Parallel.For (MinX' MaxX' x2 => {  			for (int y2 = MinY; y2 < MaxY; ++y2) {  				NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  			}  		});  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: x += (PixelSize / 2)
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  	int RValue = 0;  	int GValue = 0;  	int BValue = 0;  	var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	for (int x2 = MinX; x2 < MaxX; ++x2) {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			var Pixel = OriginalImage.GetPixel (x2' y2);  			RValue += Pixel.R;  			GValue += Pixel.G;  			BValue += Pixel.B;  		}  	}  	RValue = RValue / (PixelSize * PixelSize);  	GValue = GValue / (PixelSize * PixelSize);  	BValue = BValue / (PixelSize * PixelSize);  	var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  	Parallel.For (MinX' MaxX' x2 => {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  		}  	});  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  	int RValue = 0;  	int GValue = 0;  	int BValue = 0;  	var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	for (int x2 = MinX; x2 < MaxX; ++x2) {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			var Pixel = OriginalImage.GetPixel (x2' y2);  			RValue += Pixel.R;  			GValue += Pixel.G;  			BValue += Pixel.B;  		}  	}  	RValue = RValue / (PixelSize * PixelSize);  	GValue = GValue / (PixelSize * PixelSize);  	BValue = BValue / (PixelSize * PixelSize);  	var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  	Parallel.For (MinX' MaxX' x2 => {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  		}  	});  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  	int RValue = 0;  	int GValue = 0;  	int BValue = 0;  	var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	for (int x2 = MinX; x2 < MaxX; ++x2) {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			var Pixel = OriginalImage.GetPixel (x2' y2);  			RValue += Pixel.R;  			GValue += Pixel.G;  			BValue += Pixel.B;  		}  	}  	RValue = RValue / (PixelSize * PixelSize);  	GValue = GValue / (PixelSize * PixelSize);  	BValue = BValue / (PixelSize * PixelSize);  	var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  	Parallel.For (MinX' MaxX' x2 => {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  		}  	});  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  	int RValue = 0;  	int GValue = 0;  	int BValue = 0;  	var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	for (int x2 = MinX; x2 < MaxX; ++x2) {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			var Pixel = OriginalImage.GetPixel (x2' y2);  			RValue += Pixel.R;  			GValue += Pixel.G;  			BValue += Pixel.B;  		}  	}  	RValue = RValue / (PixelSize * PixelSize);  	GValue = GValue / (PixelSize * PixelSize);  	BValue = BValue / (PixelSize * PixelSize);  	var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  	Parallel.For (MinX' MaxX' x2 => {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  		}  	});  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  	int RValue = 0;  	int GValue = 0;  	int BValue = 0;  	var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	for (int x2 = MinX; x2 < MaxX; ++x2) {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			var Pixel = OriginalImage.GetPixel (x2' y2);  			RValue += Pixel.R;  			GValue += Pixel.G;  			BValue += Pixel.B;  		}  	}  	RValue = RValue / (PixelSize * PixelSize);  	GValue = GValue / (PixelSize * PixelSize);  	BValue = BValue / (PixelSize * PixelSize);  	var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  	Parallel.For (MinX' MaxX' x2 => {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  		}  	});  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: for (int y = 0; y < NewSwiftBitmap.Height; y += (PixelSize / 2)) {  	int RValue = 0;  	int GValue = 0;  	int BValue = 0;  	var MinY = (y - (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	var MaxY = (y + (PixelSize / 2)).Clamp (NewSwiftBitmap.Height' 0);  	for (int x2 = MinX; x2 < MaxX; ++x2) {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			var Pixel = OriginalImage.GetPixel (x2' y2);  			RValue += Pixel.R;  			GValue += Pixel.G;  			BValue += Pixel.B;  		}  	}  	RValue = RValue / (PixelSize * PixelSize);  	GValue = GValue / (PixelSize * PixelSize);  	BValue = BValue / (PixelSize * PixelSize);  	var TempPixel = Color.FromArgb (RValue.Clamp (255' 0)' GValue.Clamp (255' 0)' BValue.Clamp (255' 0));  	Parallel.For (MinX' MaxX' x2 => {  		for (int y2 = MinY; y2 < MaxY; ++y2) {  			NewSwiftBitmap.SetPixel (x2' y2' TempPixel);  		}  	});  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: y += (PixelSize / 2)
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Sharpen,The following statement contains a magic number: return Image.ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		-2'  		-1  	}'  	new int[] {  		-2'  		16'  		-2  	}'  	new int[] {  		-1'  		-2'  		-1  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Sharpen,The following statement contains a magic number: return Image.ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		-2'  		-1  	}'  	new int[] {  		-2'  		16'  		-2  	}'  	new int[] {  		-1'  		-2'  		-1  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Sharpen,The following statement contains a magic number: return Image.ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		-2'  		-1  	}'  	new int[] {  		-2'  		16'  		-2  	}'  	new int[] {  		-1'  		-2'  		-1  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Sharpen,The following statement contains a magic number: return Image.ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		-2'  		-1  	}'  	new int[] {  		-2'  		16'  		-2  	}'  	new int[] {  		-1'  		-2'  		-1  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Sharpen,The following statement contains a magic number: return Image.ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		-2'  		-1  	}'  	new int[] {  		-2'  		16'  		-2  	}'  	new int[] {  		-1'  		-2'  		-1  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SharpenLess,The following statement contains a magic number: return Image.ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		0'  		-1  	}'  	new int[] {  		0'  		7'  		0  	}'  	new int[] {  		-1'  		0'  		-1  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int ApetureMinX = -(Size / 2);  	int ApetureMaxX = (Size / 2);  	int ApetureMinY = -(Size / 2);  	int ApetureMaxY = (Size / 2);  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			int NumPixels = 0;  			for (int x2 = ApetureMinX; x2 < ApetureMaxX; ++x2) {  				int TempX1 = x + x2;  				int TempX2 = x - x2;  				if (TempX1 >= 0 && TempX1 < Width && TempX2 >= 0 && TempX2 < Width) {  					for (int y2 = ApetureMinY; y2 < ApetureMaxY; ++y2) {  						int TempY1 = y + y2;  						int TempY2 = y - y2;  						if (TempY1 >= 0 && TempY1 < Height && TempY2 >= 0 && TempY2 < Height) {  							var TempColor = OriginalImage.GetPixel (x' y);  							var TempColor2 = OriginalImage.GetPixel (TempX1' TempY1);  							var TempColor3 = OriginalImage.GetPixel (TempX2' TempY2);  							if (Distance (TempColor.R' TempColor2.R' TempColor.G' TempColor2.G' TempColor.B' TempColor2.B) < Distance (TempColor.R' TempColor3.R' TempColor.G' TempColor3.G' TempColor.B' TempColor3.B)) {  								RValue += TempColor2.R;  								GValue += TempColor2.G;  								BValue += TempColor2.B;  							} else {  								RValue += TempColor3.R;  								GValue += TempColor3.G;  								BValue += TempColor3.B;  							}  							++NumPixels;  						}  					}  				}  			}  			var MeanPixel = Color.FromArgb (RValue / NumPixels' GValue / NumPixels' BValue / NumPixels);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int ApetureMinX = -(Size / 2);  	int ApetureMaxX = (Size / 2);  	int ApetureMinY = -(Size / 2);  	int ApetureMaxY = (Size / 2);  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			int NumPixels = 0;  			for (int x2 = ApetureMinX; x2 < ApetureMaxX; ++x2) {  				int TempX1 = x + x2;  				int TempX2 = x - x2;  				if (TempX1 >= 0 && TempX1 < Width && TempX2 >= 0 && TempX2 < Width) {  					for (int y2 = ApetureMinY; y2 < ApetureMaxY; ++y2) {  						int TempY1 = y + y2;  						int TempY2 = y - y2;  						if (TempY1 >= 0 && TempY1 < Height && TempY2 >= 0 && TempY2 < Height) {  							var TempColor = OriginalImage.GetPixel (x' y);  							var TempColor2 = OriginalImage.GetPixel (TempX1' TempY1);  							var TempColor3 = OriginalImage.GetPixel (TempX2' TempY2);  							if (Distance (TempColor.R' TempColor2.R' TempColor.G' TempColor2.G' TempColor.B' TempColor2.B) < Distance (TempColor.R' TempColor3.R' TempColor.G' TempColor3.G' TempColor.B' TempColor3.B)) {  								RValue += TempColor2.R;  								GValue += TempColor2.G;  								BValue += TempColor2.B;  							} else {  								RValue += TempColor3.R;  								GValue += TempColor3.G;  								BValue += TempColor3.B;  							}  							++NumPixels;  						}  					}  				}  			}  			var MeanPixel = Color.FromArgb (RValue / NumPixels' GValue / NumPixels' BValue / NumPixels);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int ApetureMinX = -(Size / 2);  	int ApetureMaxX = (Size / 2);  	int ApetureMinY = -(Size / 2);  	int ApetureMaxY = (Size / 2);  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			int NumPixels = 0;  			for (int x2 = ApetureMinX; x2 < ApetureMaxX; ++x2) {  				int TempX1 = x + x2;  				int TempX2 = x - x2;  				if (TempX1 >= 0 && TempX1 < Width && TempX2 >= 0 && TempX2 < Width) {  					for (int y2 = ApetureMinY; y2 < ApetureMaxY; ++y2) {  						int TempY1 = y + y2;  						int TempY2 = y - y2;  						if (TempY1 >= 0 && TempY1 < Height && TempY2 >= 0 && TempY2 < Height) {  							var TempColor = OriginalImage.GetPixel (x' y);  							var TempColor2 = OriginalImage.GetPixel (TempX1' TempY1);  							var TempColor3 = OriginalImage.GetPixel (TempX2' TempY2);  							if (Distance (TempColor.R' TempColor2.R' TempColor.G' TempColor2.G' TempColor.B' TempColor2.B) < Distance (TempColor.R' TempColor3.R' TempColor.G' TempColor3.G' TempColor.B' TempColor3.B)) {  								RValue += TempColor2.R;  								GValue += TempColor2.G;  								BValue += TempColor2.B;  							} else {  								RValue += TempColor3.R;  								GValue += TempColor3.G;  								BValue += TempColor3.B;  							}  							++NumPixels;  						}  					}  				}  			}  			var MeanPixel = Color.FromArgb (RValue / NumPixels' GValue / NumPixels' BValue / NumPixels);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (OriginalImage.Width' OriginalImage.Height)) {  	NewSwiftBitmap.Lock ();  	OriginalImage.Lock ();  	int ApetureMinX = -(Size / 2);  	int ApetureMaxX = (Size / 2);  	int ApetureMinY = -(Size / 2);  	int ApetureMaxY = (Size / 2);  	int Width = NewSwiftBitmap.Width;  	int Height = NewSwiftBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			int NumPixels = 0;  			for (int x2 = ApetureMinX; x2 < ApetureMaxX; ++x2) {  				int TempX1 = x + x2;  				int TempX2 = x - x2;  				if (TempX1 >= 0 && TempX1 < Width && TempX2 >= 0 && TempX2 < Width) {  					for (int y2 = ApetureMinY; y2 < ApetureMaxY; ++y2) {  						int TempY1 = y + y2;  						int TempY2 = y - y2;  						if (TempY1 >= 0 && TempY1 < Height && TempY2 >= 0 && TempY2 < Height) {  							var TempColor = OriginalImage.GetPixel (x' y);  							var TempColor2 = OriginalImage.GetPixel (TempX1' TempY1);  							var TempColor3 = OriginalImage.GetPixel (TempX2' TempY2);  							if (Distance (TempColor.R' TempColor2.R' TempColor.G' TempColor2.G' TempColor.B' TempColor2.B) < Distance (TempColor.R' TempColor3.R' TempColor.G' TempColor3.G' TempColor.B' TempColor3.B)) {  								RValue += TempColor2.R;  								GValue += TempColor2.G;  								BValue += TempColor2.B;  							} else {  								RValue += TempColor3.R;  								GValue += TempColor3.G;  								BValue += TempColor3.B;  							}  							++NumPixels;  						}  					}  				}  			}  			var MeanPixel = Color.FromArgb (RValue / NumPixels' GValue / NumPixels' BValue / NumPixels);  			NewSwiftBitmap.SetPixel (x' y' MeanPixel);  		}  	});  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  }' true)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  		new int[] {  			1'  			2'  			1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			-1'  			-2'  			-1  		}  	}' true)) {  		using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  			NewBitmap.Lock ();  			TempImageX.Lock ();  			TempImageY.Lock ();  			int Width = NewBitmap.Width;  			int Height = NewBitmap.Height;  			Parallel.For (0' Width' x => {  				for (int y = 0; y < Height; ++y) {  					var Pixel1 = TempImageX.GetPixel (x' y);  					var Pixel2 = TempImageY.GetPixel (x' y);  					NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  				}  			});  			NewBitmap.Unlock ();  			TempImageY.Unlock ();  			TempImageX.Unlock ();  			return Input.Copy (NewBitmap).Negative ();  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  }' true)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  		new int[] {  			1'  			2'  			1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			-1'  			-2'  			-1  		}  	}' true)) {  		using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  			NewBitmap.Lock ();  			TempImageX.Lock ();  			TempImageY.Lock ();  			int Width = NewBitmap.Width;  			int Height = NewBitmap.Height;  			Parallel.For (0' Width' x => {  				for (int y = 0; y < Height; ++y) {  					var Pixel1 = TempImageX.GetPixel (x' y);  					var Pixel2 = TempImageY.GetPixel (x' y);  					NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  				}  			});  			NewBitmap.Unlock ();  			TempImageY.Unlock ();  			TempImageX.Unlock ();  			return Input.Copy (NewBitmap).Negative ();  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  }' true)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  		new int[] {  			1'  			2'  			1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			-1'  			-2'  			-1  		}  	}' true)) {  		using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  			NewBitmap.Lock ();  			TempImageX.Lock ();  			TempImageY.Lock ();  			int Width = NewBitmap.Width;  			int Height = NewBitmap.Height;  			Parallel.For (0' Width' x => {  				for (int y = 0; y < Height; ++y) {  					var Pixel1 = TempImageX.GetPixel (x' y);  					var Pixel2 = TempImageY.GetPixel (x' y);  					NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  				}  			});  			NewBitmap.Unlock ();  			TempImageY.Unlock ();  			TempImageX.Unlock ();  			return Input.Copy (NewBitmap).Negative ();  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  }' true)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  		new int[] {  			1'  			2'  			1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			-1'  			-2'  			-1  		}  	}' true)) {  		using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  			NewBitmap.Lock ();  			TempImageX.Lock ();  			TempImageY.Lock ();  			int Width = NewBitmap.Width;  			int Height = NewBitmap.Height;  			Parallel.For (0' Width' x => {  				for (int y = 0; y < Height; ++y) {  					var Pixel1 = TempImageX.GetPixel (x' y);  					var Pixel2 = TempImageY.GetPixel (x' y);  					NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  				}  			});  			NewBitmap.Unlock ();  			TempImageY.Unlock ();  			TempImageX.Unlock ();  			return Input.Copy (NewBitmap).Negative ();  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  }' true)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  		new int[] {  			1'  			2'  			1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			-1'  			-2'  			-1  		}  	}' true)) {  		using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  			NewBitmap.Lock ();  			TempImageX.Lock ();  			TempImageY.Lock ();  			int Width = NewBitmap.Width;  			int Height = NewBitmap.Height;  			Parallel.For (0' Width' x => {  				for (int y = 0; y < Height; ++y) {  					var Pixel1 = TempImageX.GetPixel (x' y);  					var Pixel2 = TempImageY.GetPixel (x' y);  					NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  				}  			});  			NewBitmap.Unlock ();  			TempImageY.Unlock ();  			TempImageX.Unlock ();  			return Input.Copy (NewBitmap).Negative ();  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  }' true)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  		new int[] {  			1'  			2'  			1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			-1'  			-2'  			-1  		}  	}' true)) {  		using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  			NewBitmap.Lock ();  			TempImageX.Lock ();  			TempImageY.Lock ();  			int Width = NewBitmap.Width;  			int Height = NewBitmap.Height;  			Parallel.For (0' Width' x => {  				for (int y = 0; y < Height; ++y) {  					var Pixel1 = TempImageX.GetPixel (x' y);  					var Pixel2 = TempImageY.GetPixel (x' y);  					NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  				}  			});  			NewBitmap.Unlock ();  			TempImageY.Unlock ();  			TempImageX.Unlock ();  			return Input.Copy (NewBitmap).Negative ();  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageX = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  }' true)) {  	using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  		new int[] {  			1'  			2'  			1  		}'  		new int[] {  			0'  			0'  			0  		}'  		new int[] {  			-1'  			-2'  			-1  		}  	}' true)) {  		using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  			NewBitmap.Lock ();  			TempImageX.Lock ();  			TempImageY.Lock ();  			int Width = NewBitmap.Width;  			int Height = NewBitmap.Height;  			Parallel.For (0' Width' x => {  				for (int y = 0; y < Height; ++y) {  					var Pixel1 = TempImageX.GetPixel (x' y);  					var Pixel2 = TempImageY.GetPixel (x' y);  					NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  				}  			});  			NewBitmap.Unlock ();  			TempImageY.Unlock ();  			TempImageX.Unlock ();  			return Input.Copy (NewBitmap).Negative ();  		}  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		1'  		2'  		1  	}'  	new int[] {  		0'  		0'  		0  	}'  	new int[] {  		-1'  		-2'  		-1  	}  }' true)) {  	using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  		NewBitmap.Lock ();  		TempImageX.Lock ();  		TempImageY.Lock ();  		int Width = NewBitmap.Width;  		int Height = NewBitmap.Height;  		Parallel.For (0' Width' x => {  			for (int y = 0; y < Height; ++y) {  				var Pixel1 = TempImageX.GetPixel (x' y);  				var Pixel2 = TempImageY.GetPixel (x' y);  				NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  			}  		});  		NewBitmap.Unlock ();  		TempImageY.Unlock ();  		TempImageX.Unlock ();  		return Input.Copy (NewBitmap).Negative ();  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		1'  		2'  		1  	}'  	new int[] {  		0'  		0'  		0  	}'  	new int[] {  		-1'  		-2'  		-1  	}  }' true)) {  	using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  		NewBitmap.Lock ();  		TempImageX.Lock ();  		TempImageY.Lock ();  		int Width = NewBitmap.Width;  		int Height = NewBitmap.Height;  		Parallel.For (0' Width' x => {  			for (int y = 0; y < Height; ++y) {  				var Pixel1 = TempImageX.GetPixel (x' y);  				var Pixel2 = TempImageY.GetPixel (x' y);  				NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  			}  		});  		NewBitmap.Unlock ();  		TempImageY.Unlock ();  		TempImageX.Unlock ();  		return Input.Copy (NewBitmap).Negative ();  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		1'  		2'  		1  	}'  	new int[] {  		0'  		0'  		0  	}'  	new int[] {  		-1'  		-2'  		-1  	}  }' true)) {  	using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  		NewBitmap.Lock ();  		TempImageX.Lock ();  		TempImageY.Lock ();  		int Width = NewBitmap.Width;  		int Height = NewBitmap.Height;  		Parallel.For (0' Width' x => {  			for (int y = 0; y < Height; ++y) {  				var Pixel1 = TempImageX.GetPixel (x' y);  				var Pixel2 = TempImageY.GetPixel (x' y);  				NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  			}  		});  		NewBitmap.Unlock ();  		TempImageY.Unlock ();  		TempImageX.Unlock ();  		return Input.Copy (NewBitmap).Negative ();  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		1'  		2'  		1  	}'  	new int[] {  		0'  		0'  		0  	}'  	new int[] {  		-1'  		-2'  		-1  	}  }' true)) {  	using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  		NewBitmap.Lock ();  		TempImageX.Lock ();  		TempImageY.Lock ();  		int Width = NewBitmap.Width;  		int Height = NewBitmap.Height;  		Parallel.For (0' Width' x => {  			for (int y = 0; y < Height; ++y) {  				var Pixel1 = TempImageX.GetPixel (x' y);  				var Pixel2 = TempImageY.GetPixel (x' y);  				NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  			}  		});  		NewBitmap.Unlock ();  		TempImageY.Unlock ();  		TempImageX.Unlock ();  		return Input.Copy (NewBitmap).Negative ();  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap TempImageY = ((SwiftBitmap)Input.Clone ()).ApplyConvolutionFilter (new int[][] {  	new int[] {  		1'  		2'  		1  	}'  	new int[] {  		0'  		0'  		0  	}'  	new int[] {  		-1'  		-2'  		-1  	}  }' true)) {  	using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  		NewBitmap.Lock ();  		TempImageX.Lock ();  		TempImageY.Lock ();  		int Width = NewBitmap.Width;  		int Height = NewBitmap.Height;  		Parallel.For (0' Width' x => {  			for (int y = 0; y < Height; ++y) {  				var Pixel1 = TempImageX.GetPixel (x' y);  				var Pixel2 = TempImageY.GetPixel (x' y);  				NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  			}  		});  		NewBitmap.Unlock ();  		TempImageY.Unlock ();  		TempImageX.Unlock ();  		return Input.Copy (NewBitmap).Negative ();  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  	NewBitmap.Lock ();  	TempImageX.Lock ();  	TempImageY.Lock ();  	int Width = NewBitmap.Width;  	int Height = NewBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			var Pixel1 = TempImageX.GetPixel (x' y);  			var Pixel2 = TempImageY.GetPixel (x' y);  			NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  		}  	});  	NewBitmap.Unlock ();  	TempImageY.Unlock ();  	TempImageX.Unlock ();  	return Input.Copy (NewBitmap).Negative ();  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  	NewBitmap.Lock ();  	TempImageX.Lock ();  	TempImageY.Lock ();  	int Width = NewBitmap.Width;  	int Height = NewBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			var Pixel1 = TempImageX.GetPixel (x' y);  			var Pixel2 = TempImageY.GetPixel (x' y);  			NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  		}  	});  	NewBitmap.Unlock ();  	TempImageY.Unlock ();  	TempImageX.Unlock ();  	return Input.Copy (NewBitmap).Negative ();  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: using (SwiftBitmap NewBitmap = new SwiftBitmap (Input.Width' Input.Height)) {  	NewBitmap.Lock ();  	TempImageX.Lock ();  	TempImageY.Lock ();  	int Width = NewBitmap.Width;  	int Height = NewBitmap.Height;  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			var Pixel1 = TempImageX.GetPixel (x' y);  			var Pixel2 = TempImageY.GetPixel (x' y);  			NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  		}  	});  	NewBitmap.Unlock ();  	TempImageY.Unlock ();  	TempImageX.Unlock ();  	return Input.Copy (NewBitmap).Negative ();  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		var Pixel1 = TempImageX.GetPixel (x' y);  		var Pixel2 = TempImageY.GetPixel (x' y);  		NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		var Pixel1 = TempImageX.GetPixel (x' y);  		var Pixel2 = TempImageY.GetPixel (x' y);  		NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		var Pixel1 = TempImageX.GetPixel (x' y);  		var Pixel2 = TempImageY.GetPixel (x' y);  		NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  	}  });  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	var Pixel1 = TempImageX.GetPixel (x' y);  	var Pixel2 = TempImageY.GetPixel (x' y);  	NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	var Pixel1 = TempImageX.GetPixel (x' y);  	var Pixel2 = TempImageY.GetPixel (x' y);  	NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	var Pixel1 = TempImageX.GetPixel (x' y);  	var Pixel2 = TempImageY.GetPixel (x' y);  	NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: NewBitmap.SetPixel (x' y' Color.FromArgb ((Pixel1.R + Pixel2.R).Clamp (255' 0)' (Pixel1.G + Pixel2.G).Clamp (255' 0)' (Pixel1.B + Pixel2.B).Clamp (255' 0)));  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEmboss,The following statement contains a magic number: return Image.ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  }' offset: 127);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEmboss,The following statement contains a magic number: return Image.ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  }' offset: 127);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEmboss,The following statement contains a magic number: return Image.ApplyConvolutionFilter (new int[][] {  	new int[] {  		-1'  		0'  		1  	}'  	new int[] {  		-2'  		0'  		2  	}'  	new int[] {  		-1'  		0'  		1  	}  }' offset: 127);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,ToASCIIArt,The following statement contains a magic number: using (SwiftBitmap TempImage = ((SwiftBitmap)Input.Clone ()).BlackAndWhite ().Lock ()) {  	var Builder = new StringBuilder ();  	for (int x = 0; x < TempImage.Height; ++x) {  		for (int y = 0; y < TempImage.Width; ++y) {  			if (ShowLine) {  				var CurrentPixel = TempImage.GetPixel (y' x);  				Builder.Append (_ASCIICharacters [((CurrentPixel.R * _ASCIICharacters.Length) / 255)]);  			}  		}  		if (ShowLine) {  			Builder.Append (System.Environment.NewLine);  			ShowLine = false;  		} else {  			ShowLine = true;  		}  	}  	TempImage.Unlock ();  	return Builder.ToString ();  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,ToASCIIArt,The following statement contains a magic number: for (int x = 0; x < TempImage.Height; ++x) {  	for (int y = 0; y < TempImage.Width; ++y) {  		if (ShowLine) {  			var CurrentPixel = TempImage.GetPixel (y' x);  			Builder.Append (_ASCIICharacters [((CurrentPixel.R * _ASCIICharacters.Length) / 255)]);  		}  	}  	if (ShowLine) {  		Builder.Append (System.Environment.NewLine);  		ShowLine = false;  	} else {  		ShowLine = true;  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,ToASCIIArt,The following statement contains a magic number: for (int y = 0; y < TempImage.Width; ++y) {  	if (ShowLine) {  		var CurrentPixel = TempImage.GetPixel (y' x);  		Builder.Append (_ASCIICharacters [((CurrentPixel.R * _ASCIICharacters.Length) / 255)]);  	}  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,ToASCIIArt,The following statement contains a magic number: if (ShowLine) {  	var CurrentPixel = TempImage.GetPixel (y' x);  	Builder.Append (_ASCIICharacters [((CurrentPixel.R * _ASCIICharacters.Length) / 255)]);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,ToASCIIArt,The following statement contains a magic number: Builder.Append (_ASCIICharacters [((CurrentPixel.R * _ASCIICharacters.Length) / 255)]);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Turbulence,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (Width' Height)) {  	NewSwiftBitmap.Lock ();  	using (SwiftBitmap XNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed)) {  		XNoise.Lock ();  		using (SwiftBitmap YNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed * 2)) {  			YNoise.Lock ();  			Parallel.For (0' Height' y => {  				for (int x = 0; x < Width; ++x) {  					float XDistortion = x + (GetHeight (x' y' XNoise) * Power);  					float YDistortion = y + (GetHeight (x' y' YNoise) * Power);  					var X1 = ((int)XDistortion).Clamp (Width - 1' 0);  					var Y1 = ((int)YDistortion).Clamp (Height - 1' 0);  					NewSwiftBitmap.SetPixel (x' y' OriginalImage.GetPixel (X1' Y1));  				}  			});  			YNoise.Unlock ();  		}  		XNoise.Unlock ();  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Turbulence,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (Width' Height)) {  	NewSwiftBitmap.Lock ();  	using (SwiftBitmap XNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed)) {  		XNoise.Lock ();  		using (SwiftBitmap YNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed * 2)) {  			YNoise.Lock ();  			Parallel.For (0' Height' y => {  				for (int x = 0; x < Width; ++x) {  					float XDistortion = x + (GetHeight (x' y' XNoise) * Power);  					float YDistortion = y + (GetHeight (x' y' YNoise) * Power);  					var X1 = ((int)XDistortion).Clamp (Width - 1' 0);  					var Y1 = ((int)YDistortion).Clamp (Height - 1' 0);  					NewSwiftBitmap.SetPixel (x' y' OriginalImage.GetPixel (X1' Y1));  				}  			});  			YNoise.Unlock ();  		}  		XNoise.Unlock ();  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Turbulence,The following statement contains a magic number: using (SwiftBitmap NewSwiftBitmap = new SwiftBitmap (Width' Height)) {  	NewSwiftBitmap.Lock ();  	using (SwiftBitmap XNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed)) {  		XNoise.Lock ();  		using (SwiftBitmap YNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed * 2)) {  			YNoise.Lock ();  			Parallel.For (0' Height' y => {  				for (int x = 0; x < Width; ++x) {  					float XDistortion = x + (GetHeight (x' y' XNoise) * Power);  					float YDistortion = y + (GetHeight (x' y' YNoise) * Power);  					var X1 = ((int)XDistortion).Clamp (Width - 1' 0);  					var Y1 = ((int)YDistortion).Clamp (Height - 1' 0);  					NewSwiftBitmap.SetPixel (x' y' OriginalImage.GetPixel (X1' Y1));  				}  			});  			YNoise.Unlock ();  		}  		XNoise.Unlock ();  	}  	NewSwiftBitmap.Unlock ();  	return OriginalImage.Unlock ().Copy (NewSwiftBitmap);  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Turbulence,The following statement contains a magic number: using (SwiftBitmap XNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed)) {  	XNoise.Lock ();  	using (SwiftBitmap YNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed * 2)) {  		YNoise.Lock ();  		Parallel.For (0' Height' y => {  			for (int x = 0; x < Width; ++x) {  				float XDistortion = x + (GetHeight (x' y' XNoise) * Power);  				float YDistortion = y + (GetHeight (x' y' YNoise) * Power);  				var X1 = ((int)XDistortion).Clamp (Width - 1' 0);  				var Y1 = ((int)YDistortion).Clamp (Height - 1' 0);  				NewSwiftBitmap.SetPixel (x' y' OriginalImage.GetPixel (X1' Y1));  			}  		});  		YNoise.Unlock ();  	}  	XNoise.Unlock ();  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Turbulence,The following statement contains a magic number: using (SwiftBitmap XNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed)) {  	XNoise.Lock ();  	using (SwiftBitmap YNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed * 2)) {  		YNoise.Lock ();  		Parallel.For (0' Height' y => {  			for (int x = 0; x < Width; ++x) {  				float XDistortion = x + (GetHeight (x' y' XNoise) * Power);  				float YDistortion = y + (GetHeight (x' y' YNoise) * Power);  				var X1 = ((int)XDistortion).Clamp (Width - 1' 0);  				var Y1 = ((int)YDistortion).Clamp (Height - 1' 0);  				NewSwiftBitmap.SetPixel (x' y' OriginalImage.GetPixel (X1' Y1));  			}  		});  		YNoise.Unlock ();  	}  	XNoise.Unlock ();  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Turbulence,The following statement contains a magic number: using (SwiftBitmap XNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed)) {  	XNoise.Lock ();  	using (SwiftBitmap YNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed * 2)) {  		YNoise.Lock ();  		Parallel.For (0' Height' y => {  			for (int x = 0; x < Width; ++x) {  				float XDistortion = x + (GetHeight (x' y' XNoise) * Power);  				float YDistortion = y + (GetHeight (x' y' YNoise) * Power);  				var X1 = ((int)XDistortion).Clamp (Width - 1' 0);  				var Y1 = ((int)YDistortion).Clamp (Height - 1' 0);  				NewSwiftBitmap.SetPixel (x' y' OriginalImage.GetPixel (X1' Y1));  			}  		});  		YNoise.Unlock ();  	}  	XNoise.Unlock ();  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Turbulence,The following statement contains a magic number: using (SwiftBitmap YNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed * 2)) {  	YNoise.Lock ();  	Parallel.For (0' Height' y => {  		for (int x = 0; x < Width; ++x) {  			float XDistortion = x + (GetHeight (x' y' XNoise) * Power);  			float YDistortion = y + (GetHeight (x' y' YNoise) * Power);  			var X1 = ((int)XDistortion).Clamp (Width - 1' 0);  			var Y1 = ((int)YDistortion).Clamp (Height - 1' 0);  			NewSwiftBitmap.SetPixel (x' y' OriginalImage.GetPixel (X1' Y1));  		}  	});  	YNoise.Unlock ();  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Turbulence,The following statement contains a magic number: using (SwiftBitmap YNoise = PerlinNoise.Generate (Width' Height' 255' 0' 0.0625f' 1.0f' 0.5f' Roughness' Seed * 2)) {  	YNoise.Lock ();  	Parallel.For (0' Height' y => {  		for (int x = 0; x < Width; ++x) {  			float XDistortion = x + (GetHeight (x' y' XNoise) * Power);  			float YDistortion = y + (GetHeight (x' y' YNoise) * Power);  			var X1 = ((int)XDistortion).Clamp (Width - 1' 0);  			var Y1 = ((int)YDistortion).Clamp (Height - 1' 0);  			NewSwiftBitmap.SetPixel (x' y' OriginalImage.GetPixel (X1' Y1));  		}  	});  	YNoise.Unlock ();  }  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Map,The following statement contains a magic number: return ((int)(TempVal * 255)).Clamp (255' 0);  
Magic Number,Utilities.Media,SwiftBitmapExtensions,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Map,The following statement contains a magic number: return ((int)(TempVal * 255)).Clamp (255' 0);  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,RGBHistogram,The following statement contains a magic number: R = new float[256];  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,RGBHistogram,The following statement contains a magic number: G = new float[256];  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,RGBHistogram,The following statement contains a magic number: B = new float[256];  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: for (int x = 0; x < 256; ++x) {  	if (R [x] > 0f) {  		if (RMax < x)  			RMax = x;  		if (RMin > x)  			RMin = x;  	}  	if (G [x] > 0f) {  		if (GMax < x)  			GMax = x;  		if (GMin > x)  			GMin = x;  	}  	if (B [x] > 0f) {  		if (BMax < x)  			BMax = x;  		if (BMin > x)  			BMin = x;  	}  }  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: R [0] = R [0] * 256 / TotalPixels;  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: G [0] = G [0] * 256 / TotalPixels;  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: B [0] = B [0] * 256 / TotalPixels;  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: for (int x = 1; x < 256; ++x) {  	PreviousR += R [x];  	PreviousG += G [x];  	PreviousB += B [x];  	R [x] = ((PreviousR - R [RMin]) / (TotalPixels - R [RMin])) * 255;  	G [x] = ((PreviousG - G [GMin]) / (TotalPixels - G [GMin])) * 255;  	B [x] = ((PreviousB - B [BMin]) / (TotalPixels - B [BMin])) * 255;  }  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: for (int x = 1; x < 256; ++x) {  	PreviousR += R [x];  	PreviousG += G [x];  	PreviousB += B [x];  	R [x] = ((PreviousR - R [RMin]) / (TotalPixels - R [RMin])) * 255;  	G [x] = ((PreviousG - G [GMin]) / (TotalPixels - G [GMin])) * 255;  	B [x] = ((PreviousB - B [BMin]) / (TotalPixels - B [BMin])) * 255;  }  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: for (int x = 1; x < 256; ++x) {  	PreviousR += R [x];  	PreviousG += G [x];  	PreviousB += B [x];  	R [x] = ((PreviousR - R [RMin]) / (TotalPixels - R [RMin])) * 255;  	G [x] = ((PreviousG - G [GMin]) / (TotalPixels - G [GMin])) * 255;  	B [x] = ((PreviousB - B [BMin]) / (TotalPixels - B [BMin])) * 255;  }  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: for (int x = 1; x < 256; ++x) {  	PreviousR += R [x];  	PreviousG += G [x];  	PreviousB += B [x];  	R [x] = ((PreviousR - R [RMin]) / (TotalPixels - R [RMin])) * 255;  	G [x] = ((PreviousG - G [GMin]) / (TotalPixels - G [GMin])) * 255;  	B [x] = ((PreviousB - B [BMin]) / (TotalPixels - B [BMin])) * 255;  }  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: R [x] = ((PreviousR - R [RMin]) / (TotalPixels - R [RMin])) * 255;  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: G [x] = ((PreviousG - G [GMin]) / (TotalPixels - G [GMin])) * 255;  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: B [x] = ((PreviousB - B [BMin]) / (TotalPixels - B [BMin])) * 255;  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: Width = 256;  
Magic Number,Utilities.Media,RGBHistogram,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Normalize,The following statement contains a magic number: for (int x = 0; x < 256; ++x) {  	R [x] /= TotalPixels;  	G [x] /= TotalPixels;  	B [x] /= TotalPixels;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: using (SwiftBitmap Result = new SwiftBitmap (Width' Height)) {  	Lock ();  	Result.Lock ();  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			int Weight = 0;  			int XCurrent = -filter [0].Length / 2;  			for (int x2 = 0; x2 < filter [0].Length; ++x2) {  				if (XCurrent + x < Width && XCurrent + x >= 0) {  					int YCurrent = -filter.Length / 2;  					for (int y2 = 0; y2 < filter.Length; ++y2) {  						if (YCurrent + y < Height && YCurrent + y >= 0) {  							var Pixel = GetPixel (XCurrent + x' YCurrent + y);  							RValue += filter [x2] [y2] * Pixel.R;  							GValue += filter [x2] [y2] * Pixel.G;  							BValue += filter [x2] [y2] * Pixel.B;  							Weight += filter [x2] [y2];  						}  						++YCurrent;  					}  				}  				++XCurrent;  			}  			var MeanPixel = GetPixel (x' y);  			if (Weight == 0)  				Weight = 1;  			if (Weight > 0) {  				if (absolute) {  					RValue = System.Math.Abs (RValue);  					GValue = System.Math.Abs (GValue);  					BValue = System.Math.Abs (BValue);  				}  				RValue = (RValue / Weight) + offset;  				RValue = RValue.Clamp (255' 0);  				GValue = (GValue / Weight) + offset;  				GValue = GValue.Clamp (255' 0);  				BValue = (BValue / Weight) + offset;  				BValue = BValue.Clamp (255' 0);  				MeanPixel = Color.FromArgb (RValue' GValue' BValue);  			}  			Result.SetPixel (x' y' MeanPixel);  		}  	});  	Unlock ();  	Result.Unlock ();  	return Copy (Result);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: using (SwiftBitmap Result = new SwiftBitmap (Width' Height)) {  	Lock ();  	Result.Lock ();  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			int Weight = 0;  			int XCurrent = -filter [0].Length / 2;  			for (int x2 = 0; x2 < filter [0].Length; ++x2) {  				if (XCurrent + x < Width && XCurrent + x >= 0) {  					int YCurrent = -filter.Length / 2;  					for (int y2 = 0; y2 < filter.Length; ++y2) {  						if (YCurrent + y < Height && YCurrent + y >= 0) {  							var Pixel = GetPixel (XCurrent + x' YCurrent + y);  							RValue += filter [x2] [y2] * Pixel.R;  							GValue += filter [x2] [y2] * Pixel.G;  							BValue += filter [x2] [y2] * Pixel.B;  							Weight += filter [x2] [y2];  						}  						++YCurrent;  					}  				}  				++XCurrent;  			}  			var MeanPixel = GetPixel (x' y);  			if (Weight == 0)  				Weight = 1;  			if (Weight > 0) {  				if (absolute) {  					RValue = System.Math.Abs (RValue);  					GValue = System.Math.Abs (GValue);  					BValue = System.Math.Abs (BValue);  				}  				RValue = (RValue / Weight) + offset;  				RValue = RValue.Clamp (255' 0);  				GValue = (GValue / Weight) + offset;  				GValue = GValue.Clamp (255' 0);  				BValue = (BValue / Weight) + offset;  				BValue = BValue.Clamp (255' 0);  				MeanPixel = Color.FromArgb (RValue' GValue' BValue);  			}  			Result.SetPixel (x' y' MeanPixel);  		}  	});  	Unlock ();  	Result.Unlock ();  	return Copy (Result);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: using (SwiftBitmap Result = new SwiftBitmap (Width' Height)) {  	Lock ();  	Result.Lock ();  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			int Weight = 0;  			int XCurrent = -filter [0].Length / 2;  			for (int x2 = 0; x2 < filter [0].Length; ++x2) {  				if (XCurrent + x < Width && XCurrent + x >= 0) {  					int YCurrent = -filter.Length / 2;  					for (int y2 = 0; y2 < filter.Length; ++y2) {  						if (YCurrent + y < Height && YCurrent + y >= 0) {  							var Pixel = GetPixel (XCurrent + x' YCurrent + y);  							RValue += filter [x2] [y2] * Pixel.R;  							GValue += filter [x2] [y2] * Pixel.G;  							BValue += filter [x2] [y2] * Pixel.B;  							Weight += filter [x2] [y2];  						}  						++YCurrent;  					}  				}  				++XCurrent;  			}  			var MeanPixel = GetPixel (x' y);  			if (Weight == 0)  				Weight = 1;  			if (Weight > 0) {  				if (absolute) {  					RValue = System.Math.Abs (RValue);  					GValue = System.Math.Abs (GValue);  					BValue = System.Math.Abs (BValue);  				}  				RValue = (RValue / Weight) + offset;  				RValue = RValue.Clamp (255' 0);  				GValue = (GValue / Weight) + offset;  				GValue = GValue.Clamp (255' 0);  				BValue = (BValue / Weight) + offset;  				BValue = BValue.Clamp (255' 0);  				MeanPixel = Color.FromArgb (RValue' GValue' BValue);  			}  			Result.SetPixel (x' y' MeanPixel);  		}  	});  	Unlock ();  	Result.Unlock ();  	return Copy (Result);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: using (SwiftBitmap Result = new SwiftBitmap (Width' Height)) {  	Lock ();  	Result.Lock ();  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			int Weight = 0;  			int XCurrent = -filter [0].Length / 2;  			for (int x2 = 0; x2 < filter [0].Length; ++x2) {  				if (XCurrent + x < Width && XCurrent + x >= 0) {  					int YCurrent = -filter.Length / 2;  					for (int y2 = 0; y2 < filter.Length; ++y2) {  						if (YCurrent + y < Height && YCurrent + y >= 0) {  							var Pixel = GetPixel (XCurrent + x' YCurrent + y);  							RValue += filter [x2] [y2] * Pixel.R;  							GValue += filter [x2] [y2] * Pixel.G;  							BValue += filter [x2] [y2] * Pixel.B;  							Weight += filter [x2] [y2];  						}  						++YCurrent;  					}  				}  				++XCurrent;  			}  			var MeanPixel = GetPixel (x' y);  			if (Weight == 0)  				Weight = 1;  			if (Weight > 0) {  				if (absolute) {  					RValue = System.Math.Abs (RValue);  					GValue = System.Math.Abs (GValue);  					BValue = System.Math.Abs (BValue);  				}  				RValue = (RValue / Weight) + offset;  				RValue = RValue.Clamp (255' 0);  				GValue = (GValue / Weight) + offset;  				GValue = GValue.Clamp (255' 0);  				BValue = (BValue / Weight) + offset;  				BValue = BValue.Clamp (255' 0);  				MeanPixel = Color.FromArgb (RValue' GValue' BValue);  			}  			Result.SetPixel (x' y' MeanPixel);  		}  	});  	Unlock ();  	Result.Unlock ();  	return Copy (Result);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: using (SwiftBitmap Result = new SwiftBitmap (Width' Height)) {  	Lock ();  	Result.Lock ();  	Parallel.For (0' Width' x => {  		for (int y = 0; y < Height; ++y) {  			int RValue = 0;  			int GValue = 0;  			int BValue = 0;  			int Weight = 0;  			int XCurrent = -filter [0].Length / 2;  			for (int x2 = 0; x2 < filter [0].Length; ++x2) {  				if (XCurrent + x < Width && XCurrent + x >= 0) {  					int YCurrent = -filter.Length / 2;  					for (int y2 = 0; y2 < filter.Length; ++y2) {  						if (YCurrent + y < Height && YCurrent + y >= 0) {  							var Pixel = GetPixel (XCurrent + x' YCurrent + y);  							RValue += filter [x2] [y2] * Pixel.R;  							GValue += filter [x2] [y2] * Pixel.G;  							BValue += filter [x2] [y2] * Pixel.B;  							Weight += filter [x2] [y2];  						}  						++YCurrent;  					}  				}  				++XCurrent;  			}  			var MeanPixel = GetPixel (x' y);  			if (Weight == 0)  				Weight = 1;  			if (Weight > 0) {  				if (absolute) {  					RValue = System.Math.Abs (RValue);  					GValue = System.Math.Abs (GValue);  					BValue = System.Math.Abs (BValue);  				}  				RValue = (RValue / Weight) + offset;  				RValue = RValue.Clamp (255' 0);  				GValue = (GValue / Weight) + offset;  				GValue = GValue.Clamp (255' 0);  				BValue = (BValue / Weight) + offset;  				BValue = BValue.Clamp (255' 0);  				MeanPixel = Color.FromArgb (RValue' GValue' BValue);  			}  			Result.SetPixel (x' y' MeanPixel);  		}  	});  	Unlock ();  	Result.Unlock ();  	return Copy (Result);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		int Weight = 0;  		int XCurrent = -filter [0].Length / 2;  		for (int x2 = 0; x2 < filter [0].Length; ++x2) {  			if (XCurrent + x < Width && XCurrent + x >= 0) {  				int YCurrent = -filter.Length / 2;  				for (int y2 = 0; y2 < filter.Length; ++y2) {  					if (YCurrent + y < Height && YCurrent + y >= 0) {  						var Pixel = GetPixel (XCurrent + x' YCurrent + y);  						RValue += filter [x2] [y2] * Pixel.R;  						GValue += filter [x2] [y2] * Pixel.G;  						BValue += filter [x2] [y2] * Pixel.B;  						Weight += filter [x2] [y2];  					}  					++YCurrent;  				}  			}  			++XCurrent;  		}  		var MeanPixel = GetPixel (x' y);  		if (Weight == 0)  			Weight = 1;  		if (Weight > 0) {  			if (absolute) {  				RValue = System.Math.Abs (RValue);  				GValue = System.Math.Abs (GValue);  				BValue = System.Math.Abs (BValue);  			}  			RValue = (RValue / Weight) + offset;  			RValue = RValue.Clamp (255' 0);  			GValue = (GValue / Weight) + offset;  			GValue = GValue.Clamp (255' 0);  			BValue = (BValue / Weight) + offset;  			BValue = BValue.Clamp (255' 0);  			MeanPixel = Color.FromArgb (RValue' GValue' BValue);  		}  		Result.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		int Weight = 0;  		int XCurrent = -filter [0].Length / 2;  		for (int x2 = 0; x2 < filter [0].Length; ++x2) {  			if (XCurrent + x < Width && XCurrent + x >= 0) {  				int YCurrent = -filter.Length / 2;  				for (int y2 = 0; y2 < filter.Length; ++y2) {  					if (YCurrent + y < Height && YCurrent + y >= 0) {  						var Pixel = GetPixel (XCurrent + x' YCurrent + y);  						RValue += filter [x2] [y2] * Pixel.R;  						GValue += filter [x2] [y2] * Pixel.G;  						BValue += filter [x2] [y2] * Pixel.B;  						Weight += filter [x2] [y2];  					}  					++YCurrent;  				}  			}  			++XCurrent;  		}  		var MeanPixel = GetPixel (x' y);  		if (Weight == 0)  			Weight = 1;  		if (Weight > 0) {  			if (absolute) {  				RValue = System.Math.Abs (RValue);  				GValue = System.Math.Abs (GValue);  				BValue = System.Math.Abs (BValue);  			}  			RValue = (RValue / Weight) + offset;  			RValue = RValue.Clamp (255' 0);  			GValue = (GValue / Weight) + offset;  			GValue = GValue.Clamp (255' 0);  			BValue = (BValue / Weight) + offset;  			BValue = BValue.Clamp (255' 0);  			MeanPixel = Color.FromArgb (RValue' GValue' BValue);  		}  		Result.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		int Weight = 0;  		int XCurrent = -filter [0].Length / 2;  		for (int x2 = 0; x2 < filter [0].Length; ++x2) {  			if (XCurrent + x < Width && XCurrent + x >= 0) {  				int YCurrent = -filter.Length / 2;  				for (int y2 = 0; y2 < filter.Length; ++y2) {  					if (YCurrent + y < Height && YCurrent + y >= 0) {  						var Pixel = GetPixel (XCurrent + x' YCurrent + y);  						RValue += filter [x2] [y2] * Pixel.R;  						GValue += filter [x2] [y2] * Pixel.G;  						BValue += filter [x2] [y2] * Pixel.B;  						Weight += filter [x2] [y2];  					}  					++YCurrent;  				}  			}  			++XCurrent;  		}  		var MeanPixel = GetPixel (x' y);  		if (Weight == 0)  			Weight = 1;  		if (Weight > 0) {  			if (absolute) {  				RValue = System.Math.Abs (RValue);  				GValue = System.Math.Abs (GValue);  				BValue = System.Math.Abs (BValue);  			}  			RValue = (RValue / Weight) + offset;  			RValue = RValue.Clamp (255' 0);  			GValue = (GValue / Weight) + offset;  			GValue = GValue.Clamp (255' 0);  			BValue = (BValue / Weight) + offset;  			BValue = BValue.Clamp (255' 0);  			MeanPixel = Color.FromArgb (RValue' GValue' BValue);  		}  		Result.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		int Weight = 0;  		int XCurrent = -filter [0].Length / 2;  		for (int x2 = 0; x2 < filter [0].Length; ++x2) {  			if (XCurrent + x < Width && XCurrent + x >= 0) {  				int YCurrent = -filter.Length / 2;  				for (int y2 = 0; y2 < filter.Length; ++y2) {  					if (YCurrent + y < Height && YCurrent + y >= 0) {  						var Pixel = GetPixel (XCurrent + x' YCurrent + y);  						RValue += filter [x2] [y2] * Pixel.R;  						GValue += filter [x2] [y2] * Pixel.G;  						BValue += filter [x2] [y2] * Pixel.B;  						Weight += filter [x2] [y2];  					}  					++YCurrent;  				}  			}  			++XCurrent;  		}  		var MeanPixel = GetPixel (x' y);  		if (Weight == 0)  			Weight = 1;  		if (Weight > 0) {  			if (absolute) {  				RValue = System.Math.Abs (RValue);  				GValue = System.Math.Abs (GValue);  				BValue = System.Math.Abs (BValue);  			}  			RValue = (RValue / Weight) + offset;  			RValue = RValue.Clamp (255' 0);  			GValue = (GValue / Weight) + offset;  			GValue = GValue.Clamp (255' 0);  			BValue = (BValue / Weight) + offset;  			BValue = BValue.Clamp (255' 0);  			MeanPixel = Color.FromArgb (RValue' GValue' BValue);  		}  		Result.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: Parallel.For (0' Width' x => {  	for (int y = 0; y < Height; ++y) {  		int RValue = 0;  		int GValue = 0;  		int BValue = 0;  		int Weight = 0;  		int XCurrent = -filter [0].Length / 2;  		for (int x2 = 0; x2 < filter [0].Length; ++x2) {  			if (XCurrent + x < Width && XCurrent + x >= 0) {  				int YCurrent = -filter.Length / 2;  				for (int y2 = 0; y2 < filter.Length; ++y2) {  					if (YCurrent + y < Height && YCurrent + y >= 0) {  						var Pixel = GetPixel (XCurrent + x' YCurrent + y);  						RValue += filter [x2] [y2] * Pixel.R;  						GValue += filter [x2] [y2] * Pixel.G;  						BValue += filter [x2] [y2] * Pixel.B;  						Weight += filter [x2] [y2];  					}  					++YCurrent;  				}  			}  			++XCurrent;  		}  		var MeanPixel = GetPixel (x' y);  		if (Weight == 0)  			Weight = 1;  		if (Weight > 0) {  			if (absolute) {  				RValue = System.Math.Abs (RValue);  				GValue = System.Math.Abs (GValue);  				BValue = System.Math.Abs (BValue);  			}  			RValue = (RValue / Weight) + offset;  			RValue = RValue.Clamp (255' 0);  			GValue = (GValue / Weight) + offset;  			GValue = GValue.Clamp (255' 0);  			BValue = (BValue / Weight) + offset;  			BValue = BValue.Clamp (255' 0);  			MeanPixel = Color.FromArgb (RValue' GValue' BValue);  		}  		Result.SetPixel (x' y' MeanPixel);  	}  });  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int RValue = 0;  	int GValue = 0;  	int BValue = 0;  	int Weight = 0;  	int XCurrent = -filter [0].Length / 2;  	for (int x2 = 0; x2 < filter [0].Length; ++x2) {  		if (XCurrent + x < Width && XCurrent + x >= 0) {  			int YCurrent = -filter.Length / 2;  			for (int y2 = 0; y2 < filter.Length; ++y2) {  				if (YCurrent + y < Height && YCurrent + y >= 0) {  					var Pixel = GetPixel (XCurrent + x' YCurrent + y);  					RValue += filter [x2] [y2] * Pixel.R;  					GValue += filter [x2] [y2] * Pixel.G;  					BValue += filter [x2] [y2] * Pixel.B;  					Weight += filter [x2] [y2];  				}  				++YCurrent;  			}  		}  		++XCurrent;  	}  	var MeanPixel = GetPixel (x' y);  	if (Weight == 0)  		Weight = 1;  	if (Weight > 0) {  		if (absolute) {  			RValue = System.Math.Abs (RValue);  			GValue = System.Math.Abs (GValue);  			BValue = System.Math.Abs (BValue);  		}  		RValue = (RValue / Weight) + offset;  		RValue = RValue.Clamp (255' 0);  		GValue = (GValue / Weight) + offset;  		GValue = GValue.Clamp (255' 0);  		BValue = (BValue / Weight) + offset;  		BValue = BValue.Clamp (255' 0);  		MeanPixel = Color.FromArgb (RValue' GValue' BValue);  	}  	Result.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int RValue = 0;  	int GValue = 0;  	int BValue = 0;  	int Weight = 0;  	int XCurrent = -filter [0].Length / 2;  	for (int x2 = 0; x2 < filter [0].Length; ++x2) {  		if (XCurrent + x < Width && XCurrent + x >= 0) {  			int YCurrent = -filter.Length / 2;  			for (int y2 = 0; y2 < filter.Length; ++y2) {  				if (YCurrent + y < Height && YCurrent + y >= 0) {  					var Pixel = GetPixel (XCurrent + x' YCurrent + y);  					RValue += filter [x2] [y2] * Pixel.R;  					GValue += filter [x2] [y2] * Pixel.G;  					BValue += filter [x2] [y2] * Pixel.B;  					Weight += filter [x2] [y2];  				}  				++YCurrent;  			}  		}  		++XCurrent;  	}  	var MeanPixel = GetPixel (x' y);  	if (Weight == 0)  		Weight = 1;  	if (Weight > 0) {  		if (absolute) {  			RValue = System.Math.Abs (RValue);  			GValue = System.Math.Abs (GValue);  			BValue = System.Math.Abs (BValue);  		}  		RValue = (RValue / Weight) + offset;  		RValue = RValue.Clamp (255' 0);  		GValue = (GValue / Weight) + offset;  		GValue = GValue.Clamp (255' 0);  		BValue = (BValue / Weight) + offset;  		BValue = BValue.Clamp (255' 0);  		MeanPixel = Color.FromArgb (RValue' GValue' BValue);  	}  	Result.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int RValue = 0;  	int GValue = 0;  	int BValue = 0;  	int Weight = 0;  	int XCurrent = -filter [0].Length / 2;  	for (int x2 = 0; x2 < filter [0].Length; ++x2) {  		if (XCurrent + x < Width && XCurrent + x >= 0) {  			int YCurrent = -filter.Length / 2;  			for (int y2 = 0; y2 < filter.Length; ++y2) {  				if (YCurrent + y < Height && YCurrent + y >= 0) {  					var Pixel = GetPixel (XCurrent + x' YCurrent + y);  					RValue += filter [x2] [y2] * Pixel.R;  					GValue += filter [x2] [y2] * Pixel.G;  					BValue += filter [x2] [y2] * Pixel.B;  					Weight += filter [x2] [y2];  				}  				++YCurrent;  			}  		}  		++XCurrent;  	}  	var MeanPixel = GetPixel (x' y);  	if (Weight == 0)  		Weight = 1;  	if (Weight > 0) {  		if (absolute) {  			RValue = System.Math.Abs (RValue);  			GValue = System.Math.Abs (GValue);  			BValue = System.Math.Abs (BValue);  		}  		RValue = (RValue / Weight) + offset;  		RValue = RValue.Clamp (255' 0);  		GValue = (GValue / Weight) + offset;  		GValue = GValue.Clamp (255' 0);  		BValue = (BValue / Weight) + offset;  		BValue = BValue.Clamp (255' 0);  		MeanPixel = Color.FromArgb (RValue' GValue' BValue);  	}  	Result.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int RValue = 0;  	int GValue = 0;  	int BValue = 0;  	int Weight = 0;  	int XCurrent = -filter [0].Length / 2;  	for (int x2 = 0; x2 < filter [0].Length; ++x2) {  		if (XCurrent + x < Width && XCurrent + x >= 0) {  			int YCurrent = -filter.Length / 2;  			for (int y2 = 0; y2 < filter.Length; ++y2) {  				if (YCurrent + y < Height && YCurrent + y >= 0) {  					var Pixel = GetPixel (XCurrent + x' YCurrent + y);  					RValue += filter [x2] [y2] * Pixel.R;  					GValue += filter [x2] [y2] * Pixel.G;  					BValue += filter [x2] [y2] * Pixel.B;  					Weight += filter [x2] [y2];  				}  				++YCurrent;  			}  		}  		++XCurrent;  	}  	var MeanPixel = GetPixel (x' y);  	if (Weight == 0)  		Weight = 1;  	if (Weight > 0) {  		if (absolute) {  			RValue = System.Math.Abs (RValue);  			GValue = System.Math.Abs (GValue);  			BValue = System.Math.Abs (BValue);  		}  		RValue = (RValue / Weight) + offset;  		RValue = RValue.Clamp (255' 0);  		GValue = (GValue / Weight) + offset;  		GValue = GValue.Clamp (255' 0);  		BValue = (BValue / Weight) + offset;  		BValue = BValue.Clamp (255' 0);  		MeanPixel = Color.FromArgb (RValue' GValue' BValue);  	}  	Result.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	int RValue = 0;  	int GValue = 0;  	int BValue = 0;  	int Weight = 0;  	int XCurrent = -filter [0].Length / 2;  	for (int x2 = 0; x2 < filter [0].Length; ++x2) {  		if (XCurrent + x < Width && XCurrent + x >= 0) {  			int YCurrent = -filter.Length / 2;  			for (int y2 = 0; y2 < filter.Length; ++y2) {  				if (YCurrent + y < Height && YCurrent + y >= 0) {  					var Pixel = GetPixel (XCurrent + x' YCurrent + y);  					RValue += filter [x2] [y2] * Pixel.R;  					GValue += filter [x2] [y2] * Pixel.G;  					BValue += filter [x2] [y2] * Pixel.B;  					Weight += filter [x2] [y2];  				}  				++YCurrent;  			}  		}  		++XCurrent;  	}  	var MeanPixel = GetPixel (x' y);  	if (Weight == 0)  		Weight = 1;  	if (Weight > 0) {  		if (absolute) {  			RValue = System.Math.Abs (RValue);  			GValue = System.Math.Abs (GValue);  			BValue = System.Math.Abs (BValue);  		}  		RValue = (RValue / Weight) + offset;  		RValue = RValue.Clamp (255' 0);  		GValue = (GValue / Weight) + offset;  		GValue = GValue.Clamp (255' 0);  		BValue = (BValue / Weight) + offset;  		BValue = BValue.Clamp (255' 0);  		MeanPixel = Color.FromArgb (RValue' GValue' BValue);  	}  	Result.SetPixel (x' y' MeanPixel);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: for (int x2 = 0; x2 < filter [0].Length; ++x2) {  	if (XCurrent + x < Width && XCurrent + x >= 0) {  		int YCurrent = -filter.Length / 2;  		for (int y2 = 0; y2 < filter.Length; ++y2) {  			if (YCurrent + y < Height && YCurrent + y >= 0) {  				var Pixel = GetPixel (XCurrent + x' YCurrent + y);  				RValue += filter [x2] [y2] * Pixel.R;  				GValue += filter [x2] [y2] * Pixel.G;  				BValue += filter [x2] [y2] * Pixel.B;  				Weight += filter [x2] [y2];  			}  			++YCurrent;  		}  	}  	++XCurrent;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: if (XCurrent + x < Width && XCurrent + x >= 0) {  	int YCurrent = -filter.Length / 2;  	for (int y2 = 0; y2 < filter.Length; ++y2) {  		if (YCurrent + y < Height && YCurrent + y >= 0) {  			var Pixel = GetPixel (XCurrent + x' YCurrent + y);  			RValue += filter [x2] [y2] * Pixel.R;  			GValue += filter [x2] [y2] * Pixel.G;  			BValue += filter [x2] [y2] * Pixel.B;  			Weight += filter [x2] [y2];  		}  		++YCurrent;  	}  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: if (Weight > 0) {  	if (absolute) {  		RValue = System.Math.Abs (RValue);  		GValue = System.Math.Abs (GValue);  		BValue = System.Math.Abs (BValue);  	}  	RValue = (RValue / Weight) + offset;  	RValue = RValue.Clamp (255' 0);  	GValue = (GValue / Weight) + offset;  	GValue = GValue.Clamp (255' 0);  	BValue = (BValue / Weight) + offset;  	BValue = BValue.Clamp (255' 0);  	MeanPixel = Color.FromArgb (RValue' GValue' BValue);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: if (Weight > 0) {  	if (absolute) {  		RValue = System.Math.Abs (RValue);  		GValue = System.Math.Abs (GValue);  		BValue = System.Math.Abs (BValue);  	}  	RValue = (RValue / Weight) + offset;  	RValue = RValue.Clamp (255' 0);  	GValue = (GValue / Weight) + offset;  	GValue = GValue.Clamp (255' 0);  	BValue = (BValue / Weight) + offset;  	BValue = BValue.Clamp (255' 0);  	MeanPixel = Color.FromArgb (RValue' GValue' BValue);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: if (Weight > 0) {  	if (absolute) {  		RValue = System.Math.Abs (RValue);  		GValue = System.Math.Abs (GValue);  		BValue = System.Math.Abs (BValue);  	}  	RValue = (RValue / Weight) + offset;  	RValue = RValue.Clamp (255' 0);  	GValue = (GValue / Weight) + offset;  	GValue = GValue.Clamp (255' 0);  	BValue = (BValue / Weight) + offset;  	BValue = BValue.Clamp (255' 0);  	MeanPixel = Color.FromArgb (RValue' GValue' BValue);  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: RValue = RValue.Clamp (255' 0);  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: GValue = GValue.Clamp (255' 0);  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: BValue = BValue.Clamp (255' 0);  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ? Color.FromArgb (TempPointer [2]' TempPointer [1]' TempPointer [0]) : Color.FromArgb (TempPointer [3]' TempPointer [2]' TempPointer [1]' TempPointer [0]);  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ? Color.FromArgb (TempPointer [2]' TempPointer [1]' TempPointer [0]) : Color.FromArgb (TempPointer [3]' TempPointer [2]' TempPointer [1]' TempPointer [0]);  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ? Color.FromArgb (TempPointer [2]' TempPointer [1]' TempPointer [0]) : Color.FromArgb (TempPointer [3]' TempPointer [2]' TempPointer [1]' TempPointer [0]);  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ? Color.FromArgb (TempPointer [2]' TempPointer [1]' TempPointer [0]) : Color.FromArgb (TempPointer [3]' TempPointer [2]' TempPointer [1]' TempPointer [0]);  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ? Color.FromArgb (TempPointer [2]' TempPointer [1]' TempPointer [0]) : Color.FromArgb (TempPointer [3]' TempPointer [2]' TempPointer [1]' TempPointer [0]);  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ? Color.FromArgb (TempPointer [2]' TempPointer [1]' TempPointer [0]) : Color.FromArgb (TempPointer [3]' TempPointer [2]' TempPointer [1]' TempPointer [0]);  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ? Color.FromArgb (TempPointer [2]' TempPointer [1]' TempPointer [0]) : Color.FromArgb (TempPointer [3]' TempPointer [2]' TempPointer [1]' TempPointer [0]);  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ? Color.FromArgb (TempPointer [2]' TempPointer [1]' TempPointer [0]) : Color.FromArgb (TempPointer [3]' TempPointer [2]' TempPointer [1]' TempPointer [0]);  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixel,The following statement contains a magic number: if (PixelSize == 3) {  	TempPointer [2] = pixelColor.R;  	TempPointer [1] = pixelColor.G;  	TempPointer [0] = pixelColor.B;  	return this;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixel,The following statement contains a magic number: if (PixelSize == 3) {  	TempPointer [2] = pixelColor.R;  	TempPointer [1] = pixelColor.G;  	TempPointer [0] = pixelColor.B;  	return this;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixel,The following statement contains a magic number: TempPointer [2] = pixelColor.R;  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixel,The following statement contains a magic number: TempPointer [3] = pixelColor.A;  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixel,The following statement contains a magic number: TempPointer [2] = pixelColor.R;  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: for (int z = 0; z < pixels.Length; ++z) {  	if (PixelSize == 3) {  		TempPointer [2] = pixels [z].R;  		TempPointer [1] = pixels [z].G;  		TempPointer [0] = pixels [z].B;  	} else {  		TempPointer [3] = pixels [z].A;  		TempPointer [2] = pixels [z].R;  		TempPointer [1] = pixels [z].G;  		TempPointer [0] = pixels [z].B;  	}  	TempPointer += PixelSize;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: for (int z = 0; z < pixels.Length; ++z) {  	if (PixelSize == 3) {  		TempPointer [2] = pixels [z].R;  		TempPointer [1] = pixels [z].G;  		TempPointer [0] = pixels [z].B;  	} else {  		TempPointer [3] = pixels [z].A;  		TempPointer [2] = pixels [z].R;  		TempPointer [1] = pixels [z].G;  		TempPointer [0] = pixels [z].B;  	}  	TempPointer += PixelSize;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: for (int z = 0; z < pixels.Length; ++z) {  	if (PixelSize == 3) {  		TempPointer [2] = pixels [z].R;  		TempPointer [1] = pixels [z].G;  		TempPointer [0] = pixels [z].B;  	} else {  		TempPointer [3] = pixels [z].A;  		TempPointer [2] = pixels [z].R;  		TempPointer [1] = pixels [z].G;  		TempPointer [0] = pixels [z].B;  	}  	TempPointer += PixelSize;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: for (int z = 0; z < pixels.Length; ++z) {  	if (PixelSize == 3) {  		TempPointer [2] = pixels [z].R;  		TempPointer [1] = pixels [z].G;  		TempPointer [0] = pixels [z].B;  	} else {  		TempPointer [3] = pixels [z].A;  		TempPointer [2] = pixels [z].R;  		TempPointer [1] = pixels [z].G;  		TempPointer [0] = pixels [z].B;  	}  	TempPointer += PixelSize;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: if (PixelSize == 3) {  	TempPointer [2] = pixels [z].R;  	TempPointer [1] = pixels [z].G;  	TempPointer [0] = pixels [z].B;  } else {  	TempPointer [3] = pixels [z].A;  	TempPointer [2] = pixels [z].R;  	TempPointer [1] = pixels [z].G;  	TempPointer [0] = pixels [z].B;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: if (PixelSize == 3) {  	TempPointer [2] = pixels [z].R;  	TempPointer [1] = pixels [z].G;  	TempPointer [0] = pixels [z].B;  } else {  	TempPointer [3] = pixels [z].A;  	TempPointer [2] = pixels [z].R;  	TempPointer [1] = pixels [z].G;  	TempPointer [0] = pixels [z].B;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: if (PixelSize == 3) {  	TempPointer [2] = pixels [z].R;  	TempPointer [1] = pixels [z].G;  	TempPointer [0] = pixels [z].B;  } else {  	TempPointer [3] = pixels [z].A;  	TempPointer [2] = pixels [z].R;  	TempPointer [1] = pixels [z].G;  	TempPointer [0] = pixels [z].B;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: if (PixelSize == 3) {  	TempPointer [2] = pixels [z].R;  	TempPointer [1] = pixels [z].G;  	TempPointer [0] = pixels [z].B;  } else {  	TempPointer [3] = pixels [z].A;  	TempPointer [2] = pixels [z].R;  	TempPointer [1] = pixels [z].G;  	TempPointer [0] = pixels [z].B;  }  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: TempPointer [2] = pixels [z].R;  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: TempPointer [3] = pixels [z].A;  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: TempPointer [2] = pixels [z].R;  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixelSize,The following statement contains a magic number: if (Data.PixelFormat == PixelFormat.Format24bppRgb)  	return 3;  else if (Data.PixelFormat == PixelFormat.Format32bppArgb || Data.PixelFormat == PixelFormat.Format32bppPArgb || Data.PixelFormat == PixelFormat.Format32bppRgb)  	return 4;  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixelSize,The following statement contains a magic number: if (Data.PixelFormat == PixelFormat.Format24bppRgb)  	return 3;  else if (Data.PixelFormat == PixelFormat.Format32bppArgb || Data.PixelFormat == PixelFormat.Format32bppPArgb || Data.PixelFormat == PixelFormat.Format32bppRgb)  	return 4;  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixelSize,The following statement contains a magic number: return 3;  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixelSize,The following statement contains a magic number: if (Data.PixelFormat == PixelFormat.Format32bppArgb || Data.PixelFormat == PixelFormat.Format32bppPArgb || Data.PixelFormat == PixelFormat.Format32bppRgb)  	return 4;  
Magic Number,Utilities.Media,SwiftBitmap,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixelSize,The following statement contains a magic number: return 4;  
Magic Number,Utilities.Media.Procedural,CellularTexture,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\CellularTexture.cs,Generate,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	for (int y = 0; y < Height; ++y) {  		var Value = GetHeight (x' y' DistanceBuffer' MinimumDistance' MaxDistance);  		Value *= 255;  		var RGBValue = ((int)Value).Clamp (255' 0);  		ReturnValue.SetPixel (x' y' Color.FromArgb (RGBValue' RGBValue' RGBValue));  	}  }  
Magic Number,Utilities.Media.Procedural,CellularTexture,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\CellularTexture.cs,Generate,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	for (int y = 0; y < Height; ++y) {  		var Value = GetHeight (x' y' DistanceBuffer' MinimumDistance' MaxDistance);  		Value *= 255;  		var RGBValue = ((int)Value).Clamp (255' 0);  		ReturnValue.SetPixel (x' y' Color.FromArgb (RGBValue' RGBValue' RGBValue));  	}  }  
Magic Number,Utilities.Media.Procedural,CellularTexture,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\CellularTexture.cs,Generate,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	var Value = GetHeight (x' y' DistanceBuffer' MinimumDistance' MaxDistance);  	Value *= 255;  	var RGBValue = ((int)Value).Clamp (255' 0);  	ReturnValue.SetPixel (x' y' Color.FromArgb (RGBValue' RGBValue' RGBValue));  }  
Magic Number,Utilities.Media.Procedural,CellularTexture,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\CellularTexture.cs,Generate,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	var Value = GetHeight (x' y' DistanceBuffer' MinimumDistance' MaxDistance);  	Value *= 255;  	var RGBValue = ((int)Value).Clamp (255' 0);  	ReturnValue.SetPixel (x' y' Color.FromArgb (RGBValue' RGBValue' RGBValue));  }  
Magic Number,Utilities.Media.Procedural,CellularTexture,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\CellularTexture.cs,Generate,The following statement contains a magic number: Value *= 255;  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,Generate,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	for (int y = 0; y < Height; ++y) {  		float Value = Heights [x' y];  		Value = (Value * 0.5f) + 0.5f;  		Value *= 255;  		var RGBValue = ((int)Value).Clamp (255' 0);  		ReturnValue.SetPixel (x' y' Color.FromArgb (RGBValue' RGBValue' RGBValue));  	}  }  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,Generate,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	for (int y = 0; y < Height; ++y) {  		float Value = Heights [x' y];  		Value = (Value * 0.5f) + 0.5f;  		Value *= 255;  		var RGBValue = ((int)Value).Clamp (255' 0);  		ReturnValue.SetPixel (x' y' Color.FromArgb (RGBValue' RGBValue' RGBValue));  	}  }  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,Generate,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	float Value = Heights [x' y];  	Value = (Value * 0.5f) + 0.5f;  	Value *= 255;  	var RGBValue = ((int)Value).Clamp (255' 0);  	ReturnValue.SetPixel (x' y' Color.FromArgb (RGBValue' RGBValue' RGBValue));  }  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,Generate,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	float Value = Heights [x' y];  	Value = (Value * 0.5f) + 0.5f;  	Value *= 255;  	var RGBValue = ((int)Value).Clamp (255' 0);  	ReturnValue.SetPixel (x' y' Color.FromArgb (RGBValue' RGBValue' RGBValue));  }  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,Generate,The following statement contains a magic number: Value *= 255;  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: while (Wall == Wall2) {  	Wall = Generator.Next (4);  	Wall2 = Generator.Next (4);  }  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: while (Wall == Wall2) {  	Wall = Generator.Next (4);  	Wall2 = Generator.Next (4);  }  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: Wall = Generator.Next (4);  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: Wall2 = Generator.Next (4);  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: while (X1 == X2 || Y1 == Y2) {  	switch (Wall) {  	case 0:  		X1 = Generator.Next (Width);  		Y1 = 0;  		break;  	case 1:  		Y1 = Generator.Next (Height);  		X1 = Width;  		break;  	case 2:  		X1 = Generator.Next (Width);  		Y1 = Height;  		break;  	default:  		X1 = 0;  		Y1 = Generator.Next (Height);  		break;  	}  	switch (Wall2) {  	case 0:  		X2 = Generator.Next (Width);  		Y2 = 0;  		break;  	case 1:  		Y2 = Generator.Next (Height);  		X2 = Width;  		break;  	case 2:  		X2 = Generator.Next (Width);  		Y2 = Height;  		break;  	default:  		X2 = 0;  		Y2 = Generator.Next (Height);  		break;  	}  }  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: while (X1 == X2 || Y1 == Y2) {  	switch (Wall) {  	case 0:  		X1 = Generator.Next (Width);  		Y1 = 0;  		break;  	case 1:  		Y1 = Generator.Next (Height);  		X1 = Width;  		break;  	case 2:  		X1 = Generator.Next (Width);  		Y1 = Height;  		break;  	default:  		X1 = 0;  		Y1 = Generator.Next (Height);  		break;  	}  	switch (Wall2) {  	case 0:  		X2 = Generator.Next (Width);  		Y2 = 0;  		break;  	case 1:  		Y2 = Generator.Next (Height);  		X2 = Width;  		break;  	case 2:  		X2 = Generator.Next (Width);  		Y2 = Height;  		break;  	default:  		X2 = 0;  		Y2 = Generator.Next (Height);  		break;  	}  }  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: switch (Wall) {  case 0:  	X1 = Generator.Next (Width);  	Y1 = 0;  	break;  case 1:  	Y1 = Generator.Next (Height);  	X1 = Width;  	break;  case 2:  	X1 = Generator.Next (Width);  	Y1 = Height;  	break;  default:  	X1 = 0;  	Y1 = Generator.Next (Height);  	break;  }  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: switch (Wall2) {  case 0:  	X2 = Generator.Next (Width);  	Y2 = 0;  	break;  case 1:  	Y2 = Generator.Next (Height);  	X2 = Width;  	break;  case 2:  	X2 = Generator.Next (Width);  	Y2 = Height;  	break;  default:  	X2 = 0;  	Y2 = Generator.Next (Height);  	break;  }  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: while (Direction == 0)  	Direction = Generator.Next (-1' 2);  
Magic Number,Utilities.Media.Procedural,FaultFormation,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: Direction = Generator.Next (-1' 2);  
Magic Number,Utilities.Media.Procedural,PerlinNoise,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,Generate,The following statement contains a magic number: for (int x = 0; x < Width; ++x) {  	for (int y = 0; y < Height; ++y) {  		var Value = GetValue (x' y' Width' Height' Frequency' Amplitude' Persistance' Octaves' Noise);  		Value = (Value * 0.5f) + 0.5f;  		Value *= 255;  		var RGBValue = ((int)Value).Clamp (MaxRGBValue' MinRGBValue);  		ReturnValue.SetPixel (x' y' Color.FromArgb (RGBValue' RGBValue' RGBValue));  	}  }  
Magic Number,Utilities.Media.Procedural,PerlinNoise,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,Generate,The following statement contains a magic number: for (int y = 0; y < Height; ++y) {  	var Value = GetValue (x' y' Width' Height' Frequency' Amplitude' Persistance' Octaves' Noise);  	Value = (Value * 0.5f) + 0.5f;  	Value *= 255;  	var RGBValue = ((int)Value).Clamp (MaxRGBValue' MinRGBValue);  	ReturnValue.SetPixel (x' y' Color.FromArgb (RGBValue' RGBValue' RGBValue));  }  
Magic Number,Utilities.Media.Procedural,PerlinNoise,F:\newReposMay17\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,Generate,The following statement contains a magic number: Value *= 255;  
