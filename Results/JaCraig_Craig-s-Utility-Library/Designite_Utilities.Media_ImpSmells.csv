Implementation smell,Namespace,Class,File,Method,Description
Long Method,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The method has 100 lines of code.
Complex Method,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,GetMinMaxPixel,Cyclomatic complexity of the method is 9
Complex Method,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,Cyclomatic complexity of the method is 12
Complex Method,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,Cyclomatic complexity of the method is 22
Long Parameter List,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The method has 7 parameters. Parameters: Image' BoxColor' XPosition' YPosition' Height' Width' CornerRadius
Long Parameter List,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SinWave,The method has 5 parameters. Parameters: OriginalImage' Amplitude' Frequency' XDirection' YDirection
Long Parameter List,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Watermark,The method has 6 parameters. Parameters: Image' WatermarkImage' Opacity' X' Y' KeyColor
Long Parameter List,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Distance,The method has 6 parameters. Parameters: R1' R2' G1' G2' B1' B2
Long Parameter List,Utilities.Media.Procedural,CellularTexture,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\CellularTexture.cs,GetHeight,The method has 5 parameters. Parameters: X' Y' DistanceBuffer' MinimumDistance' MaxDistance
Long Parameter List,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The method has 6 parameters. Parameters: Width' Height' NumberFaults' Heights' IncreaseVal' Generator
Long Parameter List,Utilities.Media.Procedural,MidpointDisplacement,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\MidpointDisplacement.cs,Generate,The method has 7 parameters. Parameters: Width' Height' NumberOfCracks' Iterations' MaxChange' MaxLength' Seed
Long Parameter List,Utilities.Media.Procedural,MidpointDisplacement,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\MidpointDisplacement.cs,GenerateLines,The method has 7 parameters. Parameters: Width' Height' NumberOfCracks' Iterations' MaxChange' MaxLength' Seed
Long Parameter List,Utilities.Media.Procedural,PerlinNoise,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,Generate,The method has 9 parameters. Parameters: Width' Height' MaxRGBValue' MinRGBValue' Frequency' Amplitude' Persistance' Octaves' Seed
Long Parameter List,Utilities.Media.Procedural,PerlinNoise,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,GetSmoothNoise,The method has 5 parameters. Parameters: X' Y' Width' Height' Noise
Long Parameter List,Utilities.Media.Procedural,PerlinNoise,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,GetValue,The method has 9 parameters. Parameters: X' Y' Width' Height' Frequency' Amplitude' Persistance' Octaves' Noise
Long Statement,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The length of the statement  "                    Path.AddArc(XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90); " is 136.
Long Statement,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,LaplaceEdgeDetection,The length of the statement  "                            new int[] {-1' -1' -1' -1' -1}'                            new int[] {-1' -1' -1' -1' -1}'                            new int[] {-1' -1' 24' -1' -1}'                            new int[] {-1' -1' -1' -1' -1}'                            new int[] {-1' -1' -1' -1' -1}                        }); " is 293.
Long Statement,Utilities.Media,ScreenExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,The length of the statement  "            var TempSwiftBitmap = new Bitmap(Screen.Bounds.Width > 1 ? Screen.Bounds.Width : 1' Screen.Bounds.Height > 1 ? Screen.Bounds.Height : 1' PixelFormat.Format32bppArgb); " is 166.
Long Statement,Utilities.Media,ScreenExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,The length of the statement  "            var TempSwiftBitmap = new Bitmap(TotalScreenRect.Width > 1 ? TotalScreenRect.Width : 1' TotalScreenRect.Height > 1 ? TotalScreenRect.Width : 1' PixelFormat.Format32bppArgb); " is 173.
Long Statement,Utilities.Media,ScreenExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,The length of the statement  "                        TempGraphics.CopyFromScreen(TotalScreenRect.X' TotalScreenRect.Y' 0' 0' TotalScreenRect.Size' CopyPixelOperation.SourceCopy); " is 125.
Long Statement,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetImageFormat,The length of the statement  "            if (fileName.EndsWith("jpg"' StringComparison.InvariantCultureIgnoreCase) || fileName.EndsWith("jpeg"' StringComparison.InvariantCultureIgnoreCase)) " is 148.
Long Statement,Utilities.Media.Procedural,CellularMap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\CellularMap.cs,FindClosestPoint,The length of the statement  "                var Distance = (float)System.Math.Sqrt(((Points[z].X - x) * (Points[z].X - x)) + ((Points[z].Y - y) * (Points[z].Y - y)));" is 122.
Complex Conditional,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The conditional expression  "TempX1 >= 0 && TempX1 < Width && TempX2 >= 0 && TempX2 < Width"  is complex.
Complex Conditional,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The conditional expression  "TempY1 >= 0 && TempY1 < Height && TempY2 >= 0 && TempY2 < Height"  is complex.
Virtual Method Call from Constructor,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,RGBHistogram,The constructor "RGBHistogram" calls a virtual method "LoadImage".
Empty Catch Block,Utilities.Media,ScreenExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,The method has an empty catch block.
Empty Catch Block,Utilities.Media,ScreenExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\ScreenExtensions.cs,TakeScreenShot,The method has an empty catch block.
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AddNoise,The following statement contains a magic number: Parallel.For(0' Image.Width' x =>              {                  for (int y = 0; y < Image.Height; ++y)                  {                      var CurrentPixel = Image.GetPixel(x' y);                      int R = CurrentPixel.R + Random.Random.ThreadSafeNext(-Amount' Amount + 1);                      int G = CurrentPixel.G + Random.Random.ThreadSafeNext(-Amount' Amount + 1);                      int B = CurrentPixel.B + Random.Random.ThreadSafeNext(-Amount' Amount + 1);                      var TempValue = Color.FromArgb(R.Clamp(255' 0)' G.Clamp(255' 0)' B.Clamp(255' 0));                      Image.SetPixel(x' y' TempValue);                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AddNoise,The following statement contains a magic number: Parallel.For(0' Image.Width' x =>              {                  for (int y = 0; y < Image.Height; ++y)                  {                      var CurrentPixel = Image.GetPixel(x' y);                      int R = CurrentPixel.R + Random.Random.ThreadSafeNext(-Amount' Amount + 1);                      int G = CurrentPixel.G + Random.Random.ThreadSafeNext(-Amount' Amount + 1);                      int B = CurrentPixel.B + Random.Random.ThreadSafeNext(-Amount' Amount + 1);                      var TempValue = Color.FromArgb(R.Clamp(255' 0)' G.Clamp(255' 0)' B.Clamp(255' 0));                      Image.SetPixel(x' y' TempValue);                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AddNoise,The following statement contains a magic number: Parallel.For(0' Image.Width' x =>              {                  for (int y = 0; y < Image.Height; ++y)                  {                      var CurrentPixel = Image.GetPixel(x' y);                      int R = CurrentPixel.R + Random.Random.ThreadSafeNext(-Amount' Amount + 1);                      int G = CurrentPixel.G + Random.Random.ThreadSafeNext(-Amount' Amount + 1);                      int B = CurrentPixel.B + Random.Random.ThreadSafeNext(-Amount' Amount + 1);                      var TempValue = Color.FromArgb(R.Clamp(255' 0)' G.Clamp(255' 0)' B.Clamp(255' 0));                      Image.SetPixel(x' y' TempValue);                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustBrightness,The following statement contains a magic number: float FinalValue = (float)Value / 255.0f;
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Value = (100.0f + Value) / 100.0f;
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Value = (100.0f + Value) / 100.0f;
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustContrast,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>              {                  for (int y = 0; y < OriginalImage.Height; ++y)                  {                      var Pixel = OriginalImage.GetPixel(x' y);                      float Red = Pixel.R / 255.0f;                      float Green = Pixel.G / 255.0f;                      float Blue = Pixel.B / 255.0f;                      Red = (((Red - 0.5f) * Value) + 0.5f) * 255.0f;                      Green = (((Green - 0.5f) * Value) + 0.5f) * 255.0f;                      Blue = (((Blue - 0.5f) * Value) + 0.5f) * 255.0f;                      OriginalImage.SetPixel(x' y'                          Color.FromArgb(((int)Red).Clamp(255' 0)'                          ((int)Green).Clamp(255' 0)'                          ((int)Blue).Clamp(255' 0)));                  }              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: int[] Ramp = new int[256];
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Parallel.For(0' 256' x =>              {                  Ramp[x] = ((int)((255.0 * System.Math.Pow(x / 255.0' 1.0 / Value)) + 0.5)).Clamp(255' 0);              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Parallel.For(0' 256' x =>              {                  Ramp[x] = ((int)((255.0 * System.Math.Pow(x / 255.0' 1.0 / Value)) + 0.5)).Clamp(255' 0);              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Parallel.For(0' 256' x =>              {                  Ramp[x] = ((int)((255.0 * System.Math.Pow(x / 255.0' 1.0 / Value)) + 0.5)).Clamp(255' 0);              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Parallel.For(0' 256' x =>              {                  Ramp[x] = ((int)((255.0 * System.Math.Pow(x / 255.0' 1.0 / Value)) + 0.5)).Clamp(255' 0);              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,AdjustGamma,The following statement contains a magic number: Parallel.For(0' 256' x =>              {                  Ramp[x] = ((int)((255.0 * System.Math.Pow(x / 255.0' 1.0 / Value)) + 0.5)).Clamp(255' 0);              });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BlackAndWhite,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.3f' .3f' .3f' 0' 0}'                              new float[] {.59f' .59f' .59f' 0' 0}'                              new float[] {.11f' .11f' .11f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BlackAndWhite,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.3f' .3f' .3f' 0' 0}'                              new float[] {.59f' .59f' .59f' 0' 0}'                              new float[] {.11f' .11f' .11f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BlackAndWhite,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.3f' .3f' .3f' 0' 0}'                              new float[] {.59f' .59f' .59f' 0' 0}'                              new float[] {.11f' .11f' .11f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BlackAndWhite,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.3f' .3f' .3f' 0' 0}'                              new float[] {.59f' .59f' .59f' 0' 0}'                              new float[] {.11f' .11f' .11f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BlackAndWhite,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.3f' .3f' .3f' 0' 0}'                              new float[] {.59f' .59f' .59f' 0' 0}'                              new float[] {.11f' .11f' .11f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BlackAndWhite,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.3f' .3f' .3f' 0' 0}'                              new float[] {.59f' .59f' .59f' 0' 0}'                              new float[] {.11f' .11f' .11f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BlackAndWhite,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.3f' .3f' .3f' 0' 0}'                              new float[] {.59f' .59f' .59f' 0' 0}'                              new float[] {.11f' .11f' .11f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BlackAndWhite,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.3f' .3f' .3f' 0' 0}'                              new float[] {.59f' .59f' .59f' 0' 0}'                              new float[] {.11f' .11f' .11f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BlackAndWhite,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.3f' .3f' .3f' 0' 0}'                              new float[] {.59f' .59f' .59f' 0' 0}'                              new float[] {.11f' .11f' .11f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: EdgeDetectionFilter = new int[][]{                              new int[] {1' 2' 1}'                              new int[] {0' 0' 0}'                              new int[] {-1' -2' -1}                          };
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: EdgeDetectionFilter = new int[][]{                              new int[] {1' 2' 1}'                              new int[] {0' 0' 0}'                              new int[] {-1' -2' -1}                          };
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,BumpMap,The following statement contains a magic number: return Image.ApplyConvolutionFilter(EdgeDetectionFilter' false' 127).BlackAndWhite();
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Colorize,The following statement contains a magic number: Colors.Length < 256
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Dilate,The following statement contains a magic number: int ApetureMin = -(Size / 2);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Dilate,The following statement contains a magic number: int ApetureMax = (Size / 2);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddLine(XPosition + CornerRadius' YPosition' XPosition + Width - (CornerRadius * 2)' YPosition);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition + Width - (CornerRadius * 2)' YPosition' CornerRadius * 2' CornerRadius * 2' 270' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddLine(XPosition + Width' YPosition + CornerRadius' XPosition + Width' YPosition + Height - (CornerRadius * 2));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition + Width - (CornerRadius * 2)' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 0' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddLine(XPosition + Width - (CornerRadius * 2)' YPosition + Height' XPosition + CornerRadius' YPosition + Height);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition' YPosition + Height - (CornerRadius * 2)' CornerRadius * 2' CornerRadius * 2' 90' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddLine(XPosition' YPosition + Height - (CornerRadius * 2)' XPosition' YPosition + CornerRadius);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,DrawRoundedRectangle,The following statement contains a magic number: Path.AddArc(XPosition' YPosition' CornerRadius * 2' CornerRadius * 2' 180' 90);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Emboss,The following statement contains a magic number: return Image.ApplyConvolutionFilter(new int[][]{                              new int[] {-2' -1' 0}'                              new int[] {-1' 1'  1}'                              new int[] {0'  1'  2}                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Emboss,The following statement contains a magic number: return Image.ApplyConvolutionFilter(new int[][]{                              new int[] {-2' -1' 0}'                              new int[] {-1' 1'  1}'                              new int[] {0'  1'  2}                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>                  {                      for (int y = 0; y < OriginalImage.Height; ++y)                      {                          var Current = OriginalImage.GetPixel(x' y);                          var NewR = (int)TempHistogram.R[Current.R];                          var NewG = (int)TempHistogram.G[Current.G];                          var NewB = (int)TempHistogram.B[Current.B];                          NewR = NewR.Clamp(255' 0);                          NewG = NewG.Clamp(255' 0);                          NewB = NewB.Clamp(255' 0);                          NewSwiftBitmap.SetPixel(x' y' Color.FromArgb(NewR' NewG' NewB));                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>                  {                      for (int y = 0; y < OriginalImage.Height; ++y)                      {                          var Current = OriginalImage.GetPixel(x' y);                          var NewR = (int)TempHistogram.R[Current.R];                          var NewG = (int)TempHistogram.G[Current.G];                          var NewB = (int)TempHistogram.B[Current.B];                          NewR = NewR.Clamp(255' 0);                          NewG = NewG.Clamp(255' 0);                          NewB = NewB.Clamp(255' 0);                          NewSwiftBitmap.SetPixel(x' y' Color.FromArgb(NewR' NewG' NewB));                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Equalize,The following statement contains a magic number: Parallel.For(0' OriginalImage.Width' x =>                  {                      for (int y = 0; y < OriginalImage.Height; ++y)                      {                          var Current = OriginalImage.GetPixel(x' y);                          var NewR = (int)TempHistogram.R[Current.R];                          var NewG = (int)TempHistogram.G[Current.G];                          var NewB = (int)TempHistogram.B[Current.B];                          NewR = NewR.Clamp(255' 0);                          NewG = NewG.Clamp(255' 0);                          NewB = NewB.Clamp(255' 0);                          NewSwiftBitmap.SetPixel(x' y' Color.FromArgb(NewR' NewG' NewB));                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: int[] ApetureMinX = { -(Size / 2)' 0' -(Size / 2)' 0 };
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: int[] ApetureMinX = { -(Size / 2)' 0' -(Size / 2)' 0 };
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: int[] ApetureMaxX = { 0' (Size / 2)' 0' (Size / 2) };
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: int[] ApetureMaxX = { 0' (Size / 2)' 0' (Size / 2) };
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: int[] ApetureMinY = { -(Size / 2)' -(Size / 2)' 0' 0 };
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: int[] ApetureMinY = { -(Size / 2)' -(Size / 2)' 0' 0 };
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: int[] ApetureMaxY = { 0' 0' (Size / 2)' (Size / 2) };
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: int[] ApetureMaxY = { 0' 0' (Size / 2)' (Size / 2) };
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,KuwaharaBlur,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int[] RValues = { 0' 0' 0' 0 };                          int[] GValues = { 0' 0' 0' 0 };                          int[] BValues = { 0' 0' 0' 0 };                          int[] NumPixels = { 0' 0' 0' 0 };                          int[] MaxRValue = { 0' 0' 0' 0 };                          int[] MaxGValue = { 0' 0' 0' 0 };                          int[] MaxBValue = { 0' 0' 0' 0 };                          int[] MinRValue = { 255' 255' 255' 255 };                          int[] MinGValue = { 255' 255' 255' 255 };                          int[] MinBValue = { 255' 255' 255' 255 };                          for (int i = 0; i < 4; ++i)                          {                              for (int x2 = ApetureMinX[i]; x2 < ApetureMaxX[i]; ++x2)                              {                                  int TempX = x + x2;                                  if (TempX >= 0 && TempX < Width)                                  {                                      for (int y2 = ApetureMinY[i]; y2 < ApetureMaxY[i]; ++y2)                                      {                                          int TempY = y + y2;                                          if (TempY >= 0 && TempY < Height)                                          {                                              var TempColor = OriginalImage.GetPixel(TempX' TempY);                                              RValues[i] += TempColor.R;                                              GValues[i] += TempColor.G;                                              BValues[i] += TempColor.B;                                              if (TempColor.R > MaxRValue[i])                                                  MaxRValue[i] = TempColor.R;                                              else if (TempColor.R < MinRValue[i])                                                  MinRValue[i] = TempColor.R;                                                if (TempColor.G > MaxGValue[i])                                                  MaxGValue[i] = TempColor.G;                                              else if (TempColor.G < MinGValue[i])                                                  MinGValue[i] = TempColor.G;                                                if (TempColor.B > MaxBValue[i])                                                  MaxBValue[i] = TempColor.B;                                              else if (TempColor.B < MinBValue[i])                                                  MinBValue[i] = TempColor.B;                                                ++NumPixels[i];                                          }                                      }                                  }                              }                          }                          int j = 0;                          int MinDifference = 10000;                          for (int i = 0; i < 4; ++i)                          {                              int CurrentDifference = (MaxRValue[i] - MinRValue[i]) + (MaxGValue[i] - MinGValue[i]) + (MaxBValue[i] - MinBValue[i]);                              if (CurrentDifference < MinDifference && NumPixels[i] > 0)                              {                                  j = i;                                  MinDifference = CurrentDifference;                              }                          }                            var MeanPixel = Color.FromArgb(RValues[j] / NumPixels[j]'                              GValues[j] / NumPixels[j]'                              BValues[j] / NumPixels[j]);                          NewSwiftBitmap.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,LaplaceEdgeDetection,The following statement contains a magic number: return Image.BlackAndWhite().ApplyConvolutionFilter(new int[][]{                              new int[] {-1' -1' -1' -1' -1}'                            new int[] {-1' -1' -1' -1' -1}'                            new int[] {-1' -1' 24' -1' -1}'                            new int[] {-1' -1' -1' -1' -1}'                            new int[] {-1' -1' -1' -1' -1}                        });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,MedianFilter,The following statement contains a magic number: int ApetureMin = -(Size / 2);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,MedianFilter,The following statement contains a magic number: int ApetureMax = (Size / 2);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          var CurrentPixel = OriginalImage.GetPixel(x' y);                          var TempValue = Color.FromArgb(255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);                          NewSwiftBitmap.SetPixel(x' y' TempValue);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          var CurrentPixel = OriginalImage.GetPixel(x' y);                          var TempValue = Color.FromArgb(255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);                          NewSwiftBitmap.SetPixel(x' y' TempValue);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Negative,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          var CurrentPixel = OriginalImage.GetPixel(x' y);                          var TempValue = Color.FromArgb(255 - CurrentPixel.R' 255 - CurrentPixel.G' 255 - CurrentPixel.B);                          NewSwiftBitmap.SetPixel(x' y' TempValue);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For(0' Height' y =>                          {                              var TempVector = new Vector3(0.0' 0.0' 0.0);                              for (int x = 0; x < Width; ++x)                              {                                  var TempPixelX = TempImageX.GetPixel(x' y);                                  var TempPixelY = TempImageY.GetPixel(x' y);                                  TempVector.X = (double)(TempPixelX.R) / 255.0;                                  TempVector.Y = (double)(TempPixelY.R) / 255.0;                                  TempVector.Z = 1.0;                                  TempVector.Normalize();                                  TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;                                  TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;                                  TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;                                  ReturnImage.SetPixel(x' y'                                      Color.FromArgb((int)TempVector.X'                                          (int)TempVector.Y'                                          (int)TempVector.Z));                              }                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For(0' Height' y =>                          {                              var TempVector = new Vector3(0.0' 0.0' 0.0);                              for (int x = 0; x < Width; ++x)                              {                                  var TempPixelX = TempImageX.GetPixel(x' y);                                  var TempPixelY = TempImageY.GetPixel(x' y);                                  TempVector.X = (double)(TempPixelX.R) / 255.0;                                  TempVector.Y = (double)(TempPixelY.R) / 255.0;                                  TempVector.Z = 1.0;                                  TempVector.Normalize();                                  TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;                                  TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;                                  TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;                                  ReturnImage.SetPixel(x' y'                                      Color.FromArgb((int)TempVector.X'                                          (int)TempVector.Y'                                          (int)TempVector.Z));                              }                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For(0' Height' y =>                          {                              var TempVector = new Vector3(0.0' 0.0' 0.0);                              for (int x = 0; x < Width; ++x)                              {                                  var TempPixelX = TempImageX.GetPixel(x' y);                                  var TempPixelY = TempImageY.GetPixel(x' y);                                  TempVector.X = (double)(TempPixelX.R) / 255.0;                                  TempVector.Y = (double)(TempPixelY.R) / 255.0;                                  TempVector.Z = 1.0;                                  TempVector.Normalize();                                  TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;                                  TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;                                  TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;                                  ReturnImage.SetPixel(x' y'                                      Color.FromArgb((int)TempVector.X'                                          (int)TempVector.Y'                                          (int)TempVector.Z));                              }                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For(0' Height' y =>                          {                              var TempVector = new Vector3(0.0' 0.0' 0.0);                              for (int x = 0; x < Width; ++x)                              {                                  var TempPixelX = TempImageX.GetPixel(x' y);                                  var TempPixelY = TempImageY.GetPixel(x' y);                                  TempVector.X = (double)(TempPixelX.R) / 255.0;                                  TempVector.Y = (double)(TempPixelY.R) / 255.0;                                  TempVector.Z = 1.0;                                  TempVector.Normalize();                                  TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;                                  TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;                                  TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;                                  ReturnImage.SetPixel(x' y'                                      Color.FromArgb((int)TempVector.X'                                          (int)TempVector.Y'                                          (int)TempVector.Z));                              }                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For(0' Height' y =>                          {                              var TempVector = new Vector3(0.0' 0.0' 0.0);                              for (int x = 0; x < Width; ++x)                              {                                  var TempPixelX = TempImageX.GetPixel(x' y);                                  var TempPixelY = TempImageY.GetPixel(x' y);                                  TempVector.X = (double)(TempPixelX.R) / 255.0;                                  TempVector.Y = (double)(TempPixelY.R) / 255.0;                                  TempVector.Z = 1.0;                                  TempVector.Normalize();                                  TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;                                  TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;                                  TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;                                  ReturnImage.SetPixel(x' y'                                      Color.FromArgb((int)TempVector.X'                                          (int)TempVector.Y'                                          (int)TempVector.Z));                              }                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For(0' Height' y =>                          {                              var TempVector = new Vector3(0.0' 0.0' 0.0);                              for (int x = 0; x < Width; ++x)                              {                                  var TempPixelX = TempImageX.GetPixel(x' y);                                  var TempPixelY = TempImageY.GetPixel(x' y);                                  TempVector.X = (double)(TempPixelX.R) / 255.0;                                  TempVector.Y = (double)(TempPixelY.R) / 255.0;                                  TempVector.Z = 1.0;                                  TempVector.Normalize();                                  TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;                                  TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;                                  TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;                                  ReturnImage.SetPixel(x' y'                                      Color.FromArgb((int)TempVector.X'                                          (int)TempVector.Y'                                          (int)TempVector.Z));                              }                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For(0' Height' y =>                          {                              var TempVector = new Vector3(0.0' 0.0' 0.0);                              for (int x = 0; x < Width; ++x)                              {                                  var TempPixelX = TempImageX.GetPixel(x' y);                                  var TempPixelY = TempImageY.GetPixel(x' y);                                  TempVector.X = (double)(TempPixelX.R) / 255.0;                                  TempVector.Y = (double)(TempPixelY.R) / 255.0;                                  TempVector.Z = 1.0;                                  TempVector.Normalize();                                  TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;                                  TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;                                  TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;                                  ReturnImage.SetPixel(x' y'                                      Color.FromArgb((int)TempVector.X'                                          (int)TempVector.Y'                                          (int)TempVector.Z));                              }                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,NormalMap,The following statement contains a magic number: Parallel.For(0' Height' y =>                          {                              var TempVector = new Vector3(0.0' 0.0' 0.0);                              for (int x = 0; x < Width; ++x)                              {                                  var TempPixelX = TempImageX.GetPixel(x' y);                                  var TempPixelY = TempImageY.GetPixel(x' y);                                  TempVector.X = (double)(TempPixelX.R) / 255.0;                                  TempVector.Y = (double)(TempPixelY.R) / 255.0;                                  TempVector.Z = 1.0;                                  TempVector.Normalize();                                  TempVector.X = ((TempVector.X + 1.0) / 2.0) * 255.0;                                  TempVector.Y = ((TempVector.Y + 1.0) / 2.0) * 255.0;                                  TempVector.Z = ((TempVector.Z + 1.0) / 2.0) * 255.0;                                  ReturnImage.SetPixel(x' y'                                      Color.FromArgb((int)TempVector.X'                                          (int)TempVector.Y'                                          (int)TempVector.Z));                              }                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: var MinX = (x - (PixelSize / 2)).Clamp(NewSwiftBitmap.Width' 0);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: var MaxX = (x + (PixelSize / 2)).Clamp(NewSwiftBitmap.Width' 0);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: var MinY = (y - (PixelSize / 2)).Clamp(NewSwiftBitmap.Height' 0);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: var MaxY = (y + (PixelSize / 2)).Clamp(NewSwiftBitmap.Height' 0);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: var TempPixel = Color.FromArgb(RValue.Clamp(255' 0)' GValue.Clamp(255' 0)' BValue.Clamp(255' 0));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: var TempPixel = Color.FromArgb(RValue.Clamp(255' 0)' GValue.Clamp(255' 0)' BValue.Clamp(255' 0));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Pixelate,The following statement contains a magic number: var TempPixel = Color.FromArgb(RValue.Clamp(255' 0)' GValue.Clamp(255' 0)' BValue.Clamp(255' 0));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SepiaTone,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.393f' .349f' .272f' 0' 0}'                              new float[] {.769f' .686f' .534f' 0' 0}'                              new float[] {.189f' .168f' .131f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SepiaTone,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.393f' .349f' .272f' 0' 0}'                              new float[] {.769f' .686f' .534f' 0' 0}'                              new float[] {.189f' .168f' .131f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SepiaTone,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.393f' .349f' .272f' 0' 0}'                              new float[] {.769f' .686f' .534f' 0' 0}'                              new float[] {.189f' .168f' .131f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SepiaTone,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.393f' .349f' .272f' 0' 0}'                              new float[] {.769f' .686f' .534f' 0' 0}'                              new float[] {.189f' .168f' .131f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SepiaTone,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.393f' .349f' .272f' 0' 0}'                              new float[] {.769f' .686f' .534f' 0' 0}'                              new float[] {.189f' .168f' .131f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SepiaTone,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.393f' .349f' .272f' 0' 0}'                              new float[] {.769f' .686f' .534f' 0' 0}'                              new float[] {.189f' .168f' .131f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SepiaTone,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.393f' .349f' .272f' 0' 0}'                              new float[] {.769f' .686f' .534f' 0' 0}'                              new float[] {.189f' .168f' .131f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SepiaTone,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.393f' .349f' .272f' 0' 0}'                              new float[] {.769f' .686f' .534f' 0' 0}'                              new float[] {.189f' .168f' .131f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SepiaTone,The following statement contains a magic number: return Image.ApplyColorMatrix(new ColorMatrix(new float[][]{                              new float[] {.393f' .349f' .272f' 0' 0}'                              new float[] {.769f' .686f' .534f' 0' 0}'                              new float[] {.189f' .168f' .131f' 0' 0}'                              new float[] {0' 0' 0' 1' 0}'                              new float[] {0' 0' 0' 0' 1}                          }));
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Sharpen,The following statement contains a magic number: return Image.ApplyConvolutionFilter(new int[][]{                              new int[] {-1' -2' -1}'                              new int[] {-2' 16' -2}'                              new int[] {-1' -2' -1}                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Sharpen,The following statement contains a magic number: return Image.ApplyConvolutionFilter(new int[][]{                              new int[] {-1' -2' -1}'                              new int[] {-2' 16' -2}'                              new int[] {-1' -2' -1}                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Sharpen,The following statement contains a magic number: return Image.ApplyConvolutionFilter(new int[][]{                              new int[] {-1' -2' -1}'                              new int[] {-2' 16' -2}'                              new int[] {-1' -2' -1}                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Sharpen,The following statement contains a magic number: return Image.ApplyConvolutionFilter(new int[][]{                              new int[] {-1' -2' -1}'                              new int[] {-2' 16' -2}'                              new int[] {-1' -2' -1}                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Sharpen,The following statement contains a magic number: return Image.ApplyConvolutionFilter(new int[][]{                              new int[] {-1' -2' -1}'                              new int[] {-2' 16' -2}'                              new int[] {-1' -2' -1}                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SharpenLess,The following statement contains a magic number: return Image.ApplyConvolutionFilter(new int[][]{                              new int[] {-1' 0' -1}'                              new int[] {0'  7'  0}'                              new int[] {-1' 0' -1}                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SinWave,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          double Value1 = 0;                          double Value2 = 0;                          if (YDirection)                              Value1 = System.Math.Sin(((x * Frequency) * System.Math.PI) / 180.0d) * Amplitude;                          if (XDirection)                              Value2 = System.Math.Sin(((y * Frequency) * System.Math.PI) / 180.0d) * Amplitude;                          Value1 = y - (int)Value1;                          Value2 = x - (int)Value2;                          while (Value1 < 0)                              Value1 += Height;                          while (Value2 < 0)                              Value2 += Width;                          while (Value1 >= Height)                              Value1 -= Height;                          while (Value2 >= Width)                              Value2 -= Width;                          NewSwiftBitmap.SetPixel(x' y' OriginalImage.GetPixel((int)Value2' (int)Value1));                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SinWave,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          double Value1 = 0;                          double Value2 = 0;                          if (YDirection)                              Value1 = System.Math.Sin(((x * Frequency) * System.Math.PI) / 180.0d) * Amplitude;                          if (XDirection)                              Value2 = System.Math.Sin(((y * Frequency) * System.Math.PI) / 180.0d) * Amplitude;                          Value1 = y - (int)Value1;                          Value2 = x - (int)Value2;                          while (Value1 < 0)                              Value1 += Height;                          while (Value2 < 0)                              Value2 += Width;                          while (Value1 >= Height)                              Value1 -= Height;                          while (Value2 >= Width)                              Value2 -= Width;                          NewSwiftBitmap.SetPixel(x' y' OriginalImage.GetPixel((int)Value2' (int)Value1));                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The following statement contains a magic number: int ApetureMinX = -(Size / 2);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The following statement contains a magic number: int ApetureMaxX = (Size / 2);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The following statement contains a magic number: int ApetureMinY = -(Size / 2);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SNNBlur,The following statement contains a magic number: int ApetureMaxY = (Size / 2);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: Parallel.For(0' Width' x =>                          {                              for (int y = 0; y < Height; ++y)                              {                                  var Pixel1 = TempImageX.GetPixel(x' y);                                  var Pixel2 = TempImageY.GetPixel(x' y);                                  NewBitmap.SetPixel(x' y'                                      Color.FromArgb((Pixel1.R + Pixel2.R).Clamp(255' 0)'                                          (Pixel1.G + Pixel2.G).Clamp(255' 0)'                                          (Pixel1.B + Pixel2.B).Clamp(255' 0)));                              }                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: Parallel.For(0' Width' x =>                          {                              for (int y = 0; y < Height; ++y)                              {                                  var Pixel1 = TempImageX.GetPixel(x' y);                                  var Pixel2 = TempImageY.GetPixel(x' y);                                  NewBitmap.SetPixel(x' y'                                      Color.FromArgb((Pixel1.R + Pixel2.R).Clamp(255' 0)'                                          (Pixel1.G + Pixel2.G).Clamp(255' 0)'                                          (Pixel1.B + Pixel2.B).Clamp(255' 0)));                              }                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEdgeDetection,The following statement contains a magic number: Parallel.For(0' Width' x =>                          {                              for (int y = 0; y < Height; ++y)                              {                                  var Pixel1 = TempImageX.GetPixel(x' y);                                  var Pixel2 = TempImageY.GetPixel(x' y);                                  NewBitmap.SetPixel(x' y'                                      Color.FromArgb((Pixel1.R + Pixel2.R).Clamp(255' 0)'                                          (Pixel1.G + Pixel2.G).Clamp(255' 0)'                                          (Pixel1.B + Pixel2.B).Clamp(255' 0)));                              }                          });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEmboss,The following statement contains a magic number: return Image.ApplyConvolutionFilter(new int[][]{                              new int[] {-1' 0' 1}'                              new int[] {-2' 0' 2}'                              new int[] {-1' 0' 1}                          }' offset: 127);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEmboss,The following statement contains a magic number: return Image.ApplyConvolutionFilter(new int[][]{                              new int[] {-1' 0' 1}'                              new int[] {-2' 0' 2}'                              new int[] {-1' 0' 1}                          }' offset: 127);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,SobelEmboss,The following statement contains a magic number: return Image.ApplyConvolutionFilter(new int[][]{                              new int[] {-1' 0' 1}'                              new int[] {-2' 0' 2}'                              new int[] {-1' 0' 1}                          }' offset: 127);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Threshold,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          var TempColor = OriginalImage.GetPixel(x' y);                          if ((TempColor.R + TempColor.G + TempColor.B) / 755.0f > Threshold)                              NewSwiftBitmap.SetPixel(x' y' Color.White);                          else                              NewSwiftBitmap.SetPixel(x' y' Color.Black);                      }                  });
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,ToASCIIArt,The following statement contains a magic number: Builder.Append(_ASCIICharacters[((CurrentPixel.R * _ASCIICharacters.Length) / 255)]);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,GetHeight,The following statement contains a magic number: return (float)Color.R / 255.0f;
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,GetMinMaxPixel,The following statement contains a magic number: int MinR = 255' MinG = 255' MinB = 255;
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,GetMinMaxPixel,The following statement contains a magic number: int MinR = 255' MinG = 255' MinB = 255;
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,GetMinMaxPixel,The following statement contains a magic number: int MinR = 255' MinG = 255' MinB = 255;
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Map,The following statement contains a magic number: return ((int)(TempVal * 255)).Clamp(255' 0);
Magic Number,Utilities.Media,SwiftBitmapExtensions,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\ExtensionMethods\BitmapExtensions.cs,Map,The following statement contains a magic number: return ((int)(TempVal * 255)).Clamp(255' 0);
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,RGBHistogram,The following statement contains a magic number: R = new float[256];
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,RGBHistogram,The following statement contains a magic number: G = new float[256];
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,RGBHistogram,The following statement contains a magic number: B = new float[256];
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: x < 256
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: R[0] = R[0] * 256 / TotalPixels;
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: G[0] = G[0] * 256 / TotalPixels;
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: B[0] = B[0] * 256 / TotalPixels;
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: R[x] = ((PreviousR - R[RMin]) / (TotalPixels - R[RMin])) * 255;
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: G[x] = ((PreviousG - G[GMin]) / (TotalPixels - G[GMin])) * 255;
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: B[x] = ((PreviousB - B[BMin]) / (TotalPixels - B[BMin])) * 255;
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: x < 256
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Equalize,The following statement contains a magic number: Width = 256;
Magic Number,Utilities.Media,RGBHistogram,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\RGBHistogram.cs,Normalize,The following statement contains a magic number: x < 256
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int RValue = 0;                          int GValue = 0;                          int BValue = 0;                          int Weight = 0;                          int XCurrent = -filter[0].Length / 2;                          for (int x2 = 0; x2 < filter[0].Length; ++x2)                          {                              if (XCurrent + x < Width && XCurrent + x >= 0)                              {                                  int YCurrent = -filter.Length / 2;                                  for (int y2 = 0; y2 < filter.Length; ++y2)                                  {                                      if (YCurrent + y < Height && YCurrent + y >= 0)                                      {                                          var Pixel = GetPixel(XCurrent + x' YCurrent + y);                                          RValue += filter[x2][y2] * Pixel.R;                                          GValue += filter[x2][y2] * Pixel.G;                                          BValue += filter[x2][y2] * Pixel.B;                                          Weight += filter[x2][y2];                                      }                                      ++YCurrent;                                  }                              }                              ++XCurrent;                          }                          var MeanPixel = GetPixel(x' y);                          if (Weight == 0)                              Weight = 1;                          if (Weight > 0)                          {                              if (absolute)                              {                                  RValue = System.Math.Abs(RValue);                                  GValue = System.Math.Abs(GValue);                                  BValue = System.Math.Abs(BValue);                              }                              RValue = (RValue / Weight) + offset;                              RValue = RValue.Clamp(255' 0);                              GValue = (GValue / Weight) + offset;                              GValue = GValue.Clamp(255' 0);                              BValue = (BValue / Weight) + offset;                              BValue = BValue.Clamp(255' 0);                              MeanPixel = Color.FromArgb(RValue' GValue' BValue);                          }                          Result.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int RValue = 0;                          int GValue = 0;                          int BValue = 0;                          int Weight = 0;                          int XCurrent = -filter[0].Length / 2;                          for (int x2 = 0; x2 < filter[0].Length; ++x2)                          {                              if (XCurrent + x < Width && XCurrent + x >= 0)                              {                                  int YCurrent = -filter.Length / 2;                                  for (int y2 = 0; y2 < filter.Length; ++y2)                                  {                                      if (YCurrent + y < Height && YCurrent + y >= 0)                                      {                                          var Pixel = GetPixel(XCurrent + x' YCurrent + y);                                          RValue += filter[x2][y2] * Pixel.R;                                          GValue += filter[x2][y2] * Pixel.G;                                          BValue += filter[x2][y2] * Pixel.B;                                          Weight += filter[x2][y2];                                      }                                      ++YCurrent;                                  }                              }                              ++XCurrent;                          }                          var MeanPixel = GetPixel(x' y);                          if (Weight == 0)                              Weight = 1;                          if (Weight > 0)                          {                              if (absolute)                              {                                  RValue = System.Math.Abs(RValue);                                  GValue = System.Math.Abs(GValue);                                  BValue = System.Math.Abs(BValue);                              }                              RValue = (RValue / Weight) + offset;                              RValue = RValue.Clamp(255' 0);                              GValue = (GValue / Weight) + offset;                              GValue = GValue.Clamp(255' 0);                              BValue = (BValue / Weight) + offset;                              BValue = BValue.Clamp(255' 0);                              MeanPixel = Color.FromArgb(RValue' GValue' BValue);                          }                          Result.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int RValue = 0;                          int GValue = 0;                          int BValue = 0;                          int Weight = 0;                          int XCurrent = -filter[0].Length / 2;                          for (int x2 = 0; x2 < filter[0].Length; ++x2)                          {                              if (XCurrent + x < Width && XCurrent + x >= 0)                              {                                  int YCurrent = -filter.Length / 2;                                  for (int y2 = 0; y2 < filter.Length; ++y2)                                  {                                      if (YCurrent + y < Height && YCurrent + y >= 0)                                      {                                          var Pixel = GetPixel(XCurrent + x' YCurrent + y);                                          RValue += filter[x2][y2] * Pixel.R;                                          GValue += filter[x2][y2] * Pixel.G;                                          BValue += filter[x2][y2] * Pixel.B;                                          Weight += filter[x2][y2];                                      }                                      ++YCurrent;                                  }                              }                              ++XCurrent;                          }                          var MeanPixel = GetPixel(x' y);                          if (Weight == 0)                              Weight = 1;                          if (Weight > 0)                          {                              if (absolute)                              {                                  RValue = System.Math.Abs(RValue);                                  GValue = System.Math.Abs(GValue);                                  BValue = System.Math.Abs(BValue);                              }                              RValue = (RValue / Weight) + offset;                              RValue = RValue.Clamp(255' 0);                              GValue = (GValue / Weight) + offset;                              GValue = GValue.Clamp(255' 0);                              BValue = (BValue / Weight) + offset;                              BValue = BValue.Clamp(255' 0);                              MeanPixel = Color.FromArgb(RValue' GValue' BValue);                          }                          Result.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int RValue = 0;                          int GValue = 0;                          int BValue = 0;                          int Weight = 0;                          int XCurrent = -filter[0].Length / 2;                          for (int x2 = 0; x2 < filter[0].Length; ++x2)                          {                              if (XCurrent + x < Width && XCurrent + x >= 0)                              {                                  int YCurrent = -filter.Length / 2;                                  for (int y2 = 0; y2 < filter.Length; ++y2)                                  {                                      if (YCurrent + y < Height && YCurrent + y >= 0)                                      {                                          var Pixel = GetPixel(XCurrent + x' YCurrent + y);                                          RValue += filter[x2][y2] * Pixel.R;                                          GValue += filter[x2][y2] * Pixel.G;                                          BValue += filter[x2][y2] * Pixel.B;                                          Weight += filter[x2][y2];                                      }                                      ++YCurrent;                                  }                              }                              ++XCurrent;                          }                          var MeanPixel = GetPixel(x' y);                          if (Weight == 0)                              Weight = 1;                          if (Weight > 0)                          {                              if (absolute)                              {                                  RValue = System.Math.Abs(RValue);                                  GValue = System.Math.Abs(GValue);                                  BValue = System.Math.Abs(BValue);                              }                              RValue = (RValue / Weight) + offset;                              RValue = RValue.Clamp(255' 0);                              GValue = (GValue / Weight) + offset;                              GValue = GValue.Clamp(255' 0);                              BValue = (BValue / Weight) + offset;                              BValue = BValue.Clamp(255' 0);                              MeanPixel = Color.FromArgb(RValue' GValue' BValue);                          }                          Result.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,ApplyConvolutionFilter,The following statement contains a magic number: Parallel.For(0' Width' x =>                  {                      for (int y = 0; y < Height; ++y)                      {                          int RValue = 0;                          int GValue = 0;                          int BValue = 0;                          int Weight = 0;                          int XCurrent = -filter[0].Length / 2;                          for (int x2 = 0; x2 < filter[0].Length; ++x2)                          {                              if (XCurrent + x < Width && XCurrent + x >= 0)                              {                                  int YCurrent = -filter.Length / 2;                                  for (int y2 = 0; y2 < filter.Length; ++y2)                                  {                                      if (YCurrent + y < Height && YCurrent + y >= 0)                                      {                                          var Pixel = GetPixel(XCurrent + x' YCurrent + y);                                          RValue += filter[x2][y2] * Pixel.R;                                          GValue += filter[x2][y2] * Pixel.G;                                          BValue += filter[x2][y2] * Pixel.B;                                          Weight += filter[x2][y2];                                      }                                      ++YCurrent;                                  }                              }                              ++XCurrent;                          }                          var MeanPixel = GetPixel(x' y);                          if (Weight == 0)                              Weight = 1;                          if (Weight > 0)                          {                              if (absolute)                              {                                  RValue = System.Math.Abs(RValue);                                  GValue = System.Math.Abs(GValue);                                  BValue = System.Math.Abs(BValue);                              }                              RValue = (RValue / Weight) + offset;                              RValue = RValue.Clamp(255' 0);                              GValue = (GValue / Weight) + offset;                              GValue = GValue.Clamp(255' 0);                              BValue = (BValue / Weight) + offset;                              BValue = BValue.Clamp(255' 0);                              MeanPixel = Color.FromArgb(RValue' GValue' BValue);                          }                          Result.SetPixel(x' y' MeanPixel);                      }                  });
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ?                  Color.FromArgb(TempPointer[2]' TempPointer[1]' TempPointer[0]) :                  Color.FromArgb(TempPointer[3]' TempPointer[2]' TempPointer[1]' TempPointer[0]);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ?                  Color.FromArgb(TempPointer[2]' TempPointer[1]' TempPointer[0]) :                  Color.FromArgb(TempPointer[3]' TempPointer[2]' TempPointer[1]' TempPointer[0]);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ?                  Color.FromArgb(TempPointer[2]' TempPointer[1]' TempPointer[0]) :                  Color.FromArgb(TempPointer[3]' TempPointer[2]' TempPointer[1]' TempPointer[0]);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ?                  Color.FromArgb(TempPointer[2]' TempPointer[1]' TempPointer[0]) :                  Color.FromArgb(TempPointer[3]' TempPointer[2]' TempPointer[1]' TempPointer[0]);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ?                  Color.FromArgb(TempPointer[2]' TempPointer[1]' TempPointer[0]) :                  Color.FromArgb(TempPointer[3]' TempPointer[2]' TempPointer[1]' TempPointer[0]);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ?                  Color.FromArgb(TempPointer[2]' TempPointer[1]' TempPointer[0]) :                  Color.FromArgb(TempPointer[3]' TempPointer[2]' TempPointer[1]' TempPointer[0]);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ?                  Color.FromArgb(TempPointer[2]' TempPointer[1]' TempPointer[0]) :                  Color.FromArgb(TempPointer[3]' TempPointer[2]' TempPointer[1]' TempPointer[0]);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixel,The following statement contains a magic number: return (PixelSize == 3) ?                  Color.FromArgb(TempPointer[2]' TempPointer[1]' TempPointer[0]) :                  Color.FromArgb(TempPointer[3]' TempPointer[2]' TempPointer[1]' TempPointer[0]);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,Rotate,The following statement contains a magic number: NewGraphics.TranslateTransform((float)Width / 2.0f' (float)Height / 2.0f);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,Rotate,The following statement contains a magic number: NewGraphics.TranslateTransform((float)Width / 2.0f' (float)Height / 2.0f);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,Rotate,The following statement contains a magic number: NewGraphics.TranslateTransform(-(float)Width / 2.0f' -(float)Height / 2.0f);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,Rotate,The following statement contains a magic number: NewGraphics.TranslateTransform(-(float)Width / 2.0f' -(float)Height / 2.0f);
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixel,The following statement contains a magic number: TempPointer[2] = pixelColor.R;
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixel,The following statement contains a magic number: PixelSize == 3
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixel,The following statement contains a magic number: TempPointer[3] = pixelColor.A;
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixel,The following statement contains a magic number: TempPointer[2] = pixelColor.R;
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: TempPointer[2] = pixels[z].R;
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,SetPixels,The following statement contains a magic number: PixelSize == 3
Magic Number,Utilities.Media,SwiftBitmap,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\SwiftBitmap.cs,GetPixelSize,The following statement contains a magic number: return 3;
Magic Number,Utilities.Media.Procedural,CellularTexture,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\CellularTexture.cs,Generate,The following statement contains a magic number: Value *= 255;
Magic Number,Utilities.Media.Procedural,CellularTexture,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\CellularTexture.cs,Generate,The following statement contains a magic number: var RGBValue = ((int)Value).Clamp(255' 0);
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,Generate,The following statement contains a magic number: float IncreaseVal = 0.1f;
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,Generate,The following statement contains a magic number: Value = (Value * 0.5f) + 0.5f;
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,Generate,The following statement contains a magic number: Value = (Value * 0.5f) + 0.5f;
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,Generate,The following statement contains a magic number: Value *= 255;
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,Generate,The following statement contains a magic number: var RGBValue = ((int)Value).Clamp(255' 0);
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: Wall = Generator.Next(4);
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: Wall2 = Generator.Next(4);
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: switch (Wall)                  {                      case 0:                          X1 = Generator.Next(Width);                          Y1 = 0;                          break;                      case 1:                          Y1 = Generator.Next(Height);                          X1 = Width;                          break;                      case 2:                          X1 = Generator.Next(Width);                          Y1 = Height;                          break;                      default:                          X1 = 0;                          Y1 = Generator.Next(Height);                          break;                  }
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: switch (Wall2)                  {                      case 0:                          X2 = Generator.Next(Width);                          Y2 = 0;                          break;                      case 1:                          Y2 = Generator.Next(Height);                          X2 = Width;                          break;                      case 2:                          X2 = Generator.Next(Width);                          Y2 = Height;                          break;                      default:                          X2 = 0;                          Y2 = Generator.Next(Height);                          break;                  }
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: var Side = Generator.Next(2);
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: Direction = Generator.Next(-1' 2);
Magic Number,Utilities.Media.Procedural,FaultFormation,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\FaultFormation.cs,GenerateFault,The following statement contains a magic number: IncreaseVal -= (0.1f / (float)NumberFaults);
Magic Number,Utilities.Media.Procedural,PerlinNoise,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,Generate,The following statement contains a magic number: Value = (Value * 0.5f) + 0.5f;
Magic Number,Utilities.Media.Procedural,PerlinNoise,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,Generate,The following statement contains a magic number: Value = (Value * 0.5f) + 0.5f;
Magic Number,Utilities.Media.Procedural,PerlinNoise,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,Generate,The following statement contains a magic number: Value *= 255;
Magic Number,Utilities.Media.Procedural,PerlinNoise,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,GenerateNoise,The following statement contains a magic number: Noise[x' y] = ((float)(RandomGenerator.NextDouble()) - 0.5f) * 2.0f;
Magic Number,Utilities.Media.Procedural,PerlinNoise,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,GenerateNoise,The following statement contains a magic number: Noise[x' y] = ((float)(RandomGenerator.NextDouble()) - 0.5f) * 2.0f;
Magic Number,Utilities.Media.Procedural,PerlinNoise,D:\research\architectureSmells\repos\JaCraig_Craig-s-Utility-Library\Utilities.Media\Media\Procedural\PerlinNoise.cs,GetValue,The following statement contains a magic number: Frequency *= 2.0f;
