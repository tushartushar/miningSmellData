Implementation smell,Namespace,Class,File,Method,Description
Long Method,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The method has 236 lines of code.
Long Method,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The method has 412 lines of code.
Long Method,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The method has 106 lines of code.
Complex Method,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,Cyclomatic complexity of the method is 44
Complex Method,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,PromptForChoice,Cyclomatic complexity of the method is 13
Complex Method,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,Cyclomatic complexity of the method is 23
Long Parameter List,EasyConnect.Protocols.PowerShell,PowerShellHost,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHost.cs,PowerShellHost,The method has 5 parameters.
Long Parameter List,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,PromptForCredential,The method has 6 parameters.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,Connect,The length of the statement  "	// This is not strictly a network connection:  we're relaying information that we receive from the runspace to the terminal over a local stream " is 143.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,Connect,The length of the statement  "		// Create the host and runspace instances for this interpreter.  If we're connecting to the local host' don't bother with the connection info. " is 142.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,Connect,The length of the statement  "		if (String.Compare (Connection.Host' "localhost"' true) != 0 && Connection.Host != "127.0.0.1" && String.Compare (Connection.Host' Environment.MachineName' true) != 0)// ReSharper restore StringCompareIsCultureSpecific.3 " is 220.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ExecuteHelper,The length of the statement  "		// Create the pipeline object and make it available to the Ctrl-C handle through the _currentPowerShell instance variable. " is 122.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ExecuteHelper,The length of the statement  "		// Create a pipeline for this execution' and then place the result in the _currentPowerShell variable so it is available to be stopped. " is 135.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ExecuteHelper,The length of the statement  "				// Add the default outputter to the end of the pipe and then call the MergeMyResults method to merge the output and error streams from  " is 134.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ExecuteHelper,The length of the statement  "				// the pipeline. This will result in the output being written using the PSHost and PSHostUserInterface classes instead of returning  " is 131.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ExecuteHelper,The length of the statement  "			// Dispose the PowerShell object and set _currentPowerShell to null. It is locked because _currentPowerShell may be accessed by the Ctrl-C  " is 138.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ReportException,The length of the statement  "		object error = errorRecord != null ? errorRecord.ErrorRecord : new ErrorRecord (e' "Host.ReportException"' ErrorCategory.NotSpecified' null); " is 141.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ReportException,The length of the statement  "			// Dispose of the pipeline and set it to null' locking it because _currentPowerShell may be accessed by the Ctrl-C handler. " is 123.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InputLoop,The length of the statement  "			// Display the prompt containing the current directory to the user' prefixed by the name of the remote machine if we are remoted into one " is 137.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InputLoop,The length of the statement  "		// Dispose of the pipeline line and set it to null' locked because _currentPowerShell may be accessed by the Ctrl-C handler " is 123.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The length of the statement  "	this._terminal.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 233.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,AddToCommandHistory,The length of the statement  "	// If the user's command matches the current history command' simply return so we don't polute the history buffer with a bunch of identical entries " is 147.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "					// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab  " is 121.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) { " is 562.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "								currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value); " is 153.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "								if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) { " is 378.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "									IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ()); " is 268.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "									intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList (); " is 379.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "								else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) { " is 192.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "										int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName); " is 166.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "													_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys " is 174.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "											intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList (); " is 175.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "						// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense " is 121.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "						Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : "")); " is 157.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "						RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width))); " is 281.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "						currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1); " is 167.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "						// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well " is 127.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1); " is 137.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "						RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1); " is 172.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "						RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1); " is 172.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "							// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end  " is 123.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "							promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1); " is 137.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The length of the statement  "					promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1); " is 137.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,WriteDebugLine,The length of the statement  "	WriteLine (ConsoleColor.DarkYellow' ConsoleColor.Black' String.Format (CultureInfo.CurrentCulture' "DEBUG: {0}"' message)); " is 123.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,WriteProgress,The length of the statement  "	_progressLabel.Text = String.IsNullOrEmpty (record.Activity) ? "" : record.Activity + (String.IsNullOrEmpty (record.CurrentOperation) ? "" : ": ") + record.CurrentOperation; " is 173.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,WriteVerboseLine,The length of the statement  "	WriteLine (ConsoleColor.Green' ConsoleColor.Black' String.Format (CultureInfo.CurrentCulture' "VERBOSE: {0}"' message)); " is 120.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,WriteWarningLine,The length of the statement  "	WriteLine (ConsoleColor.Yellow' ConsoleColor.Black' String.Format (CultureInfo.CurrentCulture' "WARNING: {0}"' message)); " is 121.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,PowerShellOptionsForm_Load,The length of the statement  "	if ((Connection.Password == null || Connection.Password.Length == 0) && Connection.InheritedPassword != null && Connection.InheritedPassword.Length > 0) " is 152.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,_userNameTextBox_TextChanged,The length of the statement  "	_inheritedUsernameLabel.Text = String.IsNullOrEmpty (_userNameTextBox.Text) && !String.IsNullOrEmpty (Connection.GetInheritedUsername (Connection.ParentFolder)) ? "Inheriting " + Connection.InheritedUsername + " from parent folders" : ""; " is 238.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,_passwordTextBox_TextChanged,The length of the statement  "		_inheritedPasswordLabel.Text = inheritedPassword != null && inheritedPassword.Length > 0 ? "Inheriting a password from parent folders" : ""; " is 140.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager (typeof(PowerShellOptionsForm)); " is 142.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	this._flowLayoutPanel.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 240.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	this._hostNameLabel.Font = new System.Drawing.Font ("Segoe UI"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 153.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	this._hostLabel.Font = new System.Drawing.Font ("Segoe UI"' 9.75F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 149.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	this._generalPanel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 192.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	this._inheritedPasswordLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 202.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	this._inheritedUsernameLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 202.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	this._backgroundColorPanel.BackColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(0))))' ((int)(((byte)(64))))); " is 137.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 185.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	this._titleLabel.Font = new System.Drawing.Font ("Segoe UI"' 15.75F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 151.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	this._titleLabel.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(92))))' ((int)(((byte)(97))))' ((int)(((byte)(102))))); " is 130.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The length of the statement  "	this.BackColor = System.Drawing.Color.FromArgb (((int)(((byte)(249))))' ((int)(((byte)(249))))' ((int)(((byte)(249))))); " is 120.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ClosestConsoleColor,The length of the statement  "		Color consoleColorColor = Color.FromName (consoleColor.ToString ("G") == "DarkYellow" ? "Orange" : consoleColor.ToString ("G")); " is 128.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ClosestConsoleColor,The length of the statement  "		double t = Math.Pow (consoleColorColor.R - r' 2.0) + Math.Pow (consoleColorColor.G - g' 2.0) + Math.Pow (consoleColorColor.B - b' 2.0); " is 135.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The length of the statement  "					// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line " is 123.
Long Statement,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The length of the statement  "					// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line " is 121.
Complex Conditional,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The conditional expression  "((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral"  is complex.
Complex Conditional,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The conditional expression  "((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral"  is complex.
Complex Conditional,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,PowerShellOptionsForm_Load,The conditional expression  "(Connection.Password == null || Connection.Password.Length == 0) && Connection.InheritedPassword != null && Connection.InheritedPassword.Length > 0"  is complex.
Empty Catch Block,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ParentForm_Closing,The method has an empty catch block.
Empty Catch Block,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,EndInput,The method has an empty catch block.
Empty Catch Block,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,EndInput,The method has an empty catch block.
Empty Catch Block,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,StopCurrentPipeline,The method has an empty catch block.
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnection,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnection.cs,PowerShellConnection,The following statement contains a magic number: Font = new Font ("Courier New"' 10);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ReportException,The following statement contains a magic number: if (e != null) {  	IContainsErrorRecord errorRecord = e as IContainsErrorRecord;  	object error = errorRecord != null ? errorRecord.ErrorRecord : new ErrorRecord (e' "Host.ReportException"' ErrorCategory.NotSpecified' null);  	lock (_instanceLock) {  		_currentPowerShell = Shell.Create ();  	}  	_currentPowerShell.Runspace = Runspace;  	try {  		_currentPowerShell.AddScript ("$input").AddCommand ("out-string");  		// Do not merge errors' this function will swallow errors.  		Collection<PSObject> result;  		PSDataCollection<object> inputCollection = new PSDataCollection<object> {  			error  		};  		inputCollection.Complete ();  		lock (_executionLock) {  			result = _currentPowerShell.Invoke (inputCollection);  		}  		if (result.Count > 0) {  			string output = result [0].BaseObject as string;  			// Remove \r\n' which is added by the Out-String cmdlet.  			if (!string.IsNullOrEmpty (output))  				_powerShellHost.UI.WriteErrorLine (output.Substring (0' output.Length - 2));  		}  	} finally {  		// Dispose of the pipeline and set it to null' locking it because _currentPowerShell may be accessed by the Ctrl-C handler.  		lock (_instanceLock) {  			_currentPowerShell.Dispose ();  			_currentPowerShell = null;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ReportException,The following statement contains a magic number: try {  	_currentPowerShell.AddScript ("$input").AddCommand ("out-string");  	// Do not merge errors' this function will swallow errors.  	Collection<PSObject> result;  	PSDataCollection<object> inputCollection = new PSDataCollection<object> {  		error  	};  	inputCollection.Complete ();  	lock (_executionLock) {  		result = _currentPowerShell.Invoke (inputCollection);  	}  	if (result.Count > 0) {  		string output = result [0].BaseObject as string;  		// Remove \r\n' which is added by the Out-String cmdlet.  		if (!string.IsNullOrEmpty (output))  			_powerShellHost.UI.WriteErrorLine (output.Substring (0' output.Length - 2));  	}  } finally {  	// Dispose of the pipeline and set it to null' locking it because _currentPowerShell may be accessed by the Ctrl-C handler.  	lock (_instanceLock) {  		_currentPowerShell.Dispose ();  		_currentPowerShell = null;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ReportException,The following statement contains a magic number: if (result.Count > 0) {  	string output = result [0].BaseObject as string;  	// Remove \r\n' which is added by the Out-String cmdlet.  	if (!string.IsNullOrEmpty (output))  		_powerShellHost.UI.WriteErrorLine (output.Substring (0' output.Length - 2));  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ReportException,The following statement contains a magic number: if (!string.IsNullOrEmpty (output))  	_powerShellHost.UI.WriteErrorLine (output.Substring (0' output.Length - 2));  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,ReportException,The following statement contains a magic number: _powerShellHost.UI.WriteErrorLine (output.Substring (0' output.Length - 2));  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._terminal.Location = new System.Drawing.Point (-2' -2);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._terminal.Location = new System.Drawing.Point (-2' -2);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._terminal.Size = new System.Drawing.Size (715' 500);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._terminal.Size = new System.Drawing.Size (715' 500);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._statusStrip.Location = new System.Drawing.Point (0' 496);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._statusStrip.Size = new System.Drawing.Size (713' 22);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._statusStrip.Size = new System.Drawing.Size (713' 22);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._statusStripSpacerLabel.Size = new System.Drawing.Size (513' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._statusStripSpacerLabel.Size = new System.Drawing.Size (513' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._progressLabel.Size = new System.Drawing.Size (52' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._progressLabel.Size = new System.Drawing.Size (52' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._progressBar.Size = new System.Drawing.Size (100' 16);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this._progressBar.Size = new System.Drawing.Size (100' 16);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (713' 518);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellConnectionForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellConnectionForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (713' 518);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,AddToCommandHistory,The following statement contains a magic number: if (_upCommandHistory.Count > 20)  	_upCommandHistory = new Stack<string> (_upCommandHistory.ToArray ().Take (20).Reverse ());  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,AddToCommandHistory,The following statement contains a magic number: if (_upCommandHistory.Count > 20)  	_upCommandHistory = new Stack<string> (_upCommandHistory.ToArray ().Take (20).Reverse ());  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,AddToCommandHistory,The following statement contains a magic number: _upCommandHistory = new Stack<string> (_upCommandHistory.ToArray ().Take (20).Reverse ());  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (!foundCarriageReturn) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the TAB character  			if (currentByte == 9) {  				// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   				// completion command and then hit tab again to cycle through it)  				if (intellisenseStartLocation == null) {  					Token[] tokens;  					ParseError[] parseErrors;  					// Parse the current input line up to the cursor location  					Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  					// Get the last grammar token prior to the end of input  					Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  					if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  							// the Intellisense candidates in  							intellisenseStartLocation = insertPosition - currentToken.Text.Length;  							intellisenseCandidatesIndex = -1;  							currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  							// If the grammar token is a command name' an identifier' or a string literal  							if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  								string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  								string searchPath = null;  								if (match.Contains ("\\")) {  									// ReSharper disable StringLastIndexOfIsCultureSpecific.1  									searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  									match = match.Substring (match.LastIndexOf ("\\") + 1);  									// ReSharper restore StringLastIndexOfIsCultureSpecific.1  								}  								// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  								// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   								// one)  								IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  								// Union the matching files and the matching commands to get the full list of Intellisense candidates  								intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  							} // If the grammar token is a command parameter  							else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  								List<Token> tokenList = tokens.ToList ();  								if (tokenList.IndexOf (currentToken) > 0) {  									// Get the token representing the name of the command for this parameter  									int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  									if (commandTokenIndex != -1) {  										Token commandToken = tokens [commandTokenIndex];  										// Get the list of parameters for the command if we don't have it already  										if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  											_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  											// Run the "Get-Command" cmdlet and look at its Parameters property  											Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  											if (command != null) {  												_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  												select "-" + parameter);  											}  										}  										intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  									}  								}  								if (intellisenseCandidates == null)  									intellisenseCandidates = new List<string> ();  							}  						}  					}  				}  				// Cycle to the next Intellisense candidate  				if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  					intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  					if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  						intellisenseCandidatesIndex = 0;  					else if (intellisenseCandidatesIndex < 0)  						intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  					string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  					// Remove the current token from the line and replace it with the current Intellisense candidate  					_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  					_currentInputLine.Insert (intellisenseStartLocation.Value' command);  					// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  					// candidate was shorter than the previous one  					RawUI.CursorPosition = promptStart;  					Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  					promptEnd = RawUI.CursorPosition;  					// Reposition the cursor properly to end of the Intellisense candidate  					RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  					insertPosition = intellisenseStartLocation.Value + command.Length;  					currentIntellisenseCommand = command;  				}  			} else if (intellisenseStartLocation != null) {  				intellisenseStartLocation = null;  				intellisenseCandidatesIndex = null;  				currentIntellisenseCommand = null;  				intellisenseCandidates.Clear ();  			}  			// Handle the BACKSPACE character  			if (currentByte == 8) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (insertPosition > 0) {  					// Remove the preceding character from _currentInputLine  					_currentInputLine.Remove (insertPosition - 1' 1);  					insertPosition--;  					currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  					// as a trailing space to cover the previous end character  					RawUI.CursorPosition = currentPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			} // In ANSI' the ESCAPE character means we're starting a special processing sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^7 translates to the HOME key  			else if (currentByte == 55 && inEscapeSequence) {  				RawUI.CursorPosition = promptStart;  				insertPosition = 0;  			} // ^8 translates to the END key  			else if (currentByte == 56 && inEscapeSequence) {  				RawUI.CursorPosition = promptEnd;  				insertPosition = _currentInputLine.Length;  			} // ^D translates to the left arrow' so we move the cursor backwards  			else if (currentByte == 68 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptStart) {  					RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  					insertPosition--;  				}  				inEscapeSequence = false;  			} // ^D translates to the right arrow' so we move the cursor forwards  			else if (currentByte == 67 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				if (RawUI.CursorPosition != promptEnd) {  					RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  					insertPosition++;  				}  				inEscapeSequence = false;  			} // ^D translates to the DELETE key' so we remove the current character  			else if (currentByte == 51 && inEscapeSequence) {  				Coordinates currentPosition = RawUI.CursorPosition;  				// If the cursor is somewhere other than the very start of the prompt  				if (RawUI.CursorPosition != promptEnd) {  					// Remove the current character from _currentInputLine  					_currentInputLine.Remove (insertPosition' 1);  					if (insertPosition < _currentInputLine.Length) {  						// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   						// character  						Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  						Write (" ");  						RawUI.CursorPosition = currentPosition;  						promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  					}  				}  				inEscapeSequence = false;  			} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 65 && inEscapeSequence) {  				// If there are any preceding items in the history buffer  				if (AtCommandPrompt && _upCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_downCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _upCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  			else if (currentByte == 66 && inEscapeSequence) {  				// If there are any following items in the history buffer  				if (AtCommandPrompt && _downCommandHistory.Count > 0) {  					// Save the current history command  					if (!String.IsNullOrEmpty (_currentHistoryCommand))  						_upCommandHistory.Push (_currentHistoryCommand);  					_currentHistoryCommand = _downCommandHistory.Pop ();  					// Wipe out the current line entered by the user  					RawUI.CursorPosition = promptStart;  					Write (new string (' '' _currentInputLine.Length));  					// Move the cursor back to the start and write the history command  					RawUI.CursorPosition = promptStart;  					Write (_currentHistoryCommand);  					promptEnd = RawUI.CursorPosition;  					_currentInputLine = new StringBuilder (_currentHistoryCommand);  					insertPosition = _currentInputLine.Length;  				}  				inEscapeSequence = false;  			} // Handle the carriage return character; write a new line and exit the loop  			else if (currentByte == 13) {  				WriteLine ();  				foundCarriageReturn = true;  				break;  			} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  			else if (currentByte >= 32) {  				inEscapeSequence = false;  				Write (Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  					currentByte  				}));  				insertPosition++;  				if (insertPosition < _currentInputLine.Length) {  					Coordinates currentPosition = RawUI.CursorPosition;  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					RawUI.CursorPosition = currentPosition;  				}  				promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  			} else  				inEscapeSequence = false;  		}  	}  	// If we're still waiting on a carriage return' sleep  	if (!foundCarriageReturn)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the TAB character  		if (currentByte == 9) {  			// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   			// completion command and then hit tab again to cycle through it)  			if (intellisenseStartLocation == null) {  				Token[] tokens;  				ParseError[] parseErrors;  				// Parse the current input line up to the cursor location  				Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  				// Get the last grammar token prior to the end of input  				Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  				if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  						// the Intellisense candidates in  						intellisenseStartLocation = insertPosition - currentToken.Text.Length;  						intellisenseCandidatesIndex = -1;  						currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  						// If the grammar token is a command name' an identifier' or a string literal  						if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  							string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  							string searchPath = null;  							if (match.Contains ("\\")) {  								// ReSharper disable StringLastIndexOfIsCultureSpecific.1  								searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  								match = match.Substring (match.LastIndexOf ("\\") + 1);  								// ReSharper restore StringLastIndexOfIsCultureSpecific.1  							}  							// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  							// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   							// one)  							IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  							// Union the matching files and the matching commands to get the full list of Intellisense candidates  							intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  						} // If the grammar token is a command parameter  						else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  							List<Token> tokenList = tokens.ToList ();  							if (tokenList.IndexOf (currentToken) > 0) {  								// Get the token representing the name of the command for this parameter  								int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  								if (commandTokenIndex != -1) {  									Token commandToken = tokens [commandTokenIndex];  									// Get the list of parameters for the command if we don't have it already  									if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  										_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  										// Run the "Get-Command" cmdlet and look at its Parameters property  										Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  										if (command != null) {  											_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  											select "-" + parameter);  										}  									}  									intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  								}  							}  							if (intellisenseCandidates == null)  								intellisenseCandidates = new List<string> ();  						}  					}  				}  			}  			// Cycle to the next Intellisense candidate  			if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  				intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  				if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  					intellisenseCandidatesIndex = 0;  				else if (intellisenseCandidatesIndex < 0)  					intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  				string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  				// Remove the current token from the line and replace it with the current Intellisense candidate  				_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  				_currentInputLine.Insert (intellisenseStartLocation.Value' command);  				// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  				// candidate was shorter than the previous one  				RawUI.CursorPosition = promptStart;  				Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  				promptEnd = RawUI.CursorPosition;  				// Reposition the cursor properly to end of the Intellisense candidate  				RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  				insertPosition = intellisenseStartLocation.Value + command.Length;  				currentIntellisenseCommand = command;  			}  		} else if (intellisenseStartLocation != null) {  			intellisenseStartLocation = null;  			intellisenseCandidatesIndex = null;  			currentIntellisenseCommand = null;  			intellisenseCandidates.Clear ();  		}  		// Handle the BACKSPACE character  		if (currentByte == 8) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (insertPosition > 0) {  				// Remove the preceding character from _currentInputLine  				_currentInputLine.Remove (insertPosition - 1' 1);  				insertPosition--;  				currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  				// as a trailing space to cover the previous end character  				RawUI.CursorPosition = currentPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		} // In ANSI' the ESCAPE character means we're starting a special processing sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^7 translates to the HOME key  		else if (currentByte == 55 && inEscapeSequence) {  			RawUI.CursorPosition = promptStart;  			insertPosition = 0;  		} // ^8 translates to the END key  		else if (currentByte == 56 && inEscapeSequence) {  			RawUI.CursorPosition = promptEnd;  			insertPosition = _currentInputLine.Length;  		} // ^D translates to the left arrow' so we move the cursor backwards  		else if (currentByte == 68 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptStart) {  				RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  				insertPosition--;  			}  			inEscapeSequence = false;  		} // ^D translates to the right arrow' so we move the cursor forwards  		else if (currentByte == 67 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			if (RawUI.CursorPosition != promptEnd) {  				RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  				insertPosition++;  			}  			inEscapeSequence = false;  		} // ^D translates to the DELETE key' so we remove the current character  		else if (currentByte == 51 && inEscapeSequence) {  			Coordinates currentPosition = RawUI.CursorPosition;  			// If the cursor is somewhere other than the very start of the prompt  			if (RawUI.CursorPosition != promptEnd) {  				// Remove the current character from _currentInputLine  				_currentInputLine.Remove (insertPosition' 1);  				if (insertPosition < _currentInputLine.Length) {  					// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   					// character  					Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  					Write (" ");  					RawUI.CursorPosition = currentPosition;  					promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  				}  			}  			inEscapeSequence = false;  		} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 65 && inEscapeSequence) {  			// If there are any preceding items in the history buffer  			if (AtCommandPrompt && _upCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_downCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _upCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  		else if (currentByte == 66 && inEscapeSequence) {  			// If there are any following items in the history buffer  			if (AtCommandPrompt && _downCommandHistory.Count > 0) {  				// Save the current history command  				if (!String.IsNullOrEmpty (_currentHistoryCommand))  					_upCommandHistory.Push (_currentHistoryCommand);  				_currentHistoryCommand = _downCommandHistory.Pop ();  				// Wipe out the current line entered by the user  				RawUI.CursorPosition = promptStart;  				Write (new string (' '' _currentInputLine.Length));  				// Move the cursor back to the start and write the history command  				RawUI.CursorPosition = promptStart;  				Write (_currentHistoryCommand);  				promptEnd = RawUI.CursorPosition;  				_currentInputLine = new StringBuilder (_currentHistoryCommand);  				insertPosition = _currentInputLine.Length;  			}  			inEscapeSequence = false;  		} // Handle the carriage return character; write a new line and exit the loop  		else if (currentByte == 13) {  			WriteLine ();  			foundCarriageReturn = true;  			break;  		} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  		else if (currentByte >= 32) {  			inEscapeSequence = false;  			Write (Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  				currentByte  			}));  			insertPosition++;  			if (insertPosition < _currentInputLine.Length) {  				Coordinates currentPosition = RawUI.CursorPosition;  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				RawUI.CursorPosition = currentPosition;  			}  			promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  		} else  			inEscapeSequence = false;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the TAB character  	if (currentByte == 9) {  		// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   		// completion command and then hit tab again to cycle through it)  		if (intellisenseStartLocation == null) {  			Token[] tokens;  			ParseError[] parseErrors;  			// Parse the current input line up to the cursor location  			Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  			// Get the last grammar token prior to the end of input  			Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  			if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  					// the Intellisense candidates in  					intellisenseStartLocation = insertPosition - currentToken.Text.Length;  					intellisenseCandidatesIndex = -1;  					currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  					// If the grammar token is a command name' an identifier' or a string literal  					if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  						string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  						string searchPath = null;  						if (match.Contains ("\\")) {  							// ReSharper disable StringLastIndexOfIsCultureSpecific.1  							searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  							match = match.Substring (match.LastIndexOf ("\\") + 1);  							// ReSharper restore StringLastIndexOfIsCultureSpecific.1  						}  						// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  						// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   						// one)  						IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  						// Union the matching files and the matching commands to get the full list of Intellisense candidates  						intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  					} // If the grammar token is a command parameter  					else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  						List<Token> tokenList = tokens.ToList ();  						if (tokenList.IndexOf (currentToken) > 0) {  							// Get the token representing the name of the command for this parameter  							int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  							if (commandTokenIndex != -1) {  								Token commandToken = tokens [commandTokenIndex];  								// Get the list of parameters for the command if we don't have it already  								if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  									_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  									// Run the "Get-Command" cmdlet and look at its Parameters property  									Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  									if (command != null) {  										_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  										select "-" + parameter);  									}  								}  								intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  							}  						}  						if (intellisenseCandidates == null)  							intellisenseCandidates = new List<string> ();  					}  				}  			}  		}  		// Cycle to the next Intellisense candidate  		if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  			intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  			if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  				intellisenseCandidatesIndex = 0;  			else if (intellisenseCandidatesIndex < 0)  				intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  			string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  			// Remove the current token from the line and replace it with the current Intellisense candidate  			_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  			_currentInputLine.Insert (intellisenseStartLocation.Value' command);  			// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  			// candidate was shorter than the previous one  			RawUI.CursorPosition = promptStart;  			Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  			promptEnd = RawUI.CursorPosition;  			// Reposition the cursor properly to end of the Intellisense candidate  			RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  			insertPosition = intellisenseStartLocation.Value + command.Length;  			currentIntellisenseCommand = command;  		}  	} else if (intellisenseStartLocation != null) {  		intellisenseStartLocation = null;  		intellisenseCandidatesIndex = null;  		currentIntellisenseCommand = null;  		intellisenseCandidates.Clear ();  	}  	// Handle the BACKSPACE character  	if (currentByte == 8) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (insertPosition > 0) {  			// Remove the preceding character from _currentInputLine  			_currentInputLine.Remove (insertPosition - 1' 1);  			insertPosition--;  			currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  			// as a trailing space to cover the previous end character  			RawUI.CursorPosition = currentPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	} // In ANSI' the ESCAPE character means we're starting a special processing sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^7 translates to the HOME key  	else if (currentByte == 55 && inEscapeSequence) {  		RawUI.CursorPosition = promptStart;  		insertPosition = 0;  	} // ^8 translates to the END key  	else if (currentByte == 56 && inEscapeSequence) {  		RawUI.CursorPosition = promptEnd;  		insertPosition = _currentInputLine.Length;  	} // ^D translates to the left arrow' so we move the cursor backwards  	else if (currentByte == 68 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptStart) {  			RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  			insertPosition--;  		}  		inEscapeSequence = false;  	} // ^D translates to the right arrow' so we move the cursor forwards  	else if (currentByte == 67 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		if (RawUI.CursorPosition != promptEnd) {  			RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  			insertPosition++;  		}  		inEscapeSequence = false;  	} // ^D translates to the DELETE key' so we remove the current character  	else if (currentByte == 51 && inEscapeSequence) {  		Coordinates currentPosition = RawUI.CursorPosition;  		// If the cursor is somewhere other than the very start of the prompt  		if (RawUI.CursorPosition != promptEnd) {  			// Remove the current character from _currentInputLine  			_currentInputLine.Remove (insertPosition' 1);  			if (insertPosition < _currentInputLine.Length) {  				// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   				// character  				Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  				Write (" ");  				RawUI.CursorPosition = currentPosition;  				promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  			}  		}  		inEscapeSequence = false;  	} // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 65 && inEscapeSequence) {  		// If there are any preceding items in the history buffer  		if (AtCommandPrompt && _upCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_downCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _upCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  	else if (currentByte == 66 && inEscapeSequence) {  		// If there are any following items in the history buffer  		if (AtCommandPrompt && _downCommandHistory.Count > 0) {  			// Save the current history command  			if (!String.IsNullOrEmpty (_currentHistoryCommand))  				_upCommandHistory.Push (_currentHistoryCommand);  			_currentHistoryCommand = _downCommandHistory.Pop ();  			// Wipe out the current line entered by the user  			RawUI.CursorPosition = promptStart;  			Write (new string (' '' _currentInputLine.Length));  			// Move the cursor back to the start and write the history command  			RawUI.CursorPosition = promptStart;  			Write (_currentHistoryCommand);  			promptEnd = RawUI.CursorPosition;  			_currentInputLine = new StringBuilder (_currentHistoryCommand);  			insertPosition = _currentInputLine.Length;  		}  		inEscapeSequence = false;  	} // Handle the carriage return character; write a new line and exit the loop  	else if (currentByte == 13) {  		WriteLine ();  		foundCarriageReturn = true;  		break;  	} // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  	else if (currentByte >= 32) {  		inEscapeSequence = false;  		Write (Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  			currentByte  		}));  		insertPosition++;  		if (insertPosition < _currentInputLine.Length) {  			Coordinates currentPosition = RawUI.CursorPosition;  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			RawUI.CursorPosition = currentPosition;  		}  		promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  	} else  		inEscapeSequence = false;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 9) {  	// This is the first time that the user has activated tab completion (i.e. they haven't hit tab to bring up the first tab   	// completion command and then hit tab again to cycle through it)  	if (intellisenseStartLocation == null) {  		Token[] tokens;  		ParseError[] parseErrors;  		// Parse the current input line up to the cursor location  		Parser.ParseInput (_currentInputLine.ToString ().Substring (0' insertPosition)' out tokens' out parseErrors);  		// Get the last grammar token prior to the end of input  		Token currentToken = tokens.LastOrDefault (t => t.Kind != TokenKind.EndOfInput);  		if (currentToken != null && !String.IsNullOrEmpty (currentToken.Text)) {  			if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  				// Set the location that we're "Intellisensing" from' basically the location in the line that we're going to insert  				// the Intellisense candidates in  				intellisenseStartLocation = insertPosition - currentToken.Text.Length;  				intellisenseCandidatesIndex = -1;  				currentIntellisenseCommand = _currentInputLine.ToString ().Substring (intellisenseStartLocation.Value' insertPosition - intellisenseStartLocation.Value);  				// If the grammar token is a command name' an identifier' or a string literal  				if (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) || (currentToken.Kind == TokenKind.Identifier && currentToken.TokenFlags == TokenFlags.None) || (currentToken.Kind == TokenKind.Generic && currentToken.TokenFlags == TokenFlags.None) || currentToken.Kind == TokenKind.StringLiteral) {  					string match = currentToken.Text.Replace ("'"' "").Replace ("\""' "");  					string searchPath = null;  					if (match.Contains ("\\")) {  						// ReSharper disable StringLastIndexOfIsCultureSpecific.1  						searchPath = match.Substring (0' match.LastIndexOf ("\\") + 1);  						match = match.Substring (match.LastIndexOf ("\\") + 1);  						// ReSharper restore StringLastIndexOfIsCultureSpecific.1  					}  					// In addition to PowerShell commands' we're also going to return a list of available files in the search directory  					// (the current directory if there's no backslash in the token' or the text preceding the backslash if there is   					// one)  					IEnumerable<string> childItems = _executeHelper ("get-childitem -Filter '" + match + "*'" + (!String.IsNullOrEmpty (searchPath) ? " -Path '" + searchPath + "'" : "")).Select (i => String.IsNullOrEmpty (searchPath) ? ".\\" + i.ToString () : searchPath + i.ToString ());  					// Union the matching files and the matching commands to get the full list of Intellisense candidates  					intellisenseCandidates = (((currentToken.Kind == TokenKind.Generic || currentToken.Kind == TokenKind.Identifier) && currentToken.TokenFlags == TokenFlags.CommandName) ? _intellisenseCommands.Where (c => c.ToLower ().StartsWith (currentToken.Text.ToLower ())) : new List<string> ()).Union (childItems).Select (c => c.Contains (" ") ? "'" + c + "'" : c).OrderBy (c => c).ToList ();  				} // If the grammar token is a command parameter  				else if (currentToken.Kind == TokenKind.Parameter || (currentToken.Kind == TokenKind.Generic && (currentToken.TokenFlags & TokenFlags.BinaryPrecedenceAdd) == TokenFlags.BinaryPrecedenceAdd)) {  					List<Token> tokenList = tokens.ToList ();  					if (tokenList.IndexOf (currentToken) > 0) {  						// Get the token representing the name of the command for this parameter  						int commandTokenIndex = tokenList.FindLastIndex (tokenList.IndexOf (currentToken) - 1' tokenList.IndexOf (currentToken)' t => t.TokenFlags == TokenFlags.CommandName);  						if (commandTokenIndex != -1) {  							Token commandToken = tokens [commandTokenIndex];  							// Get the list of parameters for the command if we don't have it already  							if (!_intellisenseParameters.ContainsKey (commandToken.Text.ToLower ())) {  								_intellisenseParameters [commandToken.Text.ToLower ()] = new List<string> ();  								// Run the "Get-Command" cmdlet and look at its Parameters property  								Collection<PSObject> command = _executeHelper ("get-command " + commandToken.Text);  								if (command != null) {  									_intellisenseParameters [commandToken.Text.ToLower ()].AddRange (from parameter in (command [0].Properties ["Parameters"].Value as Dictionary<string' ParameterMetadata>).Keys  									select "-" + parameter);  								}  							}  							intellisenseCandidates = _intellisenseParameters [commandToken.Text.ToLower ()].Where (p => p.ToLower ().StartsWith (currentToken.Text.ToLower ())).OrderBy (p => p).ToList ();  						}  					}  					if (intellisenseCandidates == null)  						intellisenseCandidates = new List<string> ();  				}  			}  		}  	}  	// Cycle to the next Intellisense candidate  	if (intellisenseStartLocation != null && intellisenseCandidates.Count > 0) {  		intellisenseCandidatesIndex += _terminal.TerminalPane.ShiftKeyDown ? -1 : 1;  		if (intellisenseCandidatesIndex >= intellisenseCandidates.Count)  			intellisenseCandidatesIndex = 0;  		else if (intellisenseCandidatesIndex < 0)  			intellisenseCandidatesIndex = intellisenseCandidates.Count - 1;  		string command = intellisenseCandidates [intellisenseCandidatesIndex.Value];  		// Remove the current token from the line and replace it with the current Intellisense candidate  		_currentInputLine.Remove (intellisenseStartLocation.Value' currentIntellisenseCommand.Length);  		_currentInputLine.Insert (intellisenseStartLocation.Value' command);  		// Move the cursor to the start of the prompt and re-write the current line' appending spaces if the current Intellisense  		// candidate was shorter than the previous one  		RawUI.CursorPosition = promptStart;  		Write (_currentInputLine + (currentIntellisenseCommand.Length > command.Length ? new string (' '' currentIntellisenseCommand.Length - command.Length) : ""));  		promptEnd = RawUI.CursorPosition;  		// Reposition the cursor properly to end of the Intellisense candidate  		RawUI.CursorPosition = new Coordinates ((promptStart.X + intellisenseStartLocation.Value + command.Length) % RawUI.BufferSize.Width' promptStart.Y + Convert.ToInt32 (Math.Floor ((promptStart.X + intellisenseStartLocation.Value + command.Length) / (double)RawUI.BufferSize.Width)));  		insertPosition = intellisenseStartLocation.Value + command.Length;  		currentIntellisenseCommand = command;  	}  } else if (intellisenseStartLocation != null) {  	intellisenseStartLocation = null;  	intellisenseCandidatesIndex = null;  	currentIntellisenseCommand = null;  	intellisenseCandidates.Clear ();  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (insertPosition > 0) {  		// Remove the preceding character from _currentInputLine  		_currentInputLine.Remove (insertPosition - 1' 1);  		insertPosition--;  		currentPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		// Move the cursor to the current input position and re-emit the rest of the line (minus the character that we removed) as well  		// as a trailing space to cover the previous end character  		RawUI.CursorPosition = currentPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		Write (" ");  		RawUI.CursorPosition = currentPosition;  		promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  	}  } // In ANSI' the ESCAPE character means we're starting a special processing sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence and we see a "[" or a "~"' simply continue on to the next character in the stream  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^7 translates to the HOME key  else if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	RawUI.CursorPosition = promptStart;  	insertPosition = 0;  } // ^8 translates to the END key  else if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 56 && inEscapeSequence) {  	RawUI.CursorPosition = promptEnd;  	insertPosition = _currentInputLine.Length;  } // ^D translates to the left arrow' so we move the cursor backwards  else if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptStart) {  		RawUI.CursorPosition = currentPosition.X > 1 ? new Coordinates (currentPosition.X - 1' currentPosition.Y) : new Coordinates (RawUI.BufferSize.Width' currentPosition.Y - 1);  		insertPosition--;  	}  	inEscapeSequence = false;  } // ^D translates to the right arrow' so we move the cursor forwards  else if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 67 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	if (RawUI.CursorPosition != promptEnd) {  		RawUI.CursorPosition = currentPosition.X < RawUI.BufferSize.Width ? new Coordinates (currentPosition.X + 1' currentPosition.Y) : new Coordinates (1' currentPosition.Y + 1);  		insertPosition++;  	}  	inEscapeSequence = false;  } // ^D translates to the DELETE key' so we remove the current character  else if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 51 && inEscapeSequence) {  	Coordinates currentPosition = RawUI.CursorPosition;  	// If the cursor is somewhere other than the very start of the prompt  	if (RawUI.CursorPosition != promptEnd) {  		// Remove the current character from _currentInputLine  		_currentInputLine.Remove (insertPosition' 1);  		if (insertPosition < _currentInputLine.Length) {  			// Re-emit the rest of the line (minus the character that we removed) as well as a trailing space to cover the previous end   			// character  			Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  			Write (" ");  			RawUI.CursorPosition = currentPosition;  			promptEnd = promptEnd.X > 1 ? new Coordinates (promptEnd.X - 1' promptEnd.Y) : new Coordinates (RawUI.BufferSize.Width' promptEnd.Y - 1);  		}  	}  	inEscapeSequence = false;  } // ^A translates to the up arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 65 && inEscapeSequence) {  	// If there are any preceding items in the history buffer  	if (AtCommandPrompt && _upCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_downCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _upCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // ^A translates to the down arrow' so we move to the previous (if any) entry in the history buffer  else if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 66 && inEscapeSequence) {  	// If there are any following items in the history buffer  	if (AtCommandPrompt && _downCommandHistory.Count > 0) {  		// Save the current history command  		if (!String.IsNullOrEmpty (_currentHistoryCommand))  			_upCommandHistory.Push (_currentHistoryCommand);  		_currentHistoryCommand = _downCommandHistory.Pop ();  		// Wipe out the current line entered by the user  		RawUI.CursorPosition = promptStart;  		Write (new string (' '' _currentInputLine.Length));  		// Move the cursor back to the start and write the history command  		RawUI.CursorPosition = promptStart;  		Write (_currentHistoryCommand);  		promptEnd = RawUI.CursorPosition;  		_currentInputLine = new StringBuilder (_currentHistoryCommand);  		insertPosition = _currentInputLine.Length;  	}  	inEscapeSequence = false;  } // Handle the carriage return character; write a new line and exit the loop  else if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 13) {  	WriteLine ();  	foundCarriageReturn = true;  	break;  } // Otherwise' if it's an ASCII character' write it to the console and add it to _currentInputLine  else if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (currentByte >= 32) {  	inEscapeSequence = false;  	Write (Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	_currentInputLine.Insert (insertPosition' Encoding.UTF8.GetString (new byte[] {  		currentByte  	}));  	insertPosition++;  	if (insertPosition < _currentInputLine.Length) {  		Coordinates currentPosition = RawUI.CursorPosition;  		Write (_currentInputLine.ToString (insertPosition' _currentInputLine.Length - insertPosition));  		RawUI.CursorPosition = currentPosition;  	}  	promptEnd = promptEnd.X < RawUI.BufferSize.Width ? new Coordinates (promptEnd.X + 1' promptEnd.Y) : new Coordinates (1' promptEnd.Y + 1);  } else  	inEscapeSequence = false;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: if (!foundCarriageReturn)  	Thread.Sleep (50);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,ReadInput,The following statement contains a magic number: Thread.Sleep (50);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,WriteProgress,The following statement contains a magic number: if (_progressBar.Value == 100) {  	_timer.Enabled = true;  	_timer.Interval = 1000;  	_timer.Elapsed += _timer_Elapsed;  	_timer.Start ();  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,WriteProgress,The following statement contains a magic number: if (_progressBar.Value == 100) {  	_timer.Enabled = true;  	_timer.Interval = 1000;  	_timer.Elapsed += _timer_Elapsed;  	_timer.Start ();  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,WriteProgress,The following statement contains a magic number: _timer.Interval = 1000;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellHostUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellHostUi.cs,GetHotkeyAndLabel,The following statement contains a magic number: if (fragments.Length == 2) {  	if (fragments [1].Length > 0)  		result [0] = fragments [1] [0].ToString ().ToUpper (CultureInfo.CurrentCulture);  	result [1] = (fragments [0] + fragments [1]).Trim ();  } else  	result [1] = input;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._flowLayoutPanel.Location = new System.Drawing.Point (0' 61);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._flowLayoutPanel.Padding = new System.Windows.Forms.Padding (15' 0' 15' 15);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._flowLayoutPanel.Padding = new System.Windows.Forms.Padding (15' 0' 15' 15);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._flowLayoutPanel.Padding = new System.Windows.Forms.Padding (15' 0' 15' 15);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._flowLayoutPanel.Size = new System.Drawing.Size (721' 451);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._flowLayoutPanel.Size = new System.Drawing.Size (721' 451);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._flowLayoutPanel.TabIndex = 84;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostPanel.Location = new System.Drawing.Point (18' 3);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostPanel.Location = new System.Drawing.Point (18' 3);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostPanel.Size = new System.Drawing.Size (684' 68);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostPanel.Size = new System.Drawing.Size (684' 68);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostPanel.TabIndex = 84;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostNameLabel.Location = new System.Drawing.Point (31' 38);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostNameLabel.Location = new System.Drawing.Point (31' 38);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostNameLabel.Size = new System.Drawing.Size (71' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostNameLabel.Size = new System.Drawing.Size (71' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostNameLabel.TabIndex = 53;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostNameTextBox.Location = new System.Drawing.Point (108' 39);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostNameTextBox.Location = new System.Drawing.Point (108' 39);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostNameTextBox.Size = new System.Drawing.Size (154' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostNameTextBox.Size = new System.Drawing.Size (154' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostNameTextBox.TabIndex = 52;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostLabel.Location = new System.Drawing.Point (8' 11);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostLabel.Location = new System.Drawing.Point (8' 11);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostLabel.Size = new System.Drawing.Size (35' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostLabel.Size = new System.Drawing.Size (35' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._hostLabel.TabIndex = 54;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._generalPanel.Location = new System.Drawing.Point (18' 77);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._generalPanel.Location = new System.Drawing.Point (18' 77);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._generalPanel.Size = new System.Drawing.Size (684' 94);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._generalPanel.Size = new System.Drawing.Size (684' 94);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._generalPanel.TabIndex = 83;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._passwordTextBox.Location = new System.Drawing.Point (108' 63);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._passwordTextBox.Location = new System.Drawing.Point (108' 63);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._passwordTextBox.Size = new System.Drawing.Size (154' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._passwordTextBox.Size = new System.Drawing.Size (154' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._passwordTextBox.TabIndex = 93;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._inheritedPasswordLabel.Location = new System.Drawing.Point (268' 66);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._inheritedPasswordLabel.Location = new System.Drawing.Point (268' 66);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._inheritedPasswordLabel.Size = new System.Drawing.Size (263' 16);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._inheritedPasswordLabel.Size = new System.Drawing.Size (263' 16);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._inheritedPasswordLabel.TabIndex = 92;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._inheritedUsernameLabel.Location = new System.Drawing.Point (268' 42);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._inheritedUsernameLabel.Location = new System.Drawing.Point (268' 42);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._inheritedUsernameLabel.Size = new System.Drawing.Size (263' 16);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._inheritedUsernameLabel.Size = new System.Drawing.Size (263' 16);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._inheritedUsernameLabel.TabIndex = 91;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._userNameLabel.Location = new System.Drawing.Point (31' 37);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._userNameLabel.Location = new System.Drawing.Point (31' 37);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._userNameLabel.Size = new System.Drawing.Size (64' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._userNameLabel.Size = new System.Drawing.Size (64' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._userNameLabel.TabIndex = 49;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._userNameTextBox.Location = new System.Drawing.Point (108' 39);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._userNameTextBox.Location = new System.Drawing.Point (108' 39);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._userNameTextBox.Size = new System.Drawing.Size (154' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._userNameTextBox.Size = new System.Drawing.Size (154' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._userNameTextBox.TabIndex = 48;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._passwordLabel.Location = new System.Drawing.Point (31' 63);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._passwordLabel.Location = new System.Drawing.Point (31' 63);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._passwordLabel.Size = new System.Drawing.Size (63' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._passwordLabel.Size = new System.Drawing.Size (63' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._passwordLabel.TabIndex = 50;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._generalLabel.Location = new System.Drawing.Point (8' 11);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._generalLabel.Location = new System.Drawing.Point (8' 11);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._generalLabel.Size = new System.Drawing.Size (53' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._generalLabel.Size = new System.Drawing.Size (53' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._generalLabel.TabIndex = 51;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._displayPanel.Location = new System.Drawing.Point (18' 177);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._displayPanel.Location = new System.Drawing.Point (18' 177);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._displayPanel.Size = new System.Drawing.Size (684' 116);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._displayPanel.Size = new System.Drawing.Size (684' 116);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._displayPanel.TabIndex = 86;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontBrowseButton.Location = new System.Drawing.Point (307' 85);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontBrowseButton.Location = new System.Drawing.Point (307' 85);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontBrowseButton.Size = new System.Drawing.Size (26' 22);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontBrowseButton.Size = new System.Drawing.Size (26' 22);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontBrowseButton.TabIndex = 88;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontTextBox.Location = new System.Drawing.Point (148' 86);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontTextBox.Location = new System.Drawing.Point (148' 86);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontTextBox.Size = new System.Drawing.Size (154' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontTextBox.Size = new System.Drawing.Size (154' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontTextBox.TabIndex = 85;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontLabel.Location = new System.Drawing.Point (31' 86);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontLabel.Location = new System.Drawing.Point (31' 86);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontLabel.Size = new System.Drawing.Size (92' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontLabel.Size = new System.Drawing.Size (92' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._fontLabel.TabIndex = 84;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._textColorPanel.Location = new System.Drawing.Point (148' 62);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._textColorPanel.Location = new System.Drawing.Point (148' 62);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._textColorPanel.Size = new System.Drawing.Size (35' 21);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._textColorPanel.Size = new System.Drawing.Size (35' 21);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._textColorPanel.TabIndex = 83;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._textColorLabel.Location = new System.Drawing.Point (31' 62);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._textColorLabel.Location = new System.Drawing.Point (31' 62);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._textColorLabel.Size = new System.Drawing.Size (99' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._textColorLabel.Size = new System.Drawing.Size (99' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._textColorLabel.TabIndex = 82;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._backgroundColorPanel.BackColor = System.Drawing.Color.FromArgb (((int)(((byte)(0))))' ((int)(((byte)(0))))' ((int)(((byte)(64)))));  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._backgroundColorPanel.Location = new System.Drawing.Point (148' 39);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._backgroundColorPanel.Location = new System.Drawing.Point (148' 39);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._backgroundColorPanel.Size = new System.Drawing.Size (35' 21);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._backgroundColorPanel.Size = new System.Drawing.Size (35' 21);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._backgroundColorPanel.TabIndex = 81;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._displayLabel.Location = new System.Drawing.Point (8' 11);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._displayLabel.Location = new System.Drawing.Point (8' 11);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._displayLabel.Size = new System.Drawing.Size (50' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._displayLabel.Size = new System.Drawing.Size (50' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._displayLabel.TabIndex = 55;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._backgroundColorLabel.Location = new System.Drawing.Point (31' 38);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._backgroundColorLabel.Location = new System.Drawing.Point (31' 38);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._backgroundColorLabel.Size = new System.Drawing.Size (108' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._backgroundColorLabel.Size = new System.Drawing.Size (108' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._backgroundColorLabel.TabIndex = 54;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point (18' 299);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point (18' 299);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size (684' 115);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size (684' 115);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.panel2.TabIndex = 88;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._clearScreenKeysLabel.Location = new System.Drawing.Point (113' 91);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._clearScreenKeysLabel.Location = new System.Drawing.Point (113' 91);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._clearScreenKeysLabel.Size = new System.Drawing.Size (36' 13);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._clearScreenKeysLabel.Size = new System.Drawing.Size (36' 13);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._clearScreenKeysLabel.TabIndex = 92;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._clearScreenLabel.Location = new System.Drawing.Point (31' 87);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._clearScreenLabel.Location = new System.Drawing.Point (31' 87);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._clearScreenLabel.Size = new System.Drawing.Size (150' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._clearScreenLabel.Size = new System.Drawing.Size (150' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._clearScreenLabel.TabIndex = 91;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._pasteKeysLabel.Location = new System.Drawing.Point (112' 66);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._pasteKeysLabel.Location = new System.Drawing.Point (112' 66);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._pasteKeysLabel.Size = new System.Drawing.Size (37' 13);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._pasteKeysLabel.Size = new System.Drawing.Size (37' 13);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._pasteKeysLabel.TabIndex = 90;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._copyKeysLabel.Location = new System.Drawing.Point (112' 41);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._copyKeysLabel.Location = new System.Drawing.Point (112' 41);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._copyKeysLabel.Size = new System.Drawing.Size (37' 13);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._copyKeysLabel.Size = new System.Drawing.Size (37' 13);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._copyKeysLabel.TabIndex = 89;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._pasteLabel.Location = new System.Drawing.Point (31' 62);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._pasteLabel.Location = new System.Drawing.Point (31' 62);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._pasteLabel.Size = new System.Drawing.Size (150' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._pasteLabel.Size = new System.Drawing.Size (150' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._pasteLabel.TabIndex = 82;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._shortcutsLabel.Location = new System.Drawing.Point (8' 11);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._shortcutsLabel.Location = new System.Drawing.Point (8' 11);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._shortcutsLabel.Size = new System.Drawing.Size (87' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._shortcutsLabel.Size = new System.Drawing.Size (87' 17);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._shortcutsLabel.TabIndex = 55;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._copyLabel.Location = new System.Drawing.Point (31' 37);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._copyLabel.Location = new System.Drawing.Point (31' 37);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._copyLabel.Size = new System.Drawing.Size (150' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._copyLabel.Size = new System.Drawing.Size (150' 20);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._copyLabel.TabIndex = 54;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point (29' 62);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point (29' 62);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size (667' 1);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.panel1.TabIndex = 86;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._titleLabel.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(92))))' ((int)(((byte)(97))))' ((int)(((byte)(102)))));  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._titleLabel.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(92))))' ((int)(((byte)(97))))' ((int)(((byte)(102)))));  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._titleLabel.ForeColor = System.Drawing.Color.FromArgb (((int)(((byte)(92))))' ((int)(((byte)(97))))' ((int)(((byte)(102)))));  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._titleLabel.Location = new System.Drawing.Point (24' 19);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._titleLabel.Location = new System.Drawing.Point (24' 19);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._titleLabel.Size = new System.Drawing.Size (193' 30);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._titleLabel.Size = new System.Drawing.Size (193' 30);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this._titleLabel.TabIndex = 85;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.BackColor = System.Drawing.Color.FromArgb (((int)(((byte)(249))))' ((int)(((byte)(249))))' ((int)(((byte)(249)))));  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.BackColor = System.Drawing.Color.FromArgb (((int)(((byte)(249))))' ((int)(((byte)(249))))' ((int)(((byte)(249)))));  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.BackColor = System.Drawing.Color.FromArgb (((int)(((byte)(249))))' ((int)(((byte)(249))))' ((int)(((byte)(249)))));  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (721' 516);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellOptionsForm,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellOptionsForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (721' 516);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ClosestConsoleColor,The following statement contains a magic number: foreach (ConsoleColor consoleColor in Enum.GetValues (typeof(ConsoleColor))) {  	Color consoleColorColor = Color.FromName (consoleColor.ToString ("G") == "DarkYellow" ? "Orange" : consoleColor.ToString ("G"));  	double t = Math.Pow (consoleColorColor.R - r' 2.0) + Math.Pow (consoleColorColor.G - g' 2.0) + Math.Pow (consoleColorColor.B - b' 2.0);  	// ReSharper disable CompareOfFloatsByEqualityOperator  	if (t == 0)  		// ReSharper restore CompareOfFloatsByEqualityOperator  		return consoleColor;  	if (t < delta) {  		delta = t;  		returnColor = consoleColor;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ClosestConsoleColor,The following statement contains a magic number: foreach (ConsoleColor consoleColor in Enum.GetValues (typeof(ConsoleColor))) {  	Color consoleColorColor = Color.FromName (consoleColor.ToString ("G") == "DarkYellow" ? "Orange" : consoleColor.ToString ("G"));  	double t = Math.Pow (consoleColorColor.R - r' 2.0) + Math.Pow (consoleColorColor.G - g' 2.0) + Math.Pow (consoleColorColor.B - b' 2.0);  	// ReSharper disable CompareOfFloatsByEqualityOperator  	if (t == 0)  		// ReSharper restore CompareOfFloatsByEqualityOperator  		return consoleColor;  	if (t < delta) {  		delta = t;  		returnColor = consoleColor;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ClosestConsoleColor,The following statement contains a magic number: foreach (ConsoleColor consoleColor in Enum.GetValues (typeof(ConsoleColor))) {  	Color consoleColorColor = Color.FromName (consoleColor.ToString ("G") == "DarkYellow" ? "Orange" : consoleColor.ToString ("G"));  	double t = Math.Pow (consoleColorColor.R - r' 2.0) + Math.Pow (consoleColorColor.G - g' 2.0) + Math.Pow (consoleColorColor.B - b' 2.0);  	// ReSharper disable CompareOfFloatsByEqualityOperator  	if (t == 0)  		// ReSharper restore CompareOfFloatsByEqualityOperator  		return consoleColor;  	if (t < delta) {  		delta = t;  		returnColor = consoleColor;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (!readKey) {  	if (connection.OutputQueue.Count > 0) {  		while (connection.OutputQueue.Count > 0) {  			byte currentByte = connection.OutputQueue.Dequeue ();  			// Handle the backspace key  			if (currentByte == 8) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 8  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // The ^X character signifies the start of an ANSI escape sequence  			else if (currentByte == 27)  				inEscapeSequence = true;  			// If we're in an escape sequence' read past the "[" and "~" characters  			else if (currentByte == 91 && inEscapeSequence) {  			} else if (currentByte == 126 && inEscapeSequence) {  			} // ^X7 is the home key  			else if (currentByte == 55 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x24  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^X8 or ^X3 is the end key  			else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x23  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XD is the left arrow  			else if (currentByte == 68 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x25  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  					CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  				readKey = true;  				break;  			} // ^XC is the right arrow  			else if (currentByte == 67 && inEscapeSequence) {  				_readKey = new KeyInfo {  					VirtualKeyCode = 0x27  				};  				// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  					CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  				readKey = true;  				break;  			} // Handle the carriage return sequence  			else if (currentByte == 13) {  				_readKey = new KeyInfo {  					Character = '\r''  					VirtualKeyCode = 0x0D  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  					CursorPosition = new Coordinates (1' CursorPosition.Y);  				readKey = true;  				break;  			} // Otherwise' get the virtual key code and character and populate _readKey  			else {  				short virtualKey = User32.VkKeyScan ((char)currentByte);  				int modifiers = virtualKey >> 8;  				ControlKeyStates controlKeys = 0;  				if ((modifiers & 2) != 0)  					controlKeys |= ControlKeyStates.LeftCtrlPressed;  				if ((modifiers & 4) != 0)  					controlKeys |= ControlKeyStates.LeftAltPressed;  				_readKey = new KeyInfo {  					Character = (char)currentByte'  					VirtualKeyCode = (virtualKey & 0xFF)'  					ControlKeyState = controlKeys  				};  				if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  					_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  						currentByte  					}' 0' 1);  				}  				readKey = true;  				break;  			}  		}  	}  	// If we didn't read a key' sleep for a bit  	if (!readKey)  		Thread.Sleep (50);  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (connection.OutputQueue.Count > 0) {  	while (connection.OutputQueue.Count > 0) {  		byte currentByte = connection.OutputQueue.Dequeue ();  		// Handle the backspace key  		if (currentByte == 8) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 8  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // The ^X character signifies the start of an ANSI escape sequence  		else if (currentByte == 27)  			inEscapeSequence = true;  		// If we're in an escape sequence' read past the "[" and "~" characters  		else if (currentByte == 91 && inEscapeSequence) {  		} else if (currentByte == 126 && inEscapeSequence) {  		} // ^X7 is the home key  		else if (currentByte == 55 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x24  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^X8 or ^X3 is the end key  		else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x23  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XD is the left arrow  		else if (currentByte == 68 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x25  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  				CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  			readKey = true;  			break;  		} // ^XC is the right arrow  		else if (currentByte == 67 && inEscapeSequence) {  			_readKey = new KeyInfo {  				VirtualKeyCode = 0x27  			};  			// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  				CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  			readKey = true;  			break;  		} // Handle the carriage return sequence  		else if (currentByte == 13) {  			_readKey = new KeyInfo {  				Character = '\r''  				VirtualKeyCode = 0x0D  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  				CursorPosition = new Coordinates (1' CursorPosition.Y);  			readKey = true;  			break;  		} // Otherwise' get the virtual key code and character and populate _readKey  		else {  			short virtualKey = User32.VkKeyScan ((char)currentByte);  			int modifiers = virtualKey >> 8;  			ControlKeyStates controlKeys = 0;  			if ((modifiers & 2) != 0)  				controlKeys |= ControlKeyStates.LeftCtrlPressed;  			if ((modifiers & 4) != 0)  				controlKeys |= ControlKeyStates.LeftAltPressed;  			_readKey = new KeyInfo {  				Character = (char)currentByte'  				VirtualKeyCode = (virtualKey & 0xFF)'  				ControlKeyState = controlKeys  			};  			if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  				_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  					currentByte  				}' 0' 1);  			}  			readKey = true;  			break;  		}  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: while (connection.OutputQueue.Count > 0) {  	byte currentByte = connection.OutputQueue.Dequeue ();  	// Handle the backspace key  	if (currentByte == 8) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 8  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // The ^X character signifies the start of an ANSI escape sequence  	else if (currentByte == 27)  		inEscapeSequence = true;  	// If we're in an escape sequence' read past the "[" and "~" characters  	else if (currentByte == 91 && inEscapeSequence) {  	} else if (currentByte == 126 && inEscapeSequence) {  	} // ^X7 is the home key  	else if (currentByte == 55 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x24  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^X8 or ^X3 is the end key  	else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x23  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XD is the left arrow  	else if (currentByte == 68 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x25  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  			CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  		readKey = true;  		break;  	} // ^XC is the right arrow  	else if (currentByte == 67 && inEscapeSequence) {  		_readKey = new KeyInfo {  			VirtualKeyCode = 0x27  		};  		// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  			CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  		readKey = true;  		break;  	} // Handle the carriage return sequence  	else if (currentByte == 13) {  		_readKey = new KeyInfo {  			Character = '\r''  			VirtualKeyCode = 0x0D  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  			CursorPosition = new Coordinates (1' CursorPosition.Y);  		readKey = true;  		break;  	} // Otherwise' get the virtual key code and character and populate _readKey  	else {  		short virtualKey = User32.VkKeyScan ((char)currentByte);  		int modifiers = virtualKey >> 8;  		ControlKeyStates controlKeys = 0;  		if ((modifiers & 2) != 0)  			controlKeys |= ControlKeyStates.LeftCtrlPressed;  		if ((modifiers & 4) != 0)  			controlKeys |= ControlKeyStates.LeftAltPressed;  		_readKey = new KeyInfo {  			Character = (char)currentByte'  			VirtualKeyCode = (virtualKey & 0xFF)'  			ControlKeyState = controlKeys  		};  		if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  			_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  				currentByte  			}' 0' 1);  		}  		readKey = true;  		break;  	}  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 8) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 8  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // The ^X character signifies the start of an ANSI escape sequence  else if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: _readKey = new KeyInfo {  	VirtualKeyCode = 8  };  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 27)  	inEscapeSequence = true;  // If we're in an escape sequence' read past the "[" and "~" characters  else if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 91 && inEscapeSequence) {  } else if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 126 && inEscapeSequence) {  } // ^X7 is the home key  else if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 55 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x24  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the start of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // ^X8 or ^X3 is the end key  else if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if ((currentByte == 56 || currentByte == 51) && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x23  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor to the end of the line  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (BufferSize.Width' CursorPosition.Y);  	readKey = true;  	break;  } // ^XD is the left arrow  else if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 68 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x25  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor left  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X > 1)  		CursorPosition = new Coordinates (CursorPosition.X - 1' CursorPosition.Y);  	readKey = true;  	break;  } // ^XC is the right arrow  else if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 67 && inEscapeSequence) {  	_readKey = new KeyInfo {  		VirtualKeyCode = 0x27  	};  	// If we're not already at the beginning of the line and we're echoing the output' move the cursor right  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho && CursorPosition.X < BufferSize.Width)  		CursorPosition = new Coordinates (CursorPosition.X + 1' CursorPosition.Y);  	readKey = true;  	break;  } // Handle the carriage return sequence  else if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (currentByte == 13) {  	_readKey = new KeyInfo {  		Character = '\r''  		VirtualKeyCode = 0x0D  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho)  		CursorPosition = new Coordinates (1' CursorPosition.Y);  	readKey = true;  	break;  } // Otherwise' get the virtual key code and character and populate _readKey  else {  	short virtualKey = User32.VkKeyScan ((char)currentByte);  	int modifiers = virtualKey >> 8;  	ControlKeyStates controlKeys = 0;  	if ((modifiers & 2) != 0)  		controlKeys |= ControlKeyStates.LeftCtrlPressed;  	if ((modifiers & 4) != 0)  		controlKeys |= ControlKeyStates.LeftAltPressed;  	_readKey = new KeyInfo {  		Character = (char)currentByte'  		VirtualKeyCode = (virtualKey & 0xFF)'  		ControlKeyState = controlKeys  	};  	if ((options & ReadKeyOptions.NoEcho) != ReadKeyOptions.NoEcho) {  		_terminal.TerminalPane.ConnectionTag.Receiver.DataArrived (new byte[] {  			currentByte  		}' 0' 1);  	}  	readKey = true;  	break;  }  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if ((modifiers & 2) != 0)  	controlKeys |= ControlKeyStates.LeftCtrlPressed;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if ((modifiers & 4) != 0)  	controlKeys |= ControlKeyStates.LeftAltPressed;  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: if (!readKey)  	Thread.Sleep (50);  
Magic Number,EasyConnect.Protocols.PowerShell,PowerShellRawUi,F:\newReposMay17\lstratman_EasyConnect\Protocols\PowerShell\PowerShellRawUi.cs,ReadInput,The following statement contains a magic number: Thread.Sleep (50);  
