Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Bespoke.Common.Osc,OscServer,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscServer.cs,OscServer,The method has 5 parameters. Parameters: transportType' ipAddress' port' multicastAddress' transmissionType
Long Parameter List,Bespoke.Common.Osc,OscServer,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscServer.cs,OscServer,The method has 6 parameters. Parameters: transportType' ipAddress' port' multicastAddress' transmissionType' consumeParsingExceptions
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String")  			{  				int count = 0;  				for (int index = start; index < data.Length && data[index] != 0; index++)  				{  					count++;  				}    				value = Encoding.ASCII.GetString(data' start' count);  				start += count + 1;  				start = ((start + 3) / 4) * 4;                    Assert.IsTrue(((String)value).Length > 0);  			}  			else if (type.Name == "Byte[]")  			{                  int length = ValueFromByteArray<int>(data' ref start);                  byte[] buffer = new byte[length];                  Array.Copy(data' start' buffer' 0' buffer.Length);                  start += buffer.Length + 1;                  start = ((start + 3) / 4) * 4;                    value = buffer;  			}  			else  			{  				byte[] buffer;  				switch (type.Name)  				{  					case "Int32":  					case "Single":  						buffer = new byte[4];  						break;    					case "Int64":  					case "Double":  						buffer = new byte[8];  						break;    					default:  						throw new Exception("Unsupported data type.");  				}    				Array.Copy(data' start' buffer' 0' buffer.Length);  				start += buffer.Length;                    if (BitConverter.IsLittleEndian != sLittleEndianByteOrder)  				{  					buffer = Library.SwapEndian(buffer);  				}    				switch (type.Name)  				{  					case "Int32":  						value = BitConverter.ToInt32(buffer' 0);  						break;    					case "Int64":  						value = BitConverter.ToInt64(buffer' 0);  						break;    					case "Single":  						value = BitConverter.ToSingle(buffer' 0);  						break;    					case "Double":  						value = BitConverter.ToDouble(buffer' 0);  						break;    					default:  						throw new Exception("Unsupported data type.");  				}  			}
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String")  			{  				int count = 0;  				for (int index = start; index < data.Length && data[index] != 0; index++)  				{  					count++;  				}    				value = Encoding.ASCII.GetString(data' start' count);  				start += count + 1;  				start = ((start + 3) / 4) * 4;                    Assert.IsTrue(((String)value).Length > 0);  			}  			else if (type.Name == "Byte[]")  			{                  int length = ValueFromByteArray<int>(data' ref start);                  byte[] buffer = new byte[length];                  Array.Copy(data' start' buffer' 0' buffer.Length);                  start += buffer.Length + 1;                  start = ((start + 3) / 4) * 4;                    value = buffer;  			}  			else  			{  				byte[] buffer;  				switch (type.Name)  				{  					case "Int32":  					case "Single":  						buffer = new byte[4];  						break;    					case "Int64":  					case "Double":  						buffer = new byte[8];  						break;    					default:  						throw new Exception("Unsupported data type.");  				}    				Array.Copy(data' start' buffer' 0' buffer.Length);  				start += buffer.Length;                    if (BitConverter.IsLittleEndian != sLittleEndianByteOrder)  				{  					buffer = Library.SwapEndian(buffer);  				}    				switch (type.Name)  				{  					case "Int32":  						value = BitConverter.ToInt32(buffer' 0);  						break;    					case "Int64":  						value = BitConverter.ToInt64(buffer' 0);  						break;    					case "Single":  						value = BitConverter.ToSingle(buffer' 0);  						break;    					case "Double":  						value = BitConverter.ToDouble(buffer' 0);  						break;    					default:  						throw new Exception("Unsupported data type.");  				}  			}
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String")  			{  				int count = 0;  				for (int index = start; index < data.Length && data[index] != 0; index++)  				{  					count++;  				}    				value = Encoding.ASCII.GetString(data' start' count);  				start += count + 1;  				start = ((start + 3) / 4) * 4;                    Assert.IsTrue(((String)value).Length > 0);  			}  			else if (type.Name == "Byte[]")  			{                  int length = ValueFromByteArray<int>(data' ref start);                  byte[] buffer = new byte[length];                  Array.Copy(data' start' buffer' 0' buffer.Length);                  start += buffer.Length + 1;                  start = ((start + 3) / 4) * 4;                    value = buffer;  			}  			else  			{  				byte[] buffer;  				switch (type.Name)  				{  					case "Int32":  					case "Single":  						buffer = new byte[4];  						break;    					case "Int64":  					case "Double":  						buffer = new byte[8];  						break;    					default:  						throw new Exception("Unsupported data type.");  				}    				Array.Copy(data' start' buffer' 0' buffer.Length);  				start += buffer.Length;                    if (BitConverter.IsLittleEndian != sLittleEndianByteOrder)  				{  					buffer = Library.SwapEndian(buffer);  				}    				switch (type.Name)  				{  					case "Int32":  						value = BitConverter.ToInt32(buffer' 0);  						break;    					case "Int64":  						value = BitConverter.ToInt64(buffer' 0);  						break;    					case "Single":  						value = BitConverter.ToSingle(buffer' 0);  						break;    					case "Double":  						value = BitConverter.ToDouble(buffer' 0);  						break;    					default:  						throw new Exception("Unsupported data type.");  				}  			}
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String")  			{  				int count = 0;  				for (int index = start; index < data.Length && data[index] != 0; index++)  				{  					count++;  				}    				value = Encoding.ASCII.GetString(data' start' count);  				start += count + 1;  				start = ((start + 3) / 4) * 4;                    Assert.IsTrue(((String)value).Length > 0);  			}  			else if (type.Name == "Byte[]")  			{                  int length = ValueFromByteArray<int>(data' ref start);                  byte[] buffer = new byte[length];                  Array.Copy(data' start' buffer' 0' buffer.Length);                  start += buffer.Length + 1;                  start = ((start + 3) / 4) * 4;                    value = buffer;  			}  			else  			{  				byte[] buffer;  				switch (type.Name)  				{  					case "Int32":  					case "Single":  						buffer = new byte[4];  						break;    					case "Int64":  					case "Double":  						buffer = new byte[8];  						break;    					default:  						throw new Exception("Unsupported data type.");  				}    				Array.Copy(data' start' buffer' 0' buffer.Length);  				start += buffer.Length;                    if (BitConverter.IsLittleEndian != sLittleEndianByteOrder)  				{  					buffer = Library.SwapEndian(buffer);  				}    				switch (type.Name)  				{  					case "Int32":  						value = BitConverter.ToInt32(buffer' 0);  						break;    					case "Int64":  						value = BitConverter.ToInt64(buffer' 0);  						break;    					case "Single":  						value = BitConverter.ToSingle(buffer' 0);  						break;    					case "Double":  						value = BitConverter.ToDouble(buffer' 0);  						break;    					default:  						throw new Exception("Unsupported data type.");  				}  			}
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String")  			{  				int count = 0;  				for (int index = start; index < data.Length && data[index] != 0; index++)  				{  					count++;  				}    				value = Encoding.ASCII.GetString(data' start' count);  				start += count + 1;  				start = ((start + 3) / 4) * 4;                    Assert.IsTrue(((String)value).Length > 0);  			}  			else if (type.Name == "Byte[]")  			{                  int length = ValueFromByteArray<int>(data' ref start);                  byte[] buffer = new byte[length];                  Array.Copy(data' start' buffer' 0' buffer.Length);                  start += buffer.Length + 1;                  start = ((start + 3) / 4) * 4;                    value = buffer;  			}  			else  			{  				byte[] buffer;  				switch (type.Name)  				{  					case "Int32":  					case "Single":  						buffer = new byte[4];  						break;    					case "Int64":  					case "Double":  						buffer = new byte[8];  						break;    					default:  						throw new Exception("Unsupported data type.");  				}    				Array.Copy(data' start' buffer' 0' buffer.Length);  				start += buffer.Length;                    if (BitConverter.IsLittleEndian != sLittleEndianByteOrder)  				{  					buffer = Library.SwapEndian(buffer);  				}    				switch (type.Name)  				{  					case "Int32":  						value = BitConverter.ToInt32(buffer' 0);  						break;    					case "Int64":  						value = BitConverter.ToInt64(buffer' 0);  						break;    					case "Single":  						value = BitConverter.ToSingle(buffer' 0);  						break;    					case "Double":  						value = BitConverter.ToDouble(buffer' 0);  						break;    					default:  						throw new Exception("Unsupported data type.");  				}  			}
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String")  			{  				int count = 0;  				for (int index = start; index < data.Length && data[index] != 0; index++)  				{  					count++;  				}    				value = Encoding.ASCII.GetString(data' start' count);  				start += count + 1;  				start = ((start + 3) / 4) * 4;                    Assert.IsTrue(((String)value).Length > 0);  			}  			else if (type.Name == "Byte[]")  			{                  int length = ValueFromByteArray<int>(data' ref start);                  byte[] buffer = new byte[length];                  Array.Copy(data' start' buffer' 0' buffer.Length);                  start += buffer.Length + 1;                  start = ((start + 3) / 4) * 4;                    value = buffer;  			}  			else  			{  				byte[] buffer;  				switch (type.Name)  				{  					case "Int32":  					case "Single":  						buffer = new byte[4];  						break;    					case "Int64":  					case "Double":  						buffer = new byte[8];  						break;    					default:  						throw new Exception("Unsupported data type.");  				}    				Array.Copy(data' start' buffer' 0' buffer.Length);  				start += buffer.Length;                    if (BitConverter.IsLittleEndian != sLittleEndianByteOrder)  				{  					buffer = Library.SwapEndian(buffer);  				}    				switch (type.Name)  				{  					case "Int32":  						value = BitConverter.ToInt32(buffer' 0);  						break;    					case "Int64":  						value = BitConverter.ToInt64(buffer' 0);  						break;    					case "Single":  						value = BitConverter.ToSingle(buffer' 0);  						break;    					case "Double":  						value = BitConverter.ToDouble(buffer' 0);  						break;    					default:  						throw new Exception("Unsupported data type.");  				}  			}
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String")  			{  				int count = 0;  				for (int index = start; index < data.Length && data[index] != 0; index++)  				{  					count++;  				}    				value = Encoding.ASCII.GetString(data' start' count);  				start += count + 1;  				start = ((start + 3) / 4) * 4;                    Assert.IsTrue(((String)value).Length > 0);  			}  			else if (type.Name == "Byte[]")  			{                  int length = ValueFromByteArray<int>(data' ref start);                  byte[] buffer = new byte[length];                  Array.Copy(data' start' buffer' 0' buffer.Length);                  start += buffer.Length + 1;                  start = ((start + 3) / 4) * 4;                    value = buffer;  			}  			else  			{  				byte[] buffer;  				switch (type.Name)  				{  					case "Int32":  					case "Single":  						buffer = new byte[4];  						break;    					case "Int64":  					case "Double":  						buffer = new byte[8];  						break;    					default:  						throw new Exception("Unsupported data type.");  				}    				Array.Copy(data' start' buffer' 0' buffer.Length);  				start += buffer.Length;                    if (BitConverter.IsLittleEndian != sLittleEndianByteOrder)  				{  					buffer = Library.SwapEndian(buffer);  				}    				switch (type.Name)  				{  					case "Int32":  						value = BitConverter.ToInt32(buffer' 0);  						break;    					case "Int64":  						value = BitConverter.ToInt64(buffer' 0);  						break;    					case "Single":  						value = BitConverter.ToSingle(buffer' 0);  						break;    					case "Double":  						value = BitConverter.ToDouble(buffer' 0);  						break;    					default:  						throw new Exception("Unsupported data type.");  				}  			}
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscPacket.cs,ValueFromByteArray,The following statement contains a magic number: if (type.Name == "String")  			{  				int count = 0;  				for (int index = start; index < data.Length && data[index] != 0; index++)  				{  					count++;  				}    				value = Encoding.ASCII.GetString(data' start' count);  				start += count + 1;  				start = ((start + 3) / 4) * 4;                    Assert.IsTrue(((String)value).Length > 0);  			}  			else if (type.Name == "Byte[]")  			{                  int length = ValueFromByteArray<int>(data' ref start);                  byte[] buffer = new byte[length];                  Array.Copy(data' start' buffer' 0' buffer.Length);                  start += buffer.Length + 1;                  start = ((start + 3) / 4) * 4;                    value = buffer;  			}  			else  			{  				byte[] buffer;  				switch (type.Name)  				{  					case "Int32":  					case "Single":  						buffer = new byte[4];  						break;    					case "Int64":  					case "Double":  						buffer = new byte[8];  						break;    					default:  						throw new Exception("Unsupported data type.");  				}    				Array.Copy(data' start' buffer' 0' buffer.Length);  				start += buffer.Length;                    if (BitConverter.IsLittleEndian != sLittleEndianByteOrder)  				{  					buffer = Library.SwapEndian(buffer);  				}    				switch (type.Name)  				{  					case "Int32":  						value = BitConverter.ToInt32(buffer' 0);  						break;    					case "Int64":  						value = BitConverter.ToInt64(buffer' 0);  						break;    					case "Single":  						value = BitConverter.ToSingle(buffer' 0);  						break;    					case "Double":  						value = BitConverter.ToDouble(buffer' 0);  						break;    					default:  						throw new Exception("Unsupported data type.");  				}  			}
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscPacket.cs,PadNull,The following statement contains a magic number: int pad = 4 - (data.Count % 4);
Magic Number,Bespoke.Common.Osc,OscPacket,C:\repos\CasparCG_Tools\csharp\OSC\trunk\Source Code\Framework\Bespoke.Common.Osc\src\OscPacket.cs,PadNull,The following statement contains a magic number: int pad = 4 - (data.Count % 4);
