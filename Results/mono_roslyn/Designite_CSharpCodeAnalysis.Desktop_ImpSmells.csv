Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The method has 892 lines of code.
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,Cyclomatic complexity of the method is 158
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,GetCompilationAndModuleNames,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,ParseAssemblyReferences,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpCompiler,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CSharpCompiler.cs,CreateCompilation,Cyclomatic complexity of the method is 11
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpFileSystemExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CSharpFileSystemExtensions.cs,Emit,The method has 7 parameters. Parameters: compilation' outputPath' pdbPath' xmlDocumentationPath' win32ResourcesPath' manifestResources' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,ParseAndResolveReferencePaths,The method has 6 parameters. Parameters: switchName' switchValue' baseDirectory' builder' origin' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,GetCompilationAndModuleNames,The method has 8 parameters. Parameters: diagnostics' outputKind' sourceFiles' sourceFilesSpecified' moduleAssemblyName' outputFileName' moduleName' compilationName
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,ValidateWin32Settings,The method has 5 parameters. Parameters: win32ResourceFile' win32IconResourceFile' win32ManifestFile' outputKind' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,ParseResourceDescription,The method has 5 parameters. Parameters: arg' resourceDescriptor' baseDirectory' diagnostics' embedded
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompiler,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CSharpCompiler.cs,CSharpCompiler,The method has 6 parameters. Parameters: parser' responseFile' args' baseDirectory' additionalReferencePaths' tempPath
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompiler,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CSharpCompiler.cs,ParseFile,The method has 6 parameters. Parameters: consoleOutput' parseOptions' scriptParseOptions' hadErrors' file' normalizedFilePath
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpFileSystemExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CSharpFileSystemExtensions.cs,Emit,The length of the statement  "            return FileSystemExtensions.Emit(compilation' outputPath' pdbPath' xmlDocumentationPath' win32ResourcesPath' manifestResources' cancellationToken); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,CommandLineDiagnosticFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineDiagnosticFormatter.cs,RelativizeNormalizedPath,The length of the statement  "            if (string.Compare(directory' 0' normalizedBaseDirectory' 0' normalizedBaseDirectory.Length' StringComparison.OrdinalIgnoreCase) == 0) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The length of the statement  "                bool parseDocumentationComments = false; //Don't just null check documentationFileName because we want to do this even if the file name is invalid. " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The length of the statement  "                                    AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' MessageID.IDS_Text.Localize()' "/doc:"); // Different argument. " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The length of the statement  "                                    metadataReferences.AddRange(ParseSeparatedPaths(value).Select(path => new CommandLineReference(path' MetadataReferenceProperties.Module))); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The length of the statement  "                    metadataReferences.Insert(0' new CommandLineReference(typeof(object).Assembly.Location' MetadataReferenceProperties.Assembly)); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The length of the statement  "                    ParseAndResolveReferencePaths(null' additionalReferencePaths' baseDirectory' libPaths' MessageID.IDS_LIB_ENV' diagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The length of the statement  "                GetCompilationAndModuleNames(diagnostics' outputKind' sourceFiles' sourceFilesSpecified' moduleAssemblyName' ref outputFileName' ref moduleName' out compilationName); " is 166.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,ParseAndResolveReferencePaths,The length of the statement  "                    AddDiagnostic(diagnostics' ErrorCode.WRN_InvalidSearchPathDir' path' origin.Localize()' MessageID.IDS_DirectoryHasInvalidPath.Localize()); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,ParseAndResolveReferencePaths,The length of the statement  "                    AddDiagnostic(diagnostics' ErrorCode.WRN_InvalidSearchPathDir' path' origin.Localize()' MessageID.IDS_DirectoryDoesNotExist.Localize()); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,ParseConditionalCompilationSymbols,The length of the statement  "                    myDiagnostic = Diagnostic.Create(CSharp.MessageProvider.Instance' (int)ErrorCode.WRN_DefineIdentifierRequired' trimmedId); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,ParseResourceDescription,The length of the statement  "            if (fullPath == null || string.IsNullOrWhiteSpace(fileName) || fileName.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,TryParseLanguageVersion,The length of the statement  "                    if (int.TryParse(str' NumberStyles.None' CultureInfo.InvariantCulture' out versionNumber) && ((LanguageVersion)versionNumber).IsValid()) " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompiler,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CSharpCompiler.cs,CreateCompilation,The length of the statement  "                    trees[i] = ParseFile(consoleOutput' parseOptions' scriptParseOptions' ref hadErrors' sourceFiles[i]' out normalizedFilePaths[i]); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompiler,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CSharpCompiler.cs,CreateCompilation,The length of the statement  "                    trees[i] = ParseFile(consoleOutput' parseOptions' scriptParseOptions' ref hadErrors' sourceFiles[i]' out normalizedFilePaths[i]); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompiler,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CSharpCompiler.cs,CreateCompilation,The length of the statement  "            var sourceFileResolver = new LoggingSourceFileResolver(ImmutableArray<string>.Empty' Arguments.BaseDirectory' touchedFilesLogger); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompiler,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CSharpCompiler.cs,CreateCompilation,The length of the statement  "            var resolvedReferences = ResolveMetadataReferences(externalReferenceResolver' metadataProvider' diagnostics' assemblyIdentityComparer' touchedFilesLogger' out referenceDirectiveResolver); " is 187.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompiler,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CSharpCompiler.cs,ParseFile,The length of the statement  "            var content = ReadFileContent(file' fileReadDiagnostics' Arguments.Encoding' Arguments.ChecksumAlgorithm' out normalizedFilePath); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompiler,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CSharpCompiler.cs,PrintLogo,The length of the statement  "            consoleOutput.WriteLine(ErrorFacts.GetMessage(MessageID.IDS_LogoLine1' Culture)' FileVersionInfo.GetVersionInfo(thisAssembly.Location).FileVersion); " is 148.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The conditional expression  "!IsInteractive && !sourceFilesSpecified && (outputKind.IsNetModule() || !resourcesOrModulesSpecified)"  is complex.
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The following statement contains a magic number: int warningLevel = 4;
Missing Default,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The following switch statement is missing a default case: switch (name)                      {                          case "?":                          case "help":                              displayHelp = true;                              continue;                            case "r":                          case "reference":                              metadataReferences.AddRange(ParseAssemblyReferences(arg' value' diagnostics' embedInteropTypes: false));                              continue;                            case "a":                          case "analyzer":                              analyzers.AddRange(ParseAnalyzers(arg' value' diagnostics));                              continue;                            case "d":                          case "define":                              if (string.IsNullOrEmpty(value))                              {                                  AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' "<text>"' arg);                                  continue;                              }                                IEnumerable<Diagnostic> defineDiagnostics;                              defines.AddRange(ParseConditionalCompilationSymbols(value' out defineDiagnostics));                              diagnostics.AddRange(defineDiagnostics);                              continue;                            case "codepage":                              if (value == null)                              {                                  AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' "<text>"' name);                                  continue;                              }                                var encoding = TryParseEncodingName(value);                              if (encoding == null)                              {                                  AddDiagnostic(diagnostics' ErrorCode.FTL_BadCodepage' value);                                  continue;                              }                                codepage = encoding;                              continue;                            case "checksumalgorithm":                              if (string.IsNullOrEmpty(value))                              {                                  AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' "<text>"' name);                                  continue;                              }                                var newChecksumAlgorithm = TryParseHashAlgorithmName(value);                              if (newChecksumAlgorithm == SourceHashAlgorithm.None)                              {                                  AddDiagnostic(diagnostics' ErrorCode.FTL_BadChecksumAlgorithm' value);                                  continue;                              }                                checksumAlgorithm = newChecksumAlgorithm;                              continue;                            case "checked":                          case "checked+":                              if (value != null)                              {                                  break;                              }                                checkOverflow = true;                              continue;                            case "checked-":                              if (value != null)                                  break;                                checkOverflow = false;                              continue;                            case "features":                              if (value == null)                              {                                  features.Clear();                              }                              else                              {                                  features.Add(value);                              }                              continue;                            case "noconfig":                              // It is already handled (see CommonCommandLineCompiler.cs).                              continue;                            case "sqmsessionguid":                              if (value == null)                              {                                  AddDiagnostic(diagnostics' ErrorCode.ERR_MissingGuidForOption' "<text>"' name);                              }                              else                              {                                  if (!Guid.TryParse(value' out sqmSessionGuid))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_InvalidFormatForGuidForOption' value' name);                                  }                              }                              continue;                            case "preferreduilang":                              if (string.IsNullOrEmpty(value))                              {                                  AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' "<text>"' arg);                                  continue;                              }                                try                              {                                  preferredUILang = new CultureInfo(value);                              }                              catch (CultureNotFoundException)                              {                                  AddDiagnostic(diagnostics' ErrorCode.WRN_BadUILang' value);                              }                              continue;    #if DEBUG                          case "attachdebugger":                              Debugger.Launch();                              continue;  #endif                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The following switch statement is missing a default case: switch (name)                          {                              // interactive:                              case "rp":                              case "referencepath":                                  // TODO: should it really go to libPaths?                                  ParseAndResolveReferencePaths(name' value' baseDirectory' libPaths' MessageID.IDS_REFERENCEPATH_OPTION' diagnostics);                                  continue;                                case "u":                              case "using":                                  usings.AddRange(ParseUsings(arg' value' diagnostics));                                  continue;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,CSharpCommandLineParser,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\CSharp\Desktop\CommandLine\CommandLineParser.cs,Parse,The following switch statement is missing a default case: switch (name)                          {                              case "out":                                  if (string.IsNullOrWhiteSpace(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_NoFileSpec' arg);                                  }                                  else                                  {                                      ParseOutputFile(value' diagnostics' baseDirectory' out outputFileName' out outputDirectory);                                  }                                    continue;                                case "t":                              case "target":                                  if (value == null)                                  {                                      break; // force 'unrecognized option'                                  }                                    if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.FTL_InvalidTarget);                                  }                                  else                                  {                                      outputKind = ParseTarget(value' diagnostics);                                  }                                    continue;                                case "moduleassemblyname":                                  value = value != null ? value.Unquote() : null;                                    if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' "<text>"' arg);                                  }                                  else if (!MetadataHelpers.IsValidAssemblyOrModuleName(value))                                  {                                      // Dev11 C# doesn't check the name (VB does)                                      AddDiagnostic(diagnostics' ErrorCode.ERR_InvalidAssemblyName' "<text>"' arg);                                  }                                  else                                  {                                      moduleAssemblyName = value;                                  }                                    continue;                                case "modulename":                                  var unquotedModuleName = RemoveAllQuotes(value);                                  if (string.IsNullOrEmpty(unquotedModuleName))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' MessageID.IDS_Text.Localize()' "modulename");                                      continue;                                  }                                  else                                  {                                      moduleName = unquotedModuleName;                                  }                                    continue;                                case "platform":                                  if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' "<string>"' arg);                                  }                                  else                                  {                                      platform = ParsePlatform(value' diagnostics);                                  }                                  continue;                                case "recurse":                                  if (value == null)                                  {                                      break; // force 'unrecognized option'                                  }                                  else if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_NoFileSpec' arg);                                  }                                  else                                  {                                      int before = sourceFiles.Count;                                      sourceFiles.AddRange(ParseRecurseArgument(value' baseDirectory' diagnostics));                                      if (sourceFiles.Count > before)                                      {                                          sourceFilesSpecified = true;                                      }                                  }                                  continue;                                case "doc":                                  parseDocumentationComments = true;                                  if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' MessageID.IDS_Text.Localize()' arg);                                      continue;                                  }                                  string unquoted = RemoveAllQuotes(value);                                  if (string.IsNullOrEmpty(unquoted))                                  {                                      // CONSIDER: This diagnostic exactly matches dev11' but it would be simpler (and more consistent with /out)                                      // if we just let the next case handle /doc:"".                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' MessageID.IDS_Text.Localize()' "/doc:"); // Different argument.                                  }                                  else                                  {                                      documentationPath = ParseGenericPathToFile(unquoted' diagnostics' baseDirectory);                                  }                                  continue;                                case "addmodule":                                  if (value == null)                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' MessageID.IDS_Text.Localize()' "/addmodule:");                                  }                                  else if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_NoFileSpec' arg);                                  }                                  else                                  {                                      // NOTE(tomat): Dev10 used to report CS1541: ERR_CantIncludeDirectory if the path was a directory.                                      // Since we now support /referencePaths option we would need to search them to see if the resolved path is a directory.                                      // An error will be reported by the assembly manager anyways.                                      metadataReferences.AddRange(ParseSeparatedPaths(value).Select(path => new CommandLineReference(path' MetadataReferenceProperties.Module)));                                      resourcesOrModulesSpecified = true;                                  }                                  continue;                                case "l":                              case "link":                                  metadataReferences.AddRange(ParseAssemblyReferences(arg' value' diagnostics' embedInteropTypes: true));                                  continue;                                case "win32res":                                  win32ResourceFile = GetWin32Setting(arg' value' diagnostics);                                  continue;                                case "win32icon":                                  win32IconFile = GetWin32Setting(arg' value' diagnostics);                                  continue;                                case "win32manifest":                                  win32ManifestFile = GetWin32Setting(arg' value' diagnostics);                                  noWin32Manifest = false;                                  continue;                                case "nowin32manifest":                                  noWin32Manifest = true;                                  win32ManifestFile = null;                                  continue;                                case "res":                              case "resource":                                  if (value == null)                                  {                                      break; // Dev11 reports inrecognized option                                  }                                    var embeddedResource = ParseResourceDescription(arg' value' baseDirectory' diagnostics' embedded: true);                                  if (embeddedResource != null)                                  {                                      managedResources.Add(embeddedResource);                                      resourcesOrModulesSpecified = true;                                  }                                    continue;                                case "linkres":                              case "linkresource":                                  if (value == null)                                  {                                      break; // Dev11 reports inrecognized option                                  }                                    var linkedResource = ParseResourceDescription(arg' value' baseDirectory' diagnostics' embedded: false);                                  if (linkedResource != null)                                  {                                      managedResources.Add(linkedResource);                                      resourcesOrModulesSpecified = true;                                  }                                    continue;                                case "debug":                                  emitPdb = true;                                    // unused' parsed for backward compat only                                  if (value != null)                                  {                                      if (value.IsEmpty())                                      {                                          AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' MessageID.IDS_Text.Localize()' name);                                      }                                      else if (!string.Equals(value' "full"' StringComparison.OrdinalIgnoreCase) &&                                               !string.Equals(value' "pdbonly"' StringComparison.OrdinalIgnoreCase))                                      {                                          AddDiagnostic(diagnostics' ErrorCode.ERR_BadDebugType' value);                                      }                                  }                                  continue;                                case "debug+":                                  //guard against "debug+:xx"                                  if (value != null)                                      break;                                    emitPdb = true;                                  continue;                                case "debug-":                                  if (value != null)                                      break;                                    emitPdb = false;                                  continue;                                case "o":                              case "optimize":                              case "o+":                              case "optimize+":                                  if (value != null)                                      break;                                    optimize = true;                                  continue;                                case "o-":                              case "optimize-":                                  if (value != null)                                      break;                                    optimize = false;                                  continue;                                case "p":                              case "parallel":                              case "p+":                              case "parallel+":                                  if (value != null)                                      break;                                    concurrentBuild = true;                                  continue;                                case "p-":                              case "parallel-":                                  if (value != null)                                      break;                                    concurrentBuild = false;                                  continue;                                case "warnaserror":                              case "warnaserror+":                                  if (value == null)                                  {                                      generalDiagnosticOption = ReportDiagnostic.Error;                                        // Clear specific warnaserror options (since last /warnaserror flag on the command line always wins).                                      warnAsErrors.Clear();                                        continue;                                  }                                    if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsNumber' name);                                  }                                  else                                  {                                      AddWarnings(warnAsErrors' ReportDiagnostic.Error' ParseWarnings(value));                                  }                                  continue;                                case "warnaserror-":                                  if (value == null)                                  {                                      generalDiagnosticOption = ReportDiagnostic.Default;                                        // Clear specific warnaserror options (since last /warnaserror flag on the command line always wins).                                      warnAsErrors.Clear();                                        continue;                                  }                                    if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsNumber' name);                                  }                                  else                                  {                                      AddWarnings(warnAsErrors' ReportDiagnostic.Default' ParseWarnings(value));                                  }                                  continue;                                case "w":                              case "warn":                                  if (value == null)                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsNumber' name);                                      continue;                                  }                                    int newWarningLevel;                                  if (string.IsNullOrEmpty(value) ||                                      !int.TryParse(value' NumberStyles.Integer' CultureInfo.InvariantCulture' out newWarningLevel))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsNumber' name);                                  }                                  else if (newWarningLevel < 0 || newWarningLevel > 4)                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_BadWarningLevel' name);                                  }                                  else                                  {                                      warningLevel = newWarningLevel;                                  }                                  continue;                                case "nowarn":                                  if (value == null)                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsNumber' name);                                      continue;                                  }                                    if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsNumber' name);                                  }                                  else                                  {                                      AddWarnings(noWarns' ReportDiagnostic.Suppress' ParseWarnings(value));                                  }                                  continue;                                case "unsafe":                              case "unsafe+":                                  if (value != null)                                      break;                                    allowUnsafe = true;                                  continue;                                case "unsafe-":                                  if (value != null)                                      break;                                    allowUnsafe = false;                                  continue;                                case "langversion":                                  if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' MessageID.IDS_Text.Localize()' "/langversion:");                                  }                                  else if (!TryParseLanguageVersion(value' CSharpParseOptions.Default.LanguageVersion' out languageVersion))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_BadCompatMode' value);                                  }                                  continue;                                case "delaysign":                              case "delaysign+":                                  if (value != null)                                  {                                      break;                                  }                                    delaySignSetting = true;                                  continue;                                case "delaysign-":                                  if (value != null)                                  {                                      break;                                  }                                    delaySignSetting = false;                                  continue;                                case "keyfile":                                  if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_NoFileSpec' "keyfile");                                  }                                  else                                  {                                      keyFileSetting = RemoveAllQuotes(value);                                  }                                  // NOTE: Dev11/VB also clears "keycontainer"' see also:                                  //                                  // MSDN: In case both /keyfile and /keycontainer are specified (either by command line option or by                                   // MSDN: custom attribute) in the same compilation' the compiler will first try the key container.                                   // MSDN: If that succeeds' then the assembly is signed with the information in the key container.                                   // MSDN: If the compiler does not find the key container' it will try the file specified with /keyfile.                                   // MSDN: If that succeeds' the assembly is signed with the information in the key file and the key                                   // MSDN: information will be installed in the key container (similar to sn -i) so that on the next                                   // MSDN: compilation' the key container will be valid.                                  continue;                                case "keycontainer":                                  if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' MessageID.IDS_Text.Localize()' "keycontainer");                                  }                                  else                                  {                                      keyContainerSetting = value;                                  }                                  // NOTE: Dev11/VB also clears "keyfile"' see also:                                  //                                  // MSDN: In case both /keyfile and /keycontainer are specified (either by command line option or by                                   // MSDN: custom attribute) in the same compilation' the compiler will first try the key container.                                   // MSDN: If that succeeds' then the assembly is signed with the information in the key container.                                   // MSDN: If the compiler does not find the key container' it will try the file specified with /keyfile.                                   // MSDN: If that succeeds' the assembly is signed with the information in the key file and the key                                   // MSDN: information will be installed in the key container (similar to sn -i) so that on the next                                   // MSDN: compilation' the key container will be valid.                                  continue;                                case "highentropyva":                              case "highentropyva+":                                  if (value != null)                                      break;                                    highEntropyVA = true;                                  continue;                                case "highentropyva-":                                  if (value != null)                                      break;                                    highEntropyVA = false;                                  continue;                                case "nologo":                                  displayLogo = false;                                  continue;                                case "baseaddress":                                  ulong newBaseAddress;                                  if (string.IsNullOrEmpty(value) || !TryParseUInt64(value' out newBaseAddress))                                  {                                      if (string.IsNullOrEmpty(value))                                      {                                          AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsNumber' name);                                      }                                      else                                      {                                          AddDiagnostic(diagnostics' ErrorCode.ERR_BadBaseNumber' value);                                      }                                  }                                  else                                  {                                      baseAddress = newBaseAddress;                                  }                                    continue;                                case "subsystemversion":                                  if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' MessageID.IDS_Text.Localize()' "subsystemversion");                                      continue;                                  }                                    // It seems VS 2012 just silently corrects invalid values and suppresses the error message                                  SubsystemVersion version = SubsystemVersion.None;                                  if (SubsystemVersion.TryParse(value' out version))                                  {                                      subsystemVersion = version;                                  }                                  else                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_InvalidSubsystemVersion' value);                                  }                                    continue;                                case "touchedfiles":                                  unquoted = RemoveAllQuotes(value);                                  if (string.IsNullOrEmpty(unquoted))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' MessageID.IDS_Text.Localize()' "touchedfiles");                                      continue;                                  }                                  else                                  {                                      touchedFilesPath = unquoted;                                  }                                    continue;                                case "bugreport":                                  UnimplementedSwitch(diagnostics' name);                                  continue;                                case "utf8output":                                  if (value != null)                                      break;                                    utf8output = true;                                  continue;                                case "m":                              case "main":                                  // Remove any quotes for consistent behaviour as MSBuild can return quoted or                                   // unquoted main.                                      unquoted = RemoveAllQuotes(value);                                  if (string.IsNullOrEmpty(unquoted))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' "<text>"' name);                                      continue;                                  }                                    mainTypeName = unquoted;                                  continue;                                case "fullpaths":                                  if (value != null)                                      break;                                    printFullPaths = true;                                  continue;                                case "filealign":                                  ushort newAlignment;                                  if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsNumber' name);                                  }                                  else if (!TryParseUInt16(value' out newAlignment))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_InvalidFileAlignment' value);                                  }                                  else if (!CompilationOptions.IsValidFileAlignment(newAlignment))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_InvalidFileAlignment' value);                                  }                                  else                                  {                                      fileAlignment = newAlignment;                                  }                                  continue;                                case "pdb":                                  if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_NoFileSpec' arg);                                  }                                  else                                  {                                      pdbPath = ParsePdbPath(value' diagnostics' baseDirectory);                                  }                                  continue;                                case "errorendlocation":                                  errorEndLocation = true;                                  continue;                                case "nostdlib":                              case "nostdlib+":                                  if (value != null)                                      break;                                    noStdLib = true;                                  continue;                                case "lib":                                  ParseAndResolveReferencePaths(name' value' baseDirectory' libPaths' MessageID.IDS_LIB_OPTION' diagnostics);                                  continue;                                case "nostdlib-":                                  if (value != null)                                      break;                                    noStdLib = false;                                  continue;                                case "errorreport":                                  continue;                                case "appconfig":                                  unquoted = RemoveAllQuotes(value);                                  if (string.IsNullOrEmpty(unquoted))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' ":<text>"' RemoveAllQuotes(arg));                                  }                                  else                                  {                                      appConfigPath = ParseGenericPathToFile(                                          unquoted' diagnostics' baseDirectory);                                  }                                  continue;                                case "runtimemetadataversion":                                  unquoted = RemoveAllQuotes(value);                                  if (string.IsNullOrEmpty(unquoted))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' "<text>"' name);                                      continue;                                  }                                    runtimeMetadataVersion = unquoted;                                  continue;                                case "ruleset":                                  // The ruleset arg has already been processed in a separate pass above.                                  continue;                                case "additionalfile":                                  if (string.IsNullOrEmpty(value))                                  {                                      AddDiagnostic(diagnostics' ErrorCode.ERR_SwitchNeedsString' "<file list>"' name);                                      continue;                                  }                                    additionalFiles.AddRange(ParseAdditionalFileArgument(value' baseDirectory' diagnostics));                                  continue;                          }
