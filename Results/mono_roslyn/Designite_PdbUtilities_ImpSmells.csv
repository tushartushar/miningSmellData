Implementation smell,Namespace,Class,File,Method,Description
Long Method,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,DumpILBlock,The method has 150 lines of code.
Long Method,Roslyn.Test.PdbUtilities,PdbToXmlConverter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\PdbToXml.cs,WriteNamespace,The method has 167 lines of code.
Long Method,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,The method has 112 lines of code.
Long Method,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,TryParseVisualBasicImportString,The method has 123 lines of code.
Complex Method,Roslyn.Test.MetadataUtilities,MetadataVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\MetadataVisualizer.cs,WriteRows,Cyclomatic complexity of the method is 8
Complex Method,Roslyn.Test.PdbUtilities,PdbToXmlConverter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\PdbToXml.cs,WriteLocalsHelper,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,Cyclomatic complexity of the method is 13
Long Parameter List,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,DumpMethod,The method has 5 parameters. Parameters: maxStack' ilBytes' locals' exceptionHandlers' markers
Long Parameter List,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,DumpMethod,The method has 6 parameters. Parameters: sb' maxStack' ilBytes' locals' exceptionHandlers' markers
Long Parameter List,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,DumpILBlock,The method has 6 parameters. Parameters: ilBytes' length' sb' spans' blockOffset' markers
Long Parameter List,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,DumpILBlock,The method has 10 parameters. Parameters: ilBytes' length' sb' spans' blockOffset' curIndex' spanIndex' indent' markers' nextSpanIndex
Long Parameter List,Roslyn.Test.MetadataUtilities,HandlerSpan,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,HandlerSpan,The method has 5 parameters. Parameters: kind' exceptionType' startOffset' endOffset' filterHandlerStart
Long Parameter List,Roslyn.Test.PdbUtilities,PdbToXmlConverter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\PdbToXml.cs,ToXml,The method has 5 parameters. Parameters: xmlWriter' pdbStream' peStream' options' methodName
Long Parameter List,Roslyn.Test.PdbUtilities,PdbToXmlConverter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\PdbToXml.cs,ToXml,The method has 5 parameters. Parameters: xmlWriter' pdbStream' metadataReaderOpt' options' methodHandles
Long Parameter List,Roslyn.Test.PdbUtilities,Token2SourceLineExporter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,LoadTokenToSourceInfo,The method has 7 parameters. Parameters: bits' module' names' dir' nameIndex' reader' tokenToSourceMapping
Long Parameter List,Roslyn.Test.PdbUtilities,Token2SourceLineExporter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadSourceFileInfo,The method has 6 parameters. Parameters: bits' limit' names' dir' nameIndex' reader
Long Parameter List,Roslyn.Test.PdbUtilities,PdbTokenLine,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,PdbTokenLine,The method has 6 parameters. Parameters: token' file_id' line' column' endLine' endColumn
Long Parameter List,Roslyn.Test.PdbUtilities,DataStream,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,Read,The method has 5 parameters. Parameters: reader' position' bytes' offset' data
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,EnumCustomAttributes,The method has 5 parameters. Parameters: handlePointerEnum' tk' tokenType' arrayCustomAttributes' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,EnumFieldsWithName,The method has 5 parameters. Parameters: handlePointerEnum' cl' stringName' arrayFields' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,EnumMembersWithName,The method has 5 parameters. Parameters: handlePointerEnum' cl' stringName' arrayMembers' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,EnumMethodImpls,The method has 5 parameters. Parameters: handlePointerEnum' td' arrayMethodBody' arrayMethodDecl' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,EnumMethodsWithName,The method has 5 parameters. Parameters: handlePointerEnum' cl' stringName' arrayMethods' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,EnumPermissionSets,The method has 5 parameters. Parameters: handlePointerEnum' tk' dwordActions' arrayPermission' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,GetClassLayout,The method has 5 parameters. Parameters: td' pdwPackSize' arrayFieldOffset' countMax' countPointerFieldOffset
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,GetEventProps,The method has 12 parameters. Parameters: ev' pointerClass' stringEvent' cchEvent' pchEvent' pdwEventFlags' ptkEventType' pmdAddOn' pmdRemoveOn' pmdFire' rmdOtherMethod' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,GetFieldProps,The method has 10 parameters. Parameters: mb' pointerClass' stringField' cchField' pchField' pdwAttr' ppvSigBlob' pcbSigBlob' pdwCPlusTypeFlag' ppValue
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,GetMemberProps,The method has 12 parameters. Parameters: mb' pointerClass' stringMember' cchMember' pchMember' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags' pdwCPlusTypeFlag' ppValue
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,GetMemberRefProps,The method has 6 parameters. Parameters: mr' ptk' stringMember' cchMember' pchMember' ppvSigBlob
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,GetMethodProps,The method has 9 parameters. Parameters: mb' pointerClass' stringMethod' cchMethod' pchMethod' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,GetParamProps,The method has 9 parameters. Parameters: tk' pmd' pulSequence' stringName' cchName' pchName' pdwAttr' pdwCPlusTypeFlag' ppValue
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,GetPinvokeMap,The method has 5 parameters. Parameters: tk' pdwMappingFlags' stringImportName' cchImportName' pchImportName
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,GetPropertyProps,The method has 15 parameters. Parameters: prop' pointerClass' stringProperty' cchProperty' pchProperty' pdwPropFlags' ppvSig' bytePointerSig' pdwCPlusTypeFlag' ppDefaultValue' pcchDefaultValue' pmdSetter' pmdGetter' rmdOtherMethod' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,DummyMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\DummyMetadataImport.cs,GetTypeDefProps,The method has 5 parameters. Parameters: td' stringTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,GetTypeDefProps,The method has 5 parameters. Parameters: td' stringTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,EnumMembersWithName,The method has 5 parameters. Parameters: handlePointerEnum' cl' stringName' arrayMembers' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,EnumMethodsWithName,The method has 5 parameters. Parameters: handlePointerEnum' cl' stringName' arrayMethods' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,EnumFieldsWithName,The method has 5 parameters. Parameters: handlePointerEnum' cl' stringName' arrayFields' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,EnumMethodImpls,The method has 5 parameters. Parameters: handlePointerEnum' td' arrayMethodBody' arrayMethodDecl' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,EnumPermissionSets,The method has 5 parameters. Parameters: handlePointerEnum' tk' dwordActions' arrayPermission' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,GetMethodProps,The method has 9 parameters. Parameters: mb' pointerClass' stringMethod' cchMethod' pchMethod' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,GetMemberRefProps,The method has 6 parameters. Parameters: mr' ptk' stringMember' cchMember' pchMember' ppvSigBlob
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,GetEventProps,The method has 12 parameters. Parameters: ev' pointerClass' stringEvent' cchEvent' pchEvent' pdwEventFlags' ptkEventType' pmdAddOn' pmdRemoveOn' pmdFire' rmdOtherMethod' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,GetClassLayout,The method has 5 parameters. Parameters: td' pdwPackSize' arrayFieldOffset' countMax' countPointerFieldOffset
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,GetPinvokeMap,The method has 5 parameters. Parameters: tk' pdwMappingFlags' stringImportName' cchImportName' pchImportName
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,EnumCustomAttributes,The method has 5 parameters. Parameters: handlePointerEnum' tk' tokenType' arrayCustomAttributes' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,GetMemberProps,The method has 12 parameters. Parameters: mb' pointerClass' stringMember' cchMember' pchMember' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags' pdwCPlusTypeFlag' ppValue
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,GetFieldProps,The method has 10 parameters. Parameters: mb' pointerClass' stringField' cchField' pchField' pdwAttr' ppvSigBlob' pcbSigBlob' pdwCPlusTypeFlag' ppValue
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,GetPropertyProps,The method has 15 parameters. Parameters: prop' pointerClass' stringProperty' cchProperty' pchProperty' pdwPropFlags' ppvSig' bytePointerSig' pdwCPlusTypeFlag' ppDefaultValue' pcchDefaultValue' pmdSetter' pmdGetter' rmdOtherMethod' countMax
Long Parameter List,Roslyn.Test.PdbUtilities,IMetadataImport,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\IMetadataImport.cs,GetParamProps,The method has 9 parameters. Parameters: tk' pmd' pulSequence' stringName' cchName' pchName' pdwAttr' pdwCPlusTypeFlag' ppValue
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,ReadRecordHeader,The method has 5 parameters. Parameters: bytes' offset' version' kind' size
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpDynamicLocalInfo,The method has 6 parameters. Parameters: customDebugInfo' methodToken' methodVersion' firstLocalName' dynamicLocalMap' dynamicLocalConstantMap
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,TryParseCSharpImportString,The method has 5 parameters. Parameters: import' alias' externAlias' target' kind
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,TryParseVisualBasicImportString,The method has 5 parameters. Parameters: import' alias' target' kind' scope
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,TrySplit,The method has 5 parameters. Parameters: input' offset' separator' before' after
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,ISymENCUnmanagedMethod,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\ISymENCUnmanagedMethod.cs,__GetLineFromOffset,The method has 6 parameters. Parameters: dwOffset' pline' pcolumn' pendLine' pendColumn' pdwStartOffset
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,ISymUnmanagedAsyncMethod,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\ISymUnmanagedAsyncMethod.cs,GetAsyncStepInfo,The method has 5 parameters. Parameters: cStepInfo' cStepInfoBack' yieldOffsets' breakpointOffset' breakpointMethod
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,ISymUnmanagedDocument,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\ISymUnmanagedDocument.cs,GetSourceRange,The method has 7 parameters. Parameters: startLine' startColumn' endLine' endColumn' cSourceBytes' pcSourceBytes' source
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,ISymUnmanagedMethod,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\ISymUnmanagedMethod.cs,GetRanges,The method has 6 parameters. Parameters: document' line' column' cRanges' pcRanges' ranges
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,ISymUnmanagedMethod,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\ISymUnmanagedMethod.cs,GetSequencePoints,The method has 8 parameters. Parameters: cPoints' pcPoints' offsets' documents' lines' columns' endLines' endColumns
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,ISymUnmanagedReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\ISymUnmanagedReader.cs,GetSymAttribute,The method has 5 parameters. Parameters: token' name' sizeBuffer' lengthBuffer' buffer
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,ISymUnmanagedReader2,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\ISymUnmanagedReader2.cs,GetDocument,The method has 5 parameters. Parameters: url' language' languageVendor' documentType' retVal
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,ISymUnmanagedReader2,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\ISymUnmanagedReader2.cs,GetSymAttribute,The method has 5 parameters. Parameters: parent' name' sizeBuffer' lengthBuffer' buffer
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,ISymUnmanagedReader2,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\ISymUnmanagedReader2.cs,GetMethodsFromDocumentPosition,The method has 6 parameters. Parameters: document' line' column' cMethod' pcMethod' pRetVal
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,ISymUnmanagedReader2,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\ISymUnmanagedReader2.cs,GetSymAttributePreRemap,The method has 5 parameters. Parameters: parent' name' sizeBuffer' lengthBuffer' buffer
Long Parameter List,Microsoft.VisualStudio.SymReaderInterop,SymUnmanagedSequencePoint,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\SymUnmanagedSequencePoint.cs,SymUnmanagedSequencePoint,The method has 6 parameters. Parameters: offset' document' startLine' startColumn' endLine' endColumn
Long Identifier,Microsoft.Cci,CustomDebugInfoConstants,C:\repos\mono_roslyn\src\Compilers\Core\Portable\PEWriter\CustomDebugInfoConstants.cs,,The length of the parameter CdiKindStateMachineHoistedLocalScopes is 37.
Long Identifier,Microsoft.Cci,CustomDebugInfoConstants,C:\repos\mono_roslyn\src\Compilers\Core\Portable\PEWriter\CustomDebugInfoConstants.cs,,The length of the parameter CdiKindEditAndContinueLocalSlotMap is 34.
Long Identifier,Microsoft.Cci,CustomDebugInfoConstants,C:\repos\mono_roslyn\src\Compilers\Core\Portable\PEWriter\CustomDebugInfoConstants.cs,,The length of the parameter CdiKindEditAndContinueLambdaMap is 31.
Long Statement,Roslyn.Utilities,ExceptionUtilities,C:\repos\mono_roslyn\src\Compilers\Core\Portable\InternalUtilities\ExceptionUtilities.cs,UnexpectedValue,The length of the statement  "            string output = string.Format("Unexpected value '{0}' of type '{1}'"' o' (o != null) ? o.GetType().FullName : "<unknown>"); " is 123.
Long Statement,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,DumpILBlock,The length of the statement  "            int curIndex = DumpILBlock(ilBytes' length' sb' spans' blockOffset' 0' spanIndex' IndentString' markers' out spanIndex); " is 120.
Long Statement,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,DumpILBlock,The length of the statement  "                    curIndex = DumpILBlock(ilBytes' length' sb' spans' blockOffset' curIndex' spanIndex + 1' indent + IndentString' markers' out spanIndex); " is 136.
Long Statement,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,GetHandlerSpans,The length of the statement  "                        span = new HandlerSpan(HandlerKind.Catch' MetadataTokens.GetToken(entry.CatchType)' handlerStartOffset' handlerEndOffset); " is 122.
Long Statement,Roslyn.Test.MetadataUtilities,MetadataVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\MetadataVisualizer.cs,MakeTableName,The length of the statement  "            return $"{index} (index: 0x{(byte)index:X2}' size: {reader.GetTableRowCount(index) * reader.GetTableRowSize(index)}): "; " is 120.
Long Statement,Roslyn.Test.MetadataUtilities,MetadataVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\MetadataVisualizer.cs,GetAggregateHandle,The length of the statement  "                throw new BadImageFormatException(string.Format("EncMap is missing record for {0:8X}."' MetadataTokens.GetToken(generationHandle))); " is 132.
Long Statement,Roslyn.Test.MetadataUtilities,MetadataVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\MetadataVisualizer.cs,TokenRange,The length of the statement  "            return (handles.Count == 0) ? "nil" : Token(genericHandles.First()' displayTable: false) + "-" + Token(genericHandles.Last()' displayTable: false); " is 147.
Long Statement,Roslyn.Test.MetadataUtilities,MetadataVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\MetadataVisualizer.cs,WriteTypeDef,The length of the statement  "                var implementedInterfaces = entry.GetInterfaceImplementations().Select(h => reader.GetInterfaceImplementation(h).Interface).ToArray(); " is 134.
Long Statement,Roslyn.Test.PdbUtilities,Token2SourceLineExporter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadSourceFileInfo,The length of the statement  "                            PdbSource src = new PdbSource(/*(uint)ni'*/ (string)names[(int)chk.name]' SymDocumentType.Text' Guid.Empty' Guid.Empty); " is 120.
Long Statement,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,The length of the statement  "                            throw new InvalidOperationException(string.Format("Expected at most one Using record for method {0}"' FormatMethodToken(methodToken))); " is 135.
Long Statement,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,The length of the statement  "                            throw new InvalidOperationException(string.Format("Did not expect both Forward and ForwardToModule records for method {0}"' FormatMethodToken(methodToken))); " is 157.
Long Statement,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,The length of the statement  "                            throw new InvalidOperationException(string.Format("Expected at most one ForwardToModule record for method {0}"' FormatMethodToken(methodToken))); " is 145.
Long Statement,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,The length of the statement  "                        ImmutableArray<string> allModuleInfoImportStrings = reader.GetMethodByVersion(moduleInfoMethodToken' methodVersion).GetImportStrings(); " is 135.
Long Statement,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,The length of the statement  "            ArrayBuilder<ImmutableArray<string>> resultBuilder = ArrayBuilder<ImmutableArray<string>>.GetInstance(groupSizes.Length); " is 121.
Long Statement,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,The length of the statement  "                        throw new InvalidOperationException(string.Format("Group size indicates more imports than there are import strings (method {0})."' FormatMethodToken(methodToken))); " is 164.
Long Statement,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,The length of the statement  "                        throw new InvalidOperationException(string.Format("Encountered extern alias info before all import strings were consumed (method {0})."' FormatMethodToken(methodToken))); " is 170.
Long Statement,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,The length of the statement  "                        throw new InvalidOperationException(string.Format("Expected only extern alias info strings after consuming the indicated number of imports (method {0})."' FormatMethodToken(methodToken))); " is 188.
Long Statement,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,The length of the statement  "                    throw new InvalidOperationException(string.Format("Group size indicates fewer imports than there are import strings (method {0})."' FormatMethodToken(methodToken))); " is 165.
Long Statement,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,CheckVersion,The length of the statement  "                throw new InvalidOperationException(string.Format("Method {0}: Expected version {1}' but found version {2}."' FormatMethodToken(methodToken)' CDI.CdiVersion' globalVersion)); " is 174.
Long Statement,Microsoft.VisualStudio.SymReaderInterop,SequencePointExtensions,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\SymUnmanagedSequencePoint.cs,GetSequencePoints,The length of the statement  "            hr = method.GetSequencePoints(numAvailable' out numRead' offsets' documents' startLines' startColumns' endLines' endColumns); " is 125.
Magic Number,Microsoft.CodeAnalysis.Collections,PooledStringBuilder,C:\repos\mono_roslyn\src\Compilers\Core\Portable\Collections\PooledStringBuilder.cs,Free,The following statement contains a magic number: if (builder.Capacity <= 1024)              {                  builder.Clear();                  _pool.Free(this);              }              else              {                  _pool.ForgetTrackedObject(this);              }
Magic Number,Microsoft.CodeAnalysis.Collections,PooledStringBuilder,C:\repos\mono_roslyn\src\Compilers\Core\Portable\Collections\PooledStringBuilder.cs,CreatePool,The following statement contains a magic number: pool = new ObjectPool<PooledStringBuilder>(() => new PooledStringBuilder(pool)' 32);
Magic Number,Microsoft.CodeAnalysis.Collections,PooledDictionary<K;V>,C:\repos\mono_roslyn\src\Compilers\Core\SharedCollections\PooledDictionary.cs,CreatePool,The following statement contains a magic number: pool = new ObjectPool<PooledDictionary<K' V>>(() => new PooledDictionary<K' V>(pool)' 128);
Magic Number,Microsoft.CodeAnalysis.Collections,PooledHashSet<T>,C:\repos\mono_roslyn\src\Compilers\Core\SharedCollections\PooledHashSet.cs,CreatePool,The following statement contains a magic number: pool = new ObjectPool<PooledHashSet<T>>(() => new PooledHashSet<T>(pool)' 128);
Magic Number,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,ReadUlong,The following statement contains a magic number: pos += 8;
Magic Number,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,ReadUint,The following statement contains a magic number: pos += 4;
Magic Number,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,ReadInt,The following statement contains a magic number: pos += 4;
Magic Number,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,ReadUShort,The following statement contains a magic number: pos += 4;
Magic Number,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,ReadSingle,The following statement contains a magic number: pos += 4;
Magic Number,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,ReadDouble,The following statement contains a magic number: pos += 8;
Magic Number,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,DumpILBlock,The following statement contains a magic number: while (curIndex < length)              {                  if (lastSpanIndex > 0 && StartsFilterHandler(spans' lastSpanIndex' curIndex + blockOffset))                  {                      sb.Append(indent.Substring(0' indent.Length - IndentString.Length));                      sb.Append("}  // end filter");                      sb.AppendLine();                        sb.Append(indent.Substring(0' indent.Length - IndentString.Length));                      sb.Append("{  // handler");                      sb.AppendLine();                  }                                    if (StartsSpan(spans' spanIndex' curIndex + blockOffset))                  {                      sb.Append(indent);                      sb.Append(spans[spanIndex].ToString(this));                      sb.AppendLine();                      sb.Append(indent);                      sb.Append("{");                      sb.AppendLine();                        curIndex = DumpILBlock(ilBytes' length' sb' spans' blockOffset' curIndex' spanIndex + 1' indent + IndentString' markers' out spanIndex);                        sb.Append(indent);                      sb.Append("}");                      sb.AppendLine();                  }                  else                  {                      int ilOffset = curIndex + blockOffset;                      string marker;                      if (markers != null && markers.TryGetValue(ilOffset' out marker))                      {                          sb.Append(indent.Substring(0' indent.Length - marker.Length));                          sb.Append(marker);                      }                      else                      {                          sb.Append(indent);                      }                        sb.AppendFormat("IL_{0:x4}:"' ilOffset);                        OpCode opCode;                      int expectedSize;                        byte op1 = ilBytes[curIndex++];                      if (op1 == 0xfe && curIndex < length)                      {                          byte op2 = ilBytes[curIndex++];                          opCode = TwoByteOpCodes[op2];                          expectedSize = 2;                      }                      else                      {                          opCode = OneByteOpCodes[op1];                          expectedSize = 1;                      }                        if (opCode.Size != expectedSize)                      {                          sb.AppendLine(string.Format("  <unknown 0x{0}{1:X2}>"' expectedSize == 2 ? "fe" : ""' op1));                          continue;                      }                        sb.Append("  ");                      sb.AppendFormat(opCode.OperandType == OperandType.InlineNone ? "{0}" : "{0'-10}"' opCode);                        switch (opCode.OperandType)                      {                          case OperandType.InlineField:                          case OperandType.InlineMethod:                          case OperandType.InlineTok:                          case OperandType.InlineType:                              sb.Append(' ');                              sb.Append(VisualizeSymbol(ReadUint(ilBytes' ref curIndex)));                              break;                            case OperandType.InlineSig: // signature (calli)' not emitted by C#/VB                              sb.AppendFormat(" 0x{0:x}"' ReadUint(ilBytes' ref curIndex));                              break;                            case OperandType.InlineString:                              sb.Append(' ');                              sb.Append(VisualizeUserString(ReadUint(ilBytes' ref curIndex)));                              break;                            case OperandType.InlineNone:                              break;                            case OperandType.ShortInlineI:                              sb.AppendFormat(" {0}"' ReadSByte(ilBytes' ref curIndex));                              break;                            case OperandType.ShortInlineVar:                              sb.AppendFormat(" V_{0}"' ReadByte(ilBytes' ref curIndex));                              break;                            case OperandType.InlineVar:                              sb.AppendFormat(" V_{0}"' ReadUShort(ilBytes' ref curIndex));                              break;                            case OperandType.InlineI:                              sb.AppendFormat(" 0x{0:x}"' ReadUint(ilBytes' ref curIndex));                              break;                            case OperandType.InlineI8:                              sb.AppendFormat(" 0x{0:x8}"' ReadUlong(ilBytes' ref curIndex));                              break;                            case OperandType.ShortInlineR:                              {                                  var value = ReadSingle(ilBytes' ref curIndex);                                  if (value == 0 && 1 / value < 0)                                  {                                      sb.Append(" -0.0");                                  }                                  else                                  {                                      sb.AppendFormat(" {0}"' value.ToString(CultureInfo.InvariantCulture));                                  }                              }                              break;                            case OperandType.InlineR:                              {                                  var value = ReadDouble(ilBytes' ref curIndex);                                  if (value == 0 && 1 / value < 0)                                  {                                      sb.Append(" -0.0");                                  }                                  else                                  {                                      sb.AppendFormat(" {0}"' value.ToString(CultureInfo.InvariantCulture));                                  }                              }                              break;                            case OperandType.ShortInlineBrTarget:                              sb.AppendFormat(" IL_{0:x4}"' ReadSByte(ilBytes' ref curIndex) + curIndex + blockOffset);                              break;                            case OperandType.InlineBrTarget:                              sb.AppendFormat(" IL_{0:x4}"' ReadInt(ilBytes' ref curIndex) + curIndex + blockOffset);                              break;                            case OperandType.InlineSwitch:                              int labelCount = ReadInt(ilBytes' ref curIndex);                              int instrEnd = curIndex + labelCount * 4;                              sb.AppendLine("(");                              for (int i = 0; i < labelCount; i++)                              {                                  sb.AppendFormat("        IL_{0:x4}"' ReadInt(ilBytes' ref curIndex) + instrEnd + blockOffset);                                  sb.AppendLine((i == labelCount - 1) ? ")" : "'");                              }                              break;                            default:                              throw ExceptionUtilities.UnexpectedValue(opCode.OperandType);                      }                        sb.AppendLine();                  }                    if (EndsSpan(spans' lastSpanIndex' curIndex + blockOffset))                  {                      break;                  }              }
Magic Number,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,DumpILBlock,The following statement contains a magic number: while (curIndex < length)              {                  if (lastSpanIndex > 0 && StartsFilterHandler(spans' lastSpanIndex' curIndex + blockOffset))                  {                      sb.Append(indent.Substring(0' indent.Length - IndentString.Length));                      sb.Append("}  // end filter");                      sb.AppendLine();                        sb.Append(indent.Substring(0' indent.Length - IndentString.Length));                      sb.Append("{  // handler");                      sb.AppendLine();                  }                                    if (StartsSpan(spans' spanIndex' curIndex + blockOffset))                  {                      sb.Append(indent);                      sb.Append(spans[spanIndex].ToString(this));                      sb.AppendLine();                      sb.Append(indent);                      sb.Append("{");                      sb.AppendLine();                        curIndex = DumpILBlock(ilBytes' length' sb' spans' blockOffset' curIndex' spanIndex + 1' indent + IndentString' markers' out spanIndex);                        sb.Append(indent);                      sb.Append("}");                      sb.AppendLine();                  }                  else                  {                      int ilOffset = curIndex + blockOffset;                      string marker;                      if (markers != null && markers.TryGetValue(ilOffset' out marker))                      {                          sb.Append(indent.Substring(0' indent.Length - marker.Length));                          sb.Append(marker);                      }                      else                      {                          sb.Append(indent);                      }                        sb.AppendFormat("IL_{0:x4}:"' ilOffset);                        OpCode opCode;                      int expectedSize;                        byte op1 = ilBytes[curIndex++];                      if (op1 == 0xfe && curIndex < length)                      {                          byte op2 = ilBytes[curIndex++];                          opCode = TwoByteOpCodes[op2];                          expectedSize = 2;                      }                      else                      {                          opCode = OneByteOpCodes[op1];                          expectedSize = 1;                      }                        if (opCode.Size != expectedSize)                      {                          sb.AppendLine(string.Format("  <unknown 0x{0}{1:X2}>"' expectedSize == 2 ? "fe" : ""' op1));                          continue;                      }                        sb.Append("  ");                      sb.AppendFormat(opCode.OperandType == OperandType.InlineNone ? "{0}" : "{0'-10}"' opCode);                        switch (opCode.OperandType)                      {                          case OperandType.InlineField:                          case OperandType.InlineMethod:                          case OperandType.InlineTok:                          case OperandType.InlineType:                              sb.Append(' ');                              sb.Append(VisualizeSymbol(ReadUint(ilBytes' ref curIndex)));                              break;                            case OperandType.InlineSig: // signature (calli)' not emitted by C#/VB                              sb.AppendFormat(" 0x{0:x}"' ReadUint(ilBytes' ref curIndex));                              break;                            case OperandType.InlineString:                              sb.Append(' ');                              sb.Append(VisualizeUserString(ReadUint(ilBytes' ref curIndex)));                              break;                            case OperandType.InlineNone:                              break;                            case OperandType.ShortInlineI:                              sb.AppendFormat(" {0}"' ReadSByte(ilBytes' ref curIndex));                              break;                            case OperandType.ShortInlineVar:                              sb.AppendFormat(" V_{0}"' ReadByte(ilBytes' ref curIndex));                              break;                            case OperandType.InlineVar:                              sb.AppendFormat(" V_{0}"' ReadUShort(ilBytes' ref curIndex));                              break;                            case OperandType.InlineI:                              sb.AppendFormat(" 0x{0:x}"' ReadUint(ilBytes' ref curIndex));                              break;                            case OperandType.InlineI8:                              sb.AppendFormat(" 0x{0:x8}"' ReadUlong(ilBytes' ref curIndex));                              break;                            case OperandType.ShortInlineR:                              {                                  var value = ReadSingle(ilBytes' ref curIndex);                                  if (value == 0 && 1 / value < 0)                                  {                                      sb.Append(" -0.0");                                  }                                  else                                  {                                      sb.AppendFormat(" {0}"' value.ToString(CultureInfo.InvariantCulture));                                  }                              }                              break;                            case OperandType.InlineR:                              {                                  var value = ReadDouble(ilBytes' ref curIndex);                                  if (value == 0 && 1 / value < 0)                                  {                                      sb.Append(" -0.0");                                  }                                  else                                  {                                      sb.AppendFormat(" {0}"' value.ToString(CultureInfo.InvariantCulture));                                  }                              }                              break;                            case OperandType.ShortInlineBrTarget:                              sb.AppendFormat(" IL_{0:x4}"' ReadSByte(ilBytes' ref curIndex) + curIndex + blockOffset);                              break;                            case OperandType.InlineBrTarget:                              sb.AppendFormat(" IL_{0:x4}"' ReadInt(ilBytes' ref curIndex) + curIndex + blockOffset);                              break;                            case OperandType.InlineSwitch:                              int labelCount = ReadInt(ilBytes' ref curIndex);                              int instrEnd = curIndex + labelCount * 4;                              sb.AppendLine("(");                              for (int i = 0; i < labelCount; i++)                              {                                  sb.AppendFormat("        IL_{0:x4}"' ReadInt(ilBytes' ref curIndex) + instrEnd + blockOffset);                                  sb.AppendLine((i == labelCount - 1) ? ")" : "'");                              }                              break;                            default:                              throw ExceptionUtilities.UnexpectedValue(opCode.OperandType);                      }                        sb.AppendLine();                  }                    if (EndsSpan(spans' lastSpanIndex' curIndex + blockOffset))                  {                      break;                  }              }
Magic Number,Roslyn.Test.MetadataUtilities,ILVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\ILVisualizer.cs,DumpILBlock,The following statement contains a magic number: while (curIndex < length)              {                  if (lastSpanIndex > 0 && StartsFilterHandler(spans' lastSpanIndex' curIndex + blockOffset))                  {                      sb.Append(indent.Substring(0' indent.Length - IndentString.Length));                      sb.Append("}  // end filter");                      sb.AppendLine();                        sb.Append(indent.Substring(0' indent.Length - IndentString.Length));                      sb.Append("{  // handler");                      sb.AppendLine();                  }                                    if (StartsSpan(spans' spanIndex' curIndex + blockOffset))                  {                      sb.Append(indent);                      sb.Append(spans[spanIndex].ToString(this));                      sb.AppendLine();                      sb.Append(indent);                      sb.Append("{");                      sb.AppendLine();                        curIndex = DumpILBlock(ilBytes' length' sb' spans' blockOffset' curIndex' spanIndex + 1' indent + IndentString' markers' out spanIndex);                        sb.Append(indent);                      sb.Append("}");                      sb.AppendLine();                  }                  else                  {                      int ilOffset = curIndex + blockOffset;                      string marker;                      if (markers != null && markers.TryGetValue(ilOffset' out marker))                      {                          sb.Append(indent.Substring(0' indent.Length - marker.Length));                          sb.Append(marker);                      }                      else                      {                          sb.Append(indent);                      }                        sb.AppendFormat("IL_{0:x4}:"' ilOffset);                        OpCode opCode;                      int expectedSize;                        byte op1 = ilBytes[curIndex++];                      if (op1 == 0xfe && curIndex < length)                      {                          byte op2 = ilBytes[curIndex++];                          opCode = TwoByteOpCodes[op2];                          expectedSize = 2;                      }                      else                      {                          opCode = OneByteOpCodes[op1];                          expectedSize = 1;                      }                        if (opCode.Size != expectedSize)                      {                          sb.AppendLine(string.Format("  <unknown 0x{0}{1:X2}>"' expectedSize == 2 ? "fe" : ""' op1));                          continue;                      }                        sb.Append("  ");                      sb.AppendFormat(opCode.OperandType == OperandType.InlineNone ? "{0}" : "{0'-10}"' opCode);                        switch (opCode.OperandType)                      {                          case OperandType.InlineField:                          case OperandType.InlineMethod:                          case OperandType.InlineTok:                          case OperandType.InlineType:                              sb.Append(' ');                              sb.Append(VisualizeSymbol(ReadUint(ilBytes' ref curIndex)));                              break;                            case OperandType.InlineSig: // signature (calli)' not emitted by C#/VB                              sb.AppendFormat(" 0x{0:x}"' ReadUint(ilBytes' ref curIndex));                              break;                            case OperandType.InlineString:                              sb.Append(' ');                              sb.Append(VisualizeUserString(ReadUint(ilBytes' ref curIndex)));                              break;                            case OperandType.InlineNone:                              break;                            case OperandType.ShortInlineI:                              sb.AppendFormat(" {0}"' ReadSByte(ilBytes' ref curIndex));                              break;                            case OperandType.ShortInlineVar:                              sb.AppendFormat(" V_{0}"' ReadByte(ilBytes' ref curIndex));                              break;                            case OperandType.InlineVar:                              sb.AppendFormat(" V_{0}"' ReadUShort(ilBytes' ref curIndex));                              break;                            case OperandType.InlineI:                              sb.AppendFormat(" 0x{0:x}"' ReadUint(ilBytes' ref curIndex));                              break;                            case OperandType.InlineI8:                              sb.AppendFormat(" 0x{0:x8}"' ReadUlong(ilBytes' ref curIndex));                              break;                            case OperandType.ShortInlineR:                              {                                  var value = ReadSingle(ilBytes' ref curIndex);                                  if (value == 0 && 1 / value < 0)                                  {                                      sb.Append(" -0.0");                                  }                                  else                                  {                                      sb.AppendFormat(" {0}"' value.ToString(CultureInfo.InvariantCulture));                                  }                              }                              break;                            case OperandType.InlineR:                              {                                  var value = ReadDouble(ilBytes' ref curIndex);                                  if (value == 0 && 1 / value < 0)                                  {                                      sb.Append(" -0.0");                                  }                                  else                                  {                                      sb.AppendFormat(" {0}"' value.ToString(CultureInfo.InvariantCulture));                                  }                              }                              break;                            case OperandType.ShortInlineBrTarget:                              sb.AppendFormat(" IL_{0:x4}"' ReadSByte(ilBytes' ref curIndex) + curIndex + blockOffset);                              break;                            case OperandType.InlineBrTarget:                              sb.AppendFormat(" IL_{0:x4}"' ReadInt(ilBytes' ref curIndex) + curIndex + blockOffset);                              break;                            case OperandType.InlineSwitch:                              int labelCount = ReadInt(ilBytes' ref curIndex);                              int instrEnd = curIndex + labelCount * 4;                              sb.AppendLine("(");                              for (int i = 0; i < labelCount; i++)                              {                                  sb.AppendFormat("        IL_{0:x4}"' ReadInt(ilBytes' ref curIndex) + instrEnd + blockOffset);                                  sb.AppendLine((i == labelCount - 1) ? ")" : "'");                              }                              break;                            default:                              throw ExceptionUtilities.UnexpectedValue(opCode.OperandType);                      }                        sb.AppendLine();                  }                    if (EndsSpan(spans' lastSpanIndex' curIndex + blockOffset))                  {                      break;                  }              }
Magic Number,Roslyn.Test.MetadataUtilities,MetadataVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\MetadataVisualizer.cs,WriteRows,The following statement contains a magic number: for (int r = 0; r < pendingRows.Count; r++)              {                  var row = pendingRows[r];                                   // header                  if (r == 0)                  {                      writer.WriteLine(horizontalSeparator);                      writer.Write(new string(' '' rowNumberWidth + 2));                  }                  else                  {                      string rowNumber = r.ToString("x");                      writer.Write(new string(' '' rowNumberWidth - rowNumber.Length));                      writer.Write(rowNumber);                      writer.Write(": ");                  }                    for (int c = 0; c < row.Length; c++)                  {                      var field = row[c];                        writer.Write(field);                      writer.Write(new string(' '' columnWidths[c] - field.Length));                  }                    writer.WriteLine();                    // header                  if (r == 0)                  {                      writer.WriteLine(horizontalSeparator);                  }              }
Magic Number,Roslyn.Test.MetadataUtilities,MetadataVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\MetadataVisualizer.cs,WriteBlobs,The following statement contains a magic number: do              {                  byte[] value = reader.GetBlobBytes(handle);                    BlobKind kind;                  string kindString;                  if (BlobKinds.TryGetValue(handle' out kind))                  {                      kindString = " (" + kind + ")";                        // ignoring the compressed blob size:                      sizePerKind[(int)kind] += value.Length;                  }                  else                  {                      kindString = "";                  }                    int displayLength = (options & MetadataVisualizerOptions.ShortenBlobs) != 0 ? Math.Min(4' value.Length) : value.Length;                  string valueString = BitConverter.ToString(value' 0' displayLength) + (displayLength < value.Length ? "-..." : null);                    writer.WriteLine($"  {reader.GetHeapOffset(handle):x}{kindString}: {valueString}");                  handle = reader.GetNextHandle(handle);              }              while (!handle.IsNil);
Magic Number,Roslyn.Test.MetadataUtilities,MetadataVisualizer,C:\repos\mono_roslyn\src\Test\PdbUtilities\Metadata\MetadataVisualizer.cs,WriteGuids,The following statement contains a magic number: while (i <= size / 16)              {                  string value = reader.GetGuid(MetadataTokens.GuidHandle(i)).ToString();                  writer.WriteLine("  {0:x}: {{{1}}}"' i' value);                  i++;              }
Magic Number,Roslyn.Test.PdbUtilities,PdbToXmlConverter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\PdbToXml.cs,WriteEditAndContinueLocalSlotMap,The following statement contains a magic number: try              {                  int syntaxOffsetBaseline = -1;                    fixed (byte* compressedSlotMapPtr = &record.Data.ToArray()[0])                  {                      var blobReader = new BlobReader(compressedSlotMapPtr' record.Data.Length);                        while (blobReader.RemainingBytes > 0)                      {                          byte b = blobReader.ReadByte();                            if (b == 0xff)                          {                              if (!blobReader.TryReadCompressedInteger(out syntaxOffsetBaseline))                              {                                  writer.WriteElementString("baseline"' "?");                                  return;                              }                                syntaxOffsetBaseline = -syntaxOffsetBaseline;                              continue;                          }                            writer.WriteStartElement("slot");                            if (b == 0)                          {                              // short-lived temp' no info                              writer.WriteAttributeString("kind"' "temp");                          }                          else                          {                              int synthesizedKind = (b & 0x3f) - 1;                              bool hasOrdinal = (b & (1 << 7)) != 0;                                int syntaxOffset;                              bool badSyntaxOffset = !blobReader.TryReadCompressedInteger(out syntaxOffset);                              syntaxOffset += syntaxOffsetBaseline;                                int ordinal = 0;                              bool badOrdinal = hasOrdinal && !blobReader.TryReadCompressedInteger(out ordinal);                                writer.WriteAttributeString("kind"' synthesizedKind.ToString());                              writer.WriteAttributeString("offset"' badSyntaxOffset ? "?" : syntaxOffset.ToString());                                if (badOrdinal || hasOrdinal)                              {                                  writer.WriteAttributeString("ordinal"' badOrdinal ? "?" : ordinal.ToString());                              }                          }                            writer.WriteEndElement();                      }                  }              }              finally              {                  writer.WriteEndElement(); //encLocalSlotMap              }
Magic Number,Roslyn.Test.PdbUtilities,Token2SourceLineExporter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,Token2String,The following statement contains a magic number: if (maskToken) result = result.Substring(0' 2) + "xxxxxx";
Magic Number,Roslyn.Test.PdbUtilities,Token2SourceLineExporter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,LoadTokenToSourceMapping,The following statement contains a magic number: BitAccess bits = new BitAccess(512 * 1024);
Magic Number,Roslyn.Test.PdbUtilities,Token2SourceLineExporter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,LoadTokenToSourceMapping,The following statement contains a magic number: BitAccess bits = new BitAccess(512 * 1024);
Magic Number,Roslyn.Test.PdbUtilities,Token2SourceLineExporter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,LoadTokenToSourceMapping,The following statement contains a magic number: dir.streams[3].Read(reader' bits);
Magic Number,Roslyn.Test.PdbUtilities,Token2SourceLineExporter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,LoadTokenToSourceInfo,The following statement contains a magic number: if (sig != 4)              {                  throw new Exception(string.Format("Invalid signature. (sig={0})"' sig));              }
Magic Number,Roslyn.Test.PdbUtilities,Token2SourceLineExporter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,LoadTokenToSourceInfo,The following statement contains a magic number: bits.Position = 4;
Magic Number,Roslyn.Test.PdbUtilities,Token2SourceLineExporter,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadSourceFileInfo,The following statement contains a magic number: while (bits.Position < limit)              {                  int sig;                  int siz;                  bits.ReadInt32(out sig);                  bits.ReadInt32(out siz);                  int place = bits.Position;                  int endSym = bits.Position + siz;                    switch ((DEBUG_S_SUBSECTION)sig)                  {                      case DEBUG_S_SUBSECTION.FILECHKSMS:                          while (bits.Position < endSym)                          {                              CV_FileCheckSum chk;                                int ni = bits.Position - place;                              bits.ReadUInt32(out chk.name);                              bits.ReadUInt8(out chk.len);                              bits.ReadUInt8(out chk.type);                                PdbSource src = new PdbSource(/*(uint)ni'*/ (string)names[(int)chk.name]' SymDocumentType.Text' Guid.Empty' Guid.Empty);                              checks.Add(ni' src);                              bits.Position += chk.len;                              bits.Align(4);                          }                          bits.Position = endSym;                          break;                        default:                          bits.Position = endSym;                          break;                  }              }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt16,The following statement contains a magic number: unchecked                  {                      value = (short)((buffer[offset + 0] & 0xFF) |                                            (buffer[offset + 1] << 8));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt16,The following statement contains a magic number: offset += 2;
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt32,The following statement contains a magic number: unchecked                  {                      value = (int)((buffer[offset + 0] & 0xFF) |                                          (buffer[offset + 1] << 8) |                                          (buffer[offset + 2] << 16) |                                          (buffer[offset + 3] << 24));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt32,The following statement contains a magic number: unchecked                  {                      value = (int)((buffer[offset + 0] & 0xFF) |                                          (buffer[offset + 1] << 8) |                                          (buffer[offset + 2] << 16) |                                          (buffer[offset + 3] << 24));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt32,The following statement contains a magic number: unchecked                  {                      value = (int)((buffer[offset + 0] & 0xFF) |                                          (buffer[offset + 1] << 8) |                                          (buffer[offset + 2] << 16) |                                          (buffer[offset + 3] << 24));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt32,The following statement contains a magic number: unchecked                  {                      value = (int)((buffer[offset + 0] & 0xFF) |                                          (buffer[offset + 1] << 8) |                                          (buffer[offset + 2] << 16) |                                          (buffer[offset + 3] << 24));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt32,The following statement contains a magic number: unchecked                  {                      value = (int)((buffer[offset + 0] & 0xFF) |                                          (buffer[offset + 1] << 8) |                                          (buffer[offset + 2] << 16) |                                          (buffer[offset + 3] << 24));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt32,The following statement contains a magic number: offset += 4;
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: unchecked                  {                      value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadInt64,The following statement contains a magic number: offset += 8;
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt16,The following statement contains a magic number: unchecked                  {                      value = (ushort)((buffer[offset + 0] & 0xFF) |                                             (buffer[offset + 1] << 8));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt16,The following statement contains a magic number: offset += 2;
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt32,The following statement contains a magic number: unchecked                  {                      value = (uint)((buffer[offset + 0] & 0xFF) |                                           (buffer[offset + 1] << 8) |                                           (buffer[offset + 2] << 16) |                                           (buffer[offset + 3] << 24));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt32,The following statement contains a magic number: unchecked                  {                      value = (uint)((buffer[offset + 0] & 0xFF) |                                           (buffer[offset + 1] << 8) |                                           (buffer[offset + 2] << 16) |                                           (buffer[offset + 3] << 24));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt32,The following statement contains a magic number: unchecked                  {                      value = (uint)((buffer[offset + 0] & 0xFF) |                                           (buffer[offset + 1] << 8) |                                           (buffer[offset + 2] << 16) |                                           (buffer[offset + 3] << 24));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt32,The following statement contains a magic number: unchecked                  {                      value = (uint)((buffer[offset + 0] & 0xFF) |                                           (buffer[offset + 1] << 8) |                                           (buffer[offset + 2] << 16) |                                           (buffer[offset + 3] << 24));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt32,The following statement contains a magic number: unchecked                  {                      value = (uint)((buffer[offset + 0] & 0xFF) |                                           (buffer[offset + 1] << 8) |                                           (buffer[offset + 2] << 16) |                                           (buffer[offset + 3] << 24));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt32,The following statement contains a magic number: offset += 4;
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: unchecked                  {                      value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                                         ((ulong)buffer[offset + 1] << 8) |                                         ((ulong)buffer[offset + 2] << 16) |                                         ((ulong)buffer[offset + 3] << 24) |                                         ((ulong)buffer[offset + 4] << 32) |                                         ((ulong)buffer[offset + 5] << 40) |                                         ((ulong)buffer[offset + 6] << 48) |                                         ((ulong)buffer[offset + 7] << 56));                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadUInt64,The following statement contains a magic number: offset += 8;
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadFloat,The following statement contains a magic number: offset += 4;
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadDouble,The following statement contains a magic number: offset += 8;
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadDecimal,The following statement contains a magic number: int[] bits = new int[4];
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadString,The following statement contains a magic number: while (offset + len < buffer.Length && buffer[offset + len] != 0)                  {                      len += 2;                  }
Magic Number,Roslyn.Test.PdbUtilities,BitAccess,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,ReadString,The following statement contains a magic number: offset += len + 2;
Magic Number,Roslyn.Test.PdbUtilities,BitSet,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,IsSet,The following statement contains a magic number: int word = index / 32;
Magic Number,Roslyn.Test.PdbUtilities,BitSet,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,GetBit,The following statement contains a magic number: return ((uint)1 << (index % 32));
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))                      throw new ArgumentOutOfRangeException("loadFactorPerc"' String.Format("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))                      throw new ArgumentOutOfRangeException("loadFactorPerc"' String.Format("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))                      throw new ArgumentOutOfRangeException("loadFactorPerc"' String.Format("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))                      throw new ArgumentOutOfRangeException("loadFactorPerc"' String.Format("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,IntHashTable,The following statement contains a magic number: this.loadFactorPerc = (loadFactorPerc * 72) / 100;
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,IntHashTable,The following statement contains a magic number: this.loadFactorPerc = (loadFactorPerc * 72) / 100;
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,IntHashTable,The following statement contains a magic number: loadsize = (int)(this.loadFactorPerc * hashsize) / 100;
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,InitHash,The following statement contains a magic number: incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)hashsize - 1)));
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,expand,The following statement contains a magic number: rehash(GetPrime(1 + buckets.Length * 2));
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,rehash,The following statement contains a magic number: loadsize = (int)(loadFactorPerc * newsize) / 100;
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,Insert,The following statement contains a magic number: if (count >= loadsize)                  {                      expand();                  }                  else if (occupancy > loadsize && count > 100)                  {                      rehash();                  }
Magic Number,Roslyn.Test.PdbUtilities,IntHashTable,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,putEntry,The following statement contains a magic number: uint incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)newBuckets.Length - 1)));
Magic Number,Roslyn.Test.PdbUtilities,DbiModuleInfo,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,DbiModuleInfo,The following statement contains a magic number: bits.Align(4);
Magic Number,Roslyn.Test.PdbUtilities,PdbFileHeader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,PdbFileHeader,The following statement contains a magic number: bits.MinCapacity(56);
Magic Number,Roslyn.Test.PdbUtilities,PdbFileHeader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,PdbFileHeader,The following statement contains a magic number: bits.FillBuffer(reader' 52);
Magic Number,Roslyn.Test.PdbUtilities,PdbFileHeader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,PdbFileHeader,The following statement contains a magic number: this.magic = new byte[32];
Magic Number,Roslyn.Test.PdbUtilities,PdbFileHeader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,PdbFileHeader,The following statement contains a magic number: int directoryPages = ((((directorySize + pageSize - 1) / pageSize) * 4) + pageSize - 1) / pageSize;
Magic Number,Roslyn.Test.PdbUtilities,PdbFileHeader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,PdbFileHeader,The following statement contains a magic number: bits.FillBuffer(reader' directoryPages * 4);
Magic Number,Roslyn.Test.PdbUtilities,MsfDirectory,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,MsfDirectory,The following statement contains a magic number: int pagesPerPage = head.pageSize / 4;
Magic Number,Roslyn.Test.PdbUtilities,MsfDirectory,C:\repos\mono_roslyn\src\Test\PdbUtilities\Pdb\Token2SourceLineExporter.cs,MsfDirectory,The following statement contains a magic number: for (int i = 0; i < directoryRootPages; i++)                  {                      int pagesInThisPage = pagesToGo <= pagesPerPage ? pagesToGo : pagesPerPage;                      reader.Seek(head.directoryRoot[i]' 0);                      bits.Append(reader.reader' pagesInThisPage * 4);                      pagesToGo -= pagesInThisPage;                  }
Magic Number,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,ReadRecordHeader,The following statement contains a magic number: size = BitConverter.ToInt32(bytes' offset + 4);
Magic Number,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,DecodeDynamicLocalsRecord,The following statement contains a magic number: for (int i = 0; i < bucketCount; i++)              {                  const int FlagBytesCount = 64;                    ulong flags = 0UL;                  for (int j = 0; j < FlagBytesCount; j++)                  {                      var flag = ReadByte(bytes' ref offset) != 0;                      if (flag)                      {                          flags |= 1UL << j;                      }                  }                    int flagCount = ReadInt32(bytes' ref offset);                  int slotId = ReadInt32(bytes' ref offset);                    const int NameBytesCount = 128;                  var pooled = PooledStringBuilder.GetInstance();                  var nameBuilder = pooled.Builder;                    int nameEnd = offset + NameBytesCount;                  while (offset < nameEnd)                  {                      char ch = (char)ReadInt16(bytes' ref offset);                      if (ch == 0)                      {                          // The Identifier name takes 64 WCHAR no matter how big its actual length is.                          offset = nameEnd;                          break;                      }                        nameBuilder.Append(ch);                  }                    var name = pooled.ToStringAndFree();                    var bucket = new DynamicLocalBucket(flagCount' flags' slotId' name);                  builder.Add(bucket);              }
Magic Number,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,DecodeDynamicLocalsRecord,The following statement contains a magic number: for (int i = 0; i < bucketCount; i++)              {                  const int FlagBytesCount = 64;                    ulong flags = 0UL;                  for (int j = 0; j < FlagBytesCount; j++)                  {                      var flag = ReadByte(bytes' ref offset) != 0;                      if (flag)                      {                          flags |= 1UL << j;                      }                  }                    int flagCount = ReadInt32(bytes' ref offset);                  int slotId = ReadInt32(bytes' ref offset);                    const int NameBytesCount = 128;                  var pooled = PooledStringBuilder.GetInstance();                  var nameBuilder = pooled.Builder;                    int nameEnd = offset + NameBytesCount;                  while (offset < nameEnd)                  {                      char ch = (char)ReadInt16(bytes' ref offset);                      if (ch == 0)                      {                          // The Identifier name takes 64 WCHAR no matter how big its actual length is.                          offset = nameEnd;                          break;                      }                        nameBuilder.Append(ch);                  }                    var name = pooled.ToStringAndFree();                    var bucket = new DynamicLocalBucket(flagCount' flags' slotId' name);                  builder.Add(bucket);              }
Magic Number,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetVisualBasicImportStrings,The following statement contains a magic number: if (importStrings.Length > 0)              {                  // As in PdbUtil::GetRawNamespaceListCore' we consider only the first string when                  // checking for forwarding.                  string importString = importStrings[0];                  if (importString.Length >= 2 && importString[0] == '@')                  {                      char ch1 = importString[1];                      if ('0' <= ch1 && ch1 <= '9')                      {                          int tempMethodToken;                          if (int.TryParse(importString.Substring(1)' NumberStyles.None' CultureInfo.InvariantCulture' out tempMethodToken))                          {                              return reader.GetMethodByVersion(tempMethodToken' methodVersion).GetImportStrings();                          }                      }                  }              }
Magic Number,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,ReadInt32,The following statement contains a magic number: return bytes[i] | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);
Magic Number,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,ReadInt32,The following statement contains a magic number: return bytes[i] | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);
Magic Number,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,ReadInt32,The following statement contains a magic number: return bytes[i] | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);
Magic Number,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,ReadInt32,The following statement contains a magic number: return bytes[i] | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);
Magic Number,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,ReadInt32,The following statement contains a magic number: return bytes[i] | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);
Magic Number,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,ReadInt16,The following statement contains a magic number: return (short)(bytes[i] | (bytes[i + 1] << 8));
Magic Number,Microsoft.CodeAnalysis,ArrayBuilder<T>,C:\repos\mono_roslyn\src\Compilers\Core\SharedCollections\ArrayBuilder.cs,Free,The following statement contains a magic number: if (pool != null)              {                  // According to the statistics of a C# compiler self-build' the most commonly used builder size is 0.  (808003 uses).                  // The distant second is the Count == 1 (455619)' then 2 (106362) ...                  // After about 50 (just 67) we have a long tail of infrequently used builder sizes.                  // However we have builders with size up to 50K   (just one such thing)                  //                  // We do not want to retain (potentially indefinitely) very large builders                   // while the chance that we will need their size is diminishingly small.                  // It makes sense to constrain the size to some "not too small" number.                   // Overal perf does not seem to be very sensitive to this number' so I picked 128 as a limit.                  if (this.Count < 128)                  {                      if (this.Count != 0)                      {                          this.Clear();                      }                        pool.Free(this);                      return;                  }                  else                  {                      pool.ForgetTrackedObject(this);                  }              }
Magic Number,Microsoft.CodeAnalysis,ArrayBuilder<T>,C:\repos\mono_roslyn\src\Compilers\Core\SharedCollections\ArrayBuilder.cs,CreatePool,The following statement contains a magic number: return CreatePool(128);
Missing Default,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,GetCSharpGroupedImportStrings,The following switch statement is missing a default case: switch (record.Kind)                  {                      case CustomDebugInfoKind.UsingInfo:                          if (!groupSizes.IsDefault)                          {                              throw new InvalidOperationException(string.Format("Expected at most one Using record for method {0}"' FormatMethodToken(methodToken)));                          }                            groupSizes = DecodeUsingRecord(record.Data);                          break;                        case CustomDebugInfoKind.ForwardInfo:                          if (!externAliasStrings.IsDefault)                          {                              throw new InvalidOperationException(string.Format("Did not expect both Forward and ForwardToModule records for method {0}"' FormatMethodToken(methodToken)));                          }                            methodToken = DecodeForwardRecord(record.Data);                            // Follow at most one forward link (as in FUNCBRECEE::ensureNamespaces).                          // NOTE: Dev11 may produce chains of forward links (e.g. for System.Collections.Immutable).                          if (!seenForward)                          {                              seenForward = true;                              goto RETRY;                          }                            break;                        case CustomDebugInfoKind.ForwardToModuleInfo:                          if (!externAliasStrings.IsDefault)                          {                              throw new InvalidOperationException(string.Format("Expected at most one ForwardToModule record for method {0}"' FormatMethodToken(methodToken)));                          }                            int moduleInfoMethodToken = DecodeForwardToModuleRecord(record.Data);                          ImmutableArray<string> allModuleInfoImportStrings = reader.GetMethodByVersion(moduleInfoMethodToken' methodVersion).GetImportStrings();                          ArrayBuilder<string> externAliasBuilder = ArrayBuilder<string>.GetInstance();                            foreach (string importString in allModuleInfoImportStrings)                          {                              if (IsCSharpExternAliasInfo(importString))                              {                                  externAliasBuilder.Add(importString);                              }                          }                            externAliasStrings = externAliasBuilder.ToImmutableAndFree();                          break;                  }
Missing Default,Microsoft.VisualStudio.SymReaderInterop,CustomDebugInfoReader,C:\repos\mono_roslyn\src\Test\PdbUtilities\Shared\CustomDebugInfoReader.cs,TryParseVisualBasicImportString,The following switch statement is missing a default case: switch (import[pos])                      {                          case 'F':                              scope = ImportScope.File;                              pos++;                              break;                          case 'P':                              scope = ImportScope.Project;                              pos++;                              break;                      }
