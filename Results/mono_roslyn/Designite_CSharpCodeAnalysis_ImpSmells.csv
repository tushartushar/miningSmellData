Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAnonymousObjectCreation,The method has 103 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateUserDefinedConversion,The method has 130 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The method has 240 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ComputeSortedCrefMembers,The method has 105 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,PerformCrefOverloadResolution,The method has 100 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExpressionInternal,The method has 167 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIdentifier,The method has 115 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNonMethod,The method has 191 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArrayCreationExpression,The method has 103 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConstructorInitializer,The method has 163 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDelegateCreationExpression,The method has 137 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The method has 134 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindClassCreationExpression,The method has 123 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The method has 166 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMethodGroupInvocation,The method has 111 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpressionContinued,The method has 140 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AnalyzeAnonymousFunction,The method has 115 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCompoundAssignment,The method has 167 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleBinaryOperator,The method has 127 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsValidUserDefinedConditionalLogicalOperator,The method has 136 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldNeverOverflowBinaryOperators,The method has 181 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetIsOperatorConstantResult,The method has 205 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAsOperator,The method has 101 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNullCoalescingOperator,The method has 144 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceJoin,The method has 119 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindVariableDeclaration,The method has 122 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckIsVariable,The method has 251 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckPropertyValueKind,The method has 108 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateAnonymousFunctionConversionError,The method has 168 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBooleanExpression,The method has 121 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The method has 341 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The method has 128 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The method has 129 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,FromSyntax,The method has 151 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AddUserDefinedConversionsToExplicitCandidateSet,The method has 154 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeApplicableUserDefinedImplicitConversionSet,The method has 155 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,MostSpecificConversionOperator,The method has 101 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetDelegateOperations,The method has 118 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddMemberToCandidateSet,The method has 115 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,RemoveLessDerivedMembers,The method has 111 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The method has 284 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionTarget,The method has 110 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,Fix,The method has 117 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportDiagnostics,The method has 191 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportBadArgumentError,The method has 123 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,BoundTreeVisitor<A;R>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs,Visit,The method has 107 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSimpleBuiltInOperators,The method has 167 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSimpleBuiltInOperators,The method has 289 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,FindEntryPoint,The method has 115 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetTypeInfoForNode,The method has 107 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The method has 275 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,CreateMemberModel,The method has 150 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,DefaultVisit,The method has 122 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,RewriteIncludeElement,The method has 140 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,The method has 166 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The method has 288 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,BindMethodBody,The method has 118 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,BindConstructorInitializer,The method has 111 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructFieldLikeEventAccessorBody_Regular,The method has 150 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,ErrorFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\ErrorFacts.cs,GetWarningLevel,The method has 181 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,RewriteLambdaConversion,The method has 173 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The method has 204 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedBuiltInComparisonOperator,The method has 120 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedUserDefinedComparisonOperator,The method has 133 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,OptimizeLiftedBinaryArithmetic,The method has 119 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSizeOfMultiplication,The method has 116 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeArguments,The method has 118 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterValue,The method has 130 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The method has 339 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteConditionalAccess,The method has 201 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The method has 203 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetIntPtrConversionMethod,The method has 105 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteEnumeratorForEachStatement,The method has 198 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteMultiDimensionalArrayForEachStatement,The method has 135 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitLockStatement,The method has 144 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectInitializer,The method has 137 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteUsingStatementTryFinally,The method has 135 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,StateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineRewriter.cs,CreateNonReusableLocalProxies,The method has 100 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,SyntaxFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\CharacterInfo.cs,GetKeywordKind,The method has 169 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,SyntaxFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\CharacterInfo.cs,GetText,The method has 396 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitMethod,The method has 222 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreateAndSetSourceAssemblyFullBind,The method has 147 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,TypeUnification,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeUnification.cs,CanUnifyHelper,The method has 122 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,ComputeDeclarations,The method has 136 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitExpression,The method has 178 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitConditionalAccessExpression,The method has 115 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitCallExpression,The method has 184 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitAssignmentPreamble,The method has 136 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitBinaryCondOperator,The method has 114 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitCondBranch,The method has 157 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitCatchBlock,The method has 134 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\SourceAttributeData.cs,GetTargetAttributeSignatureIndex,The method has 156 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,ResolveBounds,The method has 157 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindOverriddenOrHiddenMembersInType,The method has 108 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The method has 151 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The method has 191 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ForceComplete,The method has 120 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMemberNameConflicts,The method has 172 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,AddNonTypeMembers,The method has 238 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,The method has 148 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMembersAgainstBaseType,The method has 143 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The method has 210 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberFieldSymbol.cs,GetFieldType,The method has 128 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The method has 172 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,MakeOneDeclaredBases,The method has 148 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,SourcePropertySymbol,The method has 250 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceUserDefinedOperatorSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceUserDefinedOperatorSymbolBase.cs,CheckUserDefinedConversionSignature,The method has 136 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,IsAsRestrictive,The method has 131 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParsePragmaDirective,The method has 106 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsTerminator,The method has 155 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseNamespaceBody,The method has 161 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseModifiers,The method has 112 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseClassOrStructOrInterfaceDeclaration,The method has 139 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The method has 288 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseOperatorDeclaration,The method has 114 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAccessorDeclaration,The method has 117 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseParameterModifiers,The method has 103 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseVariableDeclarator,The method has 178 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberName,The method has 144 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseSubExpressionCore,The method has 150 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseTerm,The method has 109 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanSyntaxToken,The method has 427 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanNumericLiteral,The method has 275 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_FastPath,The method has 155 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_SlowPath,The method has 236 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_CrefSlowPath,The method has 219 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexSyntaxTrivia,The method has 104 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanDirectiveToken,The method has 136 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlEntity,The method has 139 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlCrefToken,The method has 252 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The method has 112 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,InterpolatedStringScanner,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer_StringLiteral.cs,ScanInterpolatedStringLiteralHoleBalancedText,The method has 128 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,MetadataDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\MetadataDecoder.cs,SubstituteNoPiaLocalType,The method has 121 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,ComputeMethodKind,The method has 102 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,LoadMembers,The method has 179 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxEquivalence,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxEquivalence.cs,AreEquivalentRecursive,The method has 109 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,NeedsSeparator,The method has 109 lines of code.
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAnonymousObjectCreation,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ProcessParameterlessCrefMemberLookupResults,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArgumentAndName,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindStackAllocArrayCreationExpression,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConstructorInitializer,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindClassCreationExpression,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExtensionMethod,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindFieldAccess,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetSymbolOrMethodOrPropertyGroup,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindPointerElementAccess,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConditionalAccessExpression,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpressionContinued,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AnalyzeAnonymousFunction,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAnonymousFunction,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInSubmissions,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddWinRTMembers,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ValidateParameterNameConflicts,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCompoundAssignment,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldBinaryOperator,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIsOperator,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAsOperator,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNullCoalescingOperator,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindVariableDeclaration,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckIsVariable,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckValue,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateAnonymousFunctionConversionError,Cyclomatic complexity of the method is 23
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBooleanExpression,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindReturn,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCatchBlock,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.CodeAnalysis.CSharp,ConsistentSymbolOrder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Symbols.cs,Compare,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp,ImportChain,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ImportChain.cs,TranslateImports,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,FromSyntax,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,InMethodBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InMethodBinder.cs,ReportConflictWithParameter,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,BestTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\BestTypeInferrer.cs,GetBestType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,BestTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\BestTypeInferrer.cs,Better,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,IsAnonymousFunctionCompatibleWithDelegate,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ClassifyExplicitBuiltInOnlyConversion,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasBoxingConversion,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceConversion,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitDelegateConversion,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitArrayConversion,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasUnboxingConversion,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AddUserDefinedConversionsToExplicitCandidateSet,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,UniqueBestValidIndex,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BinaryOperatorOverloadResolution,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,UnaryOperatorOverloadResolution,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddMemberToCandidateSet,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,RemoveAllInterfaceMembers,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,RemoveWorseMembers,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,Cyclomatic complexity of the method is 27
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,MoreSpecificType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,ExpressionMatchExactly,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionTarget,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,CanDowngradeConversionFromLambdaToNeither,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AnalyzeArguments,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,Fix,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,InferReturnType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportDiagnostics,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,GetAttributesToBind,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,MatchAttributeTarget,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyBind,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,GenerateSummaryErrors,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,IsValidObjectEquality,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,StartSourceChecksumCalculation,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDebuggableAttribute,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,FilterOverriddenOrHiddenIndexers,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolInfoFromNode,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetEnclosingBinder,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,NodeMapBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.NodeMapBuilder.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredMember,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,VisitAssembly,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,VisitTypeOrMember,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckForAttributeWithArrayArgumentInternal,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckMemberDistinctness,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,GetDeclaredCompliance,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,TryGetCollisionErrorCode,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,DefaultVisit,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,TryProcessDocumentationCommentTriviaNodes,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteFormattedMultiLineComment,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,Rewrite,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,RewriteIncludeElement,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,LowerBodyOrInitializer,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,BindMethodBody,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,ValidateOptions,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp,DeclarationTable,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTable.Cache.cs,ContainsName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,MergedNamespaceDeclaration,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\MergedNamespaceDeclaration.cs,MakeChildren,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,SourceDocumentationCommentUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\DocumentationComments\SourceDocumentationCommentUtils.cs,GetDocumentationCommentTriviaFromSyntaxNode,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,AbstractFlowPass<TLocalState>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\AbstractFlowPass.cs,VisitTryStatement,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,ReportUnassignedOutParameter,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,SetSlotAssigned,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,PreciseAbstractFlowPass<LocalState>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\PreciseAbstractFlowPass.AbstractLocalState.cs,VisitTryStatement,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,AsyncMethodBuilderMemberCollection,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodBuilderMemberCollection.cs,TryCreate,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,ConvertedHasEqual,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckOr,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,FindSurprisingSignExtensionBits,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumerableImplementation,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,IntroduceFrame,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,RewriteLambdaConversion,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,Analysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,ComputeLambdaScopesAndFrameCaptures,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,LambdaFrame,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaFrame.cs,AssertIsLambdaScopeSyntax,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWindowsRuntimeEventAssignmentOperator,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitObjectCreationExpression,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,GetDelegateType,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,PossibleIteratorScope,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,MightContainReferences,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,StateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineRewriter.cs,CreateNonReusableLocalProxies,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,ObjectDisplay,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\ObjectDisplay.cs,FormatPrimitive,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CodeAnalysis.CSharp,ObjectDisplay,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\ObjectDisplay.cs,FormatString,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitMethod,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitParameter,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddMemberModifiersIfRequired,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitNamedType,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddNameAndTypeArgumentsOrParameters,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddTypeParameterConstraints,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreateAndSetSourceAssemblyFullBind,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,InitializeNewSymbols,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,SetupReferencesForRetargetingAssembly,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,SymbolDistinguisher,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SymbolDistinguisher.cs,MakeDescriptions,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,TypedConstantExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypedConstantExtensions.cs,DisplayUnsignedEnumConstant,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,TypedConstantExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypedConstantExtensions.cs,DisplaySignedEnumConstant,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxRewriter.cs,VisitList,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,SeparatedList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,IsCompleteSubmission,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitSequenceAddress,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,ShouldEmitBlockInitializer,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitConditionalAccessExpression,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitCallExpression,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,TryEmitAssignmentInPlace,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitCatchBlock,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGen,Optimizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,RemoveIntersectingLocals,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitSequence,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,IsNestedLocalOfCompoundOperator,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,AssignTemplatesNamesAndCompile,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,NamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\NamedTypeSymbolAdapter.cs,GetExplicitImplementationOverrides,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,GetTopLevelTypeByMetadataName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\SourceAttributeData.cs,GetTargetAttributeSignatureIndex,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,BaseTypeAnalysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\BaseTypeAnalysis.cs,DependsOnDefinitelyManagedType,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,SatisfiesConstraintType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,Equals,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MethodSymbolExtensions.cs,InferExtensionMethodTypeArguments,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,NamespaceOrTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\NamespaceOrTypeSymbol.cs,LookupMetadataType,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakeInterfaceOverriddenOrHiddenMembers,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindOverriddenOrHiddenMembersInType,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindOtherOverriddenMethodsInContainingType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,ConstantEvaluationHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ConstantEvaluationHelpers.cs,OrderGraph,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedMember,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitImplementationCollisions,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForAddedModules,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportNameCollisionDiagnosticsForAddedModules,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,GetUnusedFieldWarnings,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,TryLookupForwardedMetadataTypeWithCycleDetection,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceCustomEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceCustomEventSymbol.cs,SourceCustomEventSymbol,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,ComputeIsWindowsRuntimeEvent,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MakeAndCheckTypeModifiers,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMemberNameConflicts,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckIndexerNameConflicts,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckSequentialOnPartialType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MergePartialMethods,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,AddSynthesizedConstructorsIfNecessary,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckNewModifier,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,SynthesizeInterfaceMemberImplementation,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,LazyAsyncMethodChecks,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceModuleSymbol.cs,ValidateLinkedAssemblies,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,MakeTypeParameters,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,EarlyDecodeWellKnownAttribute,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,PostDecodeWellKnownAttributes,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,MakeDeclaredBases,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,MakeOneDeclaredBases,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,MakeAcyclicInterfaces,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamespaceSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol.cs,GetNameToTypeMembersMap,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamespaceSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol.cs,MakeNameToMembersMap,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,SourcePropertySymbol,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SourceUserDefinedOperatorSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceUserDefinedOperatorSymbolBase.cs,CheckUserDefinedConversionSignature,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedMethodSymbol.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,MakeMethodScopedSynthesizedName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ComputeImplementationForInterfaceMember,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ComputeAbstractMembers,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Emit,CSharpDefinitionMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\CSharpDefinitionMap.cs,CreateLocalSlotMap,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,GetExportedTypes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,Translate,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedEvent,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedEvent.cs,EmbedCorrespondingComEventInterfaceMethodInternal,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,EmbedType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Reader,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Blender.Reader.cs,CanReuse,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseCrefTypeSuffix,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseClassOrStructOrInterfaceDeclaration,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,Cyclomatic complexity of the method is 31
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAccessorDeclaration,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseVariableDeclarator,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanNonArrayType,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleMethodDeclarationFollowingNullableType,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseSubExpressionCore,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanExplicitlyTypedLambda,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsQueryExpressionAfterFrom,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanNumericLiteral,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_SlowPath,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanStringLiteral,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxParser.cs,AddSkippedSyntax,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Enumerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\ChildSyntaxList.Enumerator.cs,MoveNext,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Enumerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\ChildSyntaxList.Enumerator.cs,MoveNext,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxToken,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.cs,GetWellKnownTokens,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxToken,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.cs,IsEquivalentTo,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,MetadataDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\MetadataDecoder.cs,SubstituteNoPiaLocalType,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,ComputeMethodKind,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,GetEnumFieldsToEmit,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,LoadMembers,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEParameterSymbol.cs,GetAttributes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEPropertySymbol.cs,PEPropertySymbol,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,SymbolFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\SymbolFactory.cs,SubstituteTypeParameters,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,RetargetNamedTypeDefinition,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,RetargetNoPiaLocalType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,Retarget,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,IsNoPiaIllegalGenericInstantiation,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxEquivalence,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxEquivalence.cs,AreEquivalentRecursive,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,NeedsSeparator,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,RewriteTrivia,Cyclomatic complexity of the method is 12
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDiagnosticsIfObsolete,The method has 7 parameters. Parameters: diagnostics' symbol' node' hasBaseReceiver' containingMember' containingType' location
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDiagnosticsIfObsoleteInternal,The method has 5 parameters. Parameters: diagnostics' symbol' node' containingMember' location
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveOverloads,The method has 6 parameters. Parameters: members' typeArguments' arguments' result' useSiteDiagnostics' allowRefOmittedArguments
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsSymbolAccessibleConditional,The method has 6 parameters. Parameters: symbol' within' throughTypeOpt' failedThroughTypeCheck' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForSynthesizedAttribute,The method has 5 parameters. Parameters: compilation' attributeMember' diagnostics' location' syntax
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAttributeTypes,The method has 5 parameters. Parameters: binders' attributesToBind' ownerSymbol' boundAttributeTypes' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAttributes,The method has 5 parameters. Parameters: binders' attributesToBind' boundAttributeTypes' attributesBuilder' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNamedAttributeArgumentName,The method has 5 parameters. Parameters: namedArgument' attributeType' diagnostics' wasError' resultKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAttributeConstructor,The method has 7 parameters. Parameters: node' attributeType' boundConstructorArguments' diagnostics' resultKind' suppressErrors' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetRewrittenAttributeConstructorArguments,The method has 7 parameters. Parameters: constructorArgumentsSourceIndices' attributeConstructor' constructorArgsArray' constructorArgumentNamesOpt' syntax' diagnostics' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetMatchingNamedOrOptionalConstructorArgument,The method has 9 parameters. Parameters: matchingArgumentIndex' constructorArgsArray' constructorArgumentNamesOpt' parameter' startIndex' argumentsCount' argsConsumedCount' syntax' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetParamArrayArgument,The method has 5 parameters. Parameters: parameter' constructorArgsArray' argumentsCount' argsConsumedCount' conversions
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAwaitableExpressionInfo,The method has 6 parameters. Parameters: expression' getAwaiter' isCompleted' getResult' node' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetIsCompletedProperty,The method has 5 parameters. Parameters: awaiterType' node' awaitedExpressionType' diagnostics' isCompletedProperty
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetGetResultMethod,The method has 5 parameters. Parameters: awaiterType' node' awaitedExpressionType' diagnostics' getResultMethod
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateConversion,The method has 6 parameters. Parameters: syntax' source' conversion' isCast' destination' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateConversion,The method has 7 parameters. Parameters: syntax' source' conversion' isCast' wasCompilerGenerated' destination' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateUserDefinedConversion,The method has 6 parameters. Parameters: syntax' source' conversion' isCast' destination' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateAnonymousFunctionConversion,The method has 6 parameters. Parameters: syntax' source' conversion' isCast' destination' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateMethodGroupConversion,The method has 6 parameters. Parameters: syntax' source' conversion' isCast' destination' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MemberGroupFinalValidation,The method has 5 parameters. Parameters: receiverOpt' methodSymbol' node' diagnostics' invokedAsExtensionMethod
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MemberGroupFinalValidationAccessibilityChecks,The method has 5 parameters. Parameters: receiverOpt' memberSymbol' node' diagnostics' invokedAsExtensionMethod
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MethodGroupIsCompatibleWithDelegate,The method has 6 parameters. Parameters: receiverOpt' isExtensionMethod' method' delegateType' errorLocation' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MethodGroupConversionHasErrors,The method has 6 parameters. Parameters: syntax' conversion' receiverOpt' isExtensionMethod' delegateType' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MethodGroupConversionDoesNotExistOrHasErrors,The method has 5 parameters. Parameters: boundMethodGroup' delegateType' delegateMismatchLocation' diagnostics' conversion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldConstantConversion,The method has 5 parameters. Parameters: syntax' source' conversion' destination' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ComputeSortedCrefMembers,The method has 6 parameters. Parameters: syntax' containerOpt' memberName' arity' hasParameterList' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ComputeSortedCrefMembers,The method has 5 parameters. Parameters: containerOpt' memberName' arity' hasParameterList' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ProcessCrefMemberLookupResults,The method has 7 parameters. Parameters: symbols' arity' memberSyntax' typeArgumentListSyntax' parameterListSyntax' ambiguityWinner' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ProcessParameterlessCrefMemberLookupResults,The method has 6 parameters. Parameters: symbols' arity' memberSyntax' typeArgumentListSyntax' ambiguityWinner' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,PerformCrefOverloadResolution,The method has 6 parameters. Parameters: candidates' parameterSymbols' arity' memberSyntax' ambiguityWinner' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNonMethod,The method has 5 parameters. Parameters: node' symbol' diagnostics' resultKind' isError
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCastCore,The method has 5 parameters. Parameters: node' operand' targetType' wasCompilerGenerated' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArgumentAndName,The method has 5 parameters. Parameters: result' diagnostics' hadError' argumentSyntax' allowArglist
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArgumentAndName,The method has 8 parameters. Parameters: result' diagnostics' hadError' argumentSyntax' argumentExpression' nameColonSyntax' refKind' allowArglist
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArrayInitializerExpressions,The method has 5 parameters. Parameters: initializer' exprBuilder' diagnostics' dimension' rank
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ConvertAndBindArrayInitialization,The method has 7 parameters. Parameters: diagnostics' node' type' knownSizes' dimension' boundInitExpr' boundInitExprIndex
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArrayInitializerList,The method has 6 parameters. Parameters: diagnostics' node' type' knownSizes' dimension' boundInitExprOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArrayCreationWithInitializer,The method has 6 parameters. Parameters: diagnostics' creationSyntax' initSyntax' type' sizes' boundInitExprOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindClassCreationExpression,The method has 5 parameters. Parameters: node' type' typeName' boundInitializerOpt' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMemberAssignment,The method has 5 parameters. Parameters: memberInitializer' initializerType' objectInitializerMemberBinder' diagnostics' implicitReceiver
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckNestedObjectInitializerPropertySymbol,The method has 5 parameters. Parameters: propertySymbol' memberNameSyntax' diagnostics' suppressErrors' resultKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BadObjectInitializerMemberAccess,The method has 6 parameters. Parameters: boundMember' implicitReceiver' memberNameSyntax' diagnostics' valueKind' suppressErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElement,The method has 6 parameters. Parameters: elementInitializer' initializerType' hasEnumerableInitializerType' collectionInitializerAddMethodBinder' diagnostics' implicitReceiver
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindComplexElementInitializerExpression,The method has 5 parameters. Parameters: elementInitializer' diagnostics' hasEnumerableInitializerType' collectionInitializerAddMethodBinder' implicitReceiver
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElementAddMethod,The method has 6 parameters. Parameters: elementInitializer' boundElementInitializerExpressions' hasEnumerableInitializerType' collectionInitializerAddMethodBinder' diagnostics' implicitReceiver
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindClassCreationExpression,The method has 7 parameters. Parameters: node' typeName' typeNode' type' analyzedArguments' diagnostics' boundInitializerOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindComImportCoClassCreationExpression,The method has 5 parameters. Parameters: node' interfaceType' coClassType' boundInitializerOpt' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNoPiaObjectCreationExpression,The method has 5 parameters. Parameters: node' interfaceType' coClassType' boundInitializerOpt' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,The method has 9 parameters. Parameters: typeContainingConstructors' analyzedArguments' errorName' errorLocation' suppressResultDiagnostics' diagnostics' memberResolutionResult' candidateConstructors' allowProtectedConstructorsOfBaseType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDynamicMemberAccess,The method has 6 parameters. Parameters: node' boundLeft' right' invoked' indexed' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The method has 7 parameters. Parameters: node' boundLeft' right' operatorToken' invoked' indexed' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInstanceMemberAccess,The method has 9 parameters. Parameters: node' right' boundLeft' rightName' rightArity' typeArgumentsSyntax' typeArguments' invoked' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessReportError,The method has 6 parameters. Parameters: node' name' plainName' boundLeft' lookupError' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessBadResult,The method has 6 parameters. Parameters: node' nameString' boundLeft' lookupError' symbols' lookupKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberOfType,The method has 10 parameters. Parameters: node' right' plainName' arity' left' typeArgumentsSyntax' typeArguments' lookupResult' methodGroupFlags' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExtensionMethod,The method has 6 parameters. Parameters: expression' methodName' analyzedArguments' left' typeArguments' isMethodGroupConversion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,PopulateExtensionMethodsFromSingleBinder,The method has 7 parameters. Parameters: scope' methodGroup' node' left' rightName' typeArguments' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindFieldAccess,The method has 6 parameters. Parameters: node' receiver' fieldSymbol' diagnostics' resultKind' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindPropertyAccess,The method has 6 parameters. Parameters: node' receiver' propertySymbol' diagnostics' lookupResult' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindEventAccess,The method has 6 parameters. Parameters: node' receiver' eventSymbol' diagnostics' lookupResult' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckInstanceOrStatic,The method has 5 parameters. Parameters: node' receiver' symbol' resultKind' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetSymbolOrMethodOrPropertyGroup,The method has 7 parameters. Parameters: result' node' plainName' arity' methodOrPropertyGroup' diagnostics' wasError
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BadIndexerExpression,The method has 5 parameters. Parameters: node' expr' analyzedArguments' errorOpt' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexedPropertyAccess,The method has 5 parameters. Parameters: syntax' receiverOpt' propertyGroup' arguments' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDynamicIndexer,The method has 5 parameters. Parameters: syntax' receiverOpt' arguments' applicableProperties' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexerOrIndexedPropertyAccess,The method has 5 parameters. Parameters: syntax' receiverOpt' propertyGroup' analyzedArguments' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveMethodGroup,The method has 5 parameters. Parameters: node' analyzedArguments' isMethodGroupConversion' useSiteDiagnostics' inferWithDynamic
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveMethodGroup,The method has 8 parameters. Parameters: node' expression' methodName' analyzedArguments' isMethodGroupConversion' useSiteDiagnostics' inferWithDynamic' allowUnexpandedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveMethodGroupInternal,The method has 8 parameters. Parameters: methodGroup' expression' methodName' analyzedArguments' isMethodGroupConversion' useSiteDiagnostics' inferWithDynamic' allowUnexpandedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveDefaultMethodGroup,The method has 6 parameters. Parameters: node' analyzedArguments' isMethodGroupConversion' useSiteDiagnostics' inferWithDynamic' allowUnexpandedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindFieldInitializers,The method has 6 parameters. Parameters: typeSymbol' scriptCtor' fieldInitializers' generateDebugInfo' diagnostics' processedInitializers
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindFieldInitializers,The method has 6 parameters. Parameters: containingType' scriptCtor' initializers' diagnostics' generateDebugInfo' firstImportChain
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindRegularCSharpFieldInitializers,The method has 6 parameters. Parameters: compilation' initializers' boundInitializers' diagnostics' generateDebugInfo' firstDebugImports
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindScriptFieldInitializers,The method has 7 parameters. Parameters: compilation' scriptCtor' initializers' boundInitializers' diagnostics' generateDebugInfo' firstDebugImports
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeInvocationExpression,The method has 10 parameters. Parameters: node' receiver' methodName' args' diagnostics' typeArgsSyntax' typeArgs' queryClause' allowFieldsAndProperties' allowUnexpandedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpression,The method has 8 parameters. Parameters: node' expression' methodName' boundExpression' analyzedArguments' diagnostics' queryClause' allowUnexpandedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDynamicInvocation,The method has 6 parameters. Parameters: node' expression' arguments' applicableMethods' diagnostics' queryClause
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDelegateInvocation,The method has 8 parameters. Parameters: node' expression' methodName' boundExpression' analyzedArguments' diagnostics' queryClause' delegateType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMethodGroupInvocation,The method has 8 parameters. Parameters: syntax' expression' methodName' methodGroup' analyzedArguments' diagnostics' queryClause' allowUnexpandedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpressionContinued,The method has 9 parameters. Parameters: node' expression' methodName' result' analyzedArguments' methodGroup' delegateTypeOpt' diagnostics' queryClause
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateBadCall,The method has 9 parameters. Parameters: node' name' receiver' methods' resultKind' typeArguments' analyzedArguments' invokedAsExtensionMethod' isDelegate
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsSimpleName,The method has 8 parameters. Parameters: result' qualifierOpt' plainName' arity' basesBeingResolved' options' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupExtensionMethods,The method has 5 parameters. Parameters: result' name' arity' options' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsWithFallback,The method has 6 parameters. Parameters: result' name' arity' useSiteDiagnostics' basesBeingResolved' options
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsInternal,The method has 7 parameters. Parameters: result' name' arity' basesBeingResolved' options' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsInSingleBinder,The method has 8 parameters. Parameters: result' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsOrMembersInternal,The method has 8 parameters. Parameters: result' qualifierOpt' name' arity' basesBeingResolved' options' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersWithFallback,The method has 7 parameters. Parameters: result' nsOrType' name' arity' useSiteDiagnostics' basesBeingResolved' options
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInternal,The method has 9 parameters. Parameters: result' nsOrType' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInType,The method has 9 parameters. Parameters: result' type' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInErrorType,The method has 9 parameters. Parameters: result' errorType' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInSubmissions,The method has 9 parameters. Parameters: result' submissionClass' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInNamespace,The method has 8 parameters. Parameters: result' ns' name' arity' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupExtensionMethodsInSingleBinder,The method has 6 parameters. Parameters: scope' result' name' arity' options' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupAttributeType,The method has 8 parameters. Parameters: result' qualifierOpt' name' arity' basesBeingResolved' options' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetCandidateExtensionMethods,The method has 6 parameters. Parameters: searchUsingsNotNamespace' methods' name' arity' options' isCallerSemanticModel
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersWithoutInheritance,The method has 10 parameters. Parameters: result' type' name' arity' options' originalBinder' accessThroughType' diagnose' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInClass,The method has 9 parameters. Parameters: result' type' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddWinRTMembers,The method has 8 parameters. Parameters: result' type' name' arity' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetWellKnownWinRTMemberInterfaces,The method has 6 parameters. Parameters: idictSymbol' iroDictSymbol' iListSymbol' iCollectionSymbol' inccSymbol' inpcSymbol
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ShouldAddWinRTMembersForInterface,The method has 7 parameters. Parameters: iface' idictSymbol' iroDictSymbol' iListSymbol' iCollectionSymbol' inccSymbol' inpcSymbol
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInInterfaceOnly,The method has 9 parameters. Parameters: current' type' name' arity' options' originalBinder' accessThroughType' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInInterfacesWithoutInheritance,The method has 9 parameters. Parameters: current' interfaces' name' arity' options' originalBinder' accessThroughType' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInInterface,The method has 9 parameters. Parameters: current' type' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInTypeParameter,The method has 9 parameters. Parameters: current' typeParameter' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckViability,The method has 7 parameters. Parameters: symbol' arity' options' accessThroughType' diagnose' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckViability,The method has 8 parameters. Parameters: result' symbols' arity' options' accessThroughType' diagnose' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsAccessible,The method has 5 parameters. Parameters: symbol' accessThroughType' failedThroughTypeCheck' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,WrongArity,The method has 5 parameters. Parameters: symbol' arity' diagnose' options' diagInfo
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddMemberLookupSymbolsInfoWithoutInheritance,The method has 5 parameters. Parameters: result' type' options' originalBinder' accessThroughType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddWinRTMembersLookupSymbolsInfo,The method has 5 parameters. Parameters: result' type' options' originalBinder' accessThroughType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddMemberLookupSymbolsInfoInClass,The method has 5 parameters. Parameters: result' type' options' originalBinder' accessThroughType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddMemberLookupSymbolsInfoInInterface,The method has 5 parameters. Parameters: result' type' options' originalBinder' accessThroughType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindEventAssignment,The method has 5 parameters. Parameters: node' left' right' opKind' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDynamicBinaryOperator,The method has 5 parameters. Parameters: node' kind' left' right' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleBinaryOperator,The method has 5 parameters. Parameters: node' diagnostics' left' right' compoundStringLength
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUnaryOperatorError,The method has 5 parameters. Parameters: node' diagnostics' operatorName' operand' resultKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportAssignmentOperatorError,The method has 5 parameters. Parameters: node' diagnostics' left' right' resultKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportBinaryOperatorError,The method has 6 parameters. Parameters: node' diagnostics' operatorToken' left' right' resultKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsValidUserDefinedConditionalLogicalOperator,The method has 5 parameters. Parameters: syntax' signature' diagnostics' trueOperator' falseOperator
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,HasApplicableBooleanOperator,The method has 5 parameters. Parameters: containingType' name' argumentType' useSiteDiagnostics' operator
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BinaryOperatorOverloadResolution,The method has 7 parameters. Parameters: kind' left' right' node' diagnostics' resultKind' originalUserDefinedOperators
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,UnaryOperatorOverloadResolution,The method has 6 parameters. Parameters: kind' operand' node' diagnostics' resultKind' originalUserDefinedOperators
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldEnumBinaryOperator,The method has 5 parameters. Parameters: syntax' kind' left' right' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldBinaryOperator,The method has 6 parameters. Parameters: syntax' kind' left' right' resultType' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldBinaryOperator,The method has 7 parameters. Parameters: syntax' kind' left' right' resultType' diagnostics' compoundStringLength
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindPointerIndirectionExpressionInternal,The method has 5 parameters. Parameters: node' operand' diagnostics' pointedAtType' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldUnaryOperator,The method has 5 parameters. Parameters: syntax' kind' operand' resultType' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportIsOperatorConstantWarnings,The method has 6 parameters. Parameters: syntax' diagnostics' operandType' targetType' conversionKind' operandConstantValue
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportAsOperatorConversionDiagnostics,The method has 7 parameters. Parameters: node' diagnostics' compilation' operandType' targetType' conversionKind' operandConstantValue
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportAsOperatorConstantWarnings,The method has 6 parameters. Parameters: node' diagnostics' operandType' targetType' conversionKind' operandConstantValue
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateNullCoalescingBadBinaryOpsError,The method has 5 parameters. Parameters: node' leftOperand' rightOperand' leftConversion' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryClause,The method has 6 parameters. Parameters: syntax' expression' definedSymbol' queryInvocation' castInvocation' unoptimizedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakePair,The method has 7 parameters. Parameters: node' field1Name' field1Value' field2Name' field2Value' state' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryUnboundLambdaWithCast,The method has 5 parameters. Parameters: qvm' parameter' expression' castTypeSyntax' castType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryInvocation,The method has 5 parameters. Parameters: node' receiver' methodName' arg' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryInvocation,The method has 5 parameters. Parameters: node' receiver' methodName' args' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryInvocation,The method has 6 parameters. Parameters: node' receiver' methodName' typeArgSyntax' typeArg' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryInvocation,The method has 7 parameters. Parameters: node' receiver' methodName' typeArgsSyntax' typeArgs' args' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportQueryLookupFailed,The method has 5 parameters. Parameters: queryClause' instanceArgument' name' symbols' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportQueryInferenceFailed,The method has 6 parameters. Parameters: queryClause' methodName' receiver' arguments' symbols' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportQueryInferenceFailedSelectMany,The method has 6 parameters. Parameters: fromClause' methodName' receiver' arguments' symbols' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindVariableType,The method has 6 parameters. Parameters: declarationNode' diagnostics' typeSyntax' isConst' isVar' alias
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindVariableDeclaration,The method has 8 parameters. Parameters: kind' isVar' declarator' typeSyntax' declTypeOpt' aliasOpt' diagnostics' associatedSyntaxNode
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindVariableDeclaration,The method has 9 parameters. Parameters: localSymbol' kind' isVar' declarator' typeSyntax' declTypeOpt' aliasOpt' diagnostics' associatedSyntaxNode
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetFixedLocalCollectionInitializer,The method has 5 parameters. Parameters: initializer' elementType' declType' hasErrors' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckLocalVariable,The method has 5 parameters. Parameters: tree' local' kind' checkingReceiver' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportReadOnlyError,The method has 5 parameters. Parameters: field' node' kind' checkingReceiver' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckIsVariable,The method has 5 parameters. Parameters: node' expr' kind' checkingReceiver' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The method has 7 parameters. Parameters: diagnostics' compilation' syntax' conversion' sourceType' targetType' sourceConstantValueOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The method has 5 parameters. Parameters: diagnostics' syntax' conversion' expression' targetType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateBlockFromExpression,The method has 5 parameters. Parameters: node' locals' expressionSyntax' expression' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleName,The method has 5 parameters. Parameters: syntax' diagnostics' basesBeingResolved' suppressUseSiteDiagnostics' qualifierOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNonGenericSimpleName,The method has 7 parameters. Parameters: node' diagnostics' basesBeingResolved' suppressUseSiteDiagnostics' qualifierOpt' isNameofArgument' symbols
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,UnwrapAlias,The method has 5 parameters. Parameters: symbol' alias' diagnostics' syntax' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupGenericTypeName,The method has 7 parameters. Parameters: diagnostics' basesBeingResolved' qualifierOpt' node' plainName' arity' options
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateErrorIfLookupOnTypeParameter,The method has 5 parameters. Parameters: node' qualifierOpt' name' arity' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ConstructNamedTypeUnlessTypeArgumentOmitted,The method has 5 parameters. Parameters: typeSyntax' type' typeArgumentsSyntax' typeArguments' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ConstructBoundMemberGroupAndReportOmittedTypeArguments,The method has 10 parameters. Parameters: syntax' typeArgumentsSyntax' typeArguments' receiver' plainName' members' lookupResult' methodGroupFlags' hasErrors' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ConstructNamedType,The method has 6 parameters. Parameters: type' typeSyntax' typeArgumentsSyntax' typeArguments' basesBeingResolved' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindQualifiedName,The method has 5 parameters. Parameters: leftName' rightName' diagnostics' basesBeingResolved' suppressUseSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetWellKnownTypeMember,The method has 6 parameters. Parameters: compilation' member' diagnostics' location' syntax' isOptional
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The method has 9 parameters. Parameters: result' simpleName' arity' where' diagnostics' suppressUseSiteDiagnostics' wasError' qualifierOpt' options
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,NotFound,The method has 8 parameters. Parameters: where' simpleName' arity' whereText' diagnostics' aliasOpt' qualifierOpt' options
Long Parameter List,Microsoft.CodeAnalysis.CSharp,WithQueryLambdaParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.WithQueryLambdaParametersBinder.cs,LookupSymbolsInSingleBinder,The method has 8 parameters. Parameters: result' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitExpression,The method has 5 parameters. Parameters: node' typedConstantKind' diagnostics' attrHasErrors' curArgumentHasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,CreateTypedConstant,The method has 7 parameters. Parameters: node' typedConstantKind' diagnostics' attrHasErrors' curArgumentHasErrors' simpleValue' arrayValue
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BuckStopsHereBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BuckStopsHereBinder.cs,IsAccessible,The method has 5 parameters. Parameters: symbol' accessThroughType' failedThroughTypeCheck' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ForEachEnumeratorInfo,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachEnumeratorInfo.cs,ForEachEnumeratorInfo,The method has 10 parameters. Parameters: collectionType' elementType' getEnumeratorMethod' currentPropertyGetter' moveNextMethod' needsDisposeMethod' collectionConversion' currentConversion' enumeratorConversion' location
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,FindForEachPatternMethod,The method has 5 parameters. Parameters: patternType' methodName' lookupResult' warningsOnly' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,ReportPatternMemberLookupDiagnostics,The method has 5 parameters. Parameters: lookupResult' patternType' memberName' warningsOnly' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,HostObjectModelBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\HostObjectModeBinder.cs,LookupSymbolsInSingleBinder,The method has 8 parameters. Parameters: result' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,Imports,The method has 5 parameters. Parameters: compilation' usingAliases' usings' externs' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupSymbol,The method has 8 parameters. Parameters: originalBinder' result' name' arity' basesBeingResolved' options' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupSymbolInAliases,The method has 8 parameters. Parameters: originalBinder' result' name' arity' basesBeingResolved' options' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupSymbolInUsings,The method has 9 parameters. Parameters: usings' originalBinder' result' name' arity' basesBeingResolved' options' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupExtensionMethodsInUsings,The method has 5 parameters. Parameters: methods' name' arity' options' callerIsSemanticModel
Long Parameter List,Microsoft.CodeAnalysis.CSharp,InContainerBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InContainerBinder.cs,InContainerBinder,The method has 5 parameters. Parameters: container' next' declarationSyntax' allowStaticClassUsings' inUsing
Long Parameter List,Microsoft.CodeAnalysis.CSharp,InContainerBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InContainerBinder.cs,IsAccessible,The method has 5 parameters. Parameters: symbol' accessThroughType' failedThroughTypeCheck' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,InContainerBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InContainerBinder.cs,GetCandidateExtensionMethods,The method has 6 parameters. Parameters: searchUsingsNotNamespace' methods' name' arity' options' isCallerSemanticModel
Long Parameter List,Microsoft.CodeAnalysis.CSharp,InContainerBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InContainerBinder.cs,LookupSymbolsInSingleBinder,The method has 8 parameters. Parameters: result' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,InMethodBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InMethodBinder.cs,LookupSymbolsInSingleBinder,The method has 8 parameters. Parameters: result' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,InMethodBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InMethodBinder.cs,ReportConflictWithParameter,The method has 5 parameters. Parameters: parameter' newSymbol' name' newLocation' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalScopeBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LocalScopeBinder.cs,LookupSymbolsInSingleBinder,The method has 8 parameters. Parameters: result' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalScopeBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LocalScopeBinder.cs,ReportConflictWithLocal,The method has 5 parameters. Parameters: local' newSymbol' name' newLocation' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodGroupResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\MethodGroupResolution.cs,MethodGroupResolution,The method has 6 parameters. Parameters: methodGroup' otherSymbol' overloadResolutionResult' analyzedArguments' resultKind' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsSymbolAccessible,The method has 6 parameters. Parameters: symbol' within' throughTypeOpt' failedThroughTypeCheck' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsSymbolAccessibleCore,The method has 7 parameters. Parameters: symbol' within' throughTypeOpt' failedThroughTypeCheck' compilation' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsMemberAccessible,The method has 8 parameters. Parameters: containingType' declaredAccessibility' within' throughTypeOpt' failedThroughTypeCheck' compilation' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsNonPublicMemberAccessible,The method has 8 parameters. Parameters: containingType' declaredAccessibility' within' throughTypeOpt' failedThroughTypeCheck' compilation' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsProtectedSymbolAccessible,The method has 7 parameters. Parameters: withinType' throughTypeOpt' originalContainingType' failedThroughTypeCheck' compilation' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,InheritsFromIgnoringConstruction,The method has 5 parameters. Parameters: type' baseType' compilation' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BestTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\BestTypeInferrer.cs,InferBestTypeForConditionalOperator,The method has 5 parameters. Parameters: expr1' expr2' conversions' hadMultipleCandidates' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Conversion,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\Conversion.cs,Conversion,The method has 5 parameters. Parameters: kind' isExtensionMethod' isArrayIndex' conversionResult' methodGroupConversionMethod
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeApplicableUserDefinedExplicitConversionSet,The method has 6 parameters. Parameters: sourceExpression' source' target' d' u' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AddUserDefinedConversionsToExplicitCandidateSet,The method has 7 parameters. Parameters: sourceExpression' source' target' u' declaringType' operatorName' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeApplicableUserDefinedImplicitConversionSet,The method has 7 parameters. Parameters: sourceExpression' source' target' d' u' useSiteDiagnostics' allowAnyTarget
Long Parameter List,Microsoft.CodeAnalysis.CSharp,UserDefinedConversionAnalysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\UserDefinedConversionAnalysis.cs,Normal,The method has 5 parameters. Parameters: op' sourceConversion' targetConversion' fromType' toType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,UserDefinedConversionAnalysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\UserDefinedConversionAnalysis.cs,Lifted,The method has 5 parameters. Parameters: op' sourceConversion' targetConversion' fromType' toType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,UserDefinedConversionAnalysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\UserDefinedConversionAnalysis.cs,UserDefinedConversionAnalysis,The method has 6 parameters. Parameters: kind' op' sourceConversion' targetConversion' fromType' toType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BinaryOperatorOverloadResolution,The method has 5 parameters. Parameters: kind' left' right' result' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetDelegateOperations,The method has 5 parameters. Parameters: kind' left' right' operators' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The method has 5 parameters. Parameters: kind' enumType' left' right' operators
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetAllBuiltInOperators,The method has 5 parameters. Parameters: kind' left' right' results' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,CandidateOperators,The method has 5 parameters. Parameters: operators' left' right' results' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetUserDefinedOperators,The method has 5 parameters. Parameters: kind' left' right' results' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetUserDefinedOperators,The method has 6 parameters. Parameters: kind' type0' left' right' results' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterOperator,The method has 5 parameters. Parameters: op1' op2' left' right' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,MethodInvocationOverloadResolution,The method has 9 parameters. Parameters: methods' typeArguments' arguments' result' useSiteDiagnostics' isMethodGroupConversion' allowRefOmittedArguments' inferWithDynamic' allowUnexpandedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,PropertyOverloadResolution,The method has 5 parameters. Parameters: indexers' arguments' result' allowRefOmittedArguments' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,MethodOrPropertyOverloadResolution,The method has 9 parameters. Parameters: members' typeArguments' arguments' result' isMethodGroupConversion' allowRefOmittedArguments' useSiteDiagnostics' inferWithDynamic' allowUnexpandedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,PerformMemberOverloadResolution,The method has 10 parameters. Parameters: results' members' typeArguments' arguments' completeResults' isMethodGroupConversion' allowRefOmittedArguments' useSiteDiagnostics' inferWithDynamic' allowUnexpandedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddConstructorToCandidateSet,The method has 5 parameters. Parameters: constructor' results' arguments' completeResults' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddMemberToCandidateSet,The method has 12 parameters. Parameters: member' results' members' typeArguments' arguments' completeResults' isMethodGroupConversion' allowRefOmittedArguments' containingTypeMapOpt' inferWithDynamic' useSiteDiagnostics' allowUnexpandedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,PerformObjectCreationOverloadResolution,The method has 5 parameters. Parameters: results' constructors' arguments' completeResults' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The method has 5 parameters. Parameters: m1' m2' arguments' considerRefKinds' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The method has 10 parameters. Parameters: node' t1' conv1' refKind1' t2' conv2' refKind2' considerRefKinds' useSiteDiagnostics' okToDowngradeToNeither
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The method has 7 parameters. Parameters: node' t1' conv1' t2' conv2' useSiteDiagnostics' okToDowngradeToNeither
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionTarget,The method has 5 parameters. Parameters: lambdaOpt' type1' type2' useSiteDiagnostics' okToDowngradeToNeither
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,CanDowngradeConversionFromLambdaToNeither,The method has 6 parameters. Parameters: currentResult' lambda' type1' type2' useSiteDiagnostics' fromTypeAnalysis
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParametersInNormalForm,The method has 5 parameters. Parameters: member' argumentCount' argToParamMap' argumentRefKinds' allowRefOmittedArguments
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParametersInNormalForm,The method has 6 parameters. Parameters: member' argumentCount' argToParamMap' argumentRefKinds' allowRefOmittedArguments' hasAnyRefOmittedArgument
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParametersInExpandedForm,The method has 5 parameters. Parameters: member' argumentCount' argToParamMap' argumentRefKinds' allowRefOmittedArguments
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParametersInExpandedForm,The method has 6 parameters. Parameters: member' argumentCount' argToParamMap' argumentRefKinds' allowRefOmittedArguments' hasAnyRefOmittedArgument
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsMemberApplicableInNormalForm,The method has 8 parameters. Parameters: member' leastOverriddenMember' typeArguments' arguments' isMethodGroupConversion' allowRefOmittedArguments' inferWithDynamic' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsMemberApplicableInExpandedForm,The method has 6 parameters. Parameters: member' leastOverriddenMember' typeArguments' arguments' allowRefOmittedArguments' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsApplicable,The method has 10 parameters. Parameters: member' leastOverriddenMember' typeArgumentsBuilder' arguments' originalEffectiveParameters' constructedEffectiveParameters' argsToParamsMap' hasAnyRefOmittedArgument' useSiteDiagnostics' inferWithDynamic
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,InferMethodTypeArguments,The method has 6 parameters. Parameters: method' originalTypeParameters' arguments' originalEffectiveParameters' error' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsApplicable,The method has 8 parameters. Parameters: candidate' parameters' arguments' argsToParameters' isVararg' hasAnyRefOmittedArgument' ignoreOpenTypes' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,CheckArgumentForApplicability,The method has 7 parameters. Parameters: candidate' argument' argRefKind' parameterType' parRefKind' ignoreOpenTypes' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,CorrespondsToAnyParameter,The method has 5 parameters. Parameters: memberParameters' expanded' arguments' argumentPosition' isNamedArgument
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BinaryOperatorSignature,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorSignature.cs,BinaryOperatorSignature,The method has 5 parameters. Parameters: kind' leftType' rightType' returnType' method
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MemberAnalysisResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MemberAnalysisResult.cs,MemberAnalysisResult,The method has 6 parameters. Parameters: kind' badArgumentsOpt' argsToParamsOpt' conversionsOpt' missingParameter' hasAnyRefOmittedArgument
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodGroup,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodGroup.cs,PopulateWithExtensionMethods,The method has 5 parameters. Parameters: receiverOpt' members' typeArguments' resultKind' error
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodGroup,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodGroup.cs,PopulateWithNonExtensionMethods,The method has 5 parameters. Parameters: receiverOpt' methods' typeArguments' resultKind' error
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,Infer,The method has 8 parameters. Parameters: binder' methodTypeParameters' constructedContainingTypeOfMethod' formalParameterTypes' formalParameterRefKinds' argumentTypes' arguments' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,MethodTypeInferrer,The method has 7 parameters. Parameters: conversions' methodTypeParameters' constructedContainingTypeOfMethod' formalParameterTypes' formalParameterRefKinds' argumentTypes' arguments
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,OutputTypeInference,The method has 5 parameters. Parameters: binder' expression' source' target' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,InferTypeArgumentsFromFirstArgument,The method has 5 parameters. Parameters: conversions' method' argumentTypes' arguments' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportDiagnostics,The method has 11 parameters. Parameters: binder' location' diagnostics' name' receiver' arguments' memberGroup' typeContainingConstructor' delegateTypeBeingInvoked' queryClause' isMethodGroupConversion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,TypeInferenceFailed,The method has 7 parameters. Parameters: binder' diagnostics' symbols' receiver' arguments' location' queryClause
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportNoCorrespondingNamedParameter,The method has 6 parameters. Parameters: bad' methodName' diagnostics' arguments' delegateTypeBeingInvoked' symbols
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportMissingRequiredParameter,The method has 6 parameters. Parameters: bad' diagnostics' arguments' delegateTypeBeingInvoked' symbols' location
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportBadParameterCount,The method has 7 parameters. Parameters: diagnostics' name' arguments' symbols' location' typeContainingConstructor' delegateTypeBeingInvoked
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ConstraintsCheckFailed,The method has 5 parameters. Parameters: conversions' compilation' diagnostics' arguments' location
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,HadBadArguments,The method has 8 parameters. Parameters: diagnostics' compilation' name' arguments' symbols' location' flags' isMethodGroupConversion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportBadArgumentError,The method has 9 parameters. Parameters: diagnostics' compilation' name' arguments' symbols' location' badArg' method' arg
Long Parameter List,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,HadAmbiguousWorseMethods,The method has 6 parameters. Parameters: diagnostics' symbols' location' isQuery' receiver' name
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,PostDecodeWellKnownAttributes,The method has 5 parameters. Parameters: boundAttributes' allAttributeSyntaxNodes' diagnostics' symbolPart' decodedData
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,GetAttributesToBind,The method has 5 parameters. Parameters: attributeDeclarationSyntaxLists' symbolPart' diagnostics' compilation' binders
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,EarlyDecodeWellKnownAttributes,The method has 5 parameters. Parameters: binders' boundAttributeTypes' attributesToBind' symbolPart' boundAttributesBuilder
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,ValidateAttributeUsageAndDecodeWellKnownAttributes,The method has 5 parameters. Parameters: binders' attributeSyntaxList' boundAttributes' diagnostics' symbolPart
Long Parameter List,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,ValidateAttributeUsage,The method has 6 parameters. Parameters: attribute' node' compilation' symbolPart' diagnostics' uniqueAttributeTypes
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,ConvertCaseExpression,The method has 6 parameters. Parameters: switchGoverningType' node' caseExpression' constantValueOpt' diagnostics' isGotoCaseExpr
Long Parameter List,Microsoft.CodeAnalysis.CSharp,UsingsBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\UsingsBinder.cs,LookupSymbolsInSingleBinder,The method has 8 parameters. Parameters: result' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,UsingsBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\UsingsBinder.cs,GetCandidateExtensionMethods,The method has 6 parameters. Parameters: searchUsingsNotNamespace' methods' name' arity' options' isCallerSemanticModel
Long Parameter List,Microsoft.CodeAnalysis.CSharp,WithClassTypeParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\WithClassTypeParametersBinder.cs,IsAccessible,The method has 5 parameters. Parameters: symbol' accessThroughType' failedThroughTypeCheck' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,WithLambdaParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\WithLambdaParametersBinder.cs,LookupSymbolsInSingleBinder,The method has 8 parameters. Parameters: result' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,WithLambdaParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\WithLambdaParametersBinder.cs,ReportConflictWithParameter,The method has 5 parameters. Parameters: parameter' newSymbol' name' newLocation' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,WithParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\WithParametersBinder.cs,LookupSymbolsInSingleBinder,The method has 8 parameters. Parameters: result' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,WithTypeParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\WithTypeParametersBinder.cs,LookupSymbolsInSingleBinder,The method has 8 parameters. Parameters: result' name' arity' basesBeingResolved' options' originalBinder' diagnose' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundCall,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,ErrorCall,The method has 10 parameters. Parameters: node' receiverOpt' method' arguments' namedArguments' refKinds' isDelegateCall' invokedAsExtensionMethod' originalMethods' resultKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundCall,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,Synthesized,The method has 5 parameters. Parameters: syntax' receiverOpt' method' arg0' arg1
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundTypeExpression,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundTypeExpression,The method has 5 parameters. Parameters: syntax' aliasOpt' inferredType' type' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundFieldAccess,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundFieldAccess,The method has 5 parameters. Parameters: syntax' receiver' fieldSymbol' constantValueOpt' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundFieldAccess,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundFieldAccess,The method has 7 parameters. Parameters: syntax' receiver' fieldSymbol' constantValueOpt' resultKind' type' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundFieldAccess,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,Update,The method has 5 parameters. Parameters: receiver' fieldSymbol' constantValueOpt' resultKind' typeSymbol
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundIndexerAccess,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,ErrorAccess,The method has 7 parameters. Parameters: node' receiverOpt' indexer' arguments' namedArguments' refKinds' originalIndexers
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundBinaryOperator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundBinaryOperator,The method has 10 parameters. Parameters: syntax' operatorKind' left' right' constantValueOpt' methodOpt' resultKind' originalUserDefinedOperatorsOpt' type' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundUserDefinedConditionalLogicalOperator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundUserDefinedConditionalLogicalOperator,The method has 11 parameters. Parameters: syntax' operatorKind' left' right' logicalOperator' trueOperator' falseOperator' resultKind' originalUserDefinedOperatorsOpt' type' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundUnaryOperator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundUnaryOperator,The method has 9 parameters. Parameters: syntax' operatorKind' operand' constantValueOpt' methodOpt' resultKind' originalUserDefinedOperatorsOpt' type' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundIncrementOperator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundIncrementOperator,The method has 10 parameters. Parameters: syntax' operatorKind' operand' methodOpt' operandConversion' resultConversion' resultKind' originalUserDefinedOperatorsOpt' type' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundCompoundAssignmentOperator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundCompoundAssignmentOperator,The method has 10 parameters. Parameters: syntax' operator' left' right' leftConversion' finalConversion' resultKind' originalUserDefinedOperatorsOpt' type' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundConversion,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,SynthesizedNonUserDefined,The method has 5 parameters. Parameters: syntax' operand' kind' type' constantValueOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundConversion,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,Synthesized,The method has 8 parameters. Parameters: syntax' operand' conversion' checked' explicitCastInCode' constantValueOpt' type' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundConversion,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundConversion,The method has 8 parameters. Parameters: syntax' operand' conversion' checked' explicitCastInCode' constantValueOpt' type' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundObjectCreationExpression,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundObjectCreationExpression,The method has 11 parameters. Parameters: syntax' constructor' arguments' argumentNamesOpt' argumentRefKindsOpt' expanded' argsToParamsOpt' constantValueOpt' initializerExpressionOpt' type' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundObjectCreationExpression,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,Update,The method has 9 parameters. Parameters: constructor' arguments' argumentNamesOpt' argumentRefKindsOpt' expanded' argsToParamsOpt' constantValueOpt' initializerExpressionOpt' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundLambda,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundLambda,The method has 6 parameters. Parameters: syntax' body' diagnostics' binder' type' inferReturnType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundLambda,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,InferReturnType,The method has 5 parameters. Parameters: block' binder' isAsync' useSiteDiagnostics' inferredFromSingleType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundTypeOrValueData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundTypeOrValueData,The method has 5 parameters. Parameters: valueSymbol' valueExpression' valueDiagnostics' typeExpression' typeDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundMethodGroup,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundMethodGroup.cs,BoundMethodGroup,The method has 8 parameters. Parameters: syntax' typeArgumentsOpt' receiverOpt' name' methods' lookupResult' flags' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundQueryClause,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundQueryClause.cs,BoundQueryClause,The method has 9 parameters. Parameters: syntax' value' definedSymbol' queryInvocation' castInvocation' binder' unoptimizedForm' type' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundQueryClause,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundQueryClause.cs,Update,The method has 7 parameters. Parameters: value' definedSymbol' queryInvocation' castInvocation' binder' unoptimizedForm' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundAssignmentOperator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\Constructors.cs,BoundAssignmentOperator,The method has 6 parameters. Parameters: syntax' left' right' type' refKind' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BoundBadExpression,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\Constructors.cs,BoundBadExpression,The method has 5 parameters. Parameters: syntax' resultKind' symbols' childBoundNodes' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,UnboundLambda,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\Formatting.cs,UnboundLambda,The method has 7 parameters. Parameters: syntax' binder' refKinds' types' names' isAsync' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,PlainUnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,PlainUnboundLambdaState,The method has 6 parameters. Parameters: unboundLambda' binder' parameterNames' parameterTypes' parameterRefKinds' isAsync
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AttributeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\AttributeSemanticModel.cs,AttributeSemanticModel,The method has 7 parameters. Parameters: compilation' syntax' attributeType' aliasOpt' rootBinder' parentSemanticModelOpt' speculatedPosition
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AttributeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\AttributeSemanticModel.cs,Create,The method has 5 parameters. Parameters: compilation' syntax' attributeType' aliasOpt' rootBinder
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AttributeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\AttributeSemanticModel.cs,CreateSpeculative,The method has 6 parameters. Parameters: parentSemanticModel' syntax' attributeType' aliasOpt' rootBinder' position
Long Parameter List,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,IsValidObjectEquality,The method has 6 parameters. Parameters: Conversions' leftType' leftIsNull' rightType' rightIsNull' useSiteDiagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,CreateSubmission,The method has 7 parameters. Parameters: assemblyName' syntaxTree' references' options' previousSubmission' returnType' hostObjectType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,Create,The method has 8 parameters. Parameters: assemblyName' options' syntaxTrees' references' previousSubmission' returnType' hostObjectType' isSubmission
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,CSharpCompilation,The method has 14 parameters. Parameters: assemblyName' options' references' syntaxTrees' syntaxTreeOrdinalMap' rootNamespaces' declarationTable' previousSubmission' submissionReturnType' hostObjectType' isSubmission' referenceManager' reuseReferenceManager' eventQueue
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,UpdateSyntaxTrees,The method has 5 parameters. Parameters: syntaxTrees' syntaxTreeOrdinalMap' rootNamespaces' declarationTable' referenceDirectivesChanged
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,AddSyntaxTreeToDeclarationMapAndTable,The method has 6 parameters. Parameters: tree' options' isSubmission' declMap' declTable' referenceDirectivesChanged
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetDiagnosticsForSyntaxTree,The method has 5 parameters. Parameters: stage' syntaxTree' filterSpanWithinTree' includeEarlierStages' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,CreateModuleBuilder,The method has 6 parameters. Parameters: emitOptions' manifestResources' assemblySymbolMapper' testData' diagnostics' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,CompileImpl,The method has 7 parameters. Parameters: moduleBuilder' win32Resources' xmlDocStream' generateDebugInfo' diagnostics' filterOpt' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,EmitDifference,The method has 9 parameters. Parameters: baseline' edits' isAddedSymbol' metadataStream' ilStream' pdbStream' updatedMethods' testData' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SymbolSearcher,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,AppendSymbolsWithName,The method has 6 parameters. Parameters: spine' current' predicate' filter' set' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SymbolSearcher,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,AppendMemberSymbolsWithName,The method has 5 parameters. Parameters: spine' current' predicate' set' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpDiagnosticFilter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpDiagnosticFilter.cs,GetDiagnosticReport,The method has 9 parameters. Parameters: severity' isEnabledByDefault' id' diagnosticWarningLevel' location' category' warningLevelOption' generalDiagnosticOption' specificDiagnosticOptions
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativelyBoundExpression,The method has 5 parameters. Parameters: position' expression' bindingOption' binder' crefSymbols
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,LookupSymbolsInternal,The method has 5 parameters. Parameters: position' container' name' options' useBaseReferenceAccessibility
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,AppendSymbolsWithName,The method has 6 parameters. Parameters: results' name' binder' container' options' info
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,AppendSymbolsWithNameAndArity,The method has 6 parameters. Parameters: results' name' arity' binder' container' options
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolInfoForNode,The method has 5 parameters. Parameters: options' lowestBoundNode' highestBoundNode' boundNodeForSyntacticParent' binderOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,TryGetSpeculativeSemanticModelCore,The method has 5 parameters. Parameters: parentModel' position' type' bindingOption' speculativeModel
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The method has 7 parameters. Parameters: boundNode' boundNodeForSyntacticParent' binderOpt' options' isDynamic' resultKind' memberGroup
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetIntrinsicOperatorSymbol,The method has 6 parameters. Parameters: op' isDynamic' leftType' rightType' returnType' isChecked
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The method has 5 parameters. Parameters: node' symbolOpt' originalCandidates' symbols' resultKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,AdjustSymbolsForObjectCreation,The method has 6 parameters. Parameters: boundNode' boundNodeForSyntacticParent' binderOpt' resultKind' symbols' memberGroup
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,AdjustSymbolsForObjectCreation,The method has 7 parameters. Parameters: lowestBoundNode' typeSymbolOpt' constructorOpt' binderOpt' resultKind' symbols' memberGroup
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetMethodGroupSemanticSymbols,The method has 6 parameters. Parameters: boundNode' boundNodeForSyntacticParent' binderOpt' resultKind' isDynamic' methodGroup
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetPropertyGroupSemanticSymbols,The method has 5 parameters. Parameters: boundNode' boundNodeForSyntacticParent' binderOpt' resultKind' propertyGroup
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,AddReducedAndFilteredMethodGroupSymbol,The method has 5 parameters. Parameters: methods' filteredMethods' method' typeArguments' receiverType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,MergeReducedAndFilteredMethodGroupSymbol,The method has 6 parameters. Parameters: methods' filteredMethods' singleResult' typeArguments' receiverType' resultKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ForEachStatementInfo,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\ForEachStatementInfo.cs,ForEachStatementInfo,The method has 7 parameters. Parameters: getEnumeratorMethod' moveNextMethod' currentProperty' disposeMethod' elementType' elementConversion' currentConversion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,InitializerSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\InitializerSemanticModel.cs,InitializerSemanticModel,The method has 6 parameters. Parameters: compilation' syntax' symbol' rootBinder' parentSemanticModelOpt' speculatedPosition
Long Parameter List,Microsoft.CodeAnalysis.CSharp,InitializerSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\InitializerSemanticModel.cs,CreateSpeculative,The method has 5 parameters. Parameters: parentSemanticModel' owner' syntax' rootBinder' position
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,MemberSemanticModel,The method has 6 parameters. Parameters: compilation' root' memberSymbol' rootBinder' parentSemanticModelOpt' speculatedPosition
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,TryGetSpeculativeSemanticModelCore,The method has 5 parameters. Parameters: parentModel' position' type' bindingOption' speculativeModel
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetBoundNodes,The method has 5 parameters. Parameters: node' bindableNode' lowestBoundNode' highestBoundNode' boundParent
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SpeculativeMemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.SpeculativeMemberSemanticModel.cs,SpeculativeMemberSemanticModel,The method has 5 parameters. Parameters: parentSemanticModel' owner' root' rootBinder' position
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodBodySemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs,MethodBodySemanticModel,The method has 6 parameters. Parameters: compilation' owner' rootBinder' syntax' parentSemanticModelOpt' speculatedPosition
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodBodySemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs,CreateSpeculative,The method has 5 parameters. Parameters: parentSemanticModel' owner' syntax' rootBinder' position
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodBodySemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs,CreateSpeculative,The method has 5 parameters. Parameters: parentSemanticModel' owner' syntax' rootBinder' position
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SpeculativeSyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SpeculativeSyntaxTreeSemanticModel.cs,Create,The method has 5 parameters. Parameters: parentSemanticModel' root' rootBinder' position' bindingOption
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SpeculativeSyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SpeculativeSyntaxTreeSemanticModel.cs,CreateCore,The method has 5 parameters. Parameters: parentSemanticModel' root' rootBinder' position' bindingOption
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SpeculativeSyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SpeculativeSyntaxTreeSemanticModel.cs,SpeculativeSyntaxTreeSemanticModel,The method has 5 parameters. Parameters: parentSemanticModel' root' rootBinder' position' bindingOption
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,TryGetSpeculativeSemanticModelCore,The method has 5 parameters. Parameters: parentModel' position' type' bindingOption' speculativeModel
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,ClsComplianceChecker,The method has 5 parameters. Parameters: compilation' filterTree' filterSpanWithinTree' diagnostics' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckCompliance,The method has 5 parameters. Parameters: compilation' diagnostics' cancellationToken' filterTree' filterSpanWithinTree
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,DocumentationCommentCompiler,The method has 9 parameters. Parameters: assemblyName' compilation' writer' filterTree' filterSpanWithinTree' processIncludes' isForSingleSymbol' diagnostics' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteDocumentationCommentXml,The method has 7 parameters. Parameters: compilation' assemblyName' xmlDocStream' diagnostics' cancellationToken' filterTree' filterSpanWithinTree
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,TryProcessDocumentationCommentTriviaNodes,The method has 9 parameters. Parameters: symbol' isPartialMethodDefinitionPart' docCommentNodes' reportParameterOrTypeParameterDiagnostics' withUnprocessedIncludes' haveParseError' documentedTypeParameters' documentedParameters' includeElementNodes
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,BindName,The method has 6 parameters. Parameters: syntax' binder' memberSymbol' documentedParameters' documentedTypeParameters' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DocumentationCommentWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.DocumentationCommentWalker.cs,DocumentationCommentWalker,The method has 7 parameters. Parameters: compilation' diagnostics' memberSymbol' writer' includeElementNodes' documentedParameters' documentedTypeParameters
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DocumentationCommentWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.DocumentationCommentWalker.cs,GetSubstitutedText,The method has 7 parameters. Parameters: compilation' diagnostics' symbol' trivia' includeElementNodes' documentedParameters' documentedTypeParameters
Long Parameter List,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,IncludeElementExpander,The method has 8 parameters. Parameters: memberSymbol' sourceIncludeElementNodes' compilation' documentedParameters' documentedTypeParameters' includedFileCache' diagnostics' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,ProcessIncludes,The method has 10 parameters. Parameters: unprocessed' memberSymbol' sourceIncludeElementNodes' compilation' documentedParameters' documentedTypeParameters' includedFileCache' writer' diagnostics' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,MethodCompiler,The method has 7 parameters. Parameters: compilation' moduleBeingBuiltOpt' generateDebugInfo' hasDeclarationErrors' diagnostics' filterOpt' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethodBodies,The method has 7 parameters. Parameters: compilation' moduleBeingBuiltOpt' generateDebugInfo' hasDeclarationErrors' diagnostics' filterOpt' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GetEntryPoint,The method has 5 parameters. Parameters: compilation' moduleBeingBuilt' hasDeclarationErrors' diagnostics' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,DefineScriptEntryPoint,The method has 5 parameters. Parameters: compilation' moduleBeingBuilt' returnType' hasDeclarationErrors' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The method has 5 parameters. Parameters: methodSymbol' methodOrdinal' processedInitializers' previousSubmissionFields' compilationState
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,LowerBodyOrInitializer,The method has 10 parameters. Parameters: method' methodOrdinal' body' previousSubmissionFields' compilationState' diagnostics' lazyVariableSlotAllocator' lambdaDebugInfoBuilder' closureDebugInfoBuilder' stateMachineTypeOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GenerateMethodBody,The method has 12 parameters. Parameters: moduleBuilder' method' methodOrdinal' block' lambdaDebugInfo' closureDebugInfo' stateMachineTypeOpt' variableSlotAllocatorOpt' diagnostics' debugDocumentProvider' importChainOpt' generateDebugInfo
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,BindMethodBody,The method has 5 parameters. Parameters: method' compilationState' diagnostics' generateDebugInfo' importChain
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,CSharpCompilationOptions,The method has 21 parameters. Parameters: outputKind' moduleName' mainTypeName' scriptClassName' usings' optimizationLevel' checkOverflow' allowUnsafe' cryptoKeyContainer' cryptoKeyFile' delaySign' platform' generalDiagnosticOption' warningLevel' specificDiagnosticOptions' concurrentBuild' xmlReferenceResolver' sourceReferenceResolver' metadataReferenceResolver' assemblyIdentityComparer' strongNameProvider
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,CSharpCompilationOptions,The method has 24 parameters. Parameters: outputKind' moduleName' mainTypeName' scriptClassName' usings' optimizationLevel' checkOverflow' allowUnsafe' cryptoKeyContainer' cryptoKeyFile' delaySign' platform' generalDiagnosticOption' warningLevel' specificDiagnosticOptions' concurrentBuild' extendedCustomDebugInformation' xmlReferenceResolver' sourceReferenceResolver' metadataReferenceResolver' assemblyIdentityComparer' strongNameProvider' metadataImportOptions' features
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpExtensions.cs,TryGetSpeculativeSemanticModel,The method has 5 parameters. Parameters: semanticModel' position' type' speculativeModel' bindingOption
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpExtensions.cs,ClassifyConversion,The method has 5 parameters. Parameters: semanticModel' position' expression' destination' isExplicitInSource
Long Parameter List,Microsoft.CodeAnalysis.CSharp,RootSingleNamespaceDeclaration,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\RootSingleNamespaceDeclaration.cs,RootSingleNamespaceDeclaration,The method has 7 parameters. Parameters: hasUsings' hasExternAliases' treeNode' children' referenceDirectives' referenceDirectiveDiagnostics' hasAssemblyAttributes
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SingleNamespaceDeclaration,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\SingleNamespaceDeclaration.cs,Create,The method has 6 parameters. Parameters: name' hasUsings' hasExternAliases' syntaxReference' nameLocation' children
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SingleNamespaceDeclarationEx,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\SingleNamespaceDeclarationEx.cs,SingleNamespaceDeclarationEx,The method has 6 parameters. Parameters: name' hasUsings' hasExternAliases' syntaxReference' nameLocation' children
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SingleTypeDeclaration,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\SingleTypeDeclaration.cs,SingleTypeDeclaration,The method has 9 parameters. Parameters: kind' name' arity' modifiers' declFlags' syntaxReference' nameLocation' memberNames' children
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSDiagnosticInfo,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\CSDiagnosticInfo.cs,CSDiagnosticInfo,The method has 5 parameters. Parameters: isWarningAsError' code' args' symbols' additionalLocations
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DiagnosticBagExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\DiagnosticBagExtensions.cs,Add,The method has 5 parameters. Parameters: diagnostics' code' location' symbols' args
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MessageProvider,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\MessageProvider.cs,ReportDuplicateMetadataReferenceStrong,The method has 6 parameters. Parameters: diagnostics' location' reference' identity' equivalentReference' equivalentIdentity
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MessageProvider,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\MessageProvider.cs,ReportDuplicateMetadataReferenceWeak,The method has 6 parameters. Parameters: diagnostics' location' reference' identity' equivalentReference' equivalentIdentity
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MessageProvider,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\MessageProvider.cs,ReportInvalidNamedArgument,The method has 5 parameters. Parameters: diagnostics' attributeSyntax' namedArgumentIndex' attributeClass' parameterName
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MessageProvider,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\MessageProvider.cs,ReportMarshalUnmanagedTypeNotValidForFields,The method has 5 parameters. Parameters: diagnostics' attributeSyntax' parameterIndex' unmanagedTypeName' attribute
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MessageProvider,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\MessageProvider.cs,ReportMarshalUnmanagedTypeOnlyValidForFields,The method has 5 parameters. Parameters: diagnostics' attributeSyntax' parameterIndex' unmanagedTypeName' attribute
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AbstractFlowPass<TLocalState>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\AbstractFlowPass.cs,AbstractFlowPass,The method has 7 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' trackRegions' trackUnassignments
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AbstractRegionControlFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\AbstractRegionControlFlowPass.cs,AbstractRegionControlFlowPass,The method has 5 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AbstractRegionDataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\AbstractRegionDataFlowPass.cs,AbstractRegionDataFlowPass,The method has 8 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' initiallyAssignedVariables' unassignedVariableAddressOfSyntaxes' trackUnassignments
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AlwaysAssignedWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\AlwaysAssignedWalker.cs,AlwaysAssignedWalker,The method has 5 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AlwaysAssignedWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\AlwaysAssignedWalker.cs,Analyze,The method has 5 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ControlFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ControlFlowPass.cs,ControlFlowPass,The method has 5 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,DataFlowPass,The method has 6 parameters. Parameters: compilation' member' node' trackUnassignments' unassignedVariableAddressOfSyntaxes' requireOutParamsAssigned
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,DataFlowPass,The method has 6 parameters. Parameters: compilation' member' node' emptyStructs' trackUnassignments' initiallyAssignedVariables
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,DataFlowPass,The method has 8 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' initiallyAssignedVariables' unassignedVariableAddressOfSyntaxes' trackUnassignments
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,Analyze,The method has 5 parameters. Parameters: compilation' member' node' diagnostics' requireOutParamsAssigned
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,AssignImpl,The method has 5 parameters. Parameters: node' value' refKind' written' read
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DataFlowsInWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsInWalker.cs,DataFlowsInWalker,The method has 7 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' unassignedVariables' unassignedVariableAddressOfSyntaxes
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DataFlowsInWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsInWalker.cs,Analyze,The method has 8 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' unassignedVariables' unassignedVariableAddressOfSyntaxes' succeeded
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DataFlowsOutWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsOutWalker.cs,DataFlowsOutWalker,The method has 7 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' unassignedVariables' dataFlowsIn
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DataFlowsOutWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsOutWalker.cs,Analyze,The method has 7 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' unassignedVariables' dataFlowsIn
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DataFlowsOutWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsOutWalker.cs,AssignImpl,The method has 5 parameters. Parameters: node' value' refKind' written' read
Long Parameter List,Microsoft.CodeAnalysis.CSharp,EntryPointsWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\EntryPointsWalker.cs,Analyze,The method has 6 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' succeeded
Long Parameter List,Microsoft.CodeAnalysis.CSharp,EntryPointsWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\EntryPointsWalker.cs,EntryPointsWalker,The method has 5 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ExitPointsWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ExitPointsWalker.cs,ExitPointsWalker,The method has 5 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ExitPointsWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ExitPointsWalker.cs,Analyze,The method has 5 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,PreciseAbstractFlowPass<LocalState>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\PreciseAbstractFlowPass.AbstractLocalState.cs,PreciseAbstractFlowPass,The method has 7 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' trackRegions' trackExceptions
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ReadWriteWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ReadWriteWalker.cs,Analyze,The method has 12 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' unassignedVariableAddressOfSyntaxes' readInside' writtenInside' readOutside' writtenOutside' captured' unsafeAddressTaken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ReadWriteWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ReadWriteWalker.cs,ReadWriteWalker,The method has 6 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' unassignedVariableAddressOfSyntaxes
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ReadWriteWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ReadWriteWalker.cs,AssignImpl,The method has 5 parameters. Parameters: node' value' refKind' written' read
Long Parameter List,Microsoft.CodeAnalysis.CSharp,RegionAnalysisContext,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\RegionAnalysisContext.cs,RegionAnalysisContext,The method has 5 parameters. Parameters: compilation' member' boundNode' firstInRegion' lastInRegion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,RegionReachableWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\RegionReachableWalker.cs,Analyze,The method has 7 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion' startPointIsReachable' endPointIsReachable
Long Parameter List,Microsoft.CodeAnalysis.CSharp,RegionReachableWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\RegionReachableWalker.cs,RegionReachableWalker,The method has 5 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,VariablesDeclaredWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\VariablesDeclaredWalker.cs,Analyze,The method has 5 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,VariablesDeclaredWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\VariablesDeclaredWalker.cs,VariablesDeclaredWalker,The method has 5 parameters. Parameters: compilation' member' node' firstInRegion' lastInRegion
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AsyncExceptionHandlerRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncExceptionHandlerRewriter.cs,AsyncExceptionHandlerRewriter,The method has 6 parameters. Parameters: containingMethod' containingType' factory' compilation' diagnostics' analysis
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AsyncExceptionHandlerRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncExceptionHandlerRewriter.cs,Rewrite,The method has 5 parameters. Parameters: containingSymbol' containingType' statement' compilationState' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AsyncExceptionHandlerRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncExceptionHandlerRewriter.cs,PendBranch,The method has 5 parameters. Parameters: bodyStatements' proxy' i' pendingBranchVar' finallyLabel
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AsyncMethodBuilderMemberCollection,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodBuilderMemberCollection.cs,AsyncMethodBuilderMemberCollection,The method has 9 parameters. Parameters: builderType' resultType' setException' setResult' awaitOnCompleted' awaitUnsafeOnCompleted' start' setStateMachine' task
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AsyncMethodBuilderMemberCollection,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodBuilderMemberCollection.cs,TryCreate,The method has 11 parameters. Parameters: F' builderType' resultType' setException' setResult' awaitOnCompleted' awaitUnsafeOnCompleted' start' setStateMachine' task' collection
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AsyncMethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodToStateMachineRewriter.cs,AsyncMethodToStateMachineRewriter,The method has 12 parameters. Parameters: method' methodOrdinal' asyncMethodBuilderMemberCollection' F' state' builder' hoistedVariables' nonReusableLocalProxies' synthesizedLocalOrdinals' slotAllocatorOpt' nextFreeHoistedLocalSlot' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,AsyncRewriter,The method has 7 parameters. Parameters: body' method' methodOrdinal' stateMachineType' slotAllocatorOpt' compilationState' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,Rewrite,The method has 7 parameters. Parameters: body' method' methodOrdinal' slotAllocatorOpt' compilationState' diagnostics' stateMachineType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AsyncStateMachine,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncStateMachine.cs,AsyncStateMachine,The method has 5 parameters. Parameters: variableAllocatorOpt' compilationState' asyncMethod' asyncMethodOrdinal' typeKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,AwaitExpressionSpiller,The method has 5 parameters. Parameters: method' syntaxNode' compilationState' tempSubstitution' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,VisitExpressionList,The method has 5 parameters. Parameters: builder' args' refKinds' forceSpill' sideEffectsOnly
Long Parameter List,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,VisitCall,The method has 7 parameters. Parameters: method' propertyAccess' arguments' argumentRefKindsOpt' argumentNamesOpt' expanded' node
Long Parameter List,Microsoft.CodeAnalysis.CSharp,IteratorMethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorMethodToStateMachineRewriter.IteratorFinallyFrame.cs,IteratorMethodToStateMachineRewriter,The method has 10 parameters. Parameters: F' originalMethod' state' current' hoistedVariables' nonReusableLocalProxies' synthesizedLocalOrdinals' slotAllocatorOpt' nextFreeHoistedLocalSlot' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,IteratorRewriter,The method has 7 parameters. Parameters: body' method' isEnumerable' stateMachineType' slotAllocatorOpt' compilationState' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,Rewrite,The method has 7 parameters. Parameters: body' method' methodOrdinal' slotAllocatorOpt' compilationState' diagnostics' stateMachineType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,IteratorStateMachine,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorStateMachine.cs,IteratorStateMachine,The method has 6 parameters. Parameters: slotAllocatorOpt' compilationState' iteratorMethod' iteratorMethodOrdinal' isEnumerable' elementType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,VisitBinaryOperator,The method has 5 parameters. Parameters: opKind' methodOpt' type' left' right
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,MakeBinary,The method has 7 parameters. Parameters: methodOpt' type' isLifted' requiresLifted' opName' loweredLeft' loweredRight
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,Convert,The method has 5 parameters. Parameters: operand' oldType' newType' isChecked' isExplicit
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,LambdaRewriter,The method has 10 parameters. Parameters: analysis' thisType' thisParameterOpt' method' methodOrdinal' lambdaDebugInfoBuilder' slotAllocatorOpt' compilationState' diagnostics' assignLocals
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,Rewrite,The method has 11 parameters. Parameters: loweredBody' thisType' thisParameter' method' methodOrdinal' lambdaDebugInfoBuilder' closureDebugInfoBuilder' slotAllocatorOpt' compilationState' diagnostics' assignLocals
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,GetLambdaId,The method has 5 parameters. Parameters: syntax' closureKind' closureOrdinal' topLevelMethodId' lambdaOrdinal
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LambdaFrame,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaFrame.cs,LambdaFrame,The method has 5 parameters. Parameters: slotAllocatorOpt' topLevelMethod' methodId' scopeSyntaxOpt' closureOrdinal
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SynthesizedLambdaMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\SynthesizedLambdaMethod.cs,SynthesizedLambdaMethod,The method has 6 parameters. Parameters: containingType' closureKind' topLevelMethod' topLevelMethodId' lambdaNode' lambdaOrdinal
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LocalRewriter,The method has 8 parameters. Parameters: compilation' containingMethod' containingMethodOrdinal' containingType' factory' previousSubmissionFields' allowOmissionOfConditionalCalls' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,Rewrite,The method has 11 parameters. Parameters: compilation' method' methodOrdinal' containingType' statement' compilationState' previousSubmissionFields' allowOmissionOfConditionalCalls' diagnostics' sawLambdas' sawAwaitInExceptionHandler
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeAsOperator,The method has 6 parameters. Parameters: oldNode' syntax' rewrittenOperand' rewrittenTargetType' conversion' rewrittenType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeAssignmentOperator,The method has 7 parameters. Parameters: syntax' rewrittenLeft' rewrittenRight' type' used' isChecked' isCompoundAssignment
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicSetIndex,The method has 8 parameters. Parameters: indexerAccess' loweredReceiver' loweredArguments' argumentNames' refKinds' loweredRight' isCompoundAssignment' isChecked
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeStaticAssignmentOperator,The method has 5 parameters. Parameters: syntax' rewrittenLeft' rewrittenRight' type' used
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakePropertyAssignment,The method has 10 parameters. Parameters: syntax' rewrittenReceiver' property' rewrittenArguments' argumentRefKindsOpt' expanded' argsToParamsOpt' rewrittenRight' type' used
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The method has 9 parameters. Parameters: syntax' operatorKind' loweredLeft' loweredRight' type' method' isPointerElementAccess' isCompoundAssignment' applyParentUnaryOperator
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The method has 10 parameters. Parameters: oldNode' syntax' operatorKind' loweredLeft' loweredRight' type' method' isPointerElementAccess' isCompoundAssignment' applyParentUnaryOperator
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicLogicalBinaryOperator,The method has 8 parameters. Parameters: syntax' operatorKind' loweredLeft' loweredRight' leftTruthOperator' type' isCompoundAssignment' applyParentUnaryOperator
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeTruthTestForDynamicLogicalOperator,The method has 5 parameters. Parameters: syntax' loweredLeft' boolean' leftTruthOperator' negative
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerUserDefinedBinaryOperator,The method has 6 parameters. Parameters: syntax' operatorKind' loweredLeft' loweredRight' type' method
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TrivialLiftedComparisonOperatorOptimizations,The method has 5 parameters. Parameters: syntax' kind' left' right' method
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedUserDefinedComparisonOperator,The method has 5 parameters. Parameters: syntax' kind' loweredLeft' loweredRight' method
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TrivialLiftedBinaryArithmeticOptimizations,The method has 6 parameters. Parameters: syntax' kind' left' right' type' method
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeLiftedBinaryOperatorConsequence,The method has 6 parameters. Parameters: syntax' kind' left' right' type' method
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedBinaryArithmeticOperator,The method has 6 parameters. Parameters: syntax' kind' loweredLeft' loweredRight' type' method
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,OptimizeLiftedBinaryArithmetic,The method has 6 parameters. Parameters: syntax' kind' left' right' type' method
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteNullableNullEquality,The method has 5 parameters. Parameters: syntax' kind' loweredLeft' loweredRight' returnType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringEquality,The method has 7 parameters. Parameters: oldNode' syntax' operatorKind' loweredLeft' loweredRight' type' member
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteDelegateOperation,The method has 6 parameters. Parameters: syntax' operatorKind' loweredLeft' loweredRight' type' member
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteBuiltInShiftOperation,The method has 7 parameters. Parameters: oldNode' syntax' operatorKind' loweredLeft' loweredRight' type' rightMask
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewritePointerNumericOperator,The method has 7 parameters. Parameters: syntax' kind' loweredLeft' loweredRight' returnType' isPointerElementAccess' isLeftPointer
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCall,The method has 11 parameters. Parameters: syntax' rewrittenReceiver' method' rewrittenArguments' argumentRefKindsOpt' expanded' invokedAsExtensionMethod' argsToParamsOpt' resultKind' type' nodeOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCall,The method has 10 parameters. Parameters: node' syntax' rewrittenReceiver' method' rewrittenArguments' argumentRefKinds' invokedAsExtensionMethod' resultKind' type' temps
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCall,The method has 5 parameters. Parameters: syntax' rewrittenReceiver' method' rewrittenArguments' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeArguments,The method has 10 parameters. Parameters: syntax' rewrittenArguments' methodOrIndexer' optionalParametersMethod' expanded' argsToParamsOpt' argumentRefKindsOpt' temps' invokedAsExtensionMethod' enableCallerInfo
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,BuildStoresToTemps,The method has 7 parameters. Parameters: expanded' argsToParamsOpt' argumentRefKinds' rewrittenArguments' arguments' refKinds' storesToTemps
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,BuildParamsArray,The method has 6 parameters. Parameters: syntax' methodOrIndexer' argsToParamsOpt' rewrittenArguments' parameters' tempStoreArgument
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteConditionalOperator,The method has 6 parameters. Parameters: syntax' rewrittenCondition' rewrittenConsequence' rewrittenAlternative' constantValueOpt' rewrittenType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The method has 11 parameters. Parameters: oldNode' syntax' rewrittenOperand' conversionKind' symbolOpt' checked' explicitCastInCode' isExtensionMethod' isArrayIndex' constantValueOpt' rewrittenType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The method has 6 parameters. Parameters: syntax' rewrittenOperand' conversionKind' rewrittenType' checked' constantValueOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The method has 7 parameters. Parameters: syntax' rewrittenOperand' conversion' rewrittenType' checked' explicitCastInCode' constantValueOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteNullableConversion,The method has 6 parameters. Parameters: syntax' rewrittenOperand' conversionKind' checked' explicitCastInCode' rewrittenType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedConversionInExpressionTree,The method has 6 parameters. Parameters: syntax' rewrittenOperand' conversionKind' checked' explicitCastInCode' rewrittenType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteFullyLiftedBuiltInConversion,The method has 5 parameters. Parameters: syntax' operand' kind' checked' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,OptimizeLiftedUserDefinedConversion,The method has 5 parameters. Parameters: syntax' operand' kind' method' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,OptimizeLiftedBuiltInConversion,The method has 5 parameters. Parameters: syntax' operand' kind' checked' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,DistributeLiftedConversionIntoLiftedOperand,The method has 6 parameters. Parameters: syntax' operand' kind' checked' method' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteUserDefinedConversion,The method has 5 parameters. Parameters: syntax' rewrittenOperand' method' rewrittenType' conversionKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedUserDefinedConversion,The method has 5 parameters. Parameters: syntax' rewrittenOperand' method' rewrittenType' conversionKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteIntPtrConversion,The method has 11 parameters. Parameters: oldNode' syntax' rewrittenOperand' conversionKind' symbolOpt' checked' explicitCastInCode' isExtensionMethod' isArrayIndex' constantValueOpt' rewrittenType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteDecimalConversion,The method has 5 parameters. Parameters: oldNode' syntax' operand' fromType' toType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeUserDefinedConversion,The method has 5 parameters. Parameters: syntax' meth' fromType' toType' isImplicit
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWindowsRuntimeEventAssignmentOperator,The method has 6 parameters. Parameters: syntax' eventSymbol' kind' isDynamic' rewrittenReceiverOpt' rewrittenArgument
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeEventAccess,The method has 6 parameters. Parameters: syntax' rewrittenReceiver' eventSymbol' constantValueOpt' resultKind' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeFieldAccess,The method has 7 parameters. Parameters: syntax' rewrittenReceiver' fieldSymbol' constantValueOpt' resultKind' type' oldNodeOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementStringLocal,The method has 5 parameters. Parameters: localSymbol' fixedInitializer' factory' stringTemp' localToClear
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,SynthesizeCall,The method has 5 parameters. Parameters: syntax' receiver' method' receiverConversion' convertedReceiverType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteForStatement,The method has 11 parameters. Parameters: syntax' outerLocals' rewrittenInitializer' rewrittenCondition' conditionSyntaxOpt' conditionSpanOpt' rewrittenIncrement' rewrittenBody' breakLabel' continueLabel' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteIfStatement,The method has 5 parameters. Parameters: syntax' rewrittenCondition' rewrittenConsequence' rewrittenAlternativeOpt' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicGetIndex,The method has 5 parameters. Parameters: node' loweredReceiver' loweredArguments' argumentNames' refKinds
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeIndexerAccess,The method has 11 parameters. Parameters: syntax' rewrittenReceiver' indexer' rewrittenArguments' argumentNamesOpt' argumentRefKindsOpt' expanded' argsToParamsOpt' type' oldNodeOpt' isLeftOfAssignment
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeIsOperator,The method has 6 parameters. Parameters: oldNode' syntax' rewrittenOperand' rewrittenTargetType' conversion' rewrittenType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLocalDeclaration,The method has 5 parameters. Parameters: syntax' localSymbol' rewrittenInitializer' wasCompilerGenerated' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeNullCoalescingOperator,The method has 5 parameters. Parameters: syntax' rewrittenLeft' rewrittenRight' leftConversion' rewrittenResultType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectOrCollectionInitializers,The method has 5 parameters. Parameters: dynamicSiteInitializers' temps' result' rewrittenReceiver' initializerExpression
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectInitializers,The method has 5 parameters. Parameters: dynamicSiteInitializers' temps' result' rewrittenReceiver' initializers
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectInitializer,The method has 5 parameters. Parameters: dynamicSiteInitializers' temps' result' rewrittenReceiver' assignment
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakePropertyAccess,The method has 7 parameters. Parameters: syntax' rewrittenReceiverOpt' propertySymbol' resultKind' type' isLeftOfAssignment' oldNodeOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakePropertyGetAccess,The method has 6 parameters. Parameters: syntax' rewrittenReceiver' property' rewrittenArguments' getMethodOpt' oldNodeOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringConcatenation,The method has 5 parameters. Parameters: syntax' operatorKind' loweredLeft' loweredRight' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringConcatInExpressionLambda,The method has 5 parameters. Parameters: syntax' operatorKind' loweredLeft' loweredRight' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSwitchStatement,The method has 7 parameters. Parameters: syntax' rewrittenExpression' rewrittenSections' constantTargetOpt' locals' breakLabel' oldNode
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSwitchStatementWithNonNullableExpression,The method has 7 parameters. Parameters: syntax' rewrittenExpression' rewrittenSections' constantTargetOpt' locals' breakLabel' oldNode
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSwitchStatementWithNullableExpression,The method has 7 parameters. Parameters: syntax' rewrittenExpression' rewrittenSections' constantTargetOpt' locals' breakLabel' oldNode
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeUnaryOperator,The method has 5 parameters. Parameters: kind' syntax' method' loweredOperand' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeUnaryOperator,The method has 6 parameters. Parameters: oldNode' kind' syntax' method' loweredOperand' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedUnaryOperator,The method has 5 parameters. Parameters: kind' syntax' method' loweredOperand' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,OptimizeLiftedUnaryOperator,The method has 5 parameters. Parameters: kind' syntax' method' operand' type
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetLiftedUnaryOperatorConsequence,The method has 5 parameters. Parameters: kind' syntax' method' type' nonNullOperand
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWithNotRefOperand,The method has 9 parameters. Parameters: isPrefix' isChecked' tempSymbols' tempInitializers' syntax' transformedLHS' operandType' boundTemp' newValue
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWithRefOperand,The method has 9 parameters. Parameters: isPrefix' isChecked' tempSymbols' tempInitializers' syntax' operand' operandType' boundTemp' newValue
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWhileStatement,The method has 7 parameters. Parameters: syntax' rewrittenCondition' conditionSequencePointSpan' rewrittenBody' breakLabel' continueLabel' hasErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicConversion,The method has 5 parameters. Parameters: loweredOperand' isExplicit' isArrayIndex' isChecked' resultType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicBinaryOperator,The method has 5 parameters. Parameters: operatorKind' loweredLeft' loweredRight' isCompoundAssignment' resultType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicMemberInvocation,The method has 8 parameters. Parameters: name' loweredReceiver' typeArguments' loweredArguments' argumentNames' refKinds' hasImplicitReceiver' resultDiscarded
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicInvocation,The method has 5 parameters. Parameters: loweredReceiver' loweredArguments' argumentNames' refKinds' resultDiscarded
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicConstructorInvocation,The method has 5 parameters. Parameters: syntax' type' loweredArguments' argumentNames' refKinds
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicSetMember,The method has 5 parameters. Parameters: loweredReceiver' name' loweredRight' isCompoundAssignment' isChecked
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicSetIndex,The method has 7 parameters. Parameters: loweredReceiver' loweredArguments' argumentNames' refKinds' loweredRight' isCompoundAssignment' isChecked
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeCallSiteArgumentInfos,The method has 8 parameters. Parameters: argumentInfoFactory' loweredArguments' argumentNames' refKinds' loweredReceiver' receiverRefKind' receiverIsStaticType' loweredRight
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicOperation,The method has 7 parameters. Parameters: binderConstruction' loweredReceiver' receiverRefKind' loweredArguments' refKinds' loweredRight' resultType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,GetDelegateType,The method has 6 parameters. Parameters: loweredReceiver' receiverRefKind' loweredArguments' refKinds' loweredRight' resultType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,GetArgumentInfo,The method has 5 parameters. Parameters: argumentInfoFactory' boundArgument' name' refKind' isStaticType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeCallSiteDelegateSignature,The method has 5 parameters. Parameters: callSiteType' receiver' arguments' right' resultType
Long Parameter List,Microsoft.CodeAnalysis.CSharp,IteratorAndAsyncCaptureWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\IteratorAndAsyncCaptureWalker.cs,IteratorAndAsyncCaptureWalker,The method has 5 parameters. Parameters: compilation' method' node' emptyStructCache' initiallyAssignedVariables
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,MethodToStateMachineRewriter,The method has 10 parameters. Parameters: F' originalMethod' state' hoistedVariables' nonReusableLocalProxies' synthesizedLocalOrdinals' slotAllocatorOpt' nextFreeHoistedLocalSlot' diagnostics' useFinalizerBookkeeping
Long Parameter List,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,HoistExpression,The method has 7 parameters. Parameters: expr' awaitSyntaxOpt' syntaxOffset' isRef' sideEffects' hoistedFields' needsSacrificialEvaluation
Long Parameter List,Microsoft.CodeAnalysis.CSharp,StateMachineFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineFieldSymbol.cs,StateMachineFieldSymbol,The method has 6 parameters. Parameters: stateMachineType' type' name' synthesizedKind' slotIndex' isPublic
Long Parameter List,Microsoft.CodeAnalysis.CSharp,StateMachineFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineFieldSymbol.cs,StateMachineFieldSymbol,The method has 6 parameters. Parameters: stateMachineType' type' name' slotDebugInfo' slotIndex' isPublic
Long Parameter List,Microsoft.CodeAnalysis.CSharp,StateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineRewriter.cs,StateMachineRewriter,The method has 6 parameters. Parameters: body' method' stateMachineType' slotAllocatorOpt' compilationState' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,StateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineRewriter.cs,OpenMethodImplementation,The method has 5 parameters. Parameters: methodToImplement' methodName' debuggerHidden' generateDebugInfo' hasMethodBodyDependency
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SynthesizedStateMachineMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\SynthesizedStateMachineMethod.cs,SynthesizedStateMachineMethod,The method has 7 parameters. Parameters: name' interfaceMethod' stateMachineType' associatedProperty' debuggerHidden' generateDebugInfo' hasMethodBodyDependency
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,SyntheticBoundNodeFactory,The method has 5 parameters. Parameters: topLevelMethodOpt' currentClassOpt' node' compilationState' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,SynthesizedLocal,The method has 7 parameters. Parameters: type' syntax' isPinned' refKind' kind' createdAtLineNumber' createdAtFilePath
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,StoreToTemp,The method has 7 parameters. Parameters: argument' store' refKind' kind' syntaxOpt' callerLineNumber' callerFilePath
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntheticBinderImpl,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,IsAccessible,The method has 5 parameters. Parameters: symbol' accessThroughType' failedThroughTypeCheck' useSiteDiagnostics' basesBeingResolved
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntheticBinderImpl,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,MakeInvocationExpression,The method has 7 parameters. Parameters: node' receiver' methodName' args' diagnostics' typeArgs' allowUnexpandedForm
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SymbolDisplay,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplay.cs,ToDisplayParts,The method has 5 parameters. Parameters: symbol' semanticModelOpt' positionOpt' format' minimal
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,SymbolDisplayVisitor,The method has 7 parameters. Parameters: builder' format' semanticModelOpt' positionOpt' escapeKeywordIdentifiers' aliasMap' isFirstSymbolVisited
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreateAssemblyDataForFile,The method has 6 parameters. Parameters: assembly' cachedSymbols' documentationProvider' sourceAssemblySimpleName' importOptions' embedInteropTypes
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,InitializeNewSymbols,The method has 5 parameters. Parameters: newSymbols' sourceAssembly' assemblies' bindingResult' missingAssemblies
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,SetupReferencesForFileAssembly,The method has 5 parameters. Parameters: fileData' bindingResult' bindingIndex' missingAssemblies' sourceAssemblyDebugOnly
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,SetupReferencesForSourceAssembly,The method has 5 parameters. Parameters: sourceAssembly' assemblyBeingBuiltData' bindingResult' missingAssemblies' moduleReferences
Long Parameter List,Microsoft.CodeAnalysis.CSharp,AssemblyDataForFile,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,AssemblyDataForFile,The method has 6 parameters. Parameters: assembly' cachedSymbols' embedInteropTypes' documentationProvider' sourceAssemblySimpleName' compilationImportOptions
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxNode,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxNode.cs,ReplaceCore,The method has 6 parameters. Parameters: nodes' computeReplacementNode' tokens' computeReplacementToken' trivia' computeReplacementTrivia
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxTree,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxTree.cs,ParseText,The method has 5 parameters. Parameters: text' options' path' encoding' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,ParsedSyntaxTree,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxTree.ParsedSyntaxTree.cs,ParsedSyntaxTree,The method has 8 parameters. Parameters: textOpt' encodingOpt' checksumAlgorithm' path' options' root' directives' cloneRoot
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Token,The method has 5 parameters. Parameters: leading' kind' text' valueText' trailing
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Identifier,The method has 5 parameters. Parameters: leading' contextualKind' text' valueText' trailing
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,ParseSyntaxTree,The method has 5 parameters. Parameters: text' options' path' encoding' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,PropertyDeclaration,The method has 6 parameters. Parameters: attributeLists' modifiers' type' explicitInterfaceSpecifier' identifier' accessorList
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,MethodDeclaration,The method has 10 parameters. Parameters: attributeLists' modifiers' returnType' explicitInterfaceSpecifier' identifier' typeParameterList' parameterList' constraintClauses' body' semicolonToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,ConversionOperatorDeclaration,The method has 8 parameters. Parameters: attributeLists' modifiers' implicitOrExplicitKeyword' operatorKeyword' type' parameterList' body' semicolonToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,OperatorDeclaration,The method has 8 parameters. Parameters: attributeLists' modifiers' returnType' operatorKeyword' operatorToken' parameterList' body' semicolonToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,IndexerDeclaration,The method has 6 parameters. Parameters: attributeLists' modifiers' type' explicitInterfaceSpecifier' parameterList' accessorList
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,TypeDeclaration,The method has 12 parameters. Parameters: kind' attributes' modifiers' keyword' identifier' typeParameterList' baseList' constraintClauses' openBraceToken' members' closeBraceToken' semicolonToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxExtensions.cs,Update,The method has 8 parameters. Parameters: syntax' attributeLists' modifiers' type' explicitInterfaceSpecifier' thisKeyword' parameterList' accessorList
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxExtensions.cs,Update,The method has 9 parameters. Parameters: syntax' attributeLists' modifiers' returnType' operatorKeyword' operatorToken' parameterList' block' semicolonToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,SyntaxExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxExtensions.cs,Update,The method has 11 parameters. Parameters: syntax' attributeLists' modifiers' returnType' explicitInterfaceSpecifier' identifier' typeParameterList' parameterList' constraintClauses' block' semicolonToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,GetDeclarationsInNode,The method has 5 parameters. Parameters: model' node' getSymbol' cancellationToken' levelsToCompute
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,ComputeDeclarations,The method has 7 parameters. Parameters: model' node' shouldSkip' getSymbol' builder' levelsToCompute' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,CodeGenerator,The method has 7 parameters. Parameters: method' boundBody' builder' moduleBuilder' diagnostics' optimizations' emittingPdbs
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitDelegateCreation,The method has 6 parameters. Parameters: node' receiver' isExtensionMethod' method' delegateType' used
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitStringSwitchJumpTable,The method has 5 parameters. Parameters: switchStatement' switchCaseLabels' fallThroughLabel' key' syntaxNode
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitStringCompareAndBranch,The method has 5 parameters. Parameters: key' syntaxNode' stringConstant' targetLabel' stringEqualityMethodRef
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ArrayTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\ArrayTypeSymbolAdapter.cs,ArrayTypeSymbol,The method has 5 parameters. Parameters: elementType' rank' array' constructedInterfaces' customModifiers
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttributeAction,The method has 5 parameters. Parameters: targetSymbol' compilation' nodeOpt' hasErrors' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedMethodBaseSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SynthesizedMethodBaseSymbol.cs,SynthesizedMethodBaseSymbol,The method has 7 parameters. Parameters: containingType' baseMethod' syntaxReference' blockSyntaxReference' location' name' declarationModifiers
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,GetTypeByMetadataName,The method has 5 parameters. Parameters: metadataName' includeReferences' isWellKnownType' useCLSCompliantNameArityEncoding' warnings
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,GetTopLevelTypeByMetadataName,The method has 5 parameters. Parameters: metadataName' assemblyOpt' includeReferences' isWellKnownType' warnings
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\SourceAttributeData.cs,SourceAttributeData,The method has 8 parameters. Parameters: applicationNode' attributeClass' attributeConstructor' constructorArguments' constructorArgumentsSourceIndices' namedArguments' hasErrors' isConditionallyOmitted
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstantValueUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstantValueUtils.cs,EvaluateFieldConstant,The method has 5 parameters. Parameters: symbol' equalsValueNode' dependencies' earlyDecodingWellKnownAttributes' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstantValueUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstantValueUtils.cs,GetAndValidateConstantValue,The method has 5 parameters. Parameters: boundValue' thisSymbol' typeSymbol' initValueNodeLocation' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,ResolveBounds,The method has 7 parameters. Parameters: typeParameter' corLibrary' inProgress' constraintTypes' inherited' currentCompilation' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,ResolveBounds,The method has 8 parameters. Parameters: typeParameter' corLibrary' inProgress' constraintTypes' inherited' currentCompilation' diagnosticsBuilder' useSiteDiagnosticsBuilder
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The method has 7 parameters. Parameters: type' conversions' typeSyntax' typeArgumentsSyntax' currentCompilation' basesBeingResolved' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The method has 5 parameters. Parameters: type' currentCompilation' conversions' location' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The method has 6 parameters. Parameters: method' conversions' syntaxNode' currentCompilation' diagnostics' skipParameters
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The method has 5 parameters. Parameters: method' conversions' location' currentCompilation' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckTypeConstraints,The method has 5 parameters. Parameters: type' conversions' currentCompilation' diagnosticsBuilder' useSiteDiagnosticsBuilder
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckMethodConstraints,The method has 6 parameters. Parameters: method' conversions' currentCompilation' diagnosticsBuilder' useSiteDiagnosticsBuilder' skipParameters
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The method has 9 parameters. Parameters: containingSymbol' conversions' substitution' typeParameters' typeArguments' currentCompilation' diagnosticsBuilder' useSiteDiagnosticsBuilder' skipParameters
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The method has 8 parameters. Parameters: containingSymbol' conversions' substitution' typeParameter' typeArgument' currentCompilation' diagnosticsBuilder' useSiteDiagnosticsBuilder
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ErrorPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ErrorPropertySymbol.cs,ErrorPropertySymbol,The method has 5 parameters. Parameters: containingSymbol' type' name' isIndexer' isIndexedProperty
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ExtendedErrorTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ExtendedErrorTypeSymbol.cs,ExtendedErrorTypeSymbol,The method has 6 parameters. Parameters: compilation' name' arity' errorInfo' unreported' variableUsedBeforeDeclaration
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ExtendedErrorTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ExtendedErrorTypeSymbol.cs,ExtendedErrorTypeSymbol,The method has 6 parameters. Parameters: containingSymbol' name' arity' errorInfo' unreported' variableUsedBeforeDeclaration
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ExtendedErrorTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ExtendedErrorTypeSymbol.cs,ExtendedErrorTypeSymbol,The method has 8 parameters. Parameters: containingSymbol' name' arity' errorInfo' unreported' variableUsedBeforeDeclaration' candidateSymbols' resultKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ExtendedErrorTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ExtendedErrorTypeSymbol.cs,ExtendedErrorTypeSymbol,The method has 5 parameters. Parameters: containingSymbol' guessSymbol' resultKind' errorInfo' unreported
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ExtendedErrorTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ExtendedErrorTypeSymbol.cs,ExtendedErrorTypeSymbol,The method has 6 parameters. Parameters: containingSymbol' candidateSymbols' resultKind' errorInfo' arity' unreported
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,MemberSignatureComparer,The method has 7 parameters. Parameters: considerName' considerExplicitlyImplementedInterfaces' considerReturnType' considerTypeConstraints' considerCallingConvention' considerRefOutDifference' considerCustomModifiers
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,HaveSameReturnTypes,The method has 5 parameters. Parameters: member1' typeMap1' member2' typeMap2' considerCustomModifiers
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,HaveSameParameterTypes,The method has 6 parameters. Parameters: params1' typeMap1' params2' typeMap2' considerRefOutDifference' considerCustomModifiers
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,TopLevel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MissingMetadataTypeSymbol.cs,TopLevel,The method has 5 parameters. Parameters: module' namespace' name' arity' mangleName
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,NoPiaMissingCanonicalTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\NoPiaMissingCanonicalTypeSymbol.cs,NoPiaMissingCanonicalTypeSymbol,The method has 5 parameters. Parameters: embeddingAssembly' fullTypeName' guid' scope' identifier
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindOverriddenOrHiddenMembersInType,The method has 7 parameters. Parameters: member' memberIsFromSomeCompilation' memberContainingType' currType' currTypeBestMatch' currTypeHasSameKindNonMatch' hiddenBuilder
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindRelatedMembers,The method has 7 parameters. Parameters: isOverride' overridingMemberIsFromSomeCompilation' overridingMemberKind' representativeMember' overriddenMembers' runtimeOverriddenMembers' hiddenBuilder
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SignatureOnlyMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SignatureOnlyMethodSymbol.cs,SignatureOnlyMethodSymbol,The method has 9 parameters. Parameters: name' containingType' methodKind' callingConvention' typeParameters' parameters' returnType' returnTypeCustomModifiers' explicitInterfaceImplementations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SignatureOnlyPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SignatureOnlyPropertySymbol.cs,SignatureOnlyPropertySymbol,The method has 7 parameters. Parameters: name' containingType' parameters' type' typeCustomModifiers' isStatic' explicitInterfaceImplementations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,CustomModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\CustomModifierUtils.cs,CopyMethodCustomModifiers,The method has 6 parameters. Parameters: sourceMethod' destinationMethod' returnType' returnTypeCustomModifiers' parameters' alsoCopyParamsModifier
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,GetMemberNameAndInterfaceSymbol,The method has 6 parameters. Parameters: binder' explicitInterfaceSpecifierOpt' name' diagnostics' explicitInterfaceTypeOpt' aliasQualifierOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedMethod,The method has 5 parameters. Parameters: implementingMethod' explicitInterfaceType' interfaceMethodName' explicitInterfaceSpecifierSyntax' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedProperty,The method has 5 parameters. Parameters: implementingProperty' explicitInterfaceType' interfacePropertyName' explicitInterfaceSpecifierSyntax' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedEvent,The method has 5 parameters. Parameters: implementingEvent' explicitInterfaceType' interfaceEventName' explicitInterfaceSpecifierSyntax' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedMember,The method has 5 parameters. Parameters: implementingMember' explicitInterfaceType' interfaceMemberName' explicitInterfaceSpecifierSyntax' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,LambdaSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\LambdaSymbol.cs,LambdaSymbol,The method has 5 parameters. Parameters: compilation' containingSymbol' unboundLambda' delegateParameters' returnType
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,LambdaSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\LambdaSymbol.cs,LambdaSymbol,The method has 7 parameters. Parameters: containingSymbol' parameters' returnType' messageID' syntax' isSynthesized' isAsync
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ModifierUtils.cs,MakeAndCheckNontypeMemberModifiers,The method has 7 parameters. Parameters: modifiers' defaultAccess' allowedModifiers' errorLocation' diagnostics' modifierErrors' ignoreParameterModifiers
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ModifierUtils.cs,CheckModifiers,The method has 5 parameters. Parameters: modifiers' allowedModifiers' errorLocation' diagnostics' modifierErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,MakeParameters,The method has 6 parameters. Parameters: binder' owner' syntax' allowRefOrOut' arglistToken' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportParameterErrors,The method has 5 parameters. Parameters: owner' parameterSyntax' parameter' firstDefault' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The method has 6 parameters. Parameters: binder' owner' parameterSyntax' parameter' defaultExpression' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,GetModifiers,The method has 5 parameters. Parameters: modifiers' outKeyword' refKeyword' paramsKeyword' thisKeyword
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeOneInternalsVisibleToAttribute,The method has 5 parameters. Parameters: nodeOpt' attrData' diagnostics' index' lazyInternalsVisibleToMap
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,SourceComplexParameterSymbol,The method has 12 parameters. Parameters: owner' ordinal' parameterType' refKind' customModifiers' hasByRefBeforeCustomModifiers' name' locations' syntaxRef' defaultSyntaxValue' isParams' isExtensionMethodThis
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,DecodeDefaultParameterValueAttribute,The method has 5 parameters. Parameters: description' attribute' node' diagnose' diagnosticsOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,PostDecodeWellKnownAttributes,The method has 5 parameters. Parameters: boundAttributes' allAttributeSyntaxNodes' diagnostics' symbolPart' decodedData
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceConstructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceConstructorSymbol.cs,SourceConstructorSymbol,The method has 5 parameters. Parameters: containingType' location' syntax' methodKind' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceConstructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceConstructorSymbol.cs,MakeModifiers,The method has 5 parameters. Parameters: modifiers' methodKind' location' diagnostics' modifierErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceCustomEventAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceCustomEventAccessorSymbol.cs,SourceCustomEventAccessorSymbol,The method has 5 parameters. Parameters: event' syntax' explicitlyImplementedEventOpt' aliasQualifierOpt' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceDelegateMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceDelegateMethodSymbol.cs,SourceDelegateMethodSymbol,The method has 5 parameters. Parameters: delegateType' returnType' syntax' methodKind' declarationModifiers
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,Constructor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceDelegateMethodSymbol.cs,Constructor,The method has 5 parameters. Parameters: delegateType' voidType' objectType' intPtrType' syntax
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,InvokeMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceDelegateMethodSymbol.cs,InvokeMethod,The method has 5 parameters. Parameters: delegateType' returnType' syntax' binder' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,BeginInvokeMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceDelegateMethodSymbol.cs,BeginInvokeMethod,The method has 5 parameters. Parameters: invoke' iAsyncResultType' objectType' asyncCallbackType' syntax
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEnumConstantSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEnumConstantSymbol.cs,CreateImplicitValuedConstant,The method has 5 parameters. Parameters: containingEnum' syntax' otherConstant' otherConstantOffset' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ImplicitValuedEnumConstantSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEnumConstantSymbol.cs,ImplicitValuedEnumConstantSymbol,The method has 5 parameters. Parameters: containingEnum' syntax' otherConstant' otherConstantOffset' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,SourceEventSymbol,The method has 6 parameters. Parameters: containingType' syntax' modifiers' interfaceSpecifierSyntaxOpt' nameTokenSyntax' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,MakeModifiers,The method has 5 parameters. Parameters: modifiers' explicitInterfaceImplementation' location' diagnostics' modifierErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldLikeEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldLikeEventSymbol.cs,SourceFieldLikeEventSymbol,The method has 5 parameters. Parameters: containingType' binder' modifiers' declaratorSyntax' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,PostDecodeWellKnownAttributes,The method has 5 parameters. Parameters: boundAttributes' allAttributeSyntaxNodes' diagnostics' symbolPart' decodedData
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFixedFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFixedFieldSymbol.cs,SourceFixedFieldSymbol,The method has 5 parameters. Parameters: containingType' declarator' modifiers' modifierErrors' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceLocalSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceLocalSymbol.cs,SourceLocalSymbol,The method has 5 parameters. Parameters: containingSymbol' binder' typeSyntax' identifierToken' declarationKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceLocalSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceLocalSymbol.cs,MakeForeachLocal,The method has 5 parameters. Parameters: containingMethod' binder' typeSyntax' identifierToken' collection
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceLocalSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceLocalSymbol.cs,MakeLocal,The method has 6 parameters. Parameters: containingSymbol' binder' typeSyntax' identifierToken' declarationKind' initializer
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,LocalWithInitializer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceLocalSymbol.cs,LocalWithInitializer,The method has 6 parameters. Parameters: containingSymbol' binder' typeSyntax' identifierToken' initializer' declarationKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,ForEachLocal,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceLocalSymbol.cs,ForEachLocal,The method has 6 parameters. Parameters: containingSymbol' binder' typeSyntax' identifierToken' collection' declarationKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MakeAndCheckTypeModifiers,The method has 5 parameters. Parameters: defaultAccess' allowedModifiers' self' diagnostics' modifierErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,TryCalculateSyntaxOffsetOfPositionInInitializer,The method has 5 parameters. Parameters: position' tree' isStatic' ctorInitializerLength' syntaxOffset
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckIndexerSignatureCollisions,The method has 5 parameters. Parameters: indexer' diagnostics' membersByName' indexersBySignature' lastIndexerName
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckNonOverrideMember,The method has 5 parameters. Parameters: hidingMember' hidingMemberIsNew' overriddenOrHiddenMembers' diagnostics' suppressAccessors
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,AddHidingAbstractDiagnostic,The method has 5 parameters. Parameters: hidingMember' hidingMemberLocation' hiddenMember' diagnostics' suppressAccessors
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,Flags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,Flags,The method has 5 parameters. Parameters: methodKind' declarationModifiers' returnsVoid' isExtensionMethod' isMetadataVirtualIgnoringModifiers
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,MembersAndInitializers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MembersAndInitializers,The method has 6 parameters. Parameters: nonTypeNonIndexerMembers' staticInitializers' instanceInitializers' indexerDeclarations' staticInitializersSyntaxLength' instanceInitializersSyntaxLength
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberFieldSymbol.cs,SourceMemberFieldSymbol,The method has 5 parameters. Parameters: containingType' declarator' modifiers' modifierErrors' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberFieldSymbol.cs,MakeModifiers,The method has 5 parameters. Parameters: containingType' firstIdentifier' modifiers' diagnostics' modifierErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,SourceMemberMethodSymbol,The method has 8 parameters. Parameters: containingType' explicitInterfaceType' name' location' bodyBinder' syntax' methodKind' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MakeModifiers,The method has 5 parameters. Parameters: modifiers' methodKind' location' diagnostics' modifierErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,MakeFlags,The method has 5 parameters. Parameters: methodKind' declarationModifiers' returnsVoid' isExtensionMethod' isMetadataVirtualIgnoringModifiers
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,PostDecodeWellKnownAttributes,The method has 5 parameters. Parameters: boundAttributes' allAttributeSyntaxNodes' diagnostics' symbolPart' decodedData
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,PostDecodeWellKnownAttributes,The method has 5 parameters. Parameters: boundAttributes' allAttributeSyntaxNodes' diagnostics' symbolPart' decodedData
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceParameterSymbol.cs,Create,The method has 10 parameters. Parameters: context' owner' parameterType' syntax' refKind' identifier' ordinal' isParams' isExtensionMethodThis' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceParameterSymbol.cs,SourceParameterSymbol,The method has 6 parameters. Parameters: owner' parameterType' ordinal' refKind' name' locations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,CreateAccessorSymbol,The method has 9 parameters. Parameters: containingType' property' propertyModifiers' propertyName' syntax' explicitlyImplementedPropertyOpt' aliasQualifierOpt' isAutoPropertyAccessor' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,CreateAccessorSymbol,The method has 8 parameters. Parameters: containingType' property' propertyModifiers' propertyName' syntax' explicitlyImplementedPropertyOpt' aliasQualifierOpt' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,GetNameAndExplicitInterfaceImplementations,The method has 7 parameters. Parameters: explicitlyImplementedPropertyOpt' propertyName' isWinMd' aliasQualifierOpt' isGetMethod' name' explicitInterfaceImplementations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,SourcePropertyAccessorSymbol,The method has 8 parameters. Parameters: containingType' name' property' propertyModifiers' explicitInterfaceImplementations' location' syntax' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,SourcePropertyAccessorSymbol,The method has 10 parameters. Parameters: containingType' name' property' propertyModifiers' explicitInterfaceImplementations' location' syntax' methodKind' isAutoPropertyAccessor' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,SourcePropertySymbol,The method has 6 parameters. Parameters: containingType' bodyBinder' syntax' name' location' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,MakeModifiers,The method has 6 parameters. Parameters: modifiers' isExplicitInterfaceImplementation' isIndexer' location' diagnostics' modifierErrors
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,CreateAccessorSymbol,The method has 5 parameters. Parameters: syntaxOpt' explicitlyImplementedPropertyOpt' aliasQualifierOpt' isAutoPropertyAccessor' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,PostDecodeWellKnownAttributes,The method has 5 parameters. Parameters: boundAttributes' allAttributeSyntaxNodes' diagnostics' symbolPart' decodedData
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceSimpleParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceSimpleParameterSymbol.cs,SourceSimpleParameterSymbol,The method has 6 parameters. Parameters: owner' parameterType' ordinal' refKind' name' locations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceTypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceTypeParameterSymbol.cs,SourceTypeParameterSymbol,The method has 6 parameters. Parameters: owner' name' ordinal' varianceKind' locations' syntaxRefs
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodTypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceTypeParameterSymbol.cs,SourceMethodTypeParameterSymbol,The method has 5 parameters. Parameters: owner' name' ordinal' locations' syntaxRefs
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceOverridingMethodTypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceTypeParameterSymbol.cs,SourceOverridingMethodTypeParameterSymbol,The method has 5 parameters. Parameters: map' name' ordinal' locations' syntaxRefs
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceUserDefinedConversionSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceUserDefinedConversionSymbol.cs,SourceUserDefinedConversionSymbol,The method has 6 parameters. Parameters: containingType' name' location' syntax' diagnostics' isExpressionBodied
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceUserDefinedOperatorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceUserDefinedOperatorSymbol.cs,SourceUserDefinedOperatorSymbol,The method has 6 parameters. Parameters: containingType' name' location' syntax' diagnostics' isExpressionBodied
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SourceUserDefinedOperatorSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceUserDefinedOperatorSymbolBase.cs,SourceUserDefinedOperatorSymbolBase,The method has 9 parameters. Parameters: methodKind' name' containingType' location' syntaxReference' bodySyntaxReference' modifiersSyntax' diagnostics' isExpressionBodied
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedNamedTypeSymbol.cs,SubstitutedNamedTypeSymbol,The method has 5 parameters. Parameters: newContainer' map' originalDefinition' constructedFrom' unbound
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,MakeMethodScopedSynthesizedName,The method has 7 parameters. Parameters: kind' methodOrdinal' generation' methodNameOpt' suffix' uniqueId' isTypeName
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedBackingFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedBackingFieldSymbol.cs,SynthesizedBackingFieldSymbol,The method has 5 parameters. Parameters: property' name' isReadOnly' isStatic' hasInitializer
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedDelegateSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedDelegateSymbol.cs,SynthesizedDelegateSymbol,The method has 7 parameters. Parameters: containingSymbol' name' objectType' intPtrType' voidReturnTypeOpt' parameterCount' byRefParameters
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedFieldSymbol.cs,SynthesizedFieldSymbol,The method has 6 parameters. Parameters: containingType' type' name' isPublic' isReadOnly' isStatic
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedFieldSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedFieldSymbolBase.cs,SynthesizedFieldSymbolBase,The method has 5 parameters. Parameters: containingType' name' isPublic' isReadOnly' isStatic
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedIntrinsicOperatorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedIntrinsicOperatorSymbol.cs,SynthesizedIntrinsicOperatorSymbol,The method has 5 parameters. Parameters: leftType' name' rightType' returnType' isCheckedBuiltin
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedLambdaCacheFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedLambdaCacheFieldSymbol.cs,SynthesizedLambdaCacheFieldSymbol,The method has 6 parameters. Parameters: containingType' type' name' topLevelMethod' isReadOnly' isStatic
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedLocal,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedLocal.cs,SynthesizedLocal,The method has 8 parameters. Parameters: containingMethodOpt' type' kind' syntaxOpt' isPinned' refKind' createdAtLineNumber' createdAtFilePath
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedImplementationMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedImplementationMethod.cs,SynthesizedImplementationMethod,The method has 6 parameters. Parameters: interfaceMethod' implementingType' name' debuggerHidden' generateDebugInfo' associatedProperty
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedParameterSymbol.cs,SynthesizedParameterSymbol,The method has 6 parameters. Parameters: container' type' ordinal' refKind' name' customModifiers
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,FindPotentialImplicitImplementationMemberDeclaredInType,The method has 5 parameters. Parameters: interfaceMember' implementingTypeIsFromSomeCompilation' currType' implicitImpl' closeMismatch
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,VarianceSafety,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\VarianceSafety.cs,IsVarianceUnsafe,The method has 7 parameters. Parameters: type' requireOutputSafety' requireInputSafety' context' locationProvider' locationArg' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,VarianceSafety,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\VarianceSafety.cs,IsVarianceUnsafe,The method has 7 parameters. Parameters: namedType' requireOutputSafety' requireInputSafety' context' locationProvider' locationArg' diagnostics
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols,VarianceSafety,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\VarianceSafety.cs,AddVarianceError,The method has 6 parameters. Parameters: diagnostics' unsafeTypeParameter' context' locationProvider' locationArg' expectedVariance
Long Parameter List,Microsoft.CodeAnalysis,CSharpExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpExtensions.cs,TryGetSpeculativeSemanticModel,The method has 5 parameters. Parameters: semanticModel' position' type' speculativeModel' bindingOption
Long Parameter List,Microsoft.CodeAnalysis,CSharpExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpExtensions.cs,ClassifyConversion,The method has 5 parameters. Parameters: semanticModel' position' expression' destination' isExplicitInSource
Long Parameter List,Microsoft.CodeAnalysis.CSharp.DocumentationComments,PEDocumentationCommentUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\DocumentationComments\PEDocumentationCommentUtils.cs,GetDocumentationComment,The method has 5 parameters. Parameters: symbol' containingPEModule' preferredCulture' cancellationToken' lazyDocComment
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit,CSharpDefinitionMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\CSharpDefinitionMap.cs,CSharpDefinitionMap,The method has 5 parameters. Parameters: module' edits' metadataDecoder' mapToMetadata' mapToPrevious
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit,CSharpDefinitionMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\CSharpDefinitionMap.cs,GetStateMachineFieldMapFromMetadata,The method has 5 parameters. Parameters: stateMachineType' localSlotDebugInfo' hoistedLocalMap' awaiterMap' awaiterSlotCount
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit,EmitHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\EmitHelpers.cs,EmitDifference,The method has 10 parameters. Parameters: compilation' baseline' edits' isAddedSymbol' metadataStream' ilStream' pdbStream' updatedMethods' testData' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit,PEDeltaAssemblyBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\PEDeltaAssemblyBuilder.cs,PEDeltaAssemblyBuilder,The method has 8 parameters. Parameters: sourceAssembly' emitOptions' outputKind' serializationProperties' manifestResources' previousGeneration' edits' isAddedSymbol
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit,CSharpSymbolMatcher,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\CSharpSymbolMatcher.cs,CSharpSymbolMatcher,The method has 6 parameters. Parameters: anonymousTypeMap' sourceAssembly' sourceContext' otherAssembly' otherContext' otherSynthesizedMembersOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit,PEAssemblyBuilderBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEAssemblyBuilder.cs,PEAssemblyBuilderBase,The method has 7 parameters. Parameters: sourceAssembly' emitOptions' outputKind' serializationProperties' manifestResources' assemblySymbolMapper' additionalTypes
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit,PEAssemblyBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEAssemblyBuilder.cs,PEAssemblyBuilder,The method has 6 parameters. Parameters: sourceAssembly' emitOptions' outputKind' serializationProperties' manifestResources' assemblySymbolMapper
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,PEModuleBuilder,The method has 6 parameters. Parameters: sourceModule' emitOptions' outputKind' serializationProperties' manifestResources' assemblySymbolMapper
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,Translate,The method has 5 parameters. Parameters: namedTypeSymbol' syntaxNodeOpt' diagnostics' fromImplements' needDeclaration
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,Translate,The method has 5 parameters. Parameters: methodSymbol' syntaxNodeOpt' diagnostics' optArgList' needDeclaration
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,ReportNotEmbeddableSymbol,The method has 5 parameters. Parameters: error' symbol' syntaxNodeOpt' diagnostics' optTypeManager
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,EmbedEvent,The method has 5 parameters. Parameters: type' event' syntaxNodeOpt' diagnostics' isUsedForComAwareEventBinding
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Blender,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Blender.cs,Blender,The method has 8 parameters. Parameters: lexer' oldTreeCursor' changes' newPosition' changeDelta' newDirectives' oldDirectives' newLexerDrivenMode
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,SkipBadTokens,The method has 5 parameters. Parameters: startNode' list' isNotExpectedFunction' abortFunction' error
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,LanguageParser,The method has 5 parameters. Parameters: lexer' oldTree' changes' lexerMode' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ReportDuplicateModifiers,The method has 5 parameters. Parameters: modTok' newMod' mods' seenNoDuplicates' seenNoAccessibilityDuplicates
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ReconsiderTypeAsAsyncModifier,The method has 5 parameters. Parameters: modifiers' type' explicitInterfaceOpt' identifierOrThisOpt' typeParameterListOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMethodDeclaration,The method has 6 parameters. Parameters: attributes' modifiers' type' explicitInterfaceOpt' identifier' typeParameterList
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseIndexerDeclaration,The method has 6 parameters. Parameters: attributes' modifiers' type' explicitInterfaceOpt' thisKeyword' typeParameterList
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParsePropertyDeclaration,The method has 6 parameters. Parameters: attributes' modifiers' type' explicitInterfaceOpt' identifier' typeParameterList
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadSeparatedListTokensWithExpectedKind,The method has 5 parameters. Parameters: startToken' list' isNotExpectedFunction' abortFunction' expected
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadListTokensWithErrorCode,The method has 5 parameters. Parameters: startToken' list' isNotExpectedFunction' abortFunction' error
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadListTokensWithExpectedKindHelper,The method has 5 parameters. Parameters: list' isNotExpectedFunction' abortFunction' expected' trailingTrivia
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadListTokensWithErrorCodeHelper,The method has 5 parameters. Parameters: list' isNotExpectedFunction' abortFunction' error' trailingTrivia
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseParameterList,The method has 8 parameters. Parameters: open' nodes' close' openKind' closeKind' allowThisKeyword' allowDefaults' allowAttributes
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadParameterListTokens,The method has 5 parameters. Parameters: open' list' expected' closeKind' allowThisKeyword
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseParameter,The method has 5 parameters. Parameters: attributes' modifiers' allowThisKeyword' allowDefaults' allowAttributes
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseEventFieldDeclaration,The method has 5 parameters. Parameters: attributes' modifiers' eventToken' type' parentKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseArgumentList,The method has 5 parameters. Parameters: openToken' arguments' closeToken' openKind' closeKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,ResetPoint,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ResetPoint,The method has 5 parameters. Parameters: resetPoint' terminatorState' isInTry' isInAsync' queryDepth
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexSingleDirective,The method has 5 parameters. Parameters: isActive' endIsActive' afterFirstToken' afterNonWhitespaceOnLine' triviaList
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanInterpolatedStringLiteralTop,The method has 5 parameters. Parameters: interpolations' isVerbatim' info' error' closeQuoteMissing
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LexerCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LexerCache.cs,LookupTrivia,The method has 5 parameters. Parameters: textBuffer' keyStart' keyLength' hashCode' createTriviaFunction
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LexerCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LexerCache.cs,LookupToken,The method has 5 parameters. Parameters: textBuffer' keyStart' keyLength' hashCode' createTokenFunction
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxParser.cs,SyntaxParser,The method has 7 parameters. Parameters: lexer' mode' oldTree' changes' allowModeReset' preLexIfNotIncremental' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxParser.cs,AddError,The method has 5 parameters. Parameters: node' offset' length' code' args
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\Syntax.cs,Token,The method has 5 parameters. Parameters: leading' kind' text' valueText' trailing
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\Syntax.cs,Identifier,The method has 5 parameters. Parameters: contextualKind' leading' text' valueText' trailing
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\Syntax.cs,Literal,The method has 5 parameters. Parameters: leading' text' kind' value' trailing
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxNodeCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNodeCache.cs,TryGetNode,The method has 5 parameters. Parameters: kind' child1' child2' context' hash
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxNodeCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNodeCache.cs,TryGetNode,The method has 5 parameters. Parameters: kind' child1' child2' flags' hash
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxNodeCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNodeCache.cs,TryGetNode,The method has 5 parameters. Parameters: kind' child1' child2' child3' hash
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxNodeCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNodeCache.cs,TryGetNode,The method has 6 parameters. Parameters: kind' child1' child2' child3' context' hash
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxNodeCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNodeCache.cs,TryGetNode,The method has 6 parameters. Parameters: kind' child1' child2' child3' flags' hash
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxNodeCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNodeCache.cs,GetCacheHash,The method has 5 parameters. Parameters: kind' flags' child1' child2' child3
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxToken,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.cs,Identifier,The method has 5 parameters. Parameters: contextualKind' leading' text' valueText' trailing
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxToken,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.cs,WithValue,The method has 5 parameters. Parameters: kind' leading' text' value' trailing
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,MissingTokenWithTrivia,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.MissingTokenWithTrivia.cs,MissingTokenWithTrivia,The method has 5 parameters. Parameters: kind' leading' trailing' diagnostics' annotations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierExtended,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierExtended.cs,SyntaxIdentifierExtended,The method has 5 parameters. Parameters: contextualKind' text' valueText' diagnostics' annotations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierWithTrivia,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierWithTrivia.cs,SyntaxIdentifierWithTrivia,The method has 5 parameters. Parameters: contextualKind' text' valueText' leading' trailing
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierWithTrivia,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierWithTrivia.cs,SyntaxIdentifierWithTrivia,The method has 7 parameters. Parameters: contextualKind' text' valueText' leading' trailing' diagnostics' annotations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxTokenWithValue<T>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxLiteral.cs,SyntaxTokenWithValue,The method has 5 parameters. Parameters: kind' text' value' diagnostics' annotations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxTokenWithValueAndTrivia<T>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxLiteralWithTrivia.cs,SyntaxTokenWithValueAndTrivia,The method has 5 parameters. Parameters: kind' text' value' leading' trailing
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxTokenWithValueAndTrivia<T>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxLiteralWithTrivia.cs,SyntaxTokenWithValueAndTrivia,The method has 7 parameters. Parameters: kind' text' value' leading' trailing' diagnostics' annotations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxTokenWithTrivia,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxTokenWithTrivia.cs,SyntaxTokenWithTrivia,The method has 5 parameters. Parameters: kind' leading' trailing' diagnostics' annotations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,DynamicTypeDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\DynamicTypeDecoder.cs,TransformType,The method has 5 parameters. Parameters: metadataType' targetSymbolCustomModifierCount' targetSymbolToken' containingModule' targetSymbolRefKind
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,DynamicTypeDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\DynamicTypeDecoder.cs,TransformTypeInternal,The method has 6 parameters. Parameters: metadataType' containingAssembly' targetSymbolCustomModifierCount' targetSymbolRefKind' dynamicTransformFlags' haveCustomModifierFlags
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,MemberRefMetadataDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\MemberRefMetadataDecoder.cs,FindMethodBySignature,The method has 5 parameters. Parameters: targetTypeSymbol' targetMemberName' targetMemberSignatureHeader' targetMemberTypeParamCount' targetParamInfo
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,MetadataDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\MetadataDecoder.cs,SubstituteNoPiaLocalType,The method has 5 parameters. Parameters: typeDef' name' interfaceGuid' scope' identifier
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,MetadataDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\MetadataDecoder.cs,SubstituteNoPiaLocalType,The method has 7 parameters. Parameters: name' isInterface' baseType' interfaceGuid' scope' identifier' referringAssembly
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEEventSymbol.cs,PEEventSymbol,The method has 6 parameters. Parameters: moduleSymbol' containingType' handle' addMethod' removeMethod' privateFieldNameToSymbols
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,GetCustomAttributesForToken,The method has 5 parameters. Parameters: token' filteredOutAttribute1' filterOut1' filteredOutAttribute2' filterOut2
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,GetGenericInfo,The method has 5 parameters. Parameters: moduleSymbol' handle' genericParameterHandles' arity' mrEx
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,PENamedTypeSymbol,The method has 6 parameters. Parameters: moduleSymbol' container' handle' emittedNamespaceName' arity' mangleName
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbolNonGeneric,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,PENamedTypeSymbolNonGeneric,The method has 5 parameters. Parameters: moduleSymbol' container' handle' emittedNamespaceName' mangleName
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbolGeneric,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,PENamedTypeSymbolGeneric,The method has 7 parameters. Parameters: moduleSymbol' container' handle' emittedNamespaceName' genericParameterHandles' arity' mangleName
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEParameterSymbol.cs,PEParameterSymbol,The method has 5 parameters. Parameters: moduleSymbol' containingSymbol' ordinal' parameter' isBad
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEParameterSymbol.cs,PEParameterSymbol,The method has 6 parameters. Parameters: moduleSymbol' containingSymbol' ordinal' handle' parameter' isBad
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEParameterSymbol.cs,PEParameterSymbol,The method has 9 parameters. Parameters: moduleSymbol' containingSymbol' ordinal' isByRef' hasByRefBeforeCustomModifiers' type' handle' customModifiers' isBad
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEPropertySymbol.cs,PEPropertySymbol,The method has 5 parameters. Parameters: moduleSymbol' containingType' handle' getMethod' setMethod
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEPropertySymbol.cs,DoSignaturesMatch,The method has 7 parameters. Parameters: module' metadataDecoder' propertyParams' getMethod' getMethodParams' setMethod' setMethodParams
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEPropertySymbol.cs,GetParameters,The method has 5 parameters. Parameters: moduleSymbol' property' propertyParams' accessorParams' anyParameterIsBad
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\RetargetingAttributeData.cs,RetargetingAttributeData,The method has 8 parameters. Parameters: applicationNode' attributeClass' attributeConstructor' constructorArguments' constructorArgumentsSourceIndices' namedArguments' hasErrors' isConditionallyOmitted
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,TypeDeclaration,The method has 12 parameters. Parameters: kind' attributes' modifiers' keyword' identifier' typeParameterList' baseList' constraintClauses' openBraceToken' members' closeBraceToken' semicolonToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,RewriteTrivia,The method has 6 parameters. Parameters: triviaList' depth' isTrailing' mustBeIndented' mustHaveSeparator' lineBreaksAfter
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxReplacer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxReplacer.cs,Replace,The method has 7 parameters. Parameters: root' nodes' computeReplacementNode' tokens' computeReplacementToken' trivia' computeReplacementTrivia
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxReplacer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxReplacer.cs,Replace,The method has 7 parameters. Parameters: root' nodes' computeReplacementNode' tokens' computeReplacementToken' trivia' computeReplacementTrivia
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Syntax,Replacer<TNode>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxReplacer.cs,Replacer,The method has 6 parameters. Parameters: nodes' computeReplacementNode' tokens' computeReplacementToken' trivia' computeReplacementTrivia
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAttribute,The length of the parameter boundConstructorArgumentNamesOpt is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAttribute,The length of the parameter constructorArgumentsSourceIndices is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetRewrittenAttributeConstructorArguments,The length of the parameter constructorArgumentsSourceIndices is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCastCore,The length of the parameter originalUserDefinedConversions is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the parameter collectionInitializerAddMethodBinder is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElement,The length of the parameter collectionInitializerAddMethodBinder is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindComplexElementInitializerExpression,The length of the parameter collectionInitializerAddMethodBinder is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElementAddMethod,The length of the parameter boundElementInitializerExpressions is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElementAddMethod,The length of the parameter collectionInitializerAddMethodBinder is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FilterInaccessibleConstructors,The length of the parameter allowProtectedConstructorsOfBaseType is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsConstructorAccessible,The length of the parameter allowProtectedConstructorsOfBaseType is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,The length of the parameter allowProtectedConstructorsOfBaseType is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,The length of the parameter succeededConsideringAccessibility is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,The length of the parameter succeededIgnoringAccessibility is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAccessibleConstructorsForOverloadResolution,The length of the parameter allowProtectedConstructorsOfBaseType is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInstanceMemberAccess,The length of the parameter searchExtensionMethodsIfNecessary is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveMethodGroupInternal,The length of the parameter preferExtensionMethodResolution is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AnalyzeAnonymousFunction,The length of the parameter hasExplicitlyTypedParameterList is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAddressOfExpression,The length of the parameter isFixedStatementAddressOfExpression is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The length of the parameter originalUserDefinedConversions is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,NotFound,The length of the parameter qualifierIsCompilationGlobalNamespace is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,,The length of the parameter s_isIndexedPropertyWithNonOptionalArguments is 43.
Long Identifier,Microsoft.CodeAnalysis.CSharp,QueryTranslationState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.QueryTranslationState.cs,,The length of the parameter _nextTransparentIdentifierNumber is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetPropertyOrEventName,The length of the parameter explicitInterfaceSpecifierSyntax is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the parameter originalUserDefinedConversions is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the parameter foundMultipleGenericIEnumerableInterfaces is 41.
Long Identifier,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,SatisfiesForEachPattern,The length of the parameter currentPropertyGetterCandidate is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupExtensionMethodsInUsings,The length of the parameter seenNamespaceWithExtensionMethods is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupExtensionMethodsInUsings,The length of the parameter seenStaticClassWithExtensionMethods is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LockOrUsingBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LockOrUsingBinder.cs,,The length of the parameter _lazyLockedOrDisposedVariables is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsMemberApplicableInNormalForm,The length of the parameter constructedEffectiveParameters is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsMemberApplicableInExpandedForm,The length of the parameter constructedEffectiveParameters is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsApplicable,The length of the parameter constructedEffectiveParameters is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,Infer,The length of the parameter constructedContainingTypeOfMethod is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,MethodTypeInferrer,The length of the parameter constructedContainingTypeOfMethod is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,,The length of the parameter _constructedContainingTypeOfMethod is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,GetCustomAttributesToEmit,The length of the parameter emittingAssemblyAttributesInNetModule is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,GetCustomAttributesToEmit,The length of the parameter emittingAssemblyAttributesInNetModule is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,LoadAndValidateAttributes,The length of the parameter lazyAttributesStoredOnThisThread is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,GetAttributesToBind,The length of the parameter attributeDeclarationSyntaxLists is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,GetAttributesToBind,The length of the parameter attributeDeclarationSyntaxList is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,BoundBinaryOperator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundBinaryOperator,The length of the parameter originalUserDefinedOperatorsOpt is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,BoundUserDefinedConditionalLogicalOperator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundUserDefinedConditionalLogicalOperator,The length of the parameter originalUserDefinedOperatorsOpt is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,BoundUnaryOperator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundUnaryOperator,The length of the parameter originalUserDefinedOperatorsOpt is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,BoundIncrementOperator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundIncrementOperator,The length of the parameter originalUserDefinedOperatorsOpt is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,BoundCompoundAssignmentOperator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,BoundCompoundAssignmentOperator,The length of the parameter originalUserDefinedOperatorsOpt is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,BoundLambda,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,,The length of the parameter _inferredReturnTypeUseSiteDiagnostics is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,CompileImpl,The length of the parameter hasMethodBodyErrorOrWarningAsError is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDebuggableAttribute,The length of the parameter ignoreSymbolStoreDebuggingMode is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDebuggableAttribute,The length of the parameter disableOptimizationsDebuggingMode is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,,The length of the parameter _lazyCompilationUnitCompletedTrees is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,,The length of the parameter _wellKnownMemberSignatureComparer is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativeSymbolInfo,The length of the parameter existingConstructorInitializer is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,LookupSymbols,The length of the parameter includeReducedExtensionMethods is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,LookupSymbolsCore,The length of the parameter includeReducedExtensionMethods is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetEnclosingBinder,The length of the parameter typeOfEncounteredBeforeUnexpectedAnonymousFunction is 50.
Long Identifier,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,,The length of the parameter _declaredOrInheritedCompliance is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,DefaultVisit,The length of the parameter reportParameterOrTypeParameterDiagnostics is 41.
Long Identifier,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,TryProcessDocumentationCommentTriviaNodes,The length of the parameter reportParameterOrTypeParameterDiagnostics is 41.
Long Identifier,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,TryProcessDocumentationCommentTriviaNodes,The length of the parameter reportDiagnosticsForCurrentTrivia is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,,The length of the parameter _nextSourceIncludeElementIndex is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,,The length of the parameter _inProgressIncludeElementNodes is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The length of the parameter initializerStateMachineTypeOpt is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GenerateMethodBody,The length of the parameter stateMachineHoistedLocalScopes is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,CSharpCompilationOptions,The length of the parameter extendedCustomDebugInformation is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,WithExtendedCustomDebugInformation,The length of the parameter extendedCustomDebugInformation is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,DeclarationTable,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTable.Cache.cs,,The length of the parameter _referenceDirectiveDiagnostics is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,DeclarationTreeBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTreeBuilder.cs,,The length of the parameter _referenceDirectiveDiagnostics is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,RootSingleNamespaceDeclaration,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\RootSingleNamespaceDeclaration.cs,,The length of the parameter _referenceDirectiveDiagnostics is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,PartVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\DocumentationComments\DocumentationCommentIDVisitor.PartVisitor.cs,,The length of the parameter s_parameterOrReturnTypeInstance is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,AbstractRegionDataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\AbstractRegionDataFlowPass.cs,AbstractRegionDataFlowPass,The length of the parameter unassignedVariableAddressOfSyntaxes is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpDataFlowAnalysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowAnalysis.cs,,The length of the parameter _unassignedVariableAddressOfSyntaxes is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,DataFlowPass,The length of the parameter unassignedVariableAddressOfSyntaxes is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,DataFlowPass,The length of the parameter unassignedVariableAddressOfSyntaxes is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,,The length of the parameter _unassignedVariableAddressOfSyntaxes is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,DataFlowsInWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsInWalker.cs,DataFlowsInWalker,The length of the parameter unassignedVariableAddressOfSyntaxes is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,DataFlowsInWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsInWalker.cs,Analyze,The length of the parameter unassignedVariableAddressOfSyntaxes is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,ReadWriteWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ReadWriteWalker.cs,Analyze,The length of the parameter unassignedVariableAddressOfSyntaxes is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,ReadWriteWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ReadWriteWalker.cs,ReadWriteWalker,The length of the parameter unassignedVariableAddressOfSyntaxes is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,AsyncMethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodToStateMachineRewriter.cs,AsyncMethodToStateMachineRewriter,The length of the parameter asyncMethodBuilderMemberCollection is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp,AsyncMethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodToStateMachineRewriter.cs,,The length of the parameter _asyncMethodBuilderMemberCollection is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,GenerateMethodImplementations,The length of the parameter IAsyncStateMachine_SetStateMachine is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,GenerateStateMachineCreation,The length of the parameter methodScopeAsyncMethodBuilderMemberCollection is 45.
Long Identifier,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,,The length of the parameter _asyncMethodBuilderMemberCollection is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,IteratorFinallyMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorFinallyMethodSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,IteratorFinallyMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorFinallyMethodSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumeratorImplementation,The length of the parameter IEnumeratorOfElementType_get_Current is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumerableImplementation,The length of the parameter IEnumerableOfElementType_GetEnumerator is 38.
Long Identifier,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumerableImplementation,The length of the parameter currentManagedThreadIdProperty is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,,The length of the parameter _synthesizedFieldNameIdDispenser is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LocalRewriter,The length of the parameter allowOmissionOfConditionalCalls is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,Rewrite,The length of the parameter allowOmissionOfConditionalCalls is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSizeOfMultiplication,The length of the parameter convertedMultiplicationResultType is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitCompoundAssignmentOperator,The length of the parameter isPossibleEventHandlerOperation is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteConditionalAccess,The length of the parameter previousConditionalAccesTarget is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,,The length of the parameter _allowOmissionOfConditionalCalls is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,,The length of the parameter _currentConditionalAccessTarget is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicOperation,The length of the parameter delegateTypeOverMethodTypeParameters is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicOperation,The length of the parameter methodToContainerTypeParametersMap is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,DefineCallSiteStorageSymbol,The length of the parameter delegateTypeOverMethodTypeParameters is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,DefineCallSiteStorageSymbol,The length of the parameter methodToContainerTypeParametersMap is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,DefineCallSiteStorageSymbol,The length of the parameter delegateTypeOverContainerTypeParameters is 39.
Long Identifier,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,,The length of the parameter _currentDynamicCallSiteContainer is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,,The length of the parameter _lazyAvailableReusableHoistedFields is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddGlobalNamespace,The length of the parameter standaloneGlobalNamespaceString is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddPropertyNameAndParameters,The length of the parameter getMemberNameWithoutInterfaceName is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddNameAndTypeArgumentsOrParameters,The length of the parameter illegalGenericInstantiationSymbol is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddConstantValue,The length of the parameter preferNumericValueOrExpandedFlagsForEnum is 40.
Long Identifier,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreatePEAssemblyForAssemblyMetadata,The length of the parameter referencedAssembliesByIdentity is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,SetupReferencesForRetargetingAssembly,The length of the parameter underlyingReferencedAssemblySymbols is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,SetupReferencesForFileAssembly,The length of the parameter portableExecutableAssemblySymbol is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp,AssemblyDataForFile,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,,The length of the parameter _internalsPotentiallyVisibleToCompilation is 41.
Long Identifier,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxTree,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxTree.cs,,The length of the parameter _preprocessorStateChangePositions is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeConstructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypePropertyGetAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeEqualsMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeGetHashCodeMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeToStringMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedSealedPropertyAccessor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedSealedPropertyAccessor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeClassInterfaceAttribute,The length of the parameter attributeArgumentSyntaxLocation is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeGuidAttribute,The length of the parameter attributeArgumentSyntaxLocation is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,ShouldEmitAttribute,The length of the parameter emittingAssemblyAttributesInNetModule is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,FieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\FieldSymbolAdapter.cs,GetConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\MethodSymbolAdapter.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\MethodSymbolAdapter.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\SynthesizedSymbols\AnonymousType.FieldSymbol.cs,GetConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedMethodBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\SynthesizedSymbols\AnonymousType.SynthesizedMethodBase.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,GetTypeByMetadataName,The length of the parameter useCLSCompliantNameArityEncoding is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\SourceAttributeData.cs,SourceAttributeData,The length of the parameter constructorArgumentsSourceIndices is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\SourceAttributeData.cs,,The length of the parameter _constructorArgumentsSourceIndices is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ConstantValueUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstantValueUtils.cs,EvaluateFieldConstant,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,,The length of the parameter s_checkConstraintsSingleTypeFunc is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ErrorMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ErrorMethodSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ErrorMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ErrorMethodSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,MemberSignatureComparer,The length of the parameter considerExplicitlyImplementedInterfaces is 39.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,Equals,The length of the parameter explicitInterfaceImplementations1 is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,Equals,The length of the parameter explicitInterfaceImplementations2 is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,,The length of the parameter ExplicitImplementationComparer is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,,The length of the parameter CSharpImplicitImplementationComparer is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,,The length of the parameter CSharpCloseImplicitImplementationComparer is 41.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,,The length of the parameter CSharpAccessorOverrideComparer is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,,The length of the parameter CSharpCustomModifierOverrideComparer is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,,The length of the parameter RuntimePlusRefOutSignatureComparer is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,,The length of the parameter RuntimeImplicitImplementationComparer is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,,The length of the parameter CSharpSignatureAndConstraintsAndReturnTypeComparer is 50.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,,The length of the parameter RetargetedExplicitImplementationComparer is 40.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,,The length of the parameter LambdaReturnInferenceCacheComparer is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,,The length of the parameter _considerExplicitlyImplementedInterfaces is 40.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MetadataOrSourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MetadataOrSourceAssemblySymbol.cs,,The length of the parameter _assembliesToWhichInternalAccessHasBeenAnalyzed is 47.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MissingModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MissingModuleSymbol.cs,SetReferences,The length of the parameter originatingSourceAssemblyDebugOnly is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ModuleSymbol.cs,SetReferences,The length of the parameter originatingSourceAssemblyDebugOnly is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,NonMissingModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\NonMissingModuleSymbol.cs,SetReferences,The length of the parameter originatingSourceAssemblyDebugOnly is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindRelatedMembers,The length of the parameter overridingMemberIsFromSomeCompilation is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindOtherOverriddenMethodsInContainingType,The length of the parameter overridingMemberIsFromSomeCompilation is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindOtherOverriddenMethodsInContainingType,The length of the parameter representativeCustomModifierCount is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,GetFirstRuntimeOverriddenMethodIgnoringNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,PEPropertyOrEventHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\PropertyOrEventSymbolExtensions.cs,GetSymbolsForExplicitlyImplementedAccessor,The length of the parameter symbolsForExplicitlyImplementedAccessors is 40.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ReducedExtensionMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReducedExtensionMethodSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ReducedExtensionMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReducedExtensionMethodSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SignatureOnlyMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SignatureOnlyMethodSymbol.cs,SignatureOnlyMethodSymbol,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SignatureOnlyMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SignatureOnlyMethodSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SignatureOnlyMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SignatureOnlyMethodSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SignatureOnlyMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SignatureOnlyMethodSymbol.cs,,The length of the parameter _explicitInterfaceImplementations is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SignatureOnlyPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SignatureOnlyPropertySymbol.cs,SignatureOnlyPropertySymbol,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SignatureOnlyPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SignatureOnlyPropertySymbol.cs,,The length of the parameter _explicitInterfaceImplementations is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ConstantEvaluationHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ConstantEvaluationHelpers.cs,OrderAllDependencies,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ConstantEvaluationHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ConstantEvaluationHelpers.cs,CreateGraph,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,GetMemberName,The length of the parameter discardedExplicitInterfaceType is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,SubstituteExplicitInterfaceImplementations,The length of the parameter unsubstitutedExplicitInterfaceImplementations is 45.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedMethod,The length of the parameter explicitInterfaceSpecifierSyntax is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedProperty,The length of the parameter explicitInterfaceSpecifierSyntax is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedEvent,The length of the parameter explicitInterfaceSpecifierSyntax is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedMember,The length of the parameter explicitInterfaceSpecifierSyntax is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitImplementationCollisions,The length of the parameter explicitInterfaceTypeIsDefinition is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,LambdaSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\LambdaSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,LambdaSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\LambdaSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,LambdaSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\LambdaSymbol.cs,MakeParameters,The length of the parameter hasExplicitlyTypedParameterList is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForSynthesizedAttributes,The length of the parameter compilationRelaxationsAttribute is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the parameter assemblyDelaySignAttributeSetting is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the parameter assemblyKeyContainerAttributeSetting is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the parameter assemblyKeyFileAttributeSetting is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,GetNetModuleAttributes,The length of the parameter moduleAssemblyAttributesBuilder is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the parameter emitCompilationRelaxationsAttribute is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the parameter typedConstantNoStringInterning is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the parameter emitRuntimeCompatibilityAttribute is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AreInternalsVisibleToThisAssembly,The length of the parameter assemblyWhoseKeysAreBeingComputed is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the parameter attributeArgumentSyntaxLocation is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the parameter attributeArgumentSyntaxLocation is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the parameter attributeArgumentSyntaxLocation is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ValidateIntegralAttributeNonNegativeArguments,The length of the parameter attributeArgumentSyntaxLocation is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,,The length of the parameter TypesReferencedInExternalMethods is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,,The length of the parameter _optimisticallyGrantedInternalsAccess is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,,The length of the parameter t_assemblyForWhichCurrentThreadIsComputingKeys is 46.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,,The length of the parameter _hasByRefBeforeCustomModifiers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceCustomEventAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceCustomEventAccessorSymbol.cs,,The length of the parameter _explicitInterfaceImplementations is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceCustomEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceCustomEventSymbol.cs,,The length of the parameter _explicitInterfaceImplementations is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,InvokeMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceDelegateMethodSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,InvokeMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceDelegateMethodSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceDestructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceDestructorSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceDestructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceDestructorSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ZeroValuedEnumConstantSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEnumConstantSymbol.cs,MakeConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitValuedEnumConstantSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEnumConstantSymbol.cs,MakeConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,ImplicitValuedEnumConstantSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEnumConstantSymbol.cs,MakeConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,MakeModifiers,The length of the parameter explicitInterfaceImplementation is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,ComputeIsWindowsRuntimeEvent,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,,The length of the parameter _lazyOverriddenOrHiddenMembers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbolWithSyntaxReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,GetConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbolWithSyntaxReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,GetConstantValueDependencies,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbolWithSyntaxReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,BindConstantValueIfNecessary,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbolWithSyntaxReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,GetLazyConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbolWithSyntaxReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,SetLazyConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbolWithSyntaxReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,MakeConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbolWithSyntaxReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,,The length of the parameter _lazyConstantEarlyDecodingValue is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,NoteFieldDefinitions,The length of the parameter containerEffectiveAccessibility is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,AddSynthesizedConstructorsIfNecessary,The length of the parameter hasParameterlessInstanceConstructor is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,The length of the parameter hasImportedBaseTypeDeclaringInterface is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,The length of the parameter implementingMemberAndDiagnostics is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The length of the parameter leastOverriddenMemberIsObsolete is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,SynthesizeInterfaceMemberImplementation,The length of the parameter implementingMemberAndDiagnostics is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,SynthesizeInterfaceMemberImplementation,The length of the parameter implementingMethodOriginalDefinition is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,SynthesizeInterfaceMemberImplementation,The length of the parameter sourceImplementMethodOriginalDefinition is 39.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,,The length of the parameter _lazyEarlyAttributeDecodingMembersDictionary is 44.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,,The length of the parameter _lazySynthesizedExplicitImplementations is 39.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,Flags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,Flags,The length of the parameter isMetadataVirtualIgnoringModifiers is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,Flags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,Flags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,,The length of the parameter IsMetadataVirtualIgnoringInterfaceChangesBit is 44.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MembersAndInitializers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MembersAndInitializers,The length of the parameter staticInitializersSyntaxLength is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MembersAndInitializers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MembersAndInitializers,The length of the parameter instanceInitializersSyntaxLength is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MembersAndInitializers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,,The length of the parameter StaticInitializersSyntaxLength is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,MembersAndInitializers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,,The length of the parameter InstanceInitializersSyntaxLength is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberFieldSymbol.cs,MakeConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,CheckModifiers,The length of the parameter partialMethodInvalidModifierMask is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,,The length of the parameter _lazyExplicitInterfaceImplementations is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,,The length of the parameter _lazyReturnTypeCustomModifiers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,MakeFlags,The length of the parameter isMetadataVirtualIgnoringModifiers is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,,The length of the parameter _lazyReturnTypeCustomAttributesBag is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,,The length of the parameter _lazyOverriddenOrHiddenMembers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceModuleSymbol.cs,ValidateLinkedAssemblies,The length of the parameter hasImportedFromTypeLibOrPrimaryInteropAssemblyAttribute is 55.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceModuleSymbol.cs,,The length of the parameter _lazyAssembliesToEmbedTypesFrom is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceModuleSymbol.cs,,The length of the parameter _lazyContainsExplicitDefinitionOfNoPiaLocalTypes is 48.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,MakeOneDeclaredBases,The length of the parameter baseTypeIsErrorWithoutInterfaceGuess is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,,The length of the parameter _lazyIsExplicitDefinitionOfNoPiaLocalType is 41.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamespaceSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol.cs,,The length of the parameter s_declaringSyntaxReferencesSelector is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,CreateAccessorSymbol,The length of the parameter explicitlyImplementedPropertyOpt is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,CreateAccessorSymbol,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,CreateAccessorSymbol,The length of the parameter explicitlyImplementedPropertyOpt is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,CreateAccessorSymbol,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,GetNameAndExplicitInterfaceImplementations,The length of the parameter explicitlyImplementedPropertyOpt is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,GetNameAndExplicitInterfaceImplementations,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,SourcePropertyAccessorSymbol,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,SourcePropertyAccessorSymbol,The length of the parameter explicitInterfaceImplementations is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,CheckModifiers,The length of the parameter isAutoPropertyOrExpressionBodied is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,,The length of the parameter _lazyReturnTypeCustomModifiers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,,The length of the parameter _explicitInterfaceImplementations is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,MakeModifiers,The length of the parameter isExplicitInterfaceImplementation is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,CreateAccessorSymbol,The length of the parameter explicitlyImplementedPropertyOpt is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,,The length of the parameter _explicitInterfaceImplementations is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,,The length of the parameter _lazyOverriddenOrHiddenMembers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,,The length of the parameter _lazySynthesizedSealedAccessor is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedEventSymbol.cs,,The length of the parameter _lazyExplicitInterfaceImplementations is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedEventSymbol.cs,,The length of the parameter _lazyOverriddenOrHiddenMembers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedFieldSymbol.cs,GetConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedMethodSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedMethodSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedMethodSymbol.cs,,The length of the parameter _lazyExplicitInterfaceImplementations is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedMethodSymbol.cs,,The length of the parameter _lazyOverriddenOrHiddenMembers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedPropertySymbol.cs,,The length of the parameter _lazyExplicitInterfaceImplementations is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedPropertySymbol.cs,,The length of the parameter _lazyOverriddenOrHiddenMembers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedEntryPointSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedEntryPointSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedEntryPointSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedEntryPointSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedFieldSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedFieldSymbolBase.cs,GetConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedGlobalMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedGlobalMethodSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedGlobalMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedGlobalMethodSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedInstanceConstructor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedInstanceConstructor.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedInstanceConstructor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedInstanceConstructor.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedIntrinsicOperatorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedIntrinsicOperatorSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedIntrinsicOperatorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedIntrinsicOperatorSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedImplementationMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedImplementationMethod.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedImplementationMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedImplementationMethod.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedImplementationMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedImplementationMethod.cs,,The length of the parameter _explicitInterfaceImplementations is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedStaticConstructor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedStaticConstructor.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedStaticConstructor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedStaticConstructor.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ComputeImplementationAndDiagnosticsForInterfaceMember,The length of the parameter implementingMemberAndDiagnostics is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ComputeImplementationForInterfaceMember,The length of the parameter implementingTypeIsFromSomeCompilation is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,CheckForImplementationOfCorrespondingPropertyOrEvent,The length of the parameter implementingTypeIsFromSomeCompilation is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,CheckForImplementationOfCorrespondingPropertyOrEvent,The length of the parameter associatedInterfacePropertyOrEvent is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,CheckForImplementationOfCorrespondingPropertyOrEvent,The length of the parameter correspondingImplementingAccessor is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,CheckForImplementationOfCorrespondingPropertyOrEvent,The length of the parameter interfaceAccessorWithImplementationName is 39.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,FindPotentialImplicitImplementationMemberDeclaredInType,The length of the parameter implementingTypeIsFromSomeCompilation is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,IsInterfaceMemberImplementation,The length of the parameter implementingTypeIsFromSomeCompilation is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,InterfaceInfo,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,,The length of the parameter interfacesAndTheirBaseInterfaces is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,InterfaceInfo,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,,The length of the parameter implementationForInterfaceMemberMap is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,InterfaceInfo,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,,The length of the parameter explicitInterfaceImplementationMap is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,,The length of the parameter s_containsTypeParameterPredicate is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,,The length of the parameter s_isTypeParameterWithSpecificContainerPredicate is 47.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Emit,EmitHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\EmitHelpers.cs,MapToCompilation,The length of the parameter matcherWithAllSynthesizedMembers is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,,The length of the parameter AssemblyOrModuleSymbolToModuleRefMap is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedType,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedType.cs,,The length of the parameter _embeddedAllMembersOfImplementedInterface is 41.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,,The length of the parameter MAX_DIRECTIVE_IDENTIFIER_WIDTH is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseXmlComment,The length of the parameter lessThanExclamationMinusMinusToken is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseXmlProcessingInstruction,The length of the parameter startProcessingInstructionToken is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseCrefName,The length of the parameter typeArgumentsMustBeIdentifiers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseCrefType,The length of the parameter typeArgumentsMustBeIdentifiers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseCrefTypeHelper,The length of the parameter typeArgumentsMustBeIdentifiers is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseCrefTypeSuffix,The length of the parameter omittedArraySizeExpressionInstance is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseArrayRankSpecifier,The length of the parameter omittedArraySizeExpressionInstance is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,,The length of the parameter _createWhitespaceTriviaFunction is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxToken,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.cs,,The length of the parameter s_tokensWithSingleTrailingSpace is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxToken,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.cs,,The length of the parameter s_tokensWithSingleTrailingCRLF is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,DynamicTypeDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\DynamicTypeDecoder.cs,TransformType,The length of the parameter targetSymbolCustomModifierCount is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,DynamicTypeDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\DynamicTypeDecoder.cs,TransformTypeInternal,The length of the parameter targetSymbolCustomModifierCount is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEFieldSymbol.cs,GetConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,,The length of the parameter _lazyConditionalAttributeSymbols is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,,The length of the parameter _lazyExplicitMethodImplementations is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,,The length of the parameter _lazyOverriddenOrHiddenMembersResult is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PackedFlags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,,The length of the parameter IsExtensionMethodIsPopulatedBit is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PackedFlags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,,The length of the parameter IsExplicitFinalizerOverrideBit is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PackedFlags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,,The length of the parameter IsExplicitOverrideIsPopulatedBit is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PackedFlags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,,The length of the parameter WellKnownAttributeCompletionFlagOffset is 38.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PackedFlags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,,The length of the parameter WellKnownAttributeCompletionFlagMask is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PackedFlags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,,The length of the parameter HasByRefBeforeCustomModifiersBit is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PackedFlags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,,The length of the parameter AllWellKnownAttributesCompleteNoData is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,GetAssemblyAttributes,The length of the parameter moduleAssemblyAttributesBuilder is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,GetAssemblyAttributes,The length of the parameter typerefAssemblyAttributesGoHere is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,OnNewTypeDeclarationsLoaded,The length of the parameter keepLookingForDeclaredCorTypes is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,,The length of the parameter _lazyEventRegistrationTokenSymbol is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,,The length of the parameter _lazyEventRegistrationTokenTableSymbol is 38.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,,The length of the parameter _lazyMembersInDeclarationOrder is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,UncommonProperties,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,,The length of the parameter lazyConditionalAttributeSymbols is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEParameterSymbol.cs,GetAttributes,The length of the parameter filterOutConstantAttributeDescription is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,SymbolFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\SymbolFactory.cs,SubstituteTypeParameters,The length of the parameter noPiaIllegalGenericInstantiation is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\RetargetingAttributeData.cs,RetargetingAttributeData,The length of the parameter constructorArgumentsSourceIndices is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingEventSymbol.cs,,The length of the parameter _lazyExplicitInterfaceImplementations is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingFieldSymbol.cs,GetConstantValue,The length of the parameter earlyDecodingWellKnownAttributes is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingMethodSymbol.cs,IsMetadataVirtual,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingMethodSymbol.cs,IsMetadataNewSlot,The length of the parameter ignoreInterfaceImplementationChanges is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingMethodSymbol.cs,,The length of the parameter _lazyReturnTypeCustomAttributes is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingMethodSymbol.cs,,The length of the parameter _lazyExplicitInterfaceImplementations is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingModuleSymbol.cs,SetReferences,The length of the parameter originatingSourceAssemblyDebugOnly is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingModuleSymbol.cs,,The length of the parameter _createRetargetingTypeParameter is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingPropertySymbol.cs,,The length of the parameter _lazyExplicitInterfaceImplementations is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,Retarget,The length of the parameter noPiaIllegalGenericInstantiation is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax,CSharpPragmaWarningStateMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpPragmaWarningStateMap.cs,CreatePragmaWarningStateEntries,The length of the parameter accumulatedGeneralWarningState is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Syntax,CSharpPragmaWarningStateMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpPragmaWarningStateMap.cs,CreatePragmaWarningStateEntries,The length of the parameter accumulatedSpecificWarningState is 31.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDiagnosticsIfObsolete,The length of the statement  "                    ReportDiagnosticsIfObsolete(diagnostics' symbol' node' hasBaseReceiver' this.ContainingMemberOrLambda' this.ContainingType' this.Flags); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDiagnosticsIfObsolete,The length of the statement  "            ThreeState reportedOnOverridden = ReportDiagnosticsIfObsoleteInternal(diagnostics' leastOverriddenSymbol' node' containingMember' location); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDiagnosticsIfObsolete,The length of the statement  "            // CONSIDER: In place of hasBaseReceiver' dev11 also accepts cases where symbol.ContainingType is a "simple type" (e.g. int) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDiagnosticsIfObsolete,The length of the statement  "            // or a special by-ref type (e.g. ArgumentHandle).  These cases are probably more important for other checks performed by " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDiagnosticsIfObsolete,The length of the statement  "            // don't make much sense for ObsoleteAttribute (e.g. this would seem to address the case where int.ToString has been made " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsSymbolAccessibleConditional,The length of the statement  "            return AccessCheck.IsSymbolAccessible(symbol' within' throughTypeOpt' out failedThroughTypeCheck' ref useSiteDiagnostics' basesBeingResolved); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForSynthesizedAttribute,The length of the statement  "            // (comes from an unified assembly). When the symbol is not found no error is reported. See test VersionUnification_UseSiteDiagnostics_OptionalAttributes. " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAnonymousObjectCreation,The length of the statement  "                fieldSyntaxNodes[i] = (nameToken.Kind() == SyntaxKind.IdentifierToken) ? (CSharpSyntaxNode)nameToken.Parent : fieldInitializer; " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAnonymousObjectCreation,The length of the statement  "                fields[i] = new AnonymousTypeField(fieldName == null ? "$" + i.ToString() : fieldName' fieldSyntaxNodes[i].Location' fieldType); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAnonymousObjectCreation,The length of the statement  "            AnonymousTypeDescriptor descriptor = new AnonymousTypeDescriptor(fields.AsImmutableOrNull()' node.NewKeyword.GetLocation()); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAttributeTypes,The length of the statement  "                    // When looking up a name in attribute type context' we generate a diagnostic + error type if it is not an attribute type' i.e. named type deriving from System.Attribute. " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAttributes,The length of the statement  "                    // its value depends on the values of conditional symbols' which in turn depends on the source file where the attribute is applied. " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAttributes,The length of the statement  "                    bool isConditionallyOmitted = binder.IsAttributeConditionallyOmitted(attribute.AttributeClass' attributeSyntax.SyntaxTree' ref useSiteDiagnostics); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAttribute,The length of the statement  "            AnalyzedAttributeArguments analyzedArguments = attributeArgumentBinder.BindAttributeArguments(argumentListOpt' attributeTypeForBinding' diagnostics); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAttribute,The length of the statement  "                BindAttributeConstructor(node' attributeTypeForBinding' analyzedArguments.ConstructorArguments' diagnostics' ref resultKind' suppressErrors: attributeType.IsErrorType()' useSiteDiagnostics: ref useSiteDiagnostics); " is 214.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAttribute,The length of the statement  "            ValidateTypeForAttributeParameters(attributeConstructor.Parameters' ((AttributeSyntax)boundAttribute.Syntax).Name' diagnostics' ref hasErrors); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAttribute,The length of the statement  "                constructorArguments = GetRewrittenAttributeConstructorArguments(out constructorArgumentsSourceIndices' attributeConstructor' " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAttribute,The length of the statement  "                    constructorArgsArray' boundAttribute.ConstructorArgumentNamesOpt' (AttributeSyntax)boundAttribute.Syntax' diagnostics' ref hasErrors); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAttribute,The length of the statement  "            bool isConditionallyOmitted = IsAttributeConditionallyOmitted(attributeType' boundAttribute.SyntaxTree' ref useSiteDiagnostics); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAttribute,The length of the statement  "            return new SourceAttributeData(boundAttribute.Syntax.GetReference()' attributeType' attributeConstructor' constructorArguments' constructorArgumentsSourceIndices' namedArguments' hasErrors' isConditionallyOmitted); " is 214.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsAttributeConditionallyOmitted,The length of the statement  "            // When early binding attributes' we don't want to determine if the attribute type is conditional and if so' must be emitted or not. " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsAttributeConditionallyOmitted,The length of the statement  "            // Invoking IsConditional property on attributeType can lead to a cycle' hence we delay this computation until after early binding. " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNamedAttributeArgument,The length of the statement  "            Symbol namedArgumentNameSymbol = BindNamedAttributeArgumentName(namedArgument' attributeType' diagnostics' out wasError' out resultKind); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNamedAttributeArgument,The length of the statement  "            // BindRValue just binds the expression without doing any validation (if its a valid expression for attribute argument). " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetRewrittenAttributeConstructorArguments,The length of the statement  "                    reorderedArgument = GetParamArrayArgument(parameter' constructorArgsArray' argumentsCount' argsConsumedCount' this.Conversions); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetRewrittenAttributeConstructorArguments,The length of the statement  "                            constructorArgumentNamesOpt' parameter' firstNamedArgIndex' argumentsCount' ref argsConsumedCount' syntax' diagnostics); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetRewrittenAttributeConstructorArguments,The length of the statement  "                    else if (reorderedArgument.Kind == TypedConstantKind.Array && parameter.Type.TypeKind == TypeKind.Array && (TypeSymbol)reorderedArgument.Type != parameter.Type) " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetRewrittenAttributeConstructorArguments,The length of the statement  "            constructorArgumentsSourceIndices = sourceIndices != null ? sourceIndices.AsImmutableOrNull() : default(ImmutableArray<int>); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetMatchingNamedOrOptionalConstructorArgument,The length of the statement  "            int index = GetMatchingNamedConstructorArgumentIndex(parameter.Name' constructorArgumentNamesOpt' startIndex' argumentsCount); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetDefaultValueArgument,The length of the statement  "            else if (!IsEarlyAttributeBinder && parameter.IsCallerMemberName && (object)((ContextualAttributeBinder)this).AttributedMember != null) " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetDefaultValueArgument,The length of the statement  "                // For example' the attribute constructor with signature: M([Optional] int x)' has no default value from syntax or attributes. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetDefaultValueArgument,The length of the statement  "                // Native compiler treats "M([Optional] object x)" equivalent to "M(object x)" for attributes if parameter type is System.Object. " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetDefaultValueArgument,The length of the statement  "                // We generate a better diagnostic for this case by treating "x" in the above case as optional' but generating CS7067 instead. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetDefaultValueArgument,The length of the statement  "                // error CS1763: '{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetParamArrayArgument,The length of the statement  "                Conversion conversion = conversions.ClassifyConversion(argumentType' parameter.Type' ref useSiteDiagnostics' builtinOnly: true); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetGetAwaiterMethod,The length of the statement  "            var getAwaiterCall = MakeInvocationExpression(node' expression' WellKnownMemberNames.GetAwaiter' ImmutableArray<BoundExpression>.Empty' diagnostics); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetGetAwaiterMethod,The length of the statement  "                HasOptionalOrVariableParameters(getAwaiterMethod) || // We might have been able to resolve a GetAwaiter overload with optional parameters' so check for that here " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetIsCompletedProperty,The length of the statement  "            var qualified = BindInstanceMemberAccess(node' node' receiver' name' 0' default(SeparatedSyntaxList<TypeSyntax>)' default(ImmutableArray<TypeSymbol>)' false' diagnostics); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AwaiterImplementsINotifyCompletion,The length of the statement  "            var INotifyCompletion = GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_INotifyCompletion' diagnostics' node); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetGetResultMethod,The length of the statement  "            var getResultCall = MakeInvocationExpression(node' receiver' WellKnownMemberNames.GetResult' ImmutableArray<BoundExpression>.Empty' diagnostics); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindTypeParameterConstraintClauses,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_TyVarNotFoundInConstraint' clause.Name.Location' name' containingSymbol.ConstructedFrom()); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsValidConstraintType,The length of the statement  "                    // "'{0}' is not a valid constraint. A type used as a constraint must be an interface' a non-sealed class or a type parameter." " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateConversion,The length of the statement  "            return CreateConversion(source.Syntax' source' conversion' isCast: false' destination: destination' diagnostics: diagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateConversion,The length of the statement  "            return CreateConversion(source.Syntax' source' conversion' isCast: false' destination: destination' diagnostics: diagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateUserDefinedConversion,The length of the statement  "                    conversion: Conversions.ClassifyStandardConversion(null' convertedOperand.Type' conversionParameterType' ref useSiteDiagnostics)' " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateUserDefinedConversion,The length of the statement  "                        conversion: Conversions.ClassifyStandardConversion(null' conversionReturnType' conversion.BestUserDefinedConversionAnalysis.ToType' ref useSiteDiagnostics)' " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateMethodGroupConversion,The length of the statement  "            if (MethodGroupConversionHasErrors(syntax' conversion' group.ReceiverOpt' conversion.IsExtensionMethod' delegateType' diagnostics)) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateMethodGroupConversion,The length of the statement  "            return new BoundConversion(syntax' group' conversion' @checked: false' explicitCastInCode: isCast' constantValueOpt: ConstantValue.NotAvailable' type: destination' hasErrors: hasErrors) { WasCompilerGenerated = source.WasCompilerGenerated }; " is 241.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FixMethodGroupWithTypeOrValue,The length of the statement  "            receiverOpt = ReplaceTypeOrValueReceiver(receiverOpt' conversion.Method.IsStatic && !conversion.IsExtensionMethod' diagnostics); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MemberGroupFinalValidation,The length of the statement  "            if (MemberGroupFinalValidationAccessibilityChecks(receiverOpt' methodSymbol' node' diagnostics' invokedAsExtensionMethod)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MemberGroupFinalValidation,The length of the statement  "            // SPEC: If the best method is a generic method' the type arguments (supplied or inferred) are checked against the constraints  " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MemberGroupFinalValidationAccessibilityChecks,The length of the statement  "            Debug.Assert(memberSymbol.Kind != SymbolKind.Method || memberSymbol.CanBeReferencedByName); //should be true since the caller has LookupOptions.MustBeReferenceableByName set " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MemberGroupFinalValidationAccessibilityChecks,The length of the statement  "            //note that the same assert does not hold for all properties. Some properties and (all indexers) are not referenceable by name' yet " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MemberGroupFinalValidationAccessibilityChecks,The length of the statement  "                // TypeOrValue expression isn't replaced only if the invocation is late bound' in which case it can't be extension method. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MemberGroupFinalValidationAccessibilityChecks,The length of the statement  "                if (!invokedAsExtensionMethod && !WasImplicitReceiver(receiverOpt) && IsMemberAccessedThroughVariableOrValue(receiverOpt)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MemberGroupFinalValidationAccessibilityChecks,The length of the statement  "                bool isAccessible = this.IsSymbolAccessibleConditional(memberSymbol.GetTypeOrReturnType()' containingType' ref useSiteDiagnostics); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MethodGroupIsCompatibleWithDelegate,The length of the statement  "                (Conversions.ConvertExtensionMethodThisArg(methodParameters[0].Type' receiverOpt.Type' ref useSiteDiagnostics).Exists && useSiteDiagnostics.IsNullOrEmpty())); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MethodGroupIsCompatibleWithDelegate,The length of the statement  "                if (!Conversions.HasIdentityOrImplicitReferenceConversion(delegateParameterType' methodParameterType' ref useSiteDiagnostics)) " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MethodGroupIsCompatibleWithDelegate,The length of the statement  "                Conversions.HasIdentityOrImplicitReferenceConversion(method.ReturnType' delegateMethod.ReturnType' ref useSiteDiagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MethodGroupConversionHasErrors,The length of the statement  "                !MethodGroupIsCompatibleWithDelegate(receiverOpt' isExtensionMethod' selectedMethod' delegateType' syntax.Location' diagnostics)) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MethodGroupConversionDoesNotExistOrHasErrors,The length of the statement  "                return this.MethodGroupConversionHasErrors(boundMethodGroup.Syntax' conversion' boundMethodGroup.ReceiverOpt' conversion.IsExtensionMethod' delegateType' diagnostics); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The length of the statement  "                            case SpecialType.System_Decimal: return (value.Discriminator == ConstantValueTypeDiscriminator.Single) ? (decimal)(float)doubleValue : (decimal)doubleValue; " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckConstantBounds,The length of the statement  "                case SpecialType.System_Decimal: return ((double)decimal.MinValue - 1D) < value && value < ((double)decimal.MaxValue + 1D); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCref,The length of the statement  "            Debug.Assert((symbols.Length > 1) == ((object)ambiguityWinner != null)' "ambiguityWinner should be set iff more than one symbol is returned."); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCrefInternal,The length of the statement  "                    return BindMemberCref((MemberCrefSyntax)syntax' containerOpt: null' ambiguityWinner: out ambiguityWinner' diagnostics: diagnostics); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberCref,The length of the statement  "                    result = BindConversionOperatorMemberCref((ConversionOperatorMemberCrefSyntax)syntax' containerOpt' out ambiguityWinner' diagnostics); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNameMemberCref,The length of the statement  "            ImmutableArray<Symbol> sortedSymbols = ComputeSortedCrefMembers(syntax' containerOpt' memberName' arity' syntax.Parameters != null' diagnostics); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexerMemberCref,The length of the statement  "            ImmutableArray<Symbol> sortedSymbols = ComputeSortedCrefMembers(syntax' containerOpt' WellKnownMemberNames.Indexer' arity' syntax.Parameters != null' diagnostics); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindOperatorMemberCref,The length of the statement  "            ImmutableArray<Symbol> sortedSymbols = ComputeSortedCrefMembers(syntax' containerOpt' memberName' arity' syntax.Parameters != null' diagnostics); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConversionOperatorMemberCref,The length of the statement  "            ImmutableArray<Symbol> sortedSymbols = ComputeSortedCrefMembers(syntax' containerOpt' memberName' arity' syntax.Parameters != null' diagnostics); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ComputeSortedCrefMembers,The length of the statement  "                            if (containerType.Name == memberName && (hasParameterList || containerType.Arity == 0 || this.ContainingType != containerType.OriginalDefinition)) " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ProcessCrefMemberLookupResults,The length of the statement  "                return ProcessParameterlessCrefMemberLookupResults(symbols' arity' memberSyntax' typeArgumentListSyntax' out ambiguityWinner' diagnostics); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ProcessCrefMemberLookupResults,The length of the statement  "            ImmutableArray<Symbol> results = PerformCrefOverloadResolution(candidates' parameterSymbols' arity' memberSyntax' out ambiguityWinner' diagnostics); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ProcessParameterlessCrefMemberLookupResults,The length of the statement  "                    diagnostics.Add(ErrorCode.WRN_AmbiguousXMLReference' crefSyntax.Location' crefSyntax.ToString()' symbol' symbols[otherIndex]); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,PerformCrefOverloadResolution,The length of the statement  "                                callingConvention: candidateMethodIsVararg ? Microsoft.Cci.CallingConvention.ExtraArguments : Microsoft.Cci.CallingConvention.HasThis' " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,PerformCrefOverloadResolution,The length of the statement  "                    Debug.Assert(candidate.GetMemberArity() != 0 || candidate.Name == WellKnownMemberNames.InstanceConstructorName || arity == 0' " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,PerformCrefOverloadResolution,The length of the statement  "                diagnostics.Add(ErrorCode.WRN_AmbiguousXMLReference' crefSyntax.Location' crefSyntax.ToString()' ambiguityWinner' viable[1]); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ConstructWithCrefTypeParameters,The length of the statement  "                    Debug.Assert(typeArgumentSyntax.ContainsDiagnostics || !typeArgumentSyntax.SyntaxTree.ReportDocumentationCommentDiagnostics() || " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCrefParameters,The length of the statement  "            ArrayBuilder<ParameterSymbol> parameterBuilder = ArrayBuilder<ParameterSymbol>.GetInstance(parameterListSyntax.Parameters.Count); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCrefParameters,The length of the statement  "                TypeSymbol type = BindCrefParameterOrReturnType(parameter.Type' (MemberCrefSyntax)parameterListSyntax.Parent' diagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCrefParameters,The length of the statement  "                parameterBuilder.Add(new SignatureOnlyParameterSymbol(type' ImmutableArray<CustomModifier>.Empty' isParams: false' refKind: refKind)); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCrefParameterOrReturnType,The length of the statement  "                Debug.Assert(type.TypeKind != TypeKind.Error || typeSyntax.ContainsDiagnostics || !typeSyntax.SyntaxTree.ReportDocumentationCommentDiagnostics()' "Why wasn't there a diagnostic?"); " is 180.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,HasThis,The length of the statement  "                inStaticContext = member.Kind == SymbolKind.Field || member.Kind == SymbolKind.Method || member.Kind == SymbolKind.Property; " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateBinderForParameterDefaultValue,The length of the statement  "            return new LocalScopeBinder(this.WithContainingMemberOrLambda(parameter.ContainingSymbol).WithAdditionalFlags(BinderFlags.ParameterDefaultValue)); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExpressionInternal,The length of the statement  "                    return BindUnexpectedArrayInitializer((InitializerExpressionSyntax)node' diagnostics' ErrorCode.ERR_ArrayInitInBadPlace); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExpressionInternal,The length of the statement  "                    return BindIncrementOperator(node' ((PostfixUnaryExpressionSyntax)node).Operand' ((PostfixUnaryExpressionSyntax)node).OperatorToken' diagnostics); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExpressionInternal,The length of the statement  "                    return BindIncrementOperator(node' ((PrefixUnaryExpressionSyntax)node).Operand' ((PrefixUnaryExpressionSyntax)node).OperatorToken' diagnostics); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindRefValue,The length of the statement  "            Conversion conversion = this.Conversions.ClassifyConversionFromExpression(argument' typedReferenceType' ref useSiteDiagnostics); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindRefType,The length of the statement  "            Conversion conversion = this.Conversions.ClassifyConversionFromExpression(argument' typedReferenceType' ref useSiteDiagnostics); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArgList,The length of the statement  "                    // CS4013: Instance of type '{0}' cannot be used inside an anonymous function' query expression' iterator block or async method " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindQualifiedName,The length of the statement  "            return BindMemberAccessWithBoundLeft(node' this.BindExpression(node.Left' diagnostics)' node.Right' node.DotToken' invoked: false' indexed: false' diagnostics: diagnostics); " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindTypeOf,The length of the statement  "            return new BoundTypeOfOperator(node' boundType' null' this.GetWellKnownType(WellKnownType.System_Type' diagnostics' node)' hasError); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIdentifier,The length of the statement  "            this.LookupSymbolsWithFallback(lookupResult' node.Identifier.ValueText' arity: arity' useSiteDiagnostics: ref useSiteDiagnostics' options: options); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIdentifier,The length of the statement  "                Symbol symbol = GetSymbolOrMethodOrPropertyGroup(lookupResult' node' node.Identifier.ValueText' node.Arity' members' diagnostics' out wasError);  // reports diagnostics in result. " is 179.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIdentifier,The length of the statement  "                        symbol = ConstructNamedTypeUnlessTypeArgumentOmitted(node' (NamedTypeSymbol)symbol' typeArgumentList' typeArguments' diagnostics); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNonMethod,The length of the statement  "                            type = new ExtendedErrorTypeSymbol(this.Compilation' name: "var"' arity: 0' errorInfo: null' variableUsedBeforeDeclaration: true); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,SynthesizeReceiver,The length of the statement  "            if (currentType.IsEqualToOrDerivedFrom(member.ContainingType' ignoreDynamic: false' useSiteDiagnostics: ref useSiteDiagnostics)) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ContainingMember,The length of the statement  "            while (containingMember.Kind != SymbolKind.NamedType && (object)containingMember.ContainingSymbol != null && containingMember.ContainingSymbol.Kind != SymbolKind.NamedType) " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryBindInteractiveReceiver,The length of the statement  "                    if ((object)hostObjectType != null && hostObjectType.IsEqualToOrDerivedFrom(memberDeclaringType' ignoreDynamic: false' useSiteDiagnostics: ref useSiteDiagnostics)) " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindLabel,The length of the statement  "            this.LookupSymbolsWithFallback(result' labelName' arity: 0' useSiteDiagnostics: ref useSiteDiagnostics' options: LookupOptions.LabelsOnly); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ThisReference,The length of the statement  "            return new BoundThisReference(node' thisTypeOpt ?? CreateErrorType()' hasErrors) { WasCompilerGenerated = wasCompilerGenerated }; " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsRefOrOutThisParameterCaptured,The length of the statement  "            if ((object)thisSymbol != null && thisSymbol.ContainingSymbol != ContainingMemberOrLambda && thisSymbol.RefKind != RefKind.None) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBase,The length of the statement  "            NamedTypeSymbol baseType = (object)this.ContainingType == null ? null : this.ContainingType.BaseTypeNoUseSiteDiagnostics; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBase,The length of the statement  "            else if (node.Parent.Kind() != SyntaxKind.SimpleMemberAccessExpression && node.Parent.Kind() != SyntaxKind.ElementAccessExpression) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCast,The length of the statement  "            return BindCastCore(node' operand' targetType' wasCompilerGenerated: operand.WasCompilerGenerated' diagnostics: diagnostics); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCastCore,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_AmbigUDConv' node.Location' originalUserDefinedConversions[0]' originalUserDefinedConversions[1]' operand.Type' targetType); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCastCore,The length of the statement  "            return CreateConversion(node' operand' conversion' isCast: true' wasCompilerGenerated: wasCompilerGenerated' destination: targetType' diagnostics: diagnostics); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExplicitNullableCastFromNonNullable,The length of the statement  "            var underlyingConversion = Conversions.ClassifyConversion(operand.Type' underlyingTargetType' ref unused' builtinOnly: true); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExplicitNullableCastFromNonNullable,The length of the statement  "                return BindCastCore(node' operand' targetType' wasCompilerGenerated: operand.WasCompilerGenerated' diagnostics: diagnostics); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExplicitNullableCastFromNonNullable,The length of the statement  "                var underlyingExpr = BindCastCore(node' operand' targetType.GetNullableUnderlyingType()' wasCompilerGenerated: false' diagnostics: bag); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExplicitNullableCastFromNonNullable,The length of the statement  "                    return BindCastCore(node' underlyingExpr' targetType' wasCompilerGenerated: operand.WasCompilerGenerated' diagnostics: diagnostics); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExplicitNullableCastFromNonNullable,The length of the statement  "                return BindCastCore(node' operand' targetType' wasCompilerGenerated: operand.WasCompilerGenerated' diagnostics: diagnostics); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindImplicitArrayCreationExpression,The length of the statement  "            ImmutableArray<BoundExpression> boundInitializerExpressions = BindArrayInitializerExpressions(initializer' diagnostics' dimension: 1' rank: rank); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindImplicitArrayCreationExpression,The length of the statement  "            TypeSymbol bestType = BestTypeInferrer.InferBestType(boundInitializerExpressions' this.Conversions' out hadMultipleCandidates' ref useSiteDiagnostics); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindImplicitArrayCreationExpression,The length of the statement  "            if ((object)bestType == null || bestType.SpecialType == SpecialType.System_Void) // Dev10 also reports ERR_ImplicitlyTypedArrayNoBestType for void. " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArrayInitializerExpressions,The length of the statement  "                        BindArrayInitializerExpressions((InitializerExpressionSyntax)expression' exprBuilder' diagnostics' dimension + 1' rank); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArrayInitializerList,The length of the statement  "            return ConvertAndBindArrayInitialization(diagnostics' node' type' knownSizes' dimension' boundInitExprOpt' ref boundInitExprIndex); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArrayCreationWithInitializer,The length of the statement  "            BoundArrayInitialization initializer = BindArrayInitializerList(diagnostics' initSyntax' type' knownSizes' 1' boundInitExprOpt); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindStackAllocArrayCreationExpression,The length of the statement  "                count = GenerateConversionForAssignment(GetSpecialType(SpecialType.System_Int32' diagnostics' node)' count' diagnostics); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConstructorInitializer,The length of the statement  "                constructor.MethodKind == MethodKind.StaticConstructor); // error scenario: constructor initializer on static constructor " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConstructorInitializer,The length of the statement  "            if ((containingType.TypeKind == TypeKind.Enum || containingType.TypeKind == TypeKind.Struct) && initializerArgumentListOpt == null) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConstructorInitializer,The length of the statement  "                    if ((object)initializerType == null || containingType.SpecialType == SpecialType.System_Object) //e.g. when defining System.Object in source " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConstructorInitializer,The length of the statement  "                    // Note: use syntax node of constructor with initializer' not constructor invoked by initializer (i.e. methodResolutionResult). " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConstructorInitializer,The length of the statement  "                            (initializerArgumentListOpt != null && initializerArgumentListOpt.Parent.Kind() == SyntaxKind.ThisConstructorInitializer)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDelegateCreationExpression,The length of the statement  "                else if (analyzedArguments.Names.Count != 0 || analyzedArguments.RefKinds.Count != 0 || analyzedArguments.Arguments.Count != 1) " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDelegateCreationExpression,The length of the statement  "                    return new BoundDelegateCreationExpression(node' boundLambda' methodOpt: null' isExtensionMethod: false' type: type' hasErrors: !conversion.IsImplicit); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDelegateCreationExpression,The length of the statement  "                            return new BoundBadExpression(node' LookupResultKind.NotInvocable' StaticCast<Symbol>.From(type.InstanceConstructors)' ImmutableArray.Create<BoundNode>(argument)' type); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDelegateCreationExpression,The length of the statement  "                return new BoundBadExpression(node' LookupResultKind.OverloadResolutionFailure' StaticCast<Symbol>.From(type.InstanceConstructors)' childNodes.ToImmutableAndFree()' type); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindClassCreationExpression,The length of the statement  "                    return new BoundBadExpression(node' LookupResultKind.NotCreatable' ImmutableArray.Create<Symbol>(type)' children.ToImmutableAndFree()' type); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindClassCreationExpression,The length of the statement  "                return BindClassCreationExpression(node' typeName' node.Type' type' analyzedArguments' diagnostics' boundInitializerOpt); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerExpression,The length of the statement  "            // SPEC:    An object initializer consists of a sequence of member initializers' enclosed by { and } tokens and separated by commas. " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerExpression,The length of the statement  "            // SPEC:    Each member initializer must name an accessible field or property of the object being initialized' followed by an equals sign and " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerExpression,The length of the statement  "            // We use a location specific binder for binding object initializer field/property access to generate object initializer specific diagnostics: " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerExpression,The length of the statement  "            return new BoundObjectInitializerExpression(initializerSyntax' initializerBuilder.ToImmutableAndFree()' initializerType); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMemberAssignment,The length of the statement  "            // SPEC:    A member initializer that specifies an expression after the equals sign is processed in the same way as an assignment (spec 7.17.1) to the field or property. " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMemberAssignment,The length of the statement  "                    // We use a location specific binder for binding object initializer field/property access to generate object initializer specific diagnostics: " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "                // SPEC:    Each member initializer must name an accessible field or property of the object being initialized' followed by an equals sign and " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "                // SPEC:    A member initializer that specifies an expression after the equals sign is processed in the same way as an assignment (7.17.1) to the field or property. " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "                // SPEC VIOLATION:  Native compiler also allows initialization of field-like events in object initializers' so we allow it as well. " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "                    boundMember = BindIndexedPropertyAccess((BoundPropertyGroup)boundMember' mustHaveAllOptionalParameters: true' diagnostics: diagnostics); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "            // SPEC:    A member initializer that specifies an object initializer after the equals sign is a nested object initializer' " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "            // SPEC:    the assignments in the nested object initializer are treated as assignments to members of the field or property. " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "            // SPEC:    Nested object initializers cannot be applied to properties with a value type' or to read-only fields with a value type. " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "            // NOTE:    The dev11 behavior does not match the spec that was current at the time (quoted above).  However' in the roslyn " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "            // NOTE:    timeframe' the spec will be updated to apply the same restriction to nested collection initializers.  Therefore' " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "            // NOTE:    In the roslyn timeframe' an additional restriction will (likely) be added to the spec - it is not sufficient for the " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "            // NOTE:    type of the member to not be a value type - it must actually be a reference type (i.e. unconstrained type parameters " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "            bool isRhsNestedInitializer = rhsKind == SyntaxKind.ObjectInitializerExpression || rhsKind == SyntaxKind.CollectionInitializerExpression; " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "                                Error(diagnostics' ErrorCode.ERR_ReadonlyValueTypeInObjectInitializer' namedAssignment.Left' fieldSymbol' fieldSymbol.Type); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "                    hasErrors |= isRhsNestedInitializer && !CheckNestedObjectInitializerPropertySymbol(((BoundPropertyAccess)boundMember).PropertySymbol' namedAssignment.Left' diagnostics' hasErrors' ref resultKind); " is 196.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "                        hasErrors |= isRhsNestedInitializer && !CheckNestedObjectInitializerPropertySymbol(indexer.Indexer' namedAssignment.Left' diagnostics' hasErrors' ref resultKind); " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindObjectInitializerMember,The length of the statement  "                    return BadObjectInitializerMemberAccess(boundMember' implicitReceiver' namedAssignment.Left' diagnostics' valueKind' hasErrors); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckNestedObjectInitializerPropertySymbol,The length of the statement  "                    Error(diagnostics' ErrorCode.ERR_ValueTypePropertyInObjectInitializer' memberNameSyntax' propertySymbol' propertySymbol.Type); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BadObjectInitializerMemberAccess,The length of the statement  "            return ToBadExpression(boundMember' (valueKind == BindValueKind.RValue) ? LookupResultKind.NotAValue : LookupResultKind.NotAVariable); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDuplicateObjectMemberInitializers,The length of the statement  "            // SPEC:    It is an error for an object initializer to include more than one member initializer for the same field or property. " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDuplicateObjectMemberInitializers,The length of the statement  "                // SPEC:    A member initializer that specifies an expression after the equals sign is processed in the same way as an assignment (7.17.1) to the field or property. " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "            // SPEC:    A collection initializer consists of a sequence of element initializers' enclosed by { and } tokens and separated by commas. " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "            // SPEC:    The collection object to which a collection initializer is applied must be of a type that implements System.Collections.IEnumerable or " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "            // SPEC:    a compile-time error occurs. For each specified element in order' the collection initializer invokes an Add method on the target object " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "            // SPEC:    with the expression list of the element initializer as argument list' applying normal overload resolution for each invocation. " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "            // SPEC:    The collection object to which a collection initializer is applied must be of a type that implements System.Collections.IEnumerable or " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "            bool hasEnumerableInitializerType = CollectionInitializerTypeImplementsIEnumerable(initializerType' initializerSyntax' diagnostics); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "            // We use a location specific binder for binding collection initializer Add method to generate specific overload resolution diagnostics: " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "                // NOTE:    collectionInitializerAddMethodBinder is used only for binding the Add method invocation expression' but not the entire initializer. " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "                // NOTE:    Ideally we would want to avoid this and bind the entire initializer with the collectionInitializerAddMethodBinder. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "                // NOTE:    However' this approach has few issues. These issues also occur when binding object initializer member assignment. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "                // NOTE:    See comments for objectInitializerMemberBinder in BindObjectInitializerExpression method for details about the pitfalls of alternate approaches. " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerExpression,The length of the statement  "            return new BoundCollectionInitializerExpression(initializerSyntax' initializerBuilder.ToImmutableAndFree()' initializerType); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CollectionInitializerTypeImplementsIEnumerable,The length of the statement  "            // SPEC:    The collection object to which a collection initializer is applied must be of a type that implements System.Collections.IEnumerable or " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CollectionInitializerTypeImplementsIEnumerable,The length of the statement  "                // We cannot determine at compile time if initializerType implements System.Collections.IEnumerable' we must assume that it does. " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CollectionInitializerTypeImplementsIEnumerable,The length of the statement  "                TypeSymbol collectionsIEnumerableType = this.GetSpecialType(SpecialType.System_Collections_IEnumerable' diagnostics' node); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CollectionInitializerTypeImplementsIEnumerable,The length of the statement  "                // NOTE:    its implemented interfaces. However the native compiler checks to see if there is conversion from initializer " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CollectionInitializerTypeImplementsIEnumerable,The length of the statement  "                var result = Conversions.ClassifyImplicitConversion(initializerType' collectionsIEnumerableType' ref useSiteDiagnostics).IsValid; " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElement,The length of the statement  "            // SPEC:    Each element initializer specifies an element to be added to the collection object being initialized' and consists of " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElement,The length of the statement  "            // SPEC:    A single-expression element initializer can be written without braces' but cannot then be an assignment expression' " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElement,The length of the statement  "                var boundElementInitializer = BindInitializerExpressionOrValue(elementInitializer' initializerType' implicitReceiver.Syntax' diagnostics); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElementAddMethod,The length of the statement  "            // SPEC:    with the expression list of the element initializer as argument list' applying normal overload resolution for each invocation. " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElementAddMethod,The length of the statement  "            // We use a location specific binder for binding collection initializer Add method to generate specific overload resolution diagnostics. " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElementAddMethod,The length of the statement  "                return BadExpression(elementInitializer' LookupResultKind.NotInvocable' ImmutableArray<Symbol>.Empty' boundElementInitializerExpressions); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCollectionInitializerElementAddMethod,The length of the statement  "                var hasErrors = ReportBadDynamicArguments(elementInitializer' boundElementInitializerExpressions' diagnostics' queryClause: null); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsConstructorAccessible,The length of the statement  "            Debug.Assert(constructor.MethodKind == MethodKind.Constructor || constructor.MethodKind == MethodKind.StaticConstructor); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindClassCreationExpression,The length of the statement  "                this.OverloadResolution.ObjectCreationOverloadResolution(GetAccessibleConstructorsForOverloadResolution(type' ref useSiteDiagnostics)' analyzedArguments' overloadResolutionResult' ref useSiteDiagnostics); " is 204.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindClassCreationExpression,The length of the statement  "            else if (memberResolutionResult.IsValid && !IsConstructorAccessible(memberResolutionResult.Member' ref useSiteDiagnostics)) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindClassCreationExpression,The length of the statement  "            // NOTE: The use site diagnostics of the candidate constructors have already been reported (in PerformConstructorOverloadResolution). " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindClassCreationExpression,The length of the statement  "                ImmutableArray<BoundExpression> args = BuildArgumentsForErrorRecovery(analyzedArguments' candidateConstructors[0].Parameters); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInterfaceCreationExpression,The length of the statement  "            // NOTE: This is done to prevent a cycle in an error scenario where we have a "new InterfaceType" expression in an attribute argument. " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInterfaceCreationExpression,The length of the statement  "            // NOTE: Accessing IsComImport/ComImportCoClass properties on given type symbol would attempt ForceCompeteAttributes' which would again try binding all attributes on the symbol. " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInterfaceCreationExpression,The length of the statement  "            // NOTE: causing infinite recursion. We avoid this cycle by checking if we are within in context of an Attribute argument. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBadInterfaceCreationExpression,The length of the statement  "            ImmutableArray<BoundNode> childNodes = BuildArgumentsForErrorRecovery(analyzedArguments).Cast<BoundExpression' BoundNode>(); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBadInterfaceCreationExpression,The length of the statement  "            BoundExpression result = new BoundBadExpression(node' LookupResultKind.NotCreatable' ImmutableArray.Create<Symbol>(type)' childNodes' type); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindComImportCoClassCreationExpression,The length of the statement  "                // BREAKING CHANGE:     Dev10 allows the following code to compile' even though the output assembly is not verifiable and generates a runtime exception: " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindComImportCoClassCreationExpression,The length of the statement  "                Conversion conversion = this.Conversions.ClassifyConversionForCast(classCreation' interfaceType' ref useSiteDiagnostics); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNoPiaObjectCreationExpression,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_BadCtorArgCount' node.ArgumentList.Location' interfaceType' analyzedArguments.Arguments.Count); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNoPiaObjectCreationExpression,The length of the statement  "                    return new BoundBadExpression(node' LookupResultKind.OverloadResolutionFailure' ImmutableArray<Symbol>.Empty' children.ToImmutableAndFree()' creation.Type); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindTypeParameterCreationExpression,The length of the statement  "            return new BoundBadExpression(node' LookupResultKind.NotCreatable' ImmutableArray.Create<Symbol>(typeParameter)' ImmutableArray<BoundNode>.Empty' typeParameter); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,The length of the statement  "            candidateConstructors = GetAccessibleConstructorsForOverloadResolution(typeContainingConstructors' allowProtectedConstructorsOfBaseType' out allInstanceConstructors' ref useSiteDiagnostics); " is 190.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,The length of the statement  "                // We have at least one accessible candidate constructor' perform overload resolution with accessible candidateConstructors. " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,The length of the statement  "                this.OverloadResolution.ObjectCreationOverloadResolution(candidateConstructors' analyzedArguments' result' ref useSiteDiagnostics); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,The length of the statement  "                // Overload resolution failed on the accessible candidateConstructors' but we have at least one inaccessible constructor. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,The length of the statement  "                // Try overload resolution with all instance constructors to generate correct diagnostics and semantic info for this case. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,The length of the statement  "                this.OverloadResolution.ObjectCreationOverloadResolution(allInstanceConstructors' analyzedArguments' inaccessibleResult' ref useSiteDiagnostics); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryPerformConstructorOverloadResolution,The length of the statement  "                default(MemberResolutionResult<MethodSymbol>); // Invalid results are not interesting - we have enough info in candidateConstructors. " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAccessibleConstructorsForOverloadResolution,The length of the statement  "            return GetAccessibleConstructorsForOverloadResolution(type' false' out allInstanceConstructors' ref useSiteDiagnostics); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAccessibleConstructorsForOverloadResolution,The length of the statement  "            return FilterInaccessibleConstructors(allInstanceConstructors' allowProtectedConstructorsOfBaseType' ref useSiteDiagnostics); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindLeftOfPotentialColorColorMemberAccess,The length of the statement  "                                    return new BoundTypeOrValueExpression(left' new BoundTypeOrValueData(leftSymbol' boundValue' newValueDiagnostics' boundType' typeDiagnostics)' leftType); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                DiagnosticInfo diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadUnaryOp' SyntaxFacts.GetText(operatorToken.Kind())' leftType); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                DiagnosticInfo diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadUnaryOp' SyntaxFacts.GetText(operatorToken.Kind())' msgId.Localize()); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                var typeArgumentsSyntax = right.Kind() == SyntaxKind.GenericName ? ((GenericNameSyntax)right).TypeArgumentList.Arguments : default(SeparatedSyntaxList<TypeSyntax>); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                var typeArguments = rightHasTypeArguments ? BindTypeArguments(typeArgumentsSyntax' diagnostics) : default(ImmutableArray<TypeSymbol>); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                                    return new BoundBadExpression(node' LookupResultKind.Ambiguous' lookupResult.Symbols.AsImmutable()' ImmutableArray.Create<BoundNode>(boundLeft)' CreateErrorType(rightName)' hasErrors: true); " is 190.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                                        new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0])' symbols.ToImmutable()' lookupResult.Kind' lookupResult.Error' rightArity)); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                                Debug.Assert(lookupResult.IsClear' "If there's a legitimate reason for having candidates without a reason' then we should produce something intelligent in such cases."); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                                return new BoundBadExpression(node' lookupResult.Kind' symbols.AsImmutable()' ImmutableArray.Create<BoundNode>(boundLeft)' CreateErrorType(rightName)' hasErrors: true); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                                return BindInstanceMemberAccess(node' right' boundLeft' rightName' rightArity' typeArgumentsSyntax' typeArguments' invoked' diagnostics); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                                this.LookupMembersWithFallback(lookupResult' leftType' rightName' rightArity' ref useSiteDiagnostics' basesBeingResolved: null' options: options); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                                    return BindMemberOfType(node' right' rightName' rightArity' boundLeft' typeArgumentsSyntax' typeArguments' lookupResult' BoundMethodGroupFlags.None' diagnostics: diagnostics); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                            return BindInstanceMemberAccess(node' right' boundLeft' rightName' rightArity' typeArgumentsSyntax' typeArguments' invoked' diagnostics); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                                return BindInstanceMemberAccess(node' right' boundLeft' rightName' rightArity' typeArgumentsSyntax' typeArguments' invoked' diagnostics); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessWithBoundLeft,The length of the statement  "                return BindMemberAccessBadResult(node' rightName' boundLeft' lookupResult.Error' lookupResult.Symbols.ToImmutable()' lookupResult.Kind); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeMemberAccessValue,The length of the statement  "                        var resolution = this.ResolveMethodGroup(methodGroup' analyzedArguments: null' isMethodGroupConversion: false' useSiteDiagnostics: ref useSiteDiagnostics); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeMemberAccessValue,The length of the statement  "                    return BindIndexedPropertyAccess((BoundPropertyGroup)expr' mustHaveAllOptionalParameters: false' diagnostics: diagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInstanceMemberAccess,The length of the statement  "                this.LookupMembersWithFallback(lookupResult' leftType' rightName' rightArity' ref useSiteDiagnostics' basesBeingResolved: null' options: options); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInstanceMemberAccess,The length of the statement  "                    return BindMemberOfType(node' right' rightName' rightArity' boundLeft' typeArgumentsSyntax' typeArguments' lookupResult' flags' diagnostics); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInstanceMemberAccess,The length of the statement  "                return BindMemberAccessBadResult(node' rightName' boundLeft' lookupResult.Error' lookupResult.Symbols.ToImmutable()' lookupResult.Kind); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessBadResult,The length of the statement  "            return this.BindMemberAccessBadResult(syntax' node.Name' node.ReceiverOpt' node.LookupError' StaticCast<Symbol>.From(node.Methods)' node.ResultKind); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberOfType,The length of the statement  "            Symbol symbol = GetSymbolOrMethodOrPropertyGroup(lookupResult' right' plainName' arity' members' diagnostics' out wasError); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExtensionMethod,The length of the statement  "                this.PopulateExtensionMethodsFromSingleBinder(scope' methodGroup' expression' left' methodName' typeArguments' diagnostics); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExtensionMethod,The length of the statement  "                OverloadResolution.MethodInvocationOverloadResolution(methodGroup.Methods' methodGroup.TypeArguments' actualArguments' overloadResolutionResult' ref useSiteDiagnostics' isMethodGroupConversion' allowRefOmittedArguments); " is 220.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindExtensionMethod,The length of the statement  "                var result = new MethodGroupResolution(methodGroup' null' overloadResolutionResult' actualArguments' methodGroup.ResultKind' sealedDiagnostics); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,PopulateExtensionMethodsFromSingleBinder,The length of the statement  "                Symbol symbol = GetSymbolOrMethodOrPropertyGroup(lookupResult' node' rightName' arity' members' diagnostics' out wasError); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindFieldAccess,The length of the statement  "                        Error(diagnostics' isFixedStatementExpression ? ErrorCode.ERR_FixedNotNeeded : ErrorCode.ERR_FixedBufferNotFixed' node); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindFieldAccess,The length of the statement  "            BoundExpression expr = new BoundFieldAccess(node' receiver' fieldSymbol' constantValueOpt' resultKind' fieldType' hasErrors: (hasErrors || hasError)); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindPropertyAccess,The length of the statement  "            return new BoundPropertyAccess(node' receiver' propertySymbol' lookupResult' propertySymbol.Type' hasErrors: (hasErrors || hasError)); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindEventAccess,The length of the statement  "            bool isUsableAsField = eventSymbol.HasAssociatedField && this.IsAccessible(eventSymbol.AssociatedField' ref useSiteDiagnostics' (receiver != null) ? receiver.Type : null); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindEventAccess,The length of the statement  "            return new BoundEventAccess(node' receiver' eventSymbol' isUsableAsField' lookupResult' eventSymbol.Type' hasErrors: (hasErrors || hasError)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindElementAccess,The length of the statement  "                    return BindIndexedPropertyAccess(node' propertyGroup.ReceiverOpt' propertyGroup.Properties' analyzedArguments' diagnostics); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BadIndexerExpression,The length of the statement  "            return new BoundBadExpression(node' LookupResultKind.Empty' ImmutableArray<Symbol>.Empty' childBoundNodes' CreateErrorType()' hasErrors: true); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindArrayAccess,The length of the statement  "                return new BoundArrayAccess(node' expr' BuildArgumentsForErrorRecovery(arguments)' arrayType.ElementType' hasErrors: true); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryImplicitConversionToArrayIndex,The length of the statement  "            BoundExpression result = CreateConversion(expr.Syntax' expr' conversion.ToArrayIndexConversion()' isCast: false' destination: type' diagnostics: attemptDiagnostics); // UNDONE: was cast? " is 186.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,TryImplicitConversionToArrayIndex,The length of the statement  "            Debug.Assert(result != null); // If this ever fails (it shouldn't)' then put a null-check around the diagnostics update. " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindPointerElementAccess,The length of the statement  "                        Error(diagnostics' ErrorCode.ERR_BadArgExtraRef' analyzedArguments.Argument(i).Syntax' i + 1' refKind.ToDisplayString()); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindPointerElementAccess,The length of the statement  "                return new BoundPointerElementAccess(node' expr' BadExpression(node' BuildArgumentsForErrorRecovery(analyzedArguments).ToArray())' CheckOverflowAtRuntime' pointedAtType' hasErrors: true); " is 187.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexerAccess,The length of the statement  "            LookupOptions lookupOptions = expr.Kind == BoundKind.BaseReference ? LookupOptions.UseBaseReferenceAccessibility : LookupOptions.Default; " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexerAccess,The length of the statement  "            this.LookupMembersWithFallback(lookupResult' expr.Type' WellKnownMemberNames.Indexer' arity: 0' useSiteDiagnostics: ref useSiteDiagnostics' options: lookupOptions); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexedPropertyAccess,The length of the statement  "                    mustHaveAllOptionalParameters ? ErrorCode.ERR_IndexedPropertyMustHaveAllOptionalParams : ErrorCode.ERR_IndexedPropertyRequiresParams' " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDynamicIndexer,The length of the statement  "                    bool useType = IsInstance(typeOrValue.Data.ValueSymbol) && !HasThis(isExplicit: false' inStaticContext: out inStaticContext); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexerOrIndexedPropertyAccess,The length of the statement  "            OverloadResolutionResult<PropertySymbol> overloadResolutionResult = OverloadResolutionResult<PropertySymbol>.GetInstance(); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexerOrIndexedPropertyAccess,The length of the statement  "            this.OverloadResolution.PropertyOverloadResolution(propertyGroup' analyzedArguments' overloadResolutionResult' allowRefOmittedArguments' ref useSiteDiagnostics); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexerOrIndexedPropertyAccess,The length of the statement  "                var result = BindDynamicIndexer(syntax' receiverOpt' analyzedArguments' overloadResolutionResult.GetAllApplicableMembers()' diagnostics); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexerOrIndexedPropertyAccess,The length of the statement  "                ReportDiagnosticsIfObsolete(diagnostics' property' syntax' hasBaseReceiver: receiverOpt != null && receiverOpt.Kind == BoundKind.BaseReference); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexerOrIndexedPropertyAccess,The length of the statement  "                var gotError = MemberGroupFinalValidationAccessibilityChecks(receiverOpt' property' syntax' diagnostics' invokedAsExtensionMethod: false); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateErrorPropertySymbol,The length of the statement  "            return new ErrorPropertySymbol(candidate.ContainingType' propertyType' candidate.Name' candidate.IsIndexer' candidate.IsIndexedProperty); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveMethodGroup,The length of the statement  "            return ResolveMethodGroup(node' node.Syntax' node.Name' analyzedArguments' isMethodGroupConversion' ref useSiteDiagnostics' inferWithDynamic: inferWithDynamic); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveMethodGroup,The length of the statement  "                return new MethodGroupResolution(methodResolution.MethodGroup' methodResolution.OtherSymbol' methodResolution.OverloadResolutionResult' methodResolution.AnalyzedArguments' methodResolution.ResultKind' diagnostics.ToReadOnlyAndFree()); " is 234.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveMethodGroupInternal,The length of the statement  "            if (!methodGroup.SearchExtensionMethods || methodResolution.HasAnyApplicableMethod || methodGroup.MethodGroupReceiverIsDynamic()) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveMethodGroupInternal,The length of the statement  "            var extensionMethodResolution = BindExtensionMethod(expression' methodName' analyzedArguments' methodGroup.ReceiverOpt' methodGroup.TypeArgumentsOpt' isMethodGroupConversion); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveMethodGroupInternal,The length of the statement  "                return extensionMethodResolution;  //NOTE: the first argument of this MethodGroupResolution could be a BoundTypeOrValueExpression " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveDefaultMethodGroup,The length of the statement  "            methodGroup.PopulateWithNonExtensionMethods(node.ReceiverOpt' methods' node.TypeArgumentsOpt' node.ResultKind' node.LookupError); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveDefaultMethodGroup,The length of the statement  "                return new MethodGroupResolution(methodGroup' null' result' analyzedArguments' methodGroup.ResultKind' sealedDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDelegateInvokeUseSiteDiagnostic,The length of the statement  "                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_InvalidDelegateType' possibleDelegateType)' location ?? node.Location); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDelegateInvokeUseSiteDiagnostic,The length of the statement  "                diagnostics.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_InvalidDelegateType' possibleDelegateType)' location)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConditionalAccessExpression,The length of the statement  "                            resultIsNotUsed = (((ParenthesizedLambdaExpressionSyntax)parent).Body == node) && ContainingMethodOrLambdaReturnsVoid(); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ContainingMethodOrLambdaReturnsVoid,The length of the statement  "            return (object)containingMember != null && containingMember.Kind == SymbolKind.Method && ((MethodSymbol)containingMember).ReturnsVoid; " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateBadConditionalAccessNodeError,The length of the statement  "            DiagnosticInfo diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadUnaryOp' SyntaxFacts.GetText(operatorToken.Kind())' access.Display); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberBindingExpression,The length of the statement  "            var memberAccess = BindMemberAccessWithBoundLeft(node' receiver' node.Name' node.OperatorToken' invoked' indexed' diagnostics); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConditionalAccessReceiver,The length of the statement  "                DiagnosticInfo diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_BadUnaryOp' SyntaxFacts.GetText(operatorToken.Kind())' msgId.Localize()); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindFieldInitializers,The length of the statement  "                BindRegularCSharpFieldInitializers(compilation' initializers' boundInitializers' diagnostics' generateDebugInfo' out firstImportChain); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindFieldInitializers,The length of the statement  "                BindScriptFieldInitializers(compilation' scriptCtor' initializers' boundInitializers' diagnostics' generateDebugInfo' out firstImportChain); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindRegularCSharpFieldInitializers,The length of the statement  "                                fieldSymbol.ContainingType.IsImplicitClass); //however' we also allow fields in namespaces to help support script scenarios " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindRegularCSharpFieldInitializers,The length of the statement  "                        parentBinder = new LocalScopeBinder(parentBinder).WithAdditionalFlagsAndContainingMemberOrLambda(parentBinder.Flags | BinderFlags.FieldInitializer' fieldSymbol); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindScriptFieldInitializers,The length of the statement  "                    Binder parentBinder = new ExecutableCodeBinder((CSharpSyntaxNode)syntaxRef.SyntaxTree.GetRoot()' scriptCtor' scriptClassBinder); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindScriptFieldInitializers,The length of the statement  "                            new LocalScopeBinder(parentBinder).WithAdditionalFlagsAndContainingMemberOrLambda(parentBinder.Flags | BinderFlags.FieldInitializer' fieldSymbol)' " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindGlobalStatement,The length of the statement  "            if (binder.Compilation.IsSubmission && isLast && boundStatement.Kind == BoundKind.ExpressionStatement && !boundStatement.HasAnyErrors) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindFieldInitializer,The length of the statement  "            var boundInitValue = collisionDetector.BindVariableOrAutoPropInitializer(equalsValueClauseNode' fieldSymbol.GetFieldType(fieldsBeingBound)' initializerDiagnostics); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInterpolatedString,The length of the statement  "                                alignment = GenerateConversionForAssignment(intType' BindValue(interpolation.AlignmentClause.Value' diagnostics' Binder.BindValueKind.RValue)' diagnostics); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInterpolatedString,The length of the statement  "                                    //  We do the arithmetic using negative numbers because the largest negative int has no corresponding positive (absolute) value. " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInterpolatedString,The length of the statement  "                                        diagnostics.Add(ErrorCode.WRN_AlignmentMagnitude' alignment.Syntax.Location' alignmentConstant.Int32Value' magnitudeLimit); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMethodGroup,The length of the statement  "                    return BindMethodGroup(((ParenthesizedExpressionSyntax)node).Expression' invoked: false' indexed: false' diagnostics: diagnostics); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeInvocationExpression,The length of the statement  "            var boundExpression = BindInstanceMemberAccess(node' node' receiver' methodName' typeArgs.NullToEmpty().Length' typeArgsSyntax' typeArgs' true' diagnostics); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeInvocationExpression,The length of the statement  "            if (!allowFieldsAndProperties && (boundExpression.Kind == BoundKind.FieldAccess || boundExpression.Kind == BoundKind.PropertyAccess)) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpression,The length of the statement  "                BoundExpression boundExpression = BindMethodGroup(node.Expression' invoked: true' indexed: false' diagnostics: diagnostics); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpression,The length of the statement  "                result = BindDynamicInvocation(node' boundExpression' analyzedArguments' ImmutableArray<MethodSymbol>.Empty' diagnostics' queryClause); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpression,The length of the statement  "                result = BindMethodGroupInvocation(node' expression' methodName' (BoundMethodGroup)boundExpression' analyzedArguments' diagnostics' queryClause' allowUnexpandedForm: allowUnexpandedForm); " is 187.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpression,The length of the statement  "                result = BindDelegateInvocation(node' expression' methodName' boundExpression' analyzedArguments' diagnostics' queryClause' delegateType); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDynamicInvocation,The length of the statement  "                            bool useType = IsInstance(typeOrValue.Data.ValueSymbol) && !HasThis(isExplicit: false' inStaticContext: out inStaticContext); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportBadDynamicArguments,The length of the statement  "                        // Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type. " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDelegateInvocation,The length of the statement  "            OverloadResolution.MethodInvocationOverloadResolution(methodGroup.Methods' methodGroup.TypeArguments' analyzedArguments' overloadResolutionResult' ref useSiteDiagnostics); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDelegateInvocation,The length of the statement  "                result = BindDynamicInvocation(node' boundExpression' analyzedArguments' overloadResolutionResult.GetAllApplicableMembers()' diagnostics' queryClause); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDelegateInvocation,The length of the statement  "                result = BindInvocationExpressionContinued(node' expression' methodName' overloadResolutionResult' analyzedArguments' methodGroup' delegateType' diagnostics' queryClause); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMethodGroupInvocation,The length of the statement  "                        result = BindInvocationExpressionContinued(syntax' expression' methodName' resolution.OverloadResolutionResult' resolution.AnalyzedArguments' resolution.MethodGroup' null' discarded' queryClause); " is 196.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMethodGroupInvocation,The length of the statement  "                            var finalApplicableCandidates = GetCandidatesPassingFinalValidation(syntax' resolution.OverloadResolutionResult' methodGroup' diagnostics); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMethodGroupInvocation,The length of the statement  "                                result = BindDynamicInvocation(syntax' methodGroup' resolution.AnalyzedArguments' finalApplicableCandidates' diagnostics' queryClause); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetCandidatesPassingFinalValidation,The length of the statement  "                    //   or a member-access whose receiver can't be classified as a type or value until after overload resolution (see §7.6.4.1).  " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetCandidatesPassingFinalValidation,The length of the statement  "                    // * If F is an instance method' the method group must have resulted from a simple-name' a member-access through a variable or value'  " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetCandidatesPassingFinalValidation,The length of the statement  "                    //   or a member-access whose receiver can't be classified as a type or value until after overload resolution (see §7.6.4.1). " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetCandidatesPassingFinalValidation,The length of the statement  "                    if (!MemberGroupFinalValidationAccessibilityChecks(methodGroup.ReceiverOpt' result.Member' syntax' candidateDiagnostics' invokedAsExtensionMethod: false) && " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetCandidatesPassingFinalValidation,The length of the statement  "                        (methodGroup.TypeArgumentsOpt.IsDefault || result.Member.CheckConstraints(this.Conversions' syntax' this.Compilation' candidateDiagnostics))) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckRestrictedTypeReceiver,The length of the statement  "                            SymbolDistinguisher distinguisher = new SymbolDistinguisher(compilation' call.ReceiverOpt.Type' call.Method.ContainingType); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpressionContinued,The length of the statement  "                return CreateBadCall(node' methodGroup.Name' invokedAsExtensionMethod && analyzedArguments.Arguments.Count > 0 && (object)methodGroup.Receiver == (object)analyzedArguments.Arguments[0] ? null : methodGroup.Receiver' " is 215.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpressionContinued,The length of the statement  "                    GetOriginalMethods(result)' methodGroup.ResultKind' methodGroup.TypeArguments.ToImmutable()' analyzedArguments' invokedAsExtensionMethod: invokedAsExtensionMethod' isDelegate: ((object)delegateTypeOpt != null)); " is 211.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpressionContinued,The length of the statement  "            var receiver = ReplaceTypeOrValueReceiver(methodGroup.Receiver' method.IsStatic && !invokedAsExtensionMethod' diagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpressionContinued,The length of the statement  "                BoundExpression convertedReceiver = CreateConversion(receiver' methodResult.Result.ConversionForArg(0)' method.Parameters[0].Type' diagnostics); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpressionContinued,The length of the statement  "            if (!gotError && !method.IsStatic && receiver != null && receiver.Kind == BoundKind.ThisReference && receiver.WasCompilerGenerated) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReplaceTypeOrValueReceiver,The length of the statement  "                    return (value == replaced) ? q : q.Update(replaced' q.DefinedSymbol' q.Operation' q.Cast' q.Binder' q.UnoptimizedForm' q.Type); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateBadCall,The length of the statement  "                var returnType = GetCommonTypeOrReturnType(methods) ?? new ExtendedErrorTypeSymbol(this.Compilation' string.Empty' arity: 0' errorInfo: null); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateBadCall,The length of the statement  "            return BoundCall.ErrorCall(node' receiver' method' args' argNames' argRefKinds' isDelegate' invokedAsExtensionMethod: invokedAsExtensionMethod' originalMethods: methods' resultKind: resultKind); " is 194.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateBadCall,The length of the statement  "            var originalMethods = (expr.Kind == BoundKind.MethodGroup) ? ((BoundMethodGroup)expr).Methods : ImmutableArray<MethodSymbol>.Empty; " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateBadCall,The length of the statement  "            return BoundCall.ErrorCall(node' expr' method' args' argNames' argRefKinds' isDelegateCall: false' invokedAsExtensionMethod: false' originalMethods: originalMethods' resultKind: resultKind); " is 190.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNameofOperatorInternal,The length of the statement  "            // We relax the instance-vs-static requirement for top-level member access expressions by creating a NameofBinder binder. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNameofOperatorInternal,The length of the statement  "            if (!boundArgument.HasAnyErrors && CheckSyntaxForNameofArgument(argument' out name' diagnostics) && boundArgument.Kind == BoundKind.MethodGroup) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNameofOperatorInternal,The length of the statement  "            return new BoundNameOfOperator(node' boundArgument' ConstantValue.Create(name)' Compilation.GetSpecialType(SpecialType.System_String)); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,EnsureNameofExpressionSymbols,The length of the statement  "            var resolution = ResolveMethodGroup(methodGroup' analyzedArguments: null' isMethodGroupConversion: false' useSiteDiagnostics: ref useSiteDiagnostics); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,InvocableNameofInScope,The length of the statement  "            this.LookupSymbolsWithFallback(lookupResult' SyntaxFacts.GetText(SyntaxKind.NameOfKeyword)' useSiteDiagnostics: ref useSiteDiagnostics' arity: 0' options: options); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsSimpleName,The length of the statement  "                this.LookupAttributeType(result' qualifierOpt' plainName' arity' basesBeingResolved' options' diagnose' ref useSiteDiagnostics); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsSimpleName,The length of the statement  "                this.LookupSymbolsOrMembersInternal(result' qualifierOpt' plainName' arity' basesBeingResolved' options' diagnose' ref useSiteDiagnostics); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsWithFallback,The length of the statement  "            this.LookupSymbolsInternal(result' name' arity' basesBeingResolved' options' diagnose: false' useSiteDiagnostics: ref useSiteDiagnostics); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsWithFallback,The length of the statement  "                this.LookupSymbolsInternal(result' name' arity' basesBeingResolved' options' diagnose: true' useSiteDiagnostics: ref useSiteDiagnostics); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsInternal,The length of the statement  "                    scope.LookupSymbolsInSingleBinder(tmp' name' arity' basesBeingResolved' options' this' diagnose' ref useSiteDiagnostics); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsInternal,The length of the statement  "                    scope.LookupSymbolsInSingleBinder(result' name' arity' basesBeingResolved' options' this' diagnose' ref useSiteDiagnostics); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupSymbolsOrMembersInternal,The length of the statement  "                this.LookupMembersInternal(result' qualifierOpt' name' arity' basesBeingResolved' options' this' diagnose' ref useSiteDiagnostics); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersWithFallback,The length of the statement  "            this.LookupMembersInternal(result' nsOrType' name' arity' basesBeingResolved' options' originalBinder: this' diagnose: false' useSiteDiagnostics: ref useSiteDiagnostics); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersWithFallback,The length of the statement  "                this.LookupMembersInternal(result' nsOrType' name' arity' basesBeingResolved' options' originalBinder: this' diagnose: true' useSiteDiagnostics: ref useSiteDiagnostics); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInternal,The length of the statement  "                LookupMembersInNamespace(result' (NamespaceSymbol)nsOrType' name' arity' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInternal,The length of the statement  "                this.LookupMembersInType(result' (TypeSymbol)nsOrType' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInType,The length of the statement  "                    this.LookupMembersInTypeParameter(result' (TypeParameterSymbol)type' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInType,The length of the statement  "                    this.LookupMembersInInterface(result' (NamedTypeSymbol)type' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInType,The length of the statement  "                    this.LookupMembersInClass(result' type' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInType,The length of the statement  "                    this.LookupMembersInSubmissions(result' type' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInType,The length of the statement  "                    LookupMembersInErrorType(result' (ErrorTypeSymbol)type' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInErrorType,The length of the statement  "                        LookupMembersInType(result' candidateType' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInSubmissions,The length of the statement  "                    LookupMembersWithoutInheritance(submissionSymbols' submission.ScriptClass' name' arity' options' originalBinder' submissionClass' diagnose' ref useSiteDiagnostics' basesBeingResolved); " is 184.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInSubmissions,The length of the statement  "                    // using alias is ambiguous with another definition within the same submission iff the other definition is a 0-ary type or a non-type: " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInSubmissions,The length of the statement  "                        CSDiagnosticInfo diagInfo = new CSDiagnosticInfo(ErrorCode.ERR_ConflictingAliasAndDefinition' name' existingDefinition.GetKindText()); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInSubmissions,The length of the statement  "                imports.LookupSymbolInAliases(originalBinder' submissionSymbols' name' arity' basesBeingResolved' options' diagnose' ref useSiteDiagnostics); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInNamespace,The length of the statement  "                SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member' arity' options' null' diagnose' ref useSiteDiagnostics); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupExtensionMethodsInSingleBinder,The length of the statement  "            binder.GetCandidateExtensionMethods(scope.SearchUsingsNotNamespace' methods' name' arity' options' this.IsSemanticModelBinder); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupExtensionMethodsInSingleBinder,The length of the statement  "                SingleLookupResult resultOfThisMember = this.CheckViability(method' arity' options' null' diagnose: true' useSiteDiagnostics: ref useSiteDiagnostics); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupAttributeType,The length of the statement  "            // Roslyn Bug 9681: Compilers incorrectly use the *failure* of binding some subexpression to indicate some other strategy is applicable (attributes' 'var') " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupAttributeType,The length of the statement  "            LookupSymbolsOrMembersInternal(result' qualifierOpt' name' arity' basesBeingResolved' options' diagnose' ref useSiteDiagnostics); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupAttributeType,The length of the statement  "                this.LookupSymbolsOrMembersInternal(resultWithSuffix' qualifierOpt' name + "Attribute"' arity' basesBeingResolved' options' diagnose' ref useSiteDiagnostics); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsAmbiguousResult,The length of the statement  "                    // NOTE: Kind of the symbol doesn't matter here. If the resolved symbol is not an attribute type' we will subsequently generate a lookup error. " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsAmbiguousResult,The length of the statement  "                    // CONSIDER: If this source symbol is the eventual result symbol for attribute type lookup and it is not a valid attribute type' " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersWithoutInheritance,The length of the statement  "                SingleLookupResult resultOfThisMember = originalBinder.CheckViability(member' arity' options' accessThroughType' diagnose' ref useSiteDiagnostics' basesBeingResolved); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInClass,The length of the statement  "                LookupMembersWithoutInheritance(tmp' currentType' name' arity' options' originalBinder' type' diagnose' ref useSiteDiagnostics' basesBeingResolved); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInClass,The length of the statement  "                // any viable non-methods [non-indexers] found here will hide viable methods [indexers] (with the same name) in any further base classes " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddWinRTMembers,The length of the statement  "            GetWellKnownWinRTMemberInterfaces(out idictSymbol' out iroDictSymbol' out iListSymbol' out iCollectionSymbol' out inccSymbol' out inpcSymbol); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddWinRTMembers,The length of the statement  "                if (ShouldAddWinRTMembersForInterface(iface' idictSymbol' iroDictSymbol' iListSymbol' iCollectionSymbol' inccSymbol' inpcSymbol)) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddWinRTMembers,The length of the statement  "                    LookupMembersWithoutInheritance(tmp' iface' name' arity' options' originalBinder' iface' diagnose' ref useSiteDiagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInInterfaceOnly,The length of the statement  "            LookupMembersWithoutInheritance(current' type' name' arity' options' originalBinder' accessThroughType' diagnose' ref useSiteDiagnostics); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInInterfaceOnly,The length of the statement  "            if ((options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) == 0 && !originalBinder.InCrefButNotParameterOrReturnType) " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInInterfaceOnly,The length of the statement  "                LookupMembersInInterfacesWithoutInheritance(current' type.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)' name' arity' options' originalBinder' accessThroughType' diagnose' ref useSiteDiagnostics); " is 220.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInInterfacesWithoutInheritance,The length of the statement  "                    LookupMembersWithoutInheritance(tmp' baseInterface' name' arity' options' originalBinder' accessThroughType' diagnose' ref useSiteDiagnostics); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInInterface,The length of the statement  "            LookupMembersInInterfaceOnly(current' type' name' arity' options' originalBinder' type' diagnose' ref useSiteDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInInterface,The length of the statement  "                this.LookupMembersInClass(tmp' this.Compilation.GetSpecialType(SpecialType.System_Object)' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 183.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInTypeParameter,The length of the statement  "            LookupMembersInClass(current' typeParameter.EffectiveBaseClass(ref useSiteDiagnostics)' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 180.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupMembersInTypeParameter,The length of the statement  "            LookupMembersInInterfacesWithoutInheritance(current' typeParameter.AllEffectiveInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)' name' arity' options' originalBinder' typeParameter' diagnose' ref useSiteDiagnostics); " is 234.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsDerivedType,The length of the statement  "            for (NamedTypeSymbol b = derivedType.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics); (object)b != null; b = b.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)) " is 193.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsDerivedType,The length of the statement  "            return baseType.IsInterface && derivedType.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics).Contains(baseType); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MergeHidingLookupResults,The length of the statement  "                            if (!IsDerivedType(baseType: hiddenContainer' derivedType: hidingSym.ContainingType' useSiteDiagnostics: ref useSiteDiagnostics) && " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckViability,The length of the statement  "                    diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadProtectedAccess' unwrappedSymbol' accessThroughType' this.ContainingType) : null; " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckViability,The length of the statement  "                    diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadAccess' new[] { unwrappedSymbol }' unwrappedSymbols' additionalLocations: ImmutableArray<Location>.Empty) : null; " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckViability,The length of the statement  "                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKunknown' unwrappedSymbol' unwrappedSymbol.GetKindText()) : null; " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckViability,The length of the statement  "                var res = this.CheckViability(symbol' arity' options' accessThroughType' diagnose' ref useSiteDiagnostics' basesBeingResolved); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CanAddLookupSymbolInfo,The length of the statement  "            else if (!InCref && !this.IsAccessible(symbol' ref useSiteDiagnostics' RefineAccessThroughType(options' accessThroughType))) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsAccessible,The length of the statement  "            return Next.IsAccessible(symbol' accessThroughType' out failedThroughTypeCheck' ref useSiteDiagnostics' basesBeingResolved); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,WrongArity,The length of the statement  "                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars' namedType' MessageID.IDS_SK_TYPE.Localize()) : null; " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,WrongArity,The length of the statement  "                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity' namedType' MessageID.IDS_SK_TYPE.Localize()' namedType.Arity) : null; " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,WrongArity,The length of the statement  "                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_HasNoTypeVars' method' MessageID.IDS_SK_METHOD.Localize()) : null; " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,WrongArity,The length of the statement  "                                diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadArity' method' MessageID.IDS_SK_METHOD.Localize()' method.Arity) : null; " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddWinRTMembersLookupSymbolsInfo,The length of the statement  "            GetWellKnownWinRTMemberInterfaces(out idictSymbol' out iroDictSymbol' out iListSymbol' out iCollectionSymbol' out inccSymbol' out inpcSymbol); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddWinRTMembersLookupSymbolsInfo,The length of the statement  "                if (ShouldAddWinRTMembersForInterface(iface' idictSymbol' iroDictSymbol' iListSymbol' iCollectionSymbol' inccSymbol' inpcSymbol)) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddMemberLookupSymbolsInfoInInterface,The length of the statement  "                this.AddMemberLookupSymbolsInfoInClass(result' Compilation.GetSpecialType(SpecialType.System_Object)' options' originalBinder' accessThroughType); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCompoundAssignment,The length of the statement  "                    var finalDynamicConversion = this.Compilation.Conversions.ClassifyConversionFromExpression(right' left.Type' ref useSiteDiagnostics); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCompoundAssignment,The length of the statement  "            if (left.Kind == BoundKind.EventAccess && !CheckEventValueKind((BoundEventAccess)left' BindValueKind.Assignment' diagnostics)) " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCompoundAssignment,The length of the statement  "            BinaryOperatorAnalysisResult best = this.BinaryOperatorOverloadResolution(kind' left' right' node' diagnostics' out resultKind' out originalUserDefinedOperators); " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCompoundAssignment,The length of the statement  "                    Conversion.NoConversion' Conversion.NoConversion' resultKind' originalUserDefinedOperators' CreateErrorType()' hasErrors: true); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCompoundAssignment,The length of the statement  "            Conversion finalConversion = Conversions.ClassifyConversionFromExpression(bestSignature.ReturnType' leftType' ref useSiteDiagnostics); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCompoundAssignment,The length of the statement  "                GenerateImplicitConversionError(diagnostics' this.Compilation' node' finalConversion' bestSignature.ReturnType' leftType); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCompoundAssignment,The length of the statement  "                Conversion rightToLeftConversion = this.Conversions.ClassifyConversionFromExpression(right' leftType' ref useSiteDiagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindEventAssignment,The length of the statement  "            Conversion argumentConversion = this.Conversions.ClassifyConversionFromExpression(right' delegateType' ref useSiteDiagnostics); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindEventAssignment,The length of the statement  "            if (!argumentConversion.IsImplicit || !argumentConversion.IsValid) // NOTE: dev10 appears to allow user-defined conversions here. " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindEventAssignment,The length of the statement  "                    Error(diagnostics' ErrorCode.ERR_MissingPredefinedMember' node' delegateType' SourceEventSymbol.GetAccessorName(eventSymbol.Name' isAddition)); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDynamicBinaryOperator,The length of the statement  "            Debug.Assert((object)left.Type != null && left.Type.IsDynamic() || (object)right.Type != null && right.Type.IsDynamic()); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDynamicBinaryOperator,The length of the statement  "                if (!IsValidDynamicCondition(left' isNegative: kind == BinaryOperatorKind.LogicalAnd' useSiteDiagnostics: ref useSiteDiagnostics' userDefinedOperator: out userDefinedOperator)) " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDynamicBinaryOperator,The length of the statement  "                    Error(diagnostics' ErrorCode.ERR_InvalidDynamicCondition' node.Left' left.Type' kind == BinaryOperatorKind.LogicalAnd ? "false" : "true"); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDynamicBinaryOperator,The length of the statement  "                operatorKind: (hasError ? kind : kind.WithType(BinaryOperatorKind.Dynamic)).WithOverflowChecksIfApplicable(CheckOverflowAtRuntime)' " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleBinaryOperator,The length of the statement  "                return new BoundBinaryOperator(node' kind' left' right' ConstantValue.NotAvailable' null' LookupResultKind.Empty' GetBinaryOperatorErrorType(kind' diagnostics' node)' true); " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleBinaryOperator,The length of the statement  "                return new BoundLiteral(node' ConstantValue.Create(kind == BinaryOperatorKind.Equal)' GetSpecialType(SpecialType.System_Boolean' diagnostics' node)); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleBinaryOperator,The length of the statement  "            var best = this.BinaryOperatorOverloadResolution(kind' left' right' node' diagnostics' out resultKind' out originalUserDefinedOperators); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleBinaryOperator,The length of the statement  "                bool isObjectEquality = signature.Kind == BinaryOperatorKind.ObjectEqual || signature.Kind == BinaryOperatorKind.ObjectNotEqual; " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleBinaryOperator,The length of the statement  "                    resultConstant = FoldBinaryOperator(node' resultOperatorKind' resultLeft' resultRight' resultType.SpecialType' diagnostics' ref compoundStringLength); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleBinaryOperator,The length of the statement  "                    hasErrors = isObjectEquality && !BuiltInOperators.IsValidObjectEquality(Conversions' leftType' leftNull' rightType' rightNull' ref useSiteDiagnostics); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportAssignmentOperatorError,The length of the statement  "            if (((SyntaxKind)node.OperatorToken.RawKind == SyntaxKind.PlusEqualsToken || (SyntaxKind)node.OperatorToken.RawKind == SyntaxKind.MinusEqualsToken) && " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConditionalLogicalOperator,The length of the statement  "                var constantValue = FoldBinaryOperator(node' kind | BinaryOperatorKind.Bool' left' right' SpecialType.System_Boolean' diagnostics); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConditionalLogicalOperator,The length of the statement  "            var best = this.BinaryOperatorOverloadResolution(kind' left' right' node' diagnostics' out lookupResult' out originalUserDefinedOperators); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConditionalLogicalOperator,The length of the statement  "                else if (bothBool || IsValidUserDefinedConditionalLogicalOperator(node' signature' diagnostics' out trueOperator' out falseOperator)) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConditionalLogicalOperator,The length of the statement  "            return new BoundBinaryOperator(node' kind' left' right' ConstantValue.NotAvailable' null' lookupResult' originalUserDefinedOperators' CreateErrorType()' true); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsValidDynamicCondition,The length of the statement  "            var implicitConversion = Conversions.ClassifyImplicitConversionFromExpression(left' Compilation.GetSpecialType(SpecialType.System_Boolean)' ref useSiteDiagnostics); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsValidDynamicCondition,The length of the statement  "            return HasApplicableBooleanOperator(namedType' isNegative ? WellKnownMemberNames.FalseOperatorName : WellKnownMemberNames.TrueOperatorName' type' ref useSiteDiagnostics' out userDefinedOperator); " is 195.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsValidUserDefinedConditionalLogicalOperator,The length of the statement  "            if (!HasApplicableBooleanOperator(t' WellKnownMemberNames.TrueOperatorName' signature.LeftType' ref useSiteDiagnostics' out trueOperator) || " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsValidUserDefinedConditionalLogicalOperator,The length of the statement  "                !HasApplicableBooleanOperator(t' WellKnownMemberNames.FalseOperatorName' signature.LeftType' ref useSiteDiagnostics' out falseOperator)) " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,HasApplicableBooleanOperator,The length of the statement  "            for (var type = containingType; type != null; type = type.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIncrementOperator,The length of the statement  "            var best = this.UnaryOperatorOverloadResolution(kind' operand' node' diagnostics' out resultKind' out originalUserDefinedOperators); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIncrementOperator,The length of the statement  "                GenerateImplicitConversionError(diagnostics' this.Compilation' node' resultConversion' signature.ReturnType' operandType); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindPointerIndirectionExpressionInternal,The length of the statement  "            hasErrors = operand.HasAnyErrors; // This would propagate automatically' but by reading it explicitly we can reduce cascading. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAddressOfExpression,The length of the statement  "            bool hasErrors = operand.HasAnyErrors; // This would propagate automatically' but by reading it explicitly we can reduce cascading. " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAddressOfExpression,The length of the statement  "                        return new BoundAddressOfOperator(node' operand' isFixedStatementAddressOfExpression' CreateErrorType()' hasErrors: true); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAddressOfExpression,The length of the statement  "                        Error(diagnostics' isFixedStatementAddressOfExpression ? ErrorCode.ERR_FixedNotNeeded : ErrorCode.ERR_FixedNeeded' node); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindUnaryOperatorCore,The length of the statement  "            var best = this.UnaryOperatorOverloadResolution(kind' operand' node' diagnostics' out resultKind' out originalUserDefinedOperators); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindUnaryOperatorCore,The length of the statement  "            var resultOperand = CreateConversion(operand.Syntax' operand' best.Conversion' false' signature.OperandType' diagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIntegralMinValConstants,The length of the statement  "                return new BoundLiteral(node' ConstantValue.Create((int)-2147483648)' GetSpecialType(SpecialType.System_Int32' diagnostics' node)); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIntegralMinValConstants,The length of the statement  "                return new BoundLiteral(node' ConstantValue.Create(-9223372036854775808)' GetSpecialType(SpecialType.System_Int64' diagnostics' node)); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportIsOperatorConstantWarnings,The length of the statement  "            ConstantValue constantValue = GetIsOperatorConstantResult(operandType' targetType' conversionKind' operandConstantValue); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetIsOperatorConstantResult,The length of the statement  "            // SPEC:        an implicit reference conversion from D to T exists' or if D is a value type and a boxing conversion from D to T exists. " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetIsOperatorConstantResult,The length of the statement  "            // NOTE:    we want to perform constant analysis of is/as expressions during binding to generate warnings (always true/false/null) " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAsOperator,The length of the statement  "            Conversion conversion = Conversions.ClassifyConversion(operandType' targetType' ref useSiteDiagnostics' builtinOnly: true); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAsOperator,The length of the statement  "            bool hasErrors = ReportAsOperatorConversionDiagnostics(node' diagnostics' this.Compilation' operandType' targetType' conversion.Kind' operand.ConstantValue); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportAsOperatorConversionDiagnostics,The length of the statement  "            // SPEC VIOLATION:  See Microsoft.CodeAnalysis.CSharp.UnitTests.SyntaxBinderTests.TestAsOperator_SpecErrorCase() test for an example. " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportAsOperatorConstantWarnings,The length of the statement  "            ConstantValue constantValue = GetAsOperatorConstantResult(operandType' targetType' conversionKind' operandConstantValue); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAsOperatorConstantResult,The length of the statement  "            // NOTE:    we want to perform constant analysis of is/as expressions during binding to generate warnings (always true/false/null) " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetAsOperatorConstantResult,The length of the statement  "            ConstantValue isOperatorConstantResult = GetIsOperatorConstantResult(operandType' targetType' conversionKind' operandConstantValue); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateNullCoalescingBadBinaryOpsError,The length of the statement  "            Error(diagnostics' ErrorCode.ERR_BadBinaryOps' node' SyntaxFacts.GetText(node.OperatorToken.Kind())' leftOperand.Display' rightOperand.Display); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNullCoalescingOperator,The length of the statement  "                var leftConversion = Conversions.ClassifyConversionFromExpression(leftOperand' GetSpecialType(SpecialType.System_Object' diagnostics' node)' ref useSiteDiagnostics); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNullCoalescingOperator,The length of the statement  "                var rightConversion = Conversions.ClassifyImplicitConversionFromExpression(rightOperand' optLeftType0' ref useSiteDiagnostics); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNullCoalescingOperator,The length of the statement  "                var rightConversion = Conversions.ClassifyImplicitConversionFromExpression(rightOperand' optLeftType' ref useSiteDiagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNullCoalescingOperator,The length of the statement  "                    leftConversion = Conversions.ClassifyImplicitConversionFromExpression(leftOperand' optRightType' ref useSiteDiagnostics); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConditionalOperator,The length of the statement  "                TypeSymbol bestType = BestTypeInferrer.InferBestTypeForConditionalOperator(trueExpr' falseExpr' this.Conversions' out hadMultipleCandidates' ref useSiteDiagnostics); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindQuery,The length of the statement  "            for (QueryContinuationSyntax continuation = node.Body.Continuation; continuation != null; continuation = continuation.Body.Continuation) " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceJoin,The length of the statement  "            var outerKeySelectorLambda = MakeQueryUnboundLambda(state.RangeVariableMap()' state.rangeVariable' join.LeftExpression); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceJoin,The length of the statement  "            var innerKeySelectorLambda = MakeQueryUnboundLambda(QueryTranslationState.RangeVariableMap(x2)' x2' join.RightExpression); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceJoin,The length of the statement  "                    var resultSelectorLambda = MakeQueryUnboundLambda(state.RangeVariableMap()' ImmutableArray.Create(x1' x2)' select.Expression); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceJoin,The length of the statement  "                    var resultSelectorLambda = MakeQueryUnboundLambda(state.RangeVariableMap()' ImmutableArray.Create(x1' g)' select.Expression); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceOrderBy,The length of the statement  "                string methodName = (first ? "OrderBy" : "ThenBy") + (ordering.IsKind(SyntaxKind.DescendingOrdering) ? "Descending" : ""); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceFrom,The length of the statement  "                collectionSelectorLambda = MakeQueryUnboundLambdaWithCast(state.RangeVariableMap()' x1' from.Expression' from.Type' BindTypeArgument(from.Type' diagnostics)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceFrom,The length of the statement  "                var resultSelectorLambda = MakeQueryUnboundLambda(state.RangeVariableMap()' ImmutableArray.Create(x1' x2)' select.Expression); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceFrom,The length of the statement  "                // Adjust the second-to-last parameter to be a query clause (if it was an extension method' an extra parameter was added) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceFrom,The length of the statement  "                    arguments.SetItem(arguments.Length - 2' MakeQueryClause(from' arguments[arguments.Length - 2]' x2' invocation' castInvocation))); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceLet,The length of the statement  "                SourceLocation errorLocation = new SourceLocation(let.SyntaxTree' new TextSpan(let.Identifier.SpanStart' let.Expression.Span.End - let.Identifier.SpanStart)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceLet,The length of the statement  "                    yExpression = new BoundBadExpression(yExpression.Syntax' LookupResultKind.Empty' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(yExpression)' CreateErrorType()); " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceLet,The length of the statement  "                    yExpression = new BoundBadExpression(yExpression.Syntax' LookupResultKind.Empty' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(yExpression)' yExpression.Type); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakePair,The length of the statement  "                field2Value = new BoundBadExpression(field2Value.Syntax' LookupResultKind.Empty' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(field2Value)' field2Value.Type' true); " is 182.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryUnboundLambda,The length of the statement  "            return MakeQueryUnboundLambda(expression' new QueryUnboundLambdaState(this' qvm' parameters' (LambdaSymbol lambdaSymbol' ref Binder lambdaBodyBinder' DiagnosticBag diagnostics) => " is 179.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryUnboundLambdaWithCast,The length of the statement  "            return MakeQueryUnboundLambda(expression' new QueryUnboundLambdaState(this' qvm' ImmutableArray.Create(parameter)' (LambdaSymbol lambdaSymbol' ref Binder lambdaBodyBinder' DiagnosticBag diagnostics) => " is 201.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryUnboundLambdaWithCast,The length of the statement  "                boundExpression = lambdaBodyBinder.MakeQueryInvocation(expression' boundExpression' "Cast"' castTypeSyntax' castType' diagnostics); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryUnboundLambdaWithCast,The length of the statement  "                return lambdaBodyBinder.CreateBlockFromExpression(expression' lambdaBodyBinder.Locals' expression' boundExpression' diagnostics); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryInvocation,The length of the statement  "            return MakeQueryInvocation(node' receiver' methodName' default(SeparatedSyntaxList<TypeSyntax>)' default(ImmutableArray<TypeSymbol>)' ImmutableArray.Create(arg)' diagnostics); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryInvocation,The length of the statement  "            return MakeQueryInvocation(node' receiver' methodName' default(SeparatedSyntaxList<TypeSyntax>)' default(ImmutableArray<TypeSymbol>)' args' diagnostics); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryInvocation,The length of the statement  "            return MakeQueryInvocation(node' receiver' methodName' new SeparatedSyntaxList<TypeSyntax>(new SyntaxNodeOrTokenList(typeArgSyntax' 0))' ImmutableArray.Create(typeArg)' ImmutableArray<BoundExpression>.Empty' diagnostics); " is 221.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryInvocation,The length of the statement  "                    var resolution = this.ResolveMethodGroup(methodGroup' analyzedArguments: null' isMethodGroupConversion: false' useSiteDiagnostics: ref useSiteDiagnostics); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryInvocation,The length of the statement  "                receiver = new BoundBadExpression(receiver.Syntax' LookupResultKind.NotAValue' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(receiver)' CreateErrorType()); " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MakeQueryInvocation,The length of the statement  "                receiver = new BoundBadExpression(receiver.Syntax' LookupResultKind.NotAValue' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(receiver)' CreateErrorType()); " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportQueryLookupFailed,The length of the statement  "                // Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing a reference to 'System.Core.dll' or a using directive for 'System.Linq'? " is 187.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportQueryLookupFailed,The length of the statement  "            else if (fromClause != null && fromClause.Type == null && HasCastToQueryProvider(instanceArgument.Type' ref useSiteDiagnostics)) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportQueryLookupFailed,The length of the statement  "                // Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'. " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ImplementsStandardQueryInterface,The length of the statement  "            if (instanceType.TypeKind == TypeKind.Array || name == "Cast" && HasCastToQueryProvider(instanceType' ref useSiteDiagnostics)) " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ImplementsStandardQueryInterface,The length of the statement  "            bool isIenumerable = originalType == ienumerable_t || HasUniqueInterface(instanceType' ienumerable_t' ref nonUnique' ref useSiteDiagnostics); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ImplementsStandardQueryInterface,The length of the statement  "            bool isQueryable = originalType == iqueryable_t || HasUniqueInterface(instanceType' iqueryable_t' ref nonUnique' ref useSiteDiagnostics); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,HasCastToQueryProvider,The length of the statement  "            bool isIenumerable = originalType == ienumerable || HasUniqueInterface(instanceType' ienumerable' ref useSiteDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsJoinRangeVariableInLeftKey,The length of the statement  "                    if (join.LeftExpression.Span.Contains(node.Span) && join.Identifier.ValueText == node.Identifier.ValueText) return true; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportQueryInferenceFailed,The length of the statement  "                    if (ReportQueryInferenceFailedSelectMany((FromClauseSyntax)queryClause' methodName' receiver' arguments' symbols' diagnostics)) " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindStatement,The length of the statement  "            Debug.Assert(System.Linq.Enumerable.Contains(result.Syntax.AncestorsAndSelf()' node)' @"Bound statement (or one of its parents)  " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindFixedStatementParts,The length of the statement  "            BindForOrUsingOrFixedDeclarations(declarationSyntax' LocalDeclarationKind.FixedVariable' diagnostics' out declarations); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindFixedStatementParts,The length of the statement  "            BoundMultipleLocalDeclarations boundMultipleDeclarations = new BoundMultipleLocalDeclarations(declarationSyntax' declarations); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindThrow,The length of the statement  "                    if ((object)type == null || !type.IsErrorType() && !Compilation.IsExceptionType(type.EffectiveType(ref useSiteDiagnostics)' ref useSiteDiagnostics)) " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindLabeled,The length of the statement  "            this.LookupSymbolsWithFallback(result' node.Identifier.ValueText' arity: 0' useSiteDiagnostics: ref useSiteDiagnostics' options: LookupOptions.LabelsOnly); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindLabeled,The length of the statement  "            // result.Symbols can be empty in some malformed code' e.g. when a labeled statement is used an embedded statement in an if or foreach statement     " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindLabeled,The length of the statement  "            this.Next.LookupSymbolsWithFallback(result' node.Identifier.ValueText' arity: 0' useSiteDiagnostics: ref useSiteDiagnostics' options: LookupOptions.LabelsOnly); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDeclarationStatement,The length of the statement  "                    boundDeclarations[i++] = BindVariableDeclaration(kind' isVar' variableDeclaratorSyntax' typeSyntax' declType' alias' diagnostics); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindVariableType,The length of the statement  "                if (declarationNode.Kind() == SyntaxKind.LocalDeclarationStatement && ((LocalDeclarationStatementSyntax)declarationNode).Declaration.Variables.Count > 1 && !declarationNode.HasErrors) " is 183.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindVariableDeclaration,The length of the statement  "            return new BoundLocalDeclaration(associatedSyntaxNode' localSymbol' boundDeclType' initializerOpt' arguments' hasErrors); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsValidFixedVariableInitializer,The length of the statement  "                            // The following assertion would not be correct because there might be an implicit conversion after (above) the explicit one. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsValidFixedVariableInitializer,The length of the statement  "                            //Debug.Assert(((BoundConversion)initializerOpt).ExplicitCastInCode' "The assignment conversion hasn't been applied yet' so this must be from source."); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetFixedLocalCollectionInitializer,The length of the statement  "                GenerateImplicitConversionError(diagnostics' this.Compilation' initializerSyntax' elementConversion' pointerType' declType); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckIsVariable,The length of the statement  "                Error(diagnostics' ErrorCode.ERR_BadSKknown' node' ns.NamespaceSymbol' MessageID.IDS_SK_NAMESPACE.Localize()' MessageID.IDS_SK_VARIABLE.Localize()); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckIsVariable,The length of the statement  "                Error(diagnostics' ErrorCode.ERR_BadSKknown' node' type.Type' MessageID.IDS_SK_TYPE.Localize()' MessageID.IDS_SK_VARIABLE.Localize()); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckIsVariable,The length of the statement  "                    Error(diagnostics' kind == BindValueKind.OutParameter ? ErrorCode.ERR_WinRtEventPassedByRef : GetStandardLvalueError(kind)' node' eventSymbol); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckIsVariable,The length of the statement  "                    Error(diagnostics' kind == BindValueKind.OutParameter ? ErrorCode.ERR_RefProperty : GetStandardLvalueError(kind)' node' propertySymbol); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckNotNamespaceOrType,The length of the statement  "                    Error(diagnostics' ErrorCode.ERR_BadSKknown' expr.Syntax' ((BoundNamespaceExpression)expr).NamespaceSymbol' MessageID.IDS_SK_NAMESPACE.Localize()' MessageID.IDS_SK_VARIABLE.Localize()); " is 185.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckValue,The length of the statement  "                    expr = BindIndexedPropertyAccess((BoundPropertyGroup)expr' mustHaveAllOptionalParameters: false' diagnostics: diagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckValue,The length of the statement  "                var resolution = this.ResolveMethodGroup(methodGroup' analyzedArguments: null' isMethodGroupConversion: false' useSiteDiagnostics: ref useSiteDiagnostics); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckValue,The length of the statement  "                        // Since we're not accessing a method' this can't be a Color Color case' so TypeOrValueExpression should not have been used. " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckEventValueKind,The length of the statement  "                            // Dev10 reports this in addition to ERR_BadAccess' but we won't even reach this point if the event isn't accessible (caught by lookup). " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckEventValueKind,The length of the statement  "                                ErrorCode errorCode = valueKind == BindValueKind.OutParameter ? ErrorCode.ERR_WinRtEventPassedByRef : GetStandardLvalueError(valueKind); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckPropertyValueKind,The length of the statement  "                else if (!object.Equals(setMethod.GetUseSiteDiagnostic()' propertySymbol.GetUseSiteDiagnostic()) && ReportUseSiteDiagnostics(setMethod' diagnostics' propertySyntax)) " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckPropertyValueKind,The length of the statement  "                    bool isAccessible = this.IsAccessible(setMethod' accessThroughType' out failedThroughTypeCheck' ref useSiteDiagnostics); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckPropertyValueKind,The length of the statement  "                else if (!object.Equals(getMethod.GetUseSiteDiagnostic()' propertySymbol.GetUseSiteDiagnostic()) && ReportUseSiteDiagnostics(getMethod' diagnostics' propertySyntax)) " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckPropertyValueKind,The length of the statement  "                    bool isAccessible = this.IsAccessible(getMethod' accessThroughType' out failedThroughTypeCheck' ref useSiteDiagnostics); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindPossibleArrayInitializer,The length of the statement  "            return BindUnexpectedArrayInitializer((InitializerExpressionSyntax)node' diagnostics' ErrorCode.ERR_ArrayInitToNonArrayType); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateAnonymousFunctionConversionError,The length of the statement  "                Error(diagnostics' ErrorCode.ERR_ExpressionTreeMustHaveDelegate' syntax' ((NamedTypeSymbol)targetType).TypeArgumentsNoUseSiteDiagnostics[0]); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateAnonymousFunctionConversionError,The length of the statement  "                        Error(diagnostics' ErrorCode.ERR_ParameterIsStaticClass' anonymousFunction.ParameterLocation(i)' delegateParameters[i].Type); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateAnonymousFunctionConversionError,The length of the statement  "                        SymbolDistinguisher distinguisher = new SymbolDistinguisher(this.Compilation' lambdaParameterType' delegateParameterType); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The length of the statement  "                        Error(diagnostics' ErrorCode.ERR_LiteralDoubleCast' syntax' (targetType.SpecialType == SpecialType.System_Single) ? "F" : "M"' targetType); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The length of the statement  "                    else if (conversion.Kind == ConversionKind.ExplicitNumeric && sourceConstantValueOpt != null && sourceConstantValueOpt != ConstantValue.Bad && " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The length of the statement  "                        ConversionsBase.HasImplicitConstantExpressionConversion(new BoundLiteral(syntax' ConstantValue.Bad' sourceType)' targetType)) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The length of the statement  "                        Error(diagnostics' ErrorCode.ERR_AmbigUDConv' syntax' originalUserDefinedConversions[0]' originalUserDefinedConversions[1]' sourceType' targetType); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The length of the statement  "                GenerateImplicitConversionError(diagnostics' this.Compilation' syntax' conversion' sourceType' targetType' expression.ConstantValue); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The length of the statement  "                    if (nodeForSquiggle.Kind() == SyntaxKind.SimpleMemberAccessExpression || nodeForSquiggle.Kind() == SyntaxKind.PointerMemberAccessExpression) " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The length of the statement  "            Debug.Assert(expression.HasAnyErrors && expression.Kind != BoundKind.UnboundLambda' "Missing a case in implicit conversion error reporting"); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBooleanExpression,The length of the statement  "                return BoundConversion.Synthesized(node' expr' Conversion.NoConversion' false' false' ConstantValue.NotAvailable' boolean' hasErrors: true); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBooleanExpression,The length of the statement  "                        if (assignment.Right.Kind == BoundKind.Literal && assignment.Right.ConstantValue.Discriminator == ConstantValueTypeDiscriminator.Boolean) " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBooleanExpression,The length of the statement  "            var best = this.UnaryOperatorOverloadResolution(UnaryOperatorKind.True' expr' node' diagnostics' out resultKind' out originalUserDefinedOperators); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBooleanExpression,The length of the statement  "                Debug.Assert(resultKind == LookupResultKind.Empty' "How could overload resolution fail if a user-defined true operator was found?"); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBooleanExpression,The length of the statement  "                Debug.Assert(originalUserDefinedOperators.IsEmpty' "How could overload resolution fail if a user-defined true operator was found?"); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBooleanExpression,The length of the statement  "                return BoundConversion.Synthesized(node' expr' Conversion.NoConversion' false' false' ConstantValue.NotAvailable' boolean' hasErrors: true); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindBooleanExpression,The length of the statement  "            return new BoundUnaryOperator(node' signature.Kind' resultOperand' ConstantValue.NotAvailable' signature.Method' resultKind' originalUserDefinedOperators' signature.ReturnType) " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindForOrUsingOrFixedDeclarations,The length of the statement  "                var declaration = BindVariableDeclaration(localKind' isVar' variableDeclarator' typeSyntax' declType' alias' diagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCatchBlock,The length of the statement  "                            // If the RuntimeCompatibility(WrapNonExceptionThrows = false) is applied on the source assembly or any referenced netmodule. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportCantConvertLambdaReturn,The length of the statement  "                    // Cannot convert async {0} to intended delegate type. An async {0} may return void' Task or Task<T>' none of which are convertible to '{1}'. " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportCantConvertLambdaReturn,The length of the statement  "                    // Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CreateBlockFromExpression,The length of the statement  "            return new BoundBlock(node' locals' ImmutableArray.Create(statement)) { WasCompilerGenerated = node.Kind() != SyntaxKind.ArrowExpressionClause }; " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindTypeOrAlias,The length of the statement  "                this.LookupSymbolsInternal(lookupResult' identifierValueText' arity: 0' useSiteDiagnostics: ref useSiteDiagnostics' basesBeingResolved: basesBeingResolved' " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindTypeOrAlias,The length of the statement  "            var diagnosticInfo = diagnostics.Add(ErrorCode.ERR_BadSKknown' syntax.Location' syntax' symbol.GetKindText()' MessageID.IDS_SK_TYPE.Localize()); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindTypeOrAlias,The length of the statement  "            return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbol)' symbol' LookupResultKind.NotATypeOrNamespace' diagnosticInfo); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNamespaceAliasSymbol,The length of the statement  "                Symbol bindingResult = ResultSymbol(result' plainName' 0' node' diagnostics' false' out wasError' options: LookupOptions.NamespaceAliasesOnly); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNamespaceOrTypeOrAliasSymbol,The length of the statement  "                    return BindNonGenericSimpleName((IdentifierNameSyntax)syntax' diagnostics' basesBeingResolved' suppressUseSiteDiagnostics' qualifierOpt: null); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNamespaceOrTypeOrAliasSymbol,The length of the statement  "                            return new ExtendedErrorTypeSymbol(left' LookupResultKind.NotATypeOrNamespace' diagnostics.Add(ErrorCode.ERR_ColColWithTypeAlias' node.Alias.Location' node.Alias.Identifier.Text)); " is 180.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleName,The length of the statement  "                    return new ExtendedErrorTypeSymbol(qualifierOpt ?? this.Compilation.Assembly.GlobalNamespace' string.Empty' arity: 0' errorInfo: null); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleName,The length of the statement  "                    return BindNonGenericSimpleName((IdentifierNameSyntax)syntax' diagnostics' basesBeingResolved' suppressUseSiteDiagnostics' qualifierOpt); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNonGenericSimpleName,The length of the statement  "            LookupOptions options = isNameofArgument ? LookupOptions.AllMethodsOnArityZero | LookupOptions.AllNamedTypesOnArityZero : GetSimpleNameLookupOptions(node' node.Identifier.IsVerbatimIdentifier()); " is 195.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNonGenericSimpleName,The length of the statement  "            this.LookupSymbolsSimpleName(result' qualifierOpt' identifierValueText' 0' basesBeingResolved' options' diagnose: true' useSiteDiagnostics: ref useSiteDiagnostics); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNonGenericSimpleName,The length of the statement  "                    bindingResult = ResultSymbol(result' identifierValueText' 0' node' diagnostics' suppressUseSiteDiagnostics' out wasError' qualifierOpt' options); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForDynamic,The length of the statement  "            // Here we report the use site error (ERR_DynamicAttributeMissing) for missing DynamicAttribute type or it's constructors. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForDynamic,The length of the statement  "            // BREAKING CHANGE: Native compiler reports ERR_DynamicAttributeMissing at emit time when synthesizing DynamicAttribute. " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForDynamic,The length of the statement  "            //                  Currently' in Roslyn we don't support reporting diagnostics while synthesizing attributes' these diagnostics are reported at bind time. " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForDynamic,The length of the statement  "            //                  Hence' we report this diagnostic here. Note that DynamicAttribute has two constructors' and either of them may be used while " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForDynamic,The length of the statement  "            //                  However' unlike the native compiler which reports use site diagnostic only for the specific DynamicAttribute constructor which is going to be used' " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForDynamic,The length of the statement  "            //                  This is a breaking change for the case where only one of the two constructor of DynamicAttribute is missing' but we never use it for any of the synthesized DynamicAttributes. " is 194.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForDynamic,The length of the statement  "                if ((object)this.Compilation.GetWellKnownTypeMember(WellKnownMember.System_Runtime_CompilerServices_DynamicAttribute__ctor) == null || " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForDynamic,The length of the statement  "                    (object)this.Compilation.GetWellKnownTypeMember(WellKnownMember.System_Runtime_CompilerServices_DynamicAttribute__ctorTransformFlags) == null) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForDynamic,The length of the statement  "                    // CONSIDER:    Native compiler reports error CS1980 for each syntax node which binds to dynamic type' we do the same by reporting a diagnostic here. " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForDynamic,The length of the statement  "                    //              We may want to consider adding an "Unreported" flag to the DynamicTypeSymbol to supress duplicate CS1980. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUseSiteDiagnosticForDynamic,The length of the statement  "                    // CS1980: Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference? " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupGenericTypeName,The length of the statement  "            this.LookupSymbolsSimpleName(lookupResult' qualifierOpt' plainName' arity' basesBeingResolved' options' diagnose: true' useSiteDiagnostics: ref useSiteDiagnostics); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,LookupGenericTypeName,The length of the statement  "            Symbol lookupResultSymbol = ResultSymbol(lookupResult' plainName' arity' node' diagnostics' (basesBeingResolved != null)' out wasError' qualifierOpt' options); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ConstructNamedTypeUnlessTypeArgumentOmitted,The length of the statement  "                Error(diagnostics' ErrorCode.ERR_BadArity' typeSyntax' type' MessageID.IDS_SK_TYPE.Localize()' typeArgumentsSyntax.Count); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ConstructNamedTypeUnlessTypeArgumentOmitted,The length of the statement  "                return ConstructNamedType(type' typeSyntax' typeArgumentsSyntax' typeArguments' basesBeingResolved: null' diagnostics: diagnostics); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ConstructBoundMemberGroupAndReportOmittedTypeArguments,The length of the statement  "                Error(diagnostics' ErrorCode.ERR_BadArity' syntax' plainName' MessageID.IDS_MethodGroup.Localize()' typeArgumentsSyntax.Count); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ConstructNamedType,The length of the statement  "                type.CheckConstraints(this.Conversions' typeSyntax' typeArgumentsSyntax' this.Compilation' basesBeingResolved' diagnostics); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindQualifiedName,The length of the statement  "            var right = this.BindSimpleName(rightName' diagnostics' basesBeingResolved' suppressUseSiteDiagnostics' left) as NamespaceOrTypeSymbol; " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetSpecialTypeMember,The length of the statement  "                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_MissingPredefinedMember' memberDescriptor.DeclaringTypeMetadataName' memberDescriptor.Name)' syntax.Location); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetWellKnownTypeMember,The length of the statement  "                diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_MissingPredefinedMember' memberDescriptor.DeclaringTypeMetadataName' memberDescriptor.Name); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The length of the statement  "                                // ErrorCode.WRN_SameFullNameThisNsAgg: The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'. " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The length of the statement  "                                // ErrorCode.WRN_SameFullNameThisAggNs: The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'. " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The length of the statement  "                                // WRN_SameFullNameThisAggAgg: The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'. " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The length of the statement  "                        singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(singleResult)' singleResult' LookupResultKind.NotReferencable' errorInfo); // UNDONE: Review resultkind. " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The length of the statement  "                                    singleResult = new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(errorType)' errorType.Name' errorType.Arity' errorInfo' unreported: false); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The length of the statement  "                CSDiagnosticInfo info = NotFound(where' simpleName' arity' where.ToString()' diagnostics' aliasOpt' qualifierOpt' options); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The length of the statement  "                // Bad type or namespace (or things expected as types/namespaces) are packaged up as error types' preserving the symbols and the result kind. " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The length of the statement  "                // We do this if there are multiple symbols too' because just returning one would be losing important information' and they might " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The length of the statement  "                return new ExtendedErrorTypeSymbol(GetContainingNamespaceOrType(symbols[0])' symbols.ToImmutable()' result.Kind' result.Error' arity); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,NotFound,The length of the statement  "                var code = (where.Parent is QueryClauseSyntax) ? ErrorCode.ERR_TypeVarNotFoundRangeVariable : ErrorCode.ERR_TypeVarNotFound; " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportUnsafeIfNotAllowed,The length of the statement  "            Debug.Assert((node.Kind() == SyntaxKind.SizeOfExpression) == !ReferenceEquals(sizeOfTypeOpt' null)' "Should have a type for (only) sizeof expressions."); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,WithQueryLambdaParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.WithQueryLambdaParametersBinder.cs,SelectField,The length of the statement  "                    var info = new CSDiagnosticInfo(ErrorCode.ERR_UnsupportedTransparentIdentifierAccess' name' receiver.ExpressionSymbol ?? receiverType); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,WithQueryLambdaParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.WithQueryLambdaParametersBinder.cs,SelectField,The length of the statement  "                LookupMembersWithFallback(lookupResult' receiver.Type' name' 0' ref useSiteDiagnostics' basesBeingResolved: null' options: options); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,WithQueryLambdaParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.WithQueryLambdaParametersBinder.cs,SelectField,The length of the statement  "                var result = BindMemberOfType(node' node' name' 0' receiver' default(SeparatedSyntaxList<TypeSyntax>)' default(ImmutableArray<TypeSymbol>)' lookupResult' BoundMethodGroupFlags.None' diagnostics); " is 195.
Long Statement,Microsoft.CodeAnalysis.CSharp,WithQueryLambdaParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.WithQueryLambdaParametersBinder.cs,LookupSymbolsInSingleBinder,The length of the statement  "                    result.MergeEqual(originalBinder.CheckViability(rangeVariable' arity' options' null' diagnose' ref useSiteDiagnostics)); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitNamedArgument,The length of the statement  "                                visitedArgument = new KeyValuePair<String' TypedConstant>(fa.FieldSymbol.Name' VisitExpression(assignment.Right' diagnostics' ref attrHasErrors' argument.HasAnyErrors)); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitNamedArgument,The length of the statement  "                                visitedArgument = new KeyValuePair<String' TypedConstant>(pa.PropertySymbol.Name' VisitExpression(assignment.Right' diagnostics' ref attrHasErrors' argument.HasAnyErrors)); " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitExpression,The length of the statement  "                return VisitExpression(node' typedConstantKind' diagnostics' ref attrHasErrors' curArgumentHasErrors || typedConstantKind == TypedConstantKind.Error); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitExpression,The length of the statement  "                    return CreateTypedConstant(node' typedConstantKind' diagnostics' ref attrHasErrors' curArgumentHasErrors' simpleValue: node.ConstantValue.Value); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitConversion,The length of the statement  "                // Devdiv Bug #8763: Additionally we allow conversions from array type to object[]' provided a conversion exists and each array element is a valid attribute argument. " is 166.
Long Statement,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitTypeOfExpression,The length of the statement  "                        Binder.Error(diagnostics' ErrorCode.ERR_AttrArgWithTypeVars' node.Syntax' typeOfArgument.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat)); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitTypeOfExpression,The length of the statement  "                return CreateTypedConstant(node' TypedConstantKind.Type' diagnostics' ref attrHasErrors' curArgumentHasErrors' simpleValue: node.SourceType.Type); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitArrayCreation,The length of the statement  "                            initializer = ImmutableArray.Create(CreateTypedConstant(node' TypedConstantKind.Error' diagnostics' ref attrHasErrors' curArgumentHasErrors)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitArrayCreation,The length of the statement  "                return CreateTypedConstant(node' typedConstantKind' diagnostics' ref attrHasErrors' curArgumentHasErrors' arrayValue: initializer); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetAssociatedMemberForXmlSyntax,The length of the statement  "            Debug.Assert(xmlSyntax is XmlAttributeSyntax || xmlSyntax.Kind() == SyntaxKind.XmlEmptyElement || xmlSyntax.Kind() == SyntaxKind.XmlElementStartTag); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetImportsBinder,The length of the statement  "                        var result = visitor.VisitNamespaceDeclaration((NamespaceDeclarationSyntax)unit' unit.SpanStart' inBody: true' inUsing: false); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,VisitConstructorDeclaration,The length of the statement  "                var extraInfo = inBodyOrInitializer ? NodeUsage.ConstructorBodyOrInitializer : NodeUsage.Normal;  // extra info for the cache. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetMethodName,The length of the statement  "                        return (baseMethodDeclarationSyntax.Modifiers.Any(SyntaxKind.StaticKeyword) ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetMethodName,The length of the statement  "                        return ((ConversionOperatorDeclarationSyntax)baseMethodDeclarationSyntax).ImplicitOrExplicitKeyword.Kind() == SyntaxKind.ImplicitKeyword " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetMethodName,The length of the statement  "                        return ExplicitInterfaceHelpers.GetMemberName(outerBinder' methodDeclSyntax.ExplicitInterfaceSpecifier' methodDeclSyntax.Identifier.ValueText); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetPropertyOrEventName,The length of the statement  "                ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifierSyntax = basePropertyDeclarationSyntax.ExplicitInterfaceSpecifier; " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetPropertyOrEventName,The length of the statement  "                        return ExplicitInterfaceHelpers.GetMemberName(outerBinder' explicitInterfaceSpecifierSyntax' propertyDecl.Identifier.ValueText); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetPropertyOrEventName,The length of the statement  "                        return ExplicitInterfaceHelpers.GetMemberName(outerBinder' explicitInterfaceSpecifierSyntax' WellKnownMemberNames.Indexer); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetPropertyOrEventName,The length of the statement  "                        return ExplicitInterfaceHelpers.GetMemberName(outerBinder' explicitInterfaceSpecifierSyntax' eventDecl.Identifier.ValueText); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetMethodSymbol,The length of the statement  "                return (SourceMethodSymbol)GetMemberSymbol(methodName' baseMethodDeclarationSyntax.FullSpan' container' SymbolKind.Method); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetPropertySymbol,The length of the statement  "                Debug.Assert(basePropertyDeclarationSyntax.Kind() == SyntaxKind.PropertyDeclaration || basePropertyDeclarationSyntax.Kind() == SyntaxKind.IndexerDeclaration); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetPropertySymbol,The length of the statement  "                return (SourcePropertySymbol)GetMemberSymbol(propertyName' basePropertyDeclarationSyntax.Span' container' SymbolKind.Property); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetMemberSymbol,The length of the statement  "                // return container.GetMembers(methodSyntax.Identifier.ValueText).OfType<SourceMethodSymbol>().Single(m => m.Locations.Any(l => l.SourceTree == tree && methodSyntax.Span.Contains(l.SourceSpan))); " is 195.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,VisitDelegateDeclaration,The length of the statement  "                    // NOTE: Hence we can assume that we are in body of the delegate type and explicitly insert the InContainerBinder in the binder chain. " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,VisitEnumDeclaration,The length of the statement  "                // This method has nothing to contribute unless the position is actually inside the enum (i.e. not in the declaration part) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,VisitEnumDeclaration,The length of the statement  "                    var container = ((NamespaceOrTypeSymbol)outer.ContainingMemberOrLambda).GetSourceTypeMember(parent.Identifier.ValueText' 0' SyntaxKind.EnumDeclaration' parent); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,VisitNamespaceDeclaration,The length of the statement  "                var extraInfo = inUsing ? NodeUsage.NamespaceUsings : (inBody ? NodeUsage.NamespaceBody : NodeUsage.Normal);  // extra info for the cache. " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,MakeNamespaceBinder,The length of the statement  "                return new InContainerBinder(ns' outer' node' allowStaticClassUsings: ((CSharpParseOptions)syntaxTree.Options).LanguageVersion >= LanguageVersion.CSharp6' inUsing: inUsing); " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,VisitCompilationUnit,The length of the statement  "                    result = new InContainerBinder(importsContainer' result' compilationUnit' allowStaticClassUsings: ((CSharpParseOptions)syntaxTree.Options).LanguageVersion >= LanguageVersion.CSharp6' inUsing: inUsing); " is 201.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,VisitCrefParameter,The length of the statement  "                XmlCrefAttributeSyntax containingAttribute = parent.FirstAncestorOrSelf<XmlCrefAttributeSyntax>(ascendOutOfTrivia: false); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,VisitConversionOperatorMemberCref,The length of the statement  "                    XmlCrefAttributeSyntax containingAttribute = parent.FirstAncestorOrSelf<XmlCrefAttributeSyntax>(ascendOutOfTrivia: false); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetParameterNameAttributeValueBinder,The length of the statement  "                    SourceNamedTypeSymbol delegateType = ((NamespaceOrTypeSymbol)outerBinder.ContainingMemberOrLambda).GetSourceTypeMember((DelegateDeclarationSyntax)memberSyntax); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetTypeParameterNameAttributeValueBinder,The length of the statement  "                    SourceNamedTypeSymbol typeSymbol = ((NamespaceOrTypeSymbol)outerBinder.ContainingMemberOrLambda).GetSourceTypeMember(typeDeclSyntax); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,GetTypeParameterNameAttributeValueBinder,The length of the statement  "                    SourceNamedTypeSymbol delegateType = ((NamespaceOrTypeSymbol)outerBinder.ContainingMemberOrLambda).GetSourceTypeMember((DelegateDeclarationSyntax)memberSyntax); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,CatchClauseBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\CatchClauseBinder.cs,BuildLocals,The length of the statement  "                local = SourceLocalSymbol.MakeLocal(this.ContainingMemberOrLambda' this' declarationOpt.Type' declarationOpt.Identifier' LocalDeclarationKind.CatchVariable); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,EarlyWellKnownAttributeBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\EarlyWellKnownAttributeBinder.cs,CanBeValidAttributeArgument,The length of the statement  "                // ObjectCreationExpression for primitive types' such as "new int()"' are treated as constants and allowed in attribute arguments. " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,EarlyWellKnownAttributeBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\EarlyWellKnownAttributeBinder.cs,CanBeValidAttributeArgument,The length of the statement  "                //  The predefined +' –' *' /' %' <<' >>' &' |' ^' &&' ||' ==' !=' <' >' <=' and >= binary operators' provided each operand is of a type listed above. " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "            BoundExpression collectionExpr = this.Next.BindValue(_syntax.Expression' diagnostics' BindValueKind.RValue); //bind with next to avoid seeing iteration variable " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "            bool hasErrors = !GetEnumeratorInfoAndInferCollectionElementType(ref builder' ref collectionExpr' diagnostics' out inferredType); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "            // Skip the conversion checks and array/enumerator differentiation if we know we have an error (except local name conflicts). " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "            ReportDiagnosticsIfObsolete(diagnostics' builder.CurrentPropertyGetter.AssociatedSymbol' foreachKeyword' hasBaseReceiver: false); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "            Conversion elementConversion = this.Conversions.ClassifyConversionForCast(inferredType' iterationVariableType' ref useSiteDiagnostics); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_AmbigUDConv' _syntax.ForEachKeyword.GetLocation()' originalUserDefinedConversions[0]' originalUserDefinedConversions[1]' inferredType' iterationVariableType); " is 188.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_NoExplicitConv' _syntax.ForEachKeyword.GetLocation()' distinguisher.First' distinguisher.Second); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "            // If the type X of expression is dynamic then there is an implicit conversion from >>expression<< (not the type of the expression)  " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "            builder.CollectionConversion = this.Conversions.ClassifyConversionFromExpression(collectionExpr' builder.CollectionType' ref useSiteDiagnostics); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "            builder.CurrentConversion = this.Conversions.ClassifyConversion(builder.CurrentPropertyGetter.ReturnType' builder.ElementType' ref useSiteDiagnostics); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "            builder.EnumeratorConversion = this.Conversions.ClassifyConversion(builder.GetEnumeratorMethod.ReturnType' GetSpecialType(SpecialType.System_Object' diagnostics' _syntax)' ref useSiteDiagnostics); " is 196.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,BindForEachPartsWorker,The length of the statement  "                (builder.ElementType.IsNullableType() && builder.ElementType.GetMemberTypeArgumentsNoUseSiteDiagnostics().Single().IsErrorType() && collectionExpr.Type.IsArray())); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfoAndInferCollectionElementType,The length of the statement  "            else if (collectionExpr.Type.SpecialType == SpecialType.System_String && builder.CollectionType.SpecialType == SpecialType.System_Collections_IEnumerable) " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,UnwrapCollectionExpressionIfNullable,The length of the statement  "            // If collectionExprType is a nullable type' then use the underlying type and take the value (i.e. .Value) of collectionExpr. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,UnwrapCollectionExpressionIfNullable,The length of the statement  "                MethodSymbol nullableValueGetter = (MethodSymbol)GetSpecialTypeMember(SpecialMember.System_Nullable_T_get_Value' diagnostics' exprSyntax); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                    (_syntax.Type.IsVar ? (TypeSymbol)DynamicTypeSymbol.Instance : GetSpecialType(SpecialType.System_Object' diagnostics' _syntax)) : " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                // For arrays none of these members will actually be emitted' so it seems strange to prevent compilation if they can't be found. " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                builder.GetEnumeratorMethod = (MethodSymbol)GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerable__GetEnumerator' diagnostics' _syntax); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                builder.CurrentPropertyGetter = (MethodSymbol)GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerator__get_Current' diagnostics' _syntax); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                builder.MoveNextMethod = (MethodSymbol)GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerator__MoveNext' diagnostics' _syntax); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                // We don't know the runtime type' so we will have to insert a runtime check for IDisposable (with a conditional call to IDisposable.Dispose). " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                    if (!enumeratorType.IsSealed || this.Conversions.ClassifyImplicitConversion(enumeratorType' this.Compilation.GetSpecialType(SpecialType.System_IDisposable)' ref useSiteDiagnostics).IsImplicit) " is 192.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_BadGetEnumerator' _syntax.Expression.Location' getEnumeratorMethod.ReturnType' getEnumeratorMethod); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_ForEachMissingMember' _syntax.Expression.Location' collectionExprType' GetEnumeratorMethodName); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "            if (AllInterfacesContainsIEnumerable(ref builder' collectionExprType' diagnostics' out foundMultipleGenericIEnumerableInterfaces)) " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_MultipleIEnumOfT' errorLocationSyntax.Location' collectionExprType' this.Compilation.GetSpecialType(SpecialType.System_Collections_Generic_IEnumerable_T)); " is 185.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                    MethodSymbol getEnumeratorMethod = (MethodSymbol)GetSpecialTypeMember(SpecialMember.System_Collections_Generic_IEnumerable_T__GetEnumerator' diagnostics' errorLocationSyntax); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                        MethodSymbol currentPropertyGetter = (MethodSymbol)GetSpecialTypeMember(SpecialMember.System_Collections_Generic_IEnumerator_T__get_Current' diagnostics' errorLocationSyntax); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                    builder.MoveNextMethod = (MethodSymbol)GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerator__MoveNext' diagnostics' errorLocationSyntax); // NOTE: MoveNext is actually inherited from System.Collections.IEnumerator " is 226.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                    builder.GetEnumeratorMethod = (MethodSymbol)GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerable__GetEnumerator' diagnostics' errorLocationSyntax); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                    builder.CurrentPropertyGetter = (MethodSymbol)GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerator__get_Current' diagnostics' errorLocationSyntax); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                    builder.MoveNextMethod = (MethodSymbol)GetSpecialTypeMember(SpecialMember.System_Collections_IEnumerator__MoveNext' diagnostics' errorLocationSyntax); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                        builder.GetEnumeratorMethod.ReturnType == GetSpecialType(SpecialType.System_Collections_IEnumerator' diagnostics' errorLocationSyntax)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                // We don't know the runtime type' so we will have to insert a runtime check for IDisposable (with a conditional call to IDisposable.Dispose). " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,GetEnumeratorInfo,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_ForEachMissingMember' _syntax.Expression.Location' collectionExprType.ToDisplayString()' GetEnumeratorMethodName); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,SatisfiesGetEnumeratorPattern,The length of the statement  "            MethodSymbol getEnumeratorMethod = FindForEachPatternMethod(collectionExprType' GetEnumeratorMethodName' lookupResult' warningsOnly: true' diagnostics: diagnostics); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,FindForEachPatternMethod,The length of the statement  "            MethodSymbol patternMethod = PerformForEachPatternOverloadResolution(patternType' candidateMethods' warningsOnly' diagnostics); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,PerformForEachPatternOverloadResolution,The length of the statement  "            this.OverloadResolution.MethodInvocationOverloadResolution(candidateMethods' typeArguments' arguments' overloadResolutionResult' ref useSiteDiagnostics); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,PerformForEachPatternOverloadResolution,The length of the statement  "                        diagnostics.Add(ErrorCode.WRN_PatternStaticOrInaccessible' _syntax.Expression.Location' patternType' MessageID.IDS_Collection.Localize()' result); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,PerformForEachPatternOverloadResolution,The length of the statement  "                    // Calls to this method are omitted in the current syntax tree' i.e it is either a partial method with no implementation part OR a conditional method whose condition is not true in this source file. " is 198.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,PerformForEachPatternOverloadResolution,The length of the statement  "                    diagnostics.Add(ErrorCode.WRN_PatternIsAmbiguous' _syntax.Expression.Location' patternType' MessageID.IDS_Collection.Localize()' " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,SatisfiesForEachPattern,The length of the statement  "                    ReportPatternMemberLookupDiagnostics(lookupResult' enumeratorType' CurrentPropertyName' warningsOnly: false' diagnostics: diagnostics); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,SatisfiesForEachPattern,The length of the statement  "                if (lookupSymbol.IsStatic || lookupSymbol.DeclaredAccessibility != Accessibility.Public || lookupSymbol.Kind != SymbolKind.Property) " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,SatisfiesForEachPattern,The length of the statement  "                MethodSymbol moveNextMethodCandidate = FindForEachPatternMethod(enumeratorType' MoveNextMethodName' lookupResult' warningsOnly: false' diagnostics: diagnostics); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,SatisfiesForEachPattern,The length of the statement  "                // SPEC VIOLATION: Dev10 checks the return type of the original definition' rather than the return type of the actual method. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,ReportEnumerableWarning,The length of the statement  "                diagnostics.Add(ErrorCode.WRN_PatternBadSignature' _syntax.Expression.Location' enumeratorType' MessageID.IDS_Collection.Localize()' patternMemberCandidate); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,AllInterfacesContainsIEnumerable,The length of the statement  "                GetIEnumerableOfT(typeParameter.EffectiveBaseClass(ref useSiteDiagnostics).AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)' ref @implementedIEnumerable' ref foundMultiple); " is 194.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,AllInterfacesContainsIEnumerable,The length of the statement  "                GetIEnumerableOfT(typeParameter.AllEffectiveInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)' ref @implementedIEnumerable' ref foundMultiple); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,AllInterfacesContainsIEnumerable,The length of the statement  "                GetIEnumerableOfT(type.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)' ref @implementedIEnumerable' ref foundMultiple); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,ForLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForLoopBinder.cs,BindForParts,The length of the statement  "                initializer = this.BindForOrUsingOrFixedDeclarations(node.Declaration' LocalDeclarationKind.ForInitializerVariable' diagnostics' out unused); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,HostObjectModelBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\HostObjectModeBinder.cs,LookupSymbolsInSingleBinder,The length of the statement  "                LookupMembersInternal(result' hostObjectType' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,ImportChain,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ImportChain.cs,TryGetAssemblyScope,The length of the statement  "            if ((object)containingAssembly != null && (object)containingAssembly != context.ModuleBuilder.CommonCompilation.Assembly) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,FromSyntax,The length of the statement  "                // A binder that contains the extern aliases but not the usings. The resolution of the target of a using directive or alias  " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,FromSyntax,The length of the statement  "                            usingAliases.Add(identifierValueText' new AliasAndUsingDirective(new AliasSymbol(usingsBinder' usingDirective)' usingDirective)); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,FromGlobalUsings,The length of the statement  "                boundUsings.Add(new NamespaceOrTypeAndUsingDirective(usingsBinder.BindNamespaceOrTypeSymbol(qualifiedName' diagnostics)' null)); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,FromGlobalUsings,The length of the statement  "            return new Imports(compilation' null' boundUsings.ToImmutableAndFree()' ImmutableArray<AliasAndExternAliasDirective>.Empty' diagnostics); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupSymbol,The length of the statement  "            LookupSymbolInAliases(originalBinder' result' name' arity' basesBeingResolved' options' diagnose' ref useSiteDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupSymbol,The length of the statement  "                LookupSymbolInUsings(this.Usings' originalBinder' result' name' arity' basesBeingResolved' options' diagnose' ref useSiteDiagnostics); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupSymbolInAliases,The length of the statement  "                var res = originalBinder.CheckViability(alias.Alias' arity' options' null' diagnose' ref useSiteDiagnostics' basesBeingResolved); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupSymbolInAliases,The length of the statement  "                    var res = originalBinder.CheckViability(a.Alias' arity' options' null' diagnose' ref useSiteDiagnostics' basesBeingResolved); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupSymbolInUsings,The length of the statement  "                ImmutableArray<Symbol> candidates = Binder.GetCandidateMembers(typeOrNamespace.NamespaceOrType' name' options' originalBinder: originalBinder); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupSymbolInUsings,The length of the statement  "                    var res = originalBinder.CheckViability(symbol' arity' options' null' diagnose' ref useSiteDiagnostics' basesBeingResolved); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupExtensionMethodsInUsings,The length of the statement  "            // We need to avoid collecting multiple candidates for an extension method imported both through a namespace and a static class " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,InContainerBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InContainerBinder.cs,GetImports,The length of the statement  "                Interlocked.CompareExchange(ref _imports' Imports.FromSyntax(_declarationSyntax' this' basesBeingResolved' _inUsing)' null); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,InContainerBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InContainerBinder.cs,IsAccessible,The length of the statement  "                return this.IsSymbolAccessibleConditional(symbol' type' accessThroughType' out failedThroughTypeCheck' ref useSiteDiagnostics); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,InContainerBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InContainerBinder.cs,IsAccessible,The length of the statement  "                return Next.IsAccessible(symbol' accessThroughType' out failedThroughTypeCheck' ref useSiteDiagnostics' basesBeingResolved);  // delegate to containing Binder' eventually checking assembly. " is 189.
Long Statement,Microsoft.CodeAnalysis.CSharp,InContainerBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InContainerBinder.cs,LookupSymbolsInSingleBinder,The length of the statement  "                this.LookupMembersInternal(result' _container' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,InContainerBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InContainerBinder.cs,LookupSymbolsInSingleBinder,The length of the statement  "                this.LookupMembersInternal(result' _container' name' arity' basesBeingResolved' options' originalBinder' diagnose' ref useSiteDiagnostics); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,InContainerBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InContainerBinder.cs,LookupSymbolsInSingleBinder,The length of the statement  "            imports.LookupSymbol(originalBinder' result' name' arity' basesBeingResolved' options' diagnose' ref useSiteDiagnostics); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,InContainerBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InContainerBinder.cs,AddLookupSymbolsInfoInSingleBinder,The length of the statement  "                LookupOptions usingOptions = (options & ~(LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) | LookupOptions.MustNotBeNamespace; " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,InMethodBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InMethodBinder.cs,LookupSymbolsInSingleBinder,The length of the statement  "                result.MergeEqual(originalBinder.CheckViability(parameterSymbol' arity' options' null' diagnose' ref useSiteDiagnostics)); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,InMethodBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InMethodBinder.cs,ReportConflictWithParameter,The length of the statement  "            Debug.Assert(oldLocation != newLocation || oldLocation == Location.None' "same nonempty location refers to different symbols?"); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,InMethodBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InMethodBinder.cs,ReportConflictWithParameter,The length of the statement  "                    // A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalBinderFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LocalBinderFactory.cs,VisitFinallyClause,The length of the statement  "            Debug.Assert(_map.TryGetValue(node.Block' out finallyBinder) && finallyBinder.Flags.Includes(BinderFlags.InFinallyBlock)); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalScopeBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LocalScopeBinder.cs,LookupSymbolsInSingleBinder,The length of the statement  "                    result.MergeEqual(originalBinder.CheckViability(localSymbol' arity' options' null' diagnose' ref useSiteDiagnostics' basesBeingResolved)); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalScopeBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LocalScopeBinder.cs,ReportConflictWithLocal,The length of the statement  "                if (this.Locals.Contains((LocalSymbol)newSymbol) && newLocation.SourceSpan.Start >= local.Locations[0].SourceSpan.Start) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalScopeBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LocalScopeBinder.cs,ReportConflictWithLocal,The length of the statement  "                // A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,LockOrUsingBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LockOrUsingBinder.cs,BindTargetExpression,The length of the statement  "                BoundExpression boundExpression = this.BindValue(TargetExpressionSyntax' expressionDiagnostics' Binder.BindValueKind.RValueOrMethodGroup); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,LockOrUsingBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LockOrUsingBinder.cs,BindTargetExpression,The length of the statement  "                Interlocked.CompareExchange(ref _lazyExpressionAndDiagnostics' new ExpressionAndDiagnostics(boundExpression' expressionDiagnostics.ToReadOnlyAndFree())' null); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,LookupOptionExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LookupOptions.cs,AreValid,The length of the statement  "            // If MustNotBeNamespace or MustNotBeMethodTypeParameter is set' neither NamespaceAliasesOnly nor NamespacesOrTypesOnly must be set. " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,LookupOptionExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LookupOptions.cs,CanConsiderMembers,The length of the statement  "            return (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly | LookupOptions.LabelsOnly)) == 0; " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LookupOptionExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LookupOptions.cs,CanConsiderLocals,The length of the statement  "            return (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly | LookupOptions.LabelsOnly)) == 0; " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LookupOptionExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LookupOptions.cs,CanConsiderTypes,The length of the statement  "            return (options & (LookupOptions.NamespaceAliasesOnly | LookupOptions.MustBeInvocableIfMember | LookupOptions.MustBeInstance | LookupOptions.LabelsOnly)) == 0; " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,LookupOptionExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LookupOptions.cs,CanConsiderNamespaces,The length of the statement  "            return (options & (LookupOptions.MustNotBeNamespace | LookupOptions.MustBeInvocableIfMember | LookupOptions.MustBeInstance | LookupOptions.LabelsOnly)) == 0; " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,LookupResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LookupResult.cs,NotTypeOrNamespace,The length of the statement  "            var diagInfo = diagnose ? new CSDiagnosticInfo(ErrorCode.ERR_BadSKknown' unwrappedSymbol' unwrappedSymbol.GetKindText()' MessageID.IDS_SK_TYPE.Localize()) : null; " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsSymbolAccessible,The length of the statement  "            return IsSymbolAccessibleCore(symbol' within' null' out failedThroughTypeCheck' within.DeclaringCompilation' ref useSiteDiagnostics); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsSymbolAccessible,The length of the statement  "            return IsSymbolAccessibleCore(symbol' within' throughTypeOpt' out failedThroughTypeCheck' within.DeclaringCompilation' ref useSiteDiagnostics); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsSymbolAccessible,The length of the statement  "            return IsSymbolAccessibleCore(symbol' within' throughTypeOpt' out failedThroughTypeCheck' within.DeclaringCompilation' ref useSiteDiagnostics' basesBeingResolved); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsSymbolAccessibleCore,The length of the statement  "                    return IsSymbolAccessibleCore(((ArrayTypeSymbol)symbol).ElementType' within' null' out failedThroughTypeCheck' compilation' ref useSiteDiagnostics); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsSymbolAccessibleCore,The length of the statement  "                    return IsSymbolAccessibleCore(((PointerTypeSymbol)symbol).PointedAtType' within' null' out failedThroughTypeCheck' compilation' ref useSiteDiagnostics); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsSymbolAccessibleCore,The length of the statement  "                    return IsMemberAccessible(symbol.ContainingType' symbol.DeclaredAccessibility' within' throughTypeOpt' out failedThroughTypeCheck' compilation' ref useSiteDiagnostics); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsNamedTypeAccessible,The length of the statement  "                    if (typeArgs[i].Kind != SymbolKind.TypeParameter && !IsSymbolAccessibleCore(typeArgs[i]' within' null' out unused' compilation' ref useSiteDiagnostics)) " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsNamedTypeAccessible,The length of the statement  "                : IsMemberAccessible(containingType' type.DeclaredAccessibility' within' null' out unused' compilation' ref useSiteDiagnostics' basesBeingResolved); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsNonPublicMemberAccessible,The length of the statement  "                    return IsProtectedSymbolAccessible(withinType' throughTypeOpt' originalContainingType' out failedThroughTypeCheck' compilation' ref useSiteDiagnostics' basesBeingResolved); " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsNonPublicMemberAccessible,The length of the statement  "                    return IsProtectedSymbolAccessible(withinType' throughTypeOpt' originalContainingType' out failedThroughTypeCheck' compilation' ref useSiteDiagnostics' basesBeingResolved); " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsNonPublicMemberAccessible,The length of the statement  "                    return IsProtectedSymbolAccessible(withinType' throughTypeOpt' originalContainingType' out failedThroughTypeCheck' compilation' ref useSiteDiagnostics' basesBeingResolved); " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,AccessCheck,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\AccessCheck.cs,IsProtectedSymbolAccessible,The length of the statement  "                    if (current.InheritsFromIgnoringConstruction(originalContainingType' compilation' ref useSiteDiagnostics' basesBeingResolved)) " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,BestTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\BestTypeInferrer.cs,InferBestType,The length of the statement  "            // SPEC:    In some cases' a common type needs to be inferred for a set of expressions. In particular' the element types of implicitly typed arrays and " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,BestTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\BestTypeInferrer.cs,InferBestType,The length of the statement  "            // SPEC:    More precisely' the inference starts out with an unfixed type variable X. Output type inferences are then made from each Ei to X. " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,BestTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\BestTypeInferrer.cs,InferBestType,The length of the statement  "            // SPEC:    Finally' X is fixed and' if successful' the resulting type S is the resulting best common type for the expressions. " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,BestTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\BestTypeInferrer.cs,InferBestTypeForConditionalOperator,The length of the statement  "            // SPEC:        o	If an implicit conversion (§6.1) exists from X to Y' but not from Y to X' then Y is the type of the conditional expression. " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,BestTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\BestTypeInferrer.cs,InferBestTypeForConditionalOperator,The length of the statement  "            // SPEC:        o	If an implicit conversion (§6.1) exists from Y to X' but not from X to Y' then X is the type of the conditional expression. " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,BestTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\BestTypeInferrer.cs,InferBestTypeForConditionalOperator,The length of the statement  "            // SPEC:    •	If only one of x and y has a type' and both x and y' are implicitly convertible to that type' then that is the type of the conditional expression. " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ClassifyConversionForCast,The length of the statement  "            Conversion explicitConversion = ClassifyExplicitOnlyConversionFromExpression(source' source.Type' destination' ref useSiteDiagnostics); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ClassifyImplicitBuiltInConversionFromExpression,The length of the statement  "                    Conversion methodGroupConversion = GetMethodGroupConversion((BoundMethodGroup)sourceExpression' destination' ref useSiteDiagnostics); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ClassifyImplicitBuiltInConversionFromExpression,The length of the statement  "                    Conversion interpolatedStringConversion = GetInterpolatedStringConversion((BoundInterpolatedString)sourceExpression' destination' ref useSiteDiagnostics); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ClassifyImplicitConversionFromExpression,The length of the statement  "            return ClassifyImplicitConversionFromExpression(sourceExpression' sourceExpression.Type' destination' ref useSiteDiagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ClassifyImplicitConversionFromExpression,The length of the statement  "            Conversion conversion = ClassifyImplicitBuiltInConversionFromExpression(sourceExpression' source' destination' ref useSiteDiagnostics); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasImplicitConstantExpressionConversion,The length of the statement  "            else if (specialSource == SpecialType.System_Int64 && destination.GetSpecialTypeSafe() == SpecialType.System_UInt64 && (constantValue.IsBad || 0 <= constantValue.Int64Value)) " is 174.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,IsAnonymousFunctionCompatibleWithDelegate,The length of the statement  "                            !delegateParameters[p].Type.Equals(anonymousFunction.ParameterType(p)' ignoreCustomModifiers: true' ignoreDynamic: true)) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ClassifyImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            UserDefinedConversionResult result = AnalyzeImplicitUserDefinedConversionForSwitchGoverningType(sourceType' ref useSiteDiagnostics); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetCallerLineNumberConversion,The length of the statement  "            var greenNode = new Syntax.InternalSyntax.LiteralExpressionSyntax(SyntaxKind.NumericLiteralExpression' new Syntax.InternalSyntax.SyntaxToken(SyntaxKind.NumericLiteralToken)); " is 174.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetCallerLineNumberConversion,The length of the statement  "            BoundLiteral intMaxValueLiteral = new BoundLiteral(syntaxNode' ConstantValue.Create(int.MaxValue)' expectedAttributeType); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetCallerLineNumberConversion,The length of the statement  "            return ClassifyStandardImplicitConversion(intMaxValueLiteral' expectedAttributeType' destination' ref useSiteDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,IsBaseClass,The length of the statement  "            for (TypeSymbol b = derivedType.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics); (object)b != null; b = b.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)) " is 188.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ClassifyStandardConversion,The length of the statement  "            Conversion conversion = ClassifyStandardImplicitConversion(sourceExpression' source' destination' ref useSiteDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ClassifyStandardImplicitConversion,The length of the statement  "            Conversion conversion = ClassifyImplicitBuiltInConversionFromExpression(sourceExpression' source' destination' ref useSiteDiagnostics); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetImplicitUserDefinedConversion,The length of the statement  "            var conversionResult = AnalyzeImplicitUserDefinedConversions(sourceExpression' source' destination' ref useSiteDiagnostics); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetExplicitUserDefinedConversion,The length of the statement  "            UserDefinedConversionResult conversionResult = AnalyzeExplicitUserDefinedConversions(sourceExpression' source' destination' ref useSiteDiagnostics); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasSpecialIntPtrConversion,The length of the statement  "            TypeSymbol otherType = (s0.SpecialType == SpecialType.System_UIntPtr || s0.SpecialType == SpecialType.System_IntPtr) ? t0 : s0; " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasImplicitConversionToInterface,The length of the statement  "            if (source.IsInterfaceType() && source != destination && HasInterfaceVarianceConversion(source' destination' ref useSiteDiagnostics)) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasImplicitConversionFromArray,The length of the statement  "            if (IsBaseInterface(destination' this.corLibrary.GetDeclaredSpecialType(SpecialType.System_Array)' ref useSiteDiagnostics)) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasImplicitConversionFromDelegate,The length of the statement  "                IsBaseInterface(destination' this.corLibrary.GetDeclaredSpecialType(SpecialType.System_MulticastDelegate)' ref useSiteDiagnostics)) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasVariantConversionNoCycleCheck,The length of the statement  "                    if (typeParameterSymbol.Variance == VarianceKind.Out && !HasImplicitReferenceConversion(sourceTypeArgument' destinationTypeArgument' ref useSiteDiagnostics)) " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasVariantConversionNoCycleCheck,The length of the statement  "                    if (typeParameterSymbol.Variance == VarianceKind.In && !HasImplicitReferenceConversion(destinationTypeArgument' sourceTypeArgument' ref useSiteDiagnostics)) " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceConversion,The length of the statement  "            if (source.IsClassType() && destination.IsInterfaceType() && !source.IsSealed && !HasAnyBaseInterfaceConversion(source' destination' ref useSiteDiagnostics)) " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceConversion,The length of the statement  "            if (source.IsInterfaceType() && destination.IsClassType() && (!destination.IsSealed || HasAnyBaseInterfaceConversion(destination' source' ref useSiteDiagnostics))) " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceConversion,The length of the statement  "            if (source.IsInterfaceType() && destination.IsInterfaceType() && !HasImplicitConversionToInterface(source' destination' ref useSiteDiagnostics)) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceConversion,The length of the statement  "            // SPEC: UNDONE: From a reference type to a reference type T if it has an explicit reference conversion to a reference type T0 and T0 has an identity conversion T. " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceConversion,The length of the statement  "            // SPEC: UNDONE: From a reference type to an interface or delegate type T if it has an explicit reference conversion to an interface or delegate type T0 and either T0 is variance-convertible to T or T is variance-convertible to T0 (Â§13.1.3.2). " is 244.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceTypeParameterConversion,The length of the statement  "                for (var type = t.EffectiveBaseClass(ref useSiteDiagnostics); (object)type != null; type = type.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)) " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceTypeParameterConversion,The length of the statement  "            if ((object)s != null && s.IsReferenceType && destination.IsInterfaceType() && !HasImplicitReferenceTypeParameterConversion(s' destination' ref useSiteDiagnostics)) " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasUnboxingTypeParameterConversion,The length of the statement  "                for (var type = t.EffectiveBaseClass(ref useSiteDiagnostics); (object)type != null; type = type.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)) " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasUnboxingTypeParameterConversion,The length of the statement  "            if ((object)s != null && !s.IsReferenceType && destination.IsInterfaceType() && !HasImplicitReferenceTypeParameterConversion(s' destination' ref useSiteDiagnostics)) " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitDelegateConversion,The length of the statement  "                if (HasImplicitConversionToInterface(this.corLibrary.GetDeclaredSpecialType(SpecialType.System_Delegate)' source' ref useSiteDiagnostics)) " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitDelegateConversion,The length of the statement  "            // SPEC: From D<S1...Sn> to a D<T1...Tn> where D<X1...Xn> is a generic delegate type' D<S1...Sn> is not compatible with or identical to D<T1...Tn>'  " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitArrayConversion,The length of the statement  "            // SPEC: From an array-type S with an element type SE to an array-type T with an element type TE' provided all of the following are true: " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitArrayConversion,The length of the statement  "                foreach (var iface in this.corLibrary.GetDeclaredSpecialType(SpecialType.System_Array).AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)) " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitArrayConversion,The length of the statement  "                if (HasExplicitReferenceConversion(sourceArray.ElementType' ((NamedTypeSymbol)destination).TypeArgumentWithDefinitionUseSiteDiagnostics(0' ref useSiteDiagnostics)' ref useSiteDiagnostics)) " is 188.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasUnboxingConversion,The length of the statement  "            // SPEC: UNDONE from an interface or delegate type I0 and either I0 is variance-convertible to I or I is variance-convertible to I0. " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetUnderlyingEffectiveType,The length of the statement  "            //   * If S or T are nullable types' let Su and Tu be their underlying types' otherwise let Su and Tu be S and T' respectively.  " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetUnderlyingEffectiveType,The length of the statement  "            //   * If Su or Tu are type parameters' S0 and T0 are their effective base types' otherwise S0 and T0 are equal to Su and Tu' respectively. " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeExplicitUserDefinedConversions,The length of the statement  "            TypeSymbol sx = MostSpecificSourceTypeForExplicitUserDefinedConversion(u' sourceExpression' source' ref useSiteDiagnostics); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeUserDefinedExplicitConversionTypeSet,The length of the statement  "            AddTypesParticipatingInUserDefinedConversion(d' s0' includeBaseTypes: true' useSiteDiagnostics: ref useSiteDiagnostics); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeUserDefinedExplicitConversionTypeSet,The length of the statement  "            AddTypesParticipatingInUserDefinedConversion(d' t0' includeBaseTypes: true' useSiteDiagnostics: ref useSiteDiagnostics); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeApplicableUserDefinedExplicitConversionSet,The length of the statement  "                AddUserDefinedConversionsToExplicitCandidateSet(sourceExpression' source' target' u' declaringType' WellKnownMemberNames.ExplicitConversionName' ref useSiteDiagnostics); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeApplicableUserDefinedExplicitConversionSet,The length of the statement  "                AddUserDefinedConversionsToExplicitCandidateSet(sourceExpression' source' target' u' declaringType' WellKnownMemberNames.ImplicitConversionName' ref useSiteDiagnostics); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AddUserDefinedConversionsToExplicitCandidateSet,The length of the statement  "                Conversion fromConversion = EncompassingExplicitConversion(sourceExpression' source' convertsFrom' ref useSiteDiagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AddUserDefinedConversionsToExplicitCandidateSet,The length of the statement  "                // As in dev11 (and the revised spec)' we also accept candidates for which the return type is encompassed by the *stripped* target type. " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AddUserDefinedConversionsToExplicitCandidateSet,The length of the statement  "                    if ((object)source != null && source.IsNullableType() && convertsFrom.IsNonNullableValueType() && target.CanBeAssignedNull()) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AddUserDefinedConversionsToExplicitCandidateSet,The length of the statement  "                        Conversion liftedFromConversion = EncompassingExplicitConversion(sourceExpression' source' nullableFrom' ref useSiteDiagnostics); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,MostSpecificSourceTypeForExplicitUserDefinedConversion,The length of the statement  "                System.Func<UserDefinedConversionAnalysis' bool> isValid = conv => IsEncompassedBy(sourceExpression' source' conv.FromType' ref _useSiteDiagnostics); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,MostSpecificTargetTypeForExplicitUserDefinedConversion,The length of the statement  "            System.Func<UserDefinedConversionAnalysis' bool> isValid = conv => IsEncompassedBy(null' conv.ToType' target' ref _useSiteDiagnostics); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeUserDefinedImplicitConversionTypeSet,The length of the statement  "            AddTypesParticipatingInUserDefinedConversion(d' s0' includeBaseTypes: true' useSiteDiagnostics: ref useSiteDiagnostics); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeUserDefinedImplicitConversionTypeSet,The length of the statement  "            AddTypesParticipatingInUserDefinedConversion(d' t0' includeBaseTypes: false' useSiteDiagnostics: ref useSiteDiagnostics); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeApplicableUserDefinedImplicitConversionSet,The length of the statement  "                    Conversion fromConversion = EncompassingImplicitConversion(sourceExpression' source' convertsFrom' ref useSiteDiagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeApplicableUserDefinedImplicitConversionSet,The length of the statement  "                    else if ((object)source != null && (object)target != null && source.IsNullableType() && convertsFrom.IsNonNullableValueType() && target.CanBeAssignedNull()) " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeApplicableUserDefinedImplicitConversionSet,The length of the statement  "                        Conversion liftedFromConversion = EncompassingImplicitConversion(sourceExpression' source' nullableFrom' ref useSiteDiagnostics); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:    2)  Native compiler's approach: Native compiler implements this by walking through all the implicit user defined operators " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:        from the source type to a valid switch governing type' as per (2)' and determining if there is a unique best. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:        This part is that piece of code doesn't call into the code for analyzing user defined implicit conversion' but does the " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:        analysis of applicable lifted/normal forms itself. This makes it very difficult to maintain and is bug prone. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:        See the SPEC VIOLATION comment later in this method for one of the cases where it gets the analysis wrong and violates the " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:    3)  Use an approach similar to native compiler's approach' but call into the common code for analyzing user defined implicit conversion. " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:    We choose approach (3) and implement it as a slight variation of AnalyzeImplicitUserDefinedConversion as follows: " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:    (a) Compute the set of types D from which user-defined conversion operators should be considered by considering only the source type. " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:    (b) Instead of computing applicable user defined implicit conversions U from the source type to a specific target type' " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:    (e) Instead of finding the most specific target type TX of the operators in U' we consider all unique target types TX for all operators in U. " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:        (i)  TX is a valid switch governing type as per condition (2) of the SPEC for establishing the switch governing type and  " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // NOTE:        If there exists such unique TX in Y' then that operator is the resultant user defined conversion and TX is the resultant switch governing type. " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // (a) Compute the set of types D from which user-defined conversion operators should be considered by considering only the source type. " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            // (b) Instead of computing applicable user defined implicit conversions U from the source type to a specific target type' " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,The length of the statement  "            ComputeApplicableUserDefinedImplicitConversionSet(null' source' target: null' d: d' u: ubuild' useSiteDiagnostics: ref useSiteDiagnostics' allowAnyTarget: true); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,MostSpecificConversionOperatorForSwitchGoverningType,The length of the statement  "            // This method finds the most specific user-defined implicit conversion operator from the best source type SX to a valid switch governing type. " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,MostSpecificConversionOperatorForSwitchGoverningType,The length of the statement  "            // It implements steps (e) and (f) for AnalyzeImplicitUserDefinedConversionForSwitchGoverningType' see comments in that method for details. " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,MostSpecificConversionOperatorForSwitchGoverningType,The length of the statement  "            // (e) Instead of finding the most specific target type TX of the operators in U' we consider all unique target types TX for all operators in U. " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,MostSpecificConversionOperatorForSwitchGoverningType,The length of the statement  "            //     (i)  TX is a valid switch governing type as per condition (2) of the SPEC for establishing the switch governing type and  " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,MostSpecificConversionOperatorForSwitchGoverningType,The length of the statement  "            // If there exists such unique TX in Y' then that operator is the resultant user defined conversion and TX is the resultant switch governing type. " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,Conversions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\Conversions.cs,ResolveDelegateMethodGroup,The length of the statement  "                var resolution = binder.ResolveMethodGroup(source' analyzedArguments' isMethodGroupConversion: true' inferWithDynamic: true' useSiteDiagnostics: ref useSiteDiagnostics); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,Conversions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\Conversions.cs,ResolveDelegateMethodGroup,The length of the statement  "                return binder.ResolveMethodGroup(source' null' isMethodGroupConversion: true' useSiteDiagnostics: ref useSiteDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,Conversions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\Conversions.cs,MethodGroupConversion,The length of the statement  "                methodGroup.Methods' methodGroup.TypeArguments' analyzedArguments' result' ref useSiteDiagnostics' isMethodGroupConversion: true); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,Conversions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\Conversions.cs,GetDelegateArguments,The length of the statement  "                    // which will cause some error to be reported.  That's sufficient (i.e. no need to specifically report its absence here). " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Conversions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\Conversions.cs,GetDelegateArguments,The length of the statement  "                        compilation.GetSpecialType(SpecialType.System_Object)' parameter.CustomModifiers' parameter.IsParams' parameter.RefKind); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Conversions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\Conversions.cs,ToConversion,The length of the statement  "            Debug.Assert(method.ParameterCount == delegateType.DelegateInvokeMethod.ParameterCount + (methodGroup.IsExtensionMethodGroup ? 1 : 0)); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinaryOperatorAnalysisResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorAnalysisResult.cs,Applicable,The length of the statement  "            return new BinaryOperatorAnalysisResult(OperatorAnalysisResultKind.Applicable' signature' leftConversion' rightConversion); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinaryOperatorAnalysisResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorAnalysisResult.cs,Inapplicable,The length of the statement  "            return new BinaryOperatorAnalysisResult(OperatorAnalysisResultKind.Inapplicable' signature' leftConversion' rightConversion); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,BinaryOperatorAnalysisResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorAnalysisResult.cs,Worse,The length of the statement  "            return new BinaryOperatorAnalysisResult(OperatorAnalysisResultKind.Worse' this.Signature' this.LeftConversion' this.RightConversion); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BinaryOperatorOverloadResolution,The length of the statement  "            bool hadUserDefinedCandidate = GetUserDefinedOperators(underlyingKind' left' right' result.Results' ref useSiteDiagnostics); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddDelegateOperation,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Delegate' delegateType' delegateType' Compilation.GetSpecialType(SpecialType.System_Boolean))); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddDelegateOperation,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Delegate' delegateType' delegateType' delegateType)); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetDelegateOperations,The length of the statement  "                        TypeSymbol systemDelegateType = _binder.GetSpecialType(SpecialType.System_Delegate' _binder.Compilation.SemanticDiagnostics' left.Syntax); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingAddition' enumType' underlying' enumType)); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumAddition' underlying' enumType' enumType)); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingAddition' nullableEnum' nullableUnderlying' nullableEnum)); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumAddition' nullableUnderlying' nullableEnum' nullableEnum)); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                        operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType)); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                        operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                        operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum)); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                        operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                        operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                        operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                        operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumSubtraction' underlying' enumType' enumType) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                        operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumSubtraction' nullableUnderlying' nullableEnum' nullableEnum) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' boolean)); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' nullableEnum)); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndIntAddition' pointerType' Compilation.GetSpecialType(SpecialType.System_Int32)' pointerType)); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndUIntAddition' pointerType' Compilation.GetSpecialType(SpecialType.System_UInt32)' pointerType)); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndLongAddition' pointerType' Compilation.GetSpecialType(SpecialType.System_Int64)' pointerType)); " is 166.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndULongAddition' pointerType' Compilation.GetSpecialType(SpecialType.System_UInt64)' pointerType)); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.IntAndPointerAddition' Compilation.GetSpecialType(SpecialType.System_Int32)' pointerType' pointerType)); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UIntAndPointerAddition' Compilation.GetSpecialType(SpecialType.System_UInt32)' pointerType' pointerType)); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LongAndPointerAddition' Compilation.GetSpecialType(SpecialType.System_Int64)' pointerType' pointerType)); " is 166.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.ULongAndPointerAddition' Compilation.GetSpecialType(SpecialType.System_UInt64)' pointerType' pointerType)); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndIntSubtraction' pointerType' Compilation.GetSpecialType(SpecialType.System_Int32)' pointerType)); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndUIntSubtraction' pointerType' Compilation.GetSpecialType(SpecialType.System_UInt32)' pointerType)); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndLongSubtraction' pointerType' Compilation.GetSpecialType(SpecialType.System_Int64)' pointerType)); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndULongSubtraction' pointerType' Compilation.GetSpecialType(SpecialType.System_UInt64)' pointerType)); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerSubtraction' pointerType' pointerType' Compilation.GetSpecialType(SpecialType.System_Int64))); " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerComparisonOperators,The length of the statement  "                    operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Pointer' voidPointerType' voidPointerType' Compilation.GetSpecialType(SpecialType.System_Boolean))); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperations,The length of the statement  "                    // Subtraction either returns underlying type or only accept a single enum type' so operations on non-equal identity-convertible types are not ambiguous.  " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperations,The length of the statement  "            if ((object)rightType != null && ((object)leftType == null || !(useIdentityConversion ? Conversions.HasIdentityConversion(rightType' leftType) : rightType.Equals(leftType)))) " is 174.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerOperators,The length of the statement  "            // This operator returns long and so it's not ambiguous to apply it on T1 and T2 that are identity convertible to each other. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,UseOnlyReferenceEquality,The length of the statement  "                BuiltInOperators.IsValidObjectEquality(Conversions' left.Type' left.IsLiteralNull()' right.Type' right.IsLiteralNull()' ref useSiteDiagnostics) && " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,UseOnlyReferenceEquality,The length of the statement  "                ((object)left.Type == null || (!left.Type.IsDelegateType() && left.Type.SpecialType != SpecialType.System_String && left.Type.SpecialType != SpecialType.System_Delegate)) && " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,UseOnlyReferenceEquality,The length of the statement  "                ((object)right.Type == null || (!right.Type.IsDelegateType() && right.Type.SpecialType != SpecialType.System_String && right.Type.SpecialType != SpecialType.System_Delegate)); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetReferenceEquality,The length of the statement  "            operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Object' @object' @object' Compilation.GetSpecialType(SpecialType.System_Boolean))); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetUserDefinedOperators,The length of the statement  "                hadApplicableCandidate = GetUserDefinedOperators(kind' strippedLeftType' left' right' operators' ref useSiteDiagnostics); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetUserDefinedOperators,The length of the statement  "                hadApplicableCandidate |= GetUserDefinedOperators(kind' strippedRightType' left' right' rightOperators' ref useSiteDiagnostics); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetUserDefinedBinaryOperatorsFromType,The length of the statement  "                operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UserDefined | kind' leftOperandType' rightOperandType' resultType' op)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterOperator,The length of the statement  "            if (op1.Priority.HasValue && op2.Priority.HasValue && op1.Priority.GetValueOrDefault() != op2.Priority.GetValueOrDefault()) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AssertNotChecked,The length of the statement  "            Debug.Assert((kind & ~BinaryOperatorKind.Checked) == kind' "Did not expect operator to be checked.  Consider using .Operator() to mask."); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterOperator,The length of the statement  "            BetterResult better = BetterConversionFromExpression(operand' op1.OperandType' op2.OperandType' ref useSiteDiagnostics); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperations,The length of the statement  "                    operators.Add(new UnaryOperatorSignature(kind | UnaryOperatorKind.Lifted | UnaryOperatorKind.Enum' nullableEnum' nullableEnum)); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,PropertyOverloadResolution,The length of the statement  "            MethodOrPropertyOverloadResolution(indexers' typeArguments' arguments' result' isMethodGroupConversion: false' allowRefOmittedArguments: allowRefOmittedArguments' useSiteDiagnostics: ref useSiteDiagnostics); " is 207.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,PerformMemberOverloadResolution,The length of the statement  "            // SPEC: If the resulting set of candidate methods is empty' then further processing along the following steps are abandoned'  " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,PerformMemberOverloadResolution,The length of the statement  "            // SPEC: and instead an attempt is made to process the invocation as an extension method invocation. If this fails' then no  " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,PartitionMembersByContainingType,The length of the statement  "            Dictionary<NamedTypeSymbol' ArrayBuilder<TMember>> containingTypeMap = new Dictionary<NamedTypeSymbol' ArrayBuilder<TMember>>(); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddConstructorToCandidateSet,The length of the statement  "                    results.Add(new MemberResolutionResult<MethodSymbol>(constructor' constructor' MemberAnalysisResult.UnsupportedMetadata())); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddConstructorToCandidateSet,The length of the statement  "            // If the constructor has a use site diagnostic' we don't want to discard it because we'll have to report the diagnostic later. " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsConstructorApplicableInNormalForm,The length of the statement  "            var argumentAnalysis = AnalyzeArguments(constructor' arguments' isMethodGroupConversion: false' expanded: false); // Constructors are never involved in method group conversion. " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsConstructorApplicableInNormalForm,The length of the statement  "            var effectiveParameters = GetEffectiveParametersInNormalForm(constructor' arguments.Arguments.Count' argumentAnalysis.ArgsToParamsOpt' arguments.RefKinds' allowRefOmittedArguments: false); " is 188.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsConstructorApplicableInNormalForm,The length of the statement  "            return IsApplicable(constructor' effectiveParameters' arguments' argumentAnalysis.ArgsToParamsOpt' isVararg: constructor.IsVararg' hasAnyRefOmittedArgument: false' ignoreOpenTypes: false' useSiteDiagnostics: ref useSiteDiagnostics); " is 232.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsConstructorApplicableInExpandedForm,The length of the statement  "            var effectiveParameters = GetEffectiveParametersInExpandedForm(constructor' arguments.Arguments.Count' argumentAnalysis.ArgsToParamsOpt' arguments.RefKinds' allowRefOmittedArguments: false); " is 190.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsConstructorApplicableInExpandedForm,The length of the statement  "            var result = IsApplicable(constructor' effectiveParameters' arguments' argumentAnalysis.ArgsToParamsOpt' isVararg: false' hasAnyRefOmittedArgument: false' ignoreOpenTypes: false' useSiteDiagnostics: ref useSiteDiagnostics); " is 223.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsConstructorApplicableInExpandedForm,The length of the statement  "            return result.IsValid ? MemberAnalysisResult.ExpandedForm(result.ArgsToParamsOpt' result.ConversionsOpt' hasAnyRefOmittedArgument: false) : result; " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddMemberToCandidateSet,The length of the statement  "                    results.Add(new MemberResolutionResult<TMember>(member' leastOverriddenMember' MemberAnalysisResult.UnsupportedMetadata())); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddMemberToCandidateSet,The length of the statement  "                ? IsMemberApplicableInNormalForm(member' leastOverriddenMember' typeArguments' arguments' isMethodGroupConversion' allowRefOmittedArguments' inferWithDynamic' ref useSiteDiagnostics) " is 182.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddMemberToCandidateSet,The length of the statement  "                    var expandedResult = IsMemberApplicableInExpandedForm(member' leastOverriddenMember' typeArguments' arguments' allowRefOmittedArguments' ref useSiteDiagnostics); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,MemberGroupHidesByName,The length of the statement  "                if (HidesByName(otherMember) && otherContainingType.IsDerivedFrom(memberContainingType' ignoreDynamic: false' useSiteDiagnostics: ref useSiteDiagnostics)) " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,RemoveInaccessibleTypeArguments,The length of the statement  "                if (result.Result.IsValid && !TypeArgumentsAccessible(result.Member.GetMemberTypeArgumentsNoUseSiteDiagnostics()' ref useSiteDiagnostics)) " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,RemoveInaccessibleTypeArguments,The length of the statement  "                    results[f] = new MemberResolutionResult<TMember>(result.Member' result.LeastOverriddenMember' MemberAnalysisResult.InaccessibleTypeArgument()); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,RemoveLessDerivedMembers,The length of the statement  "                    results[f] = new MemberResolutionResult<TMember>(result.Member' result.LeastOverriddenMember' MemberAnalysisResult.LessDerived()); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsLessDerivedThanAny,The length of the statement  "                if (currentType.IsInterfaceType() && type.IsInterfaceType() && currentType.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics).Contains((NamedTypeSymbol)type)) " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsLessDerivedThanAny,The length of the statement  "                else if (currentType.IsClassType() && type.IsClassType() && currentType.IsDerivedFrom(type' ignoreDynamic: false' useSiteDiagnostics: ref useSiteDiagnostics)) " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,RemoveAllInterfaceMembers,The length of the statement  "                    results[f] = new MemberResolutionResult<TMember>(member' result.LeastOverriddenMember' MemberAnalysisResult.LessDerived()); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,RemoveWorseMembers,The length of the statement  "                    results[i] = new MemberResolutionResult<TMember>(results[i].Member' results[i].LeastOverriddenMember' MemberAnalysisResult.Worse()); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "            // Omit ref feature for COM interop: We can pass arguments by value for ref parameters if we are calling a method/property on an instance of a COM imported type. " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "            // We should have ignored the 'ref' on the parameter while determining the applicability of argument for the given method call. " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "            // As per Devdiv Bug #696573: '[Interop] Com omit ref overload resolution is incorrect'' we must prefer non-ref omitted methods over ref omitted methods " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "            // During argument rewriting' we will replace the argument value with a temporary local and pass that local by reference. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "                return BetterFunctionMember(m1' m2' arguments' considerRefKinds: hasAnyRefOmittedArgument1' useSiteDiagnostics: ref useSiteDiagnostics); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "            //   The parameters are reordered so that they occur at the same position as the corresponding argument in the argument list. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "                    if (allSame && Conversions.ClassifyImplicitConversion(type1' type2' ref useSiteDiagnostics).Kind != ConversionKind.Identity) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "                    Debug.Assert(Conversions.ClassifyImplicitConversion(type1' type2' ref useSiteDiagnostics).Kind != ConversionKind.Identity); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "            if (m1.Result.Kind == MemberResolutionKind.ApplicableInNormalForm && m2.Result.Kind == MemberResolutionKind.ApplicableInExpandedForm) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "            if (m1.Result.Kind == MemberResolutionKind.ApplicableInExpandedForm && m2.Result.Kind == MemberResolutionKind.ApplicableInNormalForm) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "            if (m1.Result.Kind == MemberResolutionKind.ApplicableInExpandedForm && m2.Result.Kind == MemberResolutionKind.ApplicableInExpandedForm) " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterFunctionMember,The length of the statement  "            if (m1.Member.ContainingType.TypeKind == TypeKind.Submission && m2.Member.ContainingType.TypeKind == TypeKind.Submission) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The length of the statement  "                // We may need to consider the ref kinds of the parameters while determining the better conversion from the given expression to the respective parameter types. " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The length of the statement  "                // This is needed for the omit ref feature for COM interop: We can pass arguments by value for ref parameters if we are calling a method within a COM imported type. " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The length of the statement  "                // We can reach here only if we had at least one ref omitted argument for the given call' which must be a call to a method within a COM imported type. " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The length of the statement  "                // Algorithm for determining the better conversion from expression when ref kinds need to be considered is NOT provided in the C# language specification' " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The length of the statement  "                //     then p2 is a better result if the argument has an identity conversion to p2's type. Otherwise' neither result is better. " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The length of the statement  "                // NOTE:    Native compiler does not explicitly implement the above algorithm' but gets it by default. This is due to the fact that the RefKind of a parameter " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The length of the statement  "                // NOTE:    gets considered while classifying conversions between parameter types when computing better conversion target in the native compiler. " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The length of the statement  "                // NOTE:    Roslyn correctly follows the specification and ref kinds are not considered while classifying conversions between types' see method BetterConversionTarget. " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The length of the statement  "                okToDowngradeToNeither = lambdaOpt != null && CanDowngradeConversionFromLambdaToNeither(BetterResult.Left' lambdaOpt' t1' t2' ref useSiteDiagnostics' false); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionFromExpression,The length of the statement  "                okToDowngradeToNeither = lambdaOpt != null && CanDowngradeConversionFromLambdaToNeither(BetterResult.Right' lambdaOpt' t1' t2' ref useSiteDiagnostics' false); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,ExpressionMatchExactly,The length of the statement  "                // - an inferred return type X exists for E in the context of the parameter list of D(§7.5.2.12)' and an identity conversion exists from X to Y " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionTarget,The length of the statement  "            // Given two different types T1 and T2' T1 is a better conversion target than T2 if no implicit conversion from T2 to T1 exists'  " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionTarget,The length of the statement  "                okToDowngradeToNeither = lambdaOpt != null && CanDowngradeConversionFromLambdaToNeither(BetterResult.Left' lambdaOpt' type1' type2' ref useSiteDiagnostics' true); " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterConversionTarget,The length of the statement  "                okToDowngradeToNeither = lambdaOpt != null && CanDowngradeConversionFromLambdaToNeither(BetterResult.Right' lambdaOpt' type1' type2' ref useSiteDiagnostics' true); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParametersInNormalForm,The length of the statement  "            return GetEffectiveParametersInNormalForm(member' argumentCount' argToParamMap' argumentRefKinds' allowRefOmittedArguments' hasAnyRefOmittedArgument: out discarded); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParametersInNormalForm,The length of the statement  "                RefKind paramRefKind = GetEffectiveParameterRefKind(parameter' argRefKind' allowRefOmittedArguments' ref hasAnyRefOmittedArgument); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParameterRefKind,The length of the statement  "            // Omit ref feature for COM interop: We can pass arguments by value for ref parameters if we are calling a method/property on an instance of a COM imported type. " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParameterRefKind,The length of the statement  "            // During argument rewriting' we will replace the argument value with a temporary local and pass that local by reference. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParameterRefKind,The length of the statement  "            if (allowRefOmittedArguments && paramRefKind == RefKind.Ref && argRefKind == RefKind.None && !_binder.InAttributeArgument) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParametersInExpandedForm,The length of the statement  "            return GetEffectiveParametersInExpandedForm(member' argumentCount' argToParamMap' argumentRefKinds' allowRefOmittedArguments' hasAnyRefOmittedArgument: out discarded); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParametersInExpandedForm,The length of the statement  "                var paramRefKind = GetEffectiveParameterRefKind(parameter' argRefKind' allowRefOmittedArguments' ref hasAnyRefOmittedArgument); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsMemberApplicableInNormalForm,The length of the statement  "                return new MemberResolutionResult<TMember>(member' leastOverriddenMember' MemberAnalysisResult.ArgumentParameterMismatch(argumentAnalysis)); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsMemberApplicableInExpandedForm,The length of the statement  "                return new MemberResolutionResult<TMember>(member' leastOverriddenMember' MemberAnalysisResult.ArgumentParameterMismatch(argumentAnalysis)); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsMemberApplicableInExpandedForm,The length of the statement  "                    MemberAnalysisResult.ExpandedForm(result.Result.ArgsToParamsOpt' result.Result.ConversionsOpt' hasAnyRefOmittedArgument)) : " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsApplicable,The length of the statement  "                        typeArguments = InferMethodTypeArguments(method' leastOverriddenMethod.ConstructedFrom.TypeParameters' arguments' originalEffectiveParameters' out inferenceError' ref useSiteDiagnostics); " is 187.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsApplicable,The length of the statement  "                            return new MemberResolutionResult<TMember>(member' leastOverriddenMember' MemberAnalysisResult.ConstructedParameterFailedConstraintsCheck(i)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsApplicable,The length of the statement  "                IsApplicable(member' effectiveParameters' arguments' argsToParamsMap' member.GetIsVararg()' hasAnyRefOmittedArgument' ignoreOpenTypes' ref useSiteDiagnostics)); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,InferMethodTypeArguments,The length of the statement  "                var inferredFromFirstArgument = MethodTypeInferrer.InferTypeArgumentsFromFirstArgument(_binder.Conversions' method' originalEffectiveParameters.ParameterTypes' args' ref useSiteDiagnostics); " is 190.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsApplicable,The length of the statement  "                    RefKind parameterRefKind = parameters.ParameterRefKinds.IsDefault ? RefKind.None : parameters.ParameterRefKinds[argumentPosition]; " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsApplicable,The length of the statement  "                    conversion = CheckArgumentForApplicability(candidate' argument' argumentRefKind' parameters.ParameterTypes[argumentPosition]' parameterRefKind' ignoreOpenTypes' ref useSiteDiagnostics); " is 185.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsApplicable,The length of the statement  "                        (arguments.IsExtensionMethodThisArgument(argumentPosition) && !Conversions.IsValidExtensionMethodThisArgConversion(conversion))) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,IsApplicable,The length of the statement  "                result = MemberAnalysisResult.BadArgumentConversions(argsToParameters' badArguments.ToImmutableAndFree()' conversionsArray); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,CheckArgumentForApplicability,The length of the statement  "            // RefKind has to match unless the ref kind is None and argument expression is of the type dynamic. This is a bug in Dev11 which we also implement.  " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,CheckArgumentForApplicability,The length of the statement  "            // - Then' any parameter whose type is open (i.e. contains a type parameter; see §4.4.2) is elided' along with its corresponding parameter(s). " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,CheckArgumentForApplicability,The length of the statement  "                Debug.Assert((!conversion.Exists) || conversion.IsImplicit' "ClassifyImplicitConversion should only return implicit conversions"); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AnalyzeArguments,The length of the statement  "                return AnalyzeArgumentsForNormalFormNoNamedArguments(parameters' arguments' isMethodGroupConversion' symbol.GetIsVararg()); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AnalyzeArguments,The length of the statement  "                int parameterPosition = CorrespondsToAnyParameter(parameters' expanded' arguments' argumentPosition' out isNamedArgument) ?? -1; " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AnalyzeArguments,The length of the statement  "            int? requiredParameterMissing = CheckForMissingRequiredParameter(argsToParameters' parameters' isMethodGroupConversion' expanded); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,CorrespondsToAnyParameter,The length of the statement  "            //   declaration or override of the function member' starting with the static type of the receiver' and searching through its base classes. " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,ArgumentAnalysisResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\ArgumentAnalysisResult.cs,NameUsedForPositional,The length of the statement  "            return new ArgumentAnalysisResult(ArgumentAnalysisResultKind.NameUsedForPositional' argumentPosition' 0' default(ImmutableArray<int>)); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,ArgumentAnalysisResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\ArgumentAnalysisResult.cs,NoCorrespondingParameter,The length of the statement  "            return new ArgumentAnalysisResult(ArgumentAnalysisResultKind.NoCorrespondingParameter' argumentPosition' 0' default(ImmutableArray<int>)); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,ArgumentAnalysisResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\ArgumentAnalysisResult.cs,NoCorrespondingNamedParameter,The length of the statement  "            return new ArgumentAnalysisResult(ArgumentAnalysisResultKind.NoCorrespondingNamedParameter' argumentPosition' 0' default(ImmutableArray<int>)); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,ArgumentAnalysisResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\ArgumentAnalysisResult.cs,RequiredParameterMissing,The length of the statement  "            return new ArgumentAnalysisResult(ArgumentAnalysisResultKind.RequiredParameterMissing' 0' parameterPosition' default(ImmutableArray<int>)); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,MemberAnalysisResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MemberAnalysisResult.cs,NormalForm,The length of the statement  "            return new MemberAnalysisResult(MemberResolutionKind.ApplicableInNormalForm' default(ImmutableArray<int>)' argsToParamsOpt' conversions' hasAnyRefOmittedArgument: hasAnyRefOmittedArgument); " is 189.
Long Statement,Microsoft.CodeAnalysis.CSharp,MemberAnalysisResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MemberAnalysisResult.cs,ExpandedForm,The length of the statement  "            return new MemberAnalysisResult(MemberResolutionKind.ApplicableInExpandedForm' default(ImmutableArray<int>)' argsToParamsOpt' conversions' hasAnyRefOmittedArgument: hasAnyRefOmittedArgument); " is 191.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,GetResults,The length of the statement  "                _fixedResults[i] = new ExtendedErrorTypeSymbol(_constructedContainingTypeOfMethod' _methodTypeParameters[i].Name' 0' null' false); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,AllFixed,The length of the statement  "            for (int methodTypeParameterIndex = 0; methodTypeParameterIndex < _methodTypeParameters.Length; ++methodTypeParameterIndex) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,GetFixedDelegate,The length of the statement  "            TypeMap typeMap = new TypeMap(_constructedContainingTypeOfMethod' _methodTypeParameters' fixedArguments.ToImmutableAndFree()); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,MethodGroupReturnTypeInference,The length of the statement  "            var returnType = MethodGroupReturnType(binder' (BoundMethodGroup)source' fixedDelegateParameters' ref useSiteDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,MethodGroupReturnType,The length of the statement  "            var resolution = binder.ResolveMethodGroup(source' analyzedArguments' isMethodGroupConversion: true' useSiteDiagnostics: ref useSiteDiagnostics); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,UpperBoundInterfaceInference,The length of the statement  "            NamedTypeSymbol bestInterface = GetInterfaceInferenceBound(target.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)' source); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,ImplicitConversionExists,The length of the statement  "            // SPEC VIOLATION: For the purpose of algorithm in Fix method' dynamic type is not considered convertible to any other type' including object. " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,TryGetBestResult,The length of the statement  "                        Debug.Assert(false' "How did we manage to get two methods in the overload resolution results that were both better than every other method?"); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,TryGetBestResult,The length of the statement  "            // TODO: There might be a situation in which there were no valid results but we still want to identify a "best of a bad lot" result for " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportDiagnostics,The length of the statement  "            if (HadBadArguments(diagnostics' binder.Compilation' name' arguments' symbols' location' binder.Flags' isMethodGroupConversion)) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportDiagnostics,The length of the statement  "                ReportBadParameterCount(diagnostics' name' arguments' symbols' location' typeContainingConstructor' delegateTypeBeingInvoked); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,UseSiteError,The length of the statement  "            // Use site errors are reported unconditionally in PerformMemberOverloadResolution/PerformObjectCreationOverloadResolution. " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,HadBadArguments,The length of the statement  "                        //  The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters. " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportBadArgumentError,The length of the statement  "                        // CS1928: '{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' has some invalid arguments " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportBadArgumentError,The length of the statement  "                        // CS1929: '{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}' " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportBadArgumentError,The length of the statement  "                        Debug.Assert((object)parameter == UnwrapIfParamsArray(parameter)' "If they ever differ' just call the method when constructing the diagnostic."); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,HadAmbiguousWorseMethods,The length of the statement  "                Debug.Assert(nWorse == 0' "How is it that there is exactly one applicable but worse method' and exactly zero applicable best methods?  What was better than this thing?"); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,HadAmbiguousBestMethods,The length of the statement  "                Debug.Assert(nValid == 0' "Why are we doing error reporting on an overload resolution problem that had one valid result?"); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,Dump,The length of the statement  "            else if (System.Linq.Enumerable.Any(ResultsBuilder' x => (x.Result.Kind == MemberResolutionKind.TypeInferenceFailed) || (x.Result.Kind == MemberResolutionKind.TypeInferenceExtensionInstanceArgument))) " is 200.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,GetCustomAttributesToEmit,The length of the statement  "            return GetCustomAttributesToEmit(userDefined' synthesized' isReturnType: false' emittingAssemblyAttributesInNetModule: emittingAssemblyAttributesInNetModule); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,ForceCompleteMemberByLocation,The length of the statement  "            if (locationOpt == null || member.IsDefinedInSourceTree(locationOpt.SourceTree' locationOpt.SourceSpan' cancellationToken)) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,MergeUseSiteDiagnostics,The length of the statement  "            if (info.Severity == DiagnosticSeverity.Error && (info.Code == HighestPriorityUseSiteError || HighestPriorityUseSiteError == Int32.MaxValue)) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,ReportUseSiteDiagnostic,The length of the statement  "            // By dropping the location we effectively merge all unification use-site errors that have the same error code into a single error. " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,ReportUseSiteDiagnostic,The length of the statement  "            // The error message clearly explains how to fix the problem and reporting the error for each location wouldn't add much value.  " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,GetUnificationUseSiteDiagnosticRecursive,The length of the statement  "                if (GetUnificationUseSiteDiagnosticRecursive(ref result' typeParameter.ConstraintTypesNoUseSiteDiagnostics' owner' ref checkedTypes)) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,EarlyDecodeDeprecatedOrObsoleteAttribute,The length of the statement  "            if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.ObsoleteAttribute)) " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,EarlyDecodeDeprecatedOrObsoleteAttribute,The length of the statement  "                attributeData = arguments.Binder.GetAttribute(arguments.AttributeSyntax' arguments.AttributeType' out hasAnyDiagnostics); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,EarlyDecodeDeprecatedOrObsoleteAttribute,The length of the statement  "            if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.DeprecatedAttribute)) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,EarlyDecodeDeprecatedOrObsoleteAttribute,The length of the statement  "                attributeData = arguments.Binder.GetAttribute(arguments.AttributeSyntax' arguments.AttributeType' out hasAnyDiagnostics); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,LoadAndValidateAttributes,The length of the statement  "            ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists' symbolPart' diagnostics' compilation' out binders); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,LoadAndValidateAttributes,The length of the statement  "                EarlyWellKnownAttributeData earlyData = this.EarlyDecodeWellKnownAttributes(binders' boundAttributeTypes' attributesToBind' symbolPart' attributesBuilder); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,LoadAndValidateAttributes,The length of the statement  "                wellKnownAttributeData = this.ValidateAttributeUsageAndDecodeWellKnownAttributes(binders' attributesToBind' boundAttributes' diagnostics' symbolPart); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,LoadAndValidateAttributes,The length of the statement  "                Interlocked.CompareExchange(ref lazyCustomAttributesBag' CustomAttributesBag<CSharpAttributeData>.WithEmptyData()' null); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,EarlyDecodeWellKnownAttributes,The length of the statement  "            var arguments = new EarlyDecodeWellKnownAttributeArguments<EarlyWellKnownAttributeBinder' NamedTypeSymbol' AttributeSyntax' AttributeLocation>(); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,ValidateAttributeUsageAndDecodeWellKnownAttributes,The length of the statement  "                if (!boundAttribute.HasErrors && ValidateAttributeUsage(boundAttribute' attributeSyntax' binder.Compilation' symbolPart' diagnostics' uniqueAttributeTypes)) " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,ValidateAttributeUsage,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_AttributeOnBadSymbolType' node.Name.Location' node.Name' attributeUsageInfo.GetValidTargetsErrorArgument()); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,ValidateAttributeUsage,The length of the statement  "                        // CS7070: Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly' type and method declarations. " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,BuildMap,The length of the statement  "            var map = new Dictionary<object' List<SourceLabelSymbol>>(labels.Length' new SwitchConstantValueHelper.SwitchLabelsComparer()); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,BuildSwitchLabels,The length of the statement  "                    boundLabelExpression = ConvertCaseExpression(switchGoverningType' labelSyntax' boundLabelExpression' ref boundLabelConstantOpt' tempDiagnosticBag); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,ConvertCaseExpression,The length of the statement  "                Conversion conversion = Conversions.ClassifyConversionFromExpression(caseExpression' switchGoverningType' ref useSiteDiagnostics); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,BindSwitchExpressionAndSections,The length of the statement  "            ImmutableArray<BoundSwitchSection> boundSwitchSections = BindSwitchSections(node.Sections' originalBinder' diagnostics); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,BindSwitchExpressionAndSections,The length of the statement  "            return new BoundSwitchStatement(node' boundSwitchExpression' constantTargetOpt' Locals' boundSwitchSections' this.BreakLabel' null); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,BindSwitchExpression,The length of the statement  "                    Conversion conversion = Conversions.ClassifyImplicitUserDefinedConversionForSwitchGoverningType(switchGoverningType' out resultantGoverningType' ref useSiteDiagnostics); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,BindSwitchExpression,The length of the statement  "                        // We need to create an error type here as certain diagnostics generated during binding the switch case label expression and " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,BindSwitchExpression,The length of the statement  "            return new BoundBadExpression(node' LookupResultKind.Empty' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(switchExpression)' switchGoverningType ?? CreateErrorType()); " is 184.
Long Statement,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,BindSwitchSection,The length of the statement  "            return new BoundSwitchSection(node' boundLabelsBuilder.ToImmutableAndFree()' boundStatementsBuilder.ToImmutableAndFree()); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,BindSwitchSectionLabel,The length of the statement  "                boundLabelExpressionOpt = ConvertCaseExpression(switchGoverningType' caseLabelSyntax' boundLabelExpressionOpt' ref labelExpressionConstant' diagnostics); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,SwitchBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\SwitchBinder.cs,BindGotoCaseOrDefault,The length of the statement  "                childBoundNodes: gotoCaseExpressionOpt != null ? ImmutableArray.Create<BoundNode>(gotoCaseExpressionOpt) : ImmutableArray<BoundNode>.Empty' " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,UsingsBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\UsingsBinder.cs,LookupSymbolsInSingleBinder,The length of the statement  "            Imports.Empty.LookupSymbolInUsings(ConsolidatedUsings' originalBinder' tmp' name' arity' basesBeingResolved' options' diagnose' ref useSiteDiagnostics); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,UsingsBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\UsingsBinder.cs,AddLookupSymbolsInfoInSingleBinder,The length of the statement  "            LookupOptions usingOptions = (options & ~(LookupOptions.NamespaceAliasesOnly | LookupOptions.NamespacesOrTypesOnly)) | LookupOptions.MustNotBeNamespace; " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,UsingStatementBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\UsingStatementBinder.cs,BindUsingStatementParts,The length of the statement  "            TypeSymbol iDisposable = this.Compilation.GetSpecialType(SpecialType.System_IDisposable); // no need for diagnostics' so use the Compilation version " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,UsingStatementBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\UsingStatementBinder.cs,BindUsingStatementParts,The length of the statement  "                iDisposableConversion = this.Conversions.ClassifyImplicitConversionFromExpression(expressionOpt' iDisposable' ref useSiteDiagnostics); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,UsingStatementBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\UsingStatementBinder.cs,BindUsingStatementParts,The length of the statement  "                BindForOrUsingOrFixedDeclarations(declarationSyntax' LocalDeclarationKind.UsingVariable' diagnostics' out declarations); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,WithClassTypeParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\WithClassTypeParametersBinder.cs,IsAccessible,The length of the statement  "            return this.IsSymbolAccessibleConditional(symbol' _namedType' accessThroughType' out failedThroughTypeCheck' ref useSiteDiagnostics' basesBeingResolved); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,WithLambdaParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\WithLambdaParametersBinder.cs,LookupSymbolsInSingleBinder,The length of the statement  "                result.MergeEqual(originalBinder.CheckViability(parameterSymbol' arity' options' null' diagnose' ref useSiteDiagnostics)); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,WithLambdaParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\WithLambdaParametersBinder.cs,ReportConflictWithParameter,The length of the statement  "            Debug.Assert(oldLocation != newLocation || oldLocation == Location.None' "same nonempty location refers to different symbols?"); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,WithLambdaParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\WithLambdaParametersBinder.cs,ReportConflictWithParameter,The length of the statement  "                // A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,WithTypeParametersBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\WithTypeParametersBinder.cs,LookupSymbolsInSingleBinder,The length of the statement  "                result.MergeEqual(originalBinder.CheckViability(typeParameter' arity' options' null' diagnose' ref useSiteDiagnostics)); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,BoundCall,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,ErrorCall,The length of the statement  "                refKinds' isDelegateCall: isDelegateCall' expanded: false' invokedAsExtensionMethod: invokedAsExtensionMethod' argsToParamsOpt: default(ImmutableArray<int>)' " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,BoundCall,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,Update,The length of the statement  "            return this.Update(receiverOpt' method' arguments' ArgumentNamesOpt' ArgumentRefKindsOpt' IsDelegateCall' Expanded' InvokedAsExtensionMethod' ArgsToParamsOpt' ResultKind' Type); " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp,BoundConversion,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,SynthesizedNonUserDefined,The length of the statement  "            Debug.Assert(!kind.IsUserDefinedConversion()' "Use the BoundConversion.Synthesized overload that takes a 'Conversion' parameter for generating synthesized user defined conversions."); " is 183.
Long Statement,Microsoft.CodeAnalysis.CSharp,BoundObjectCreationExpression,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,Update,The length of the statement  "            return this.Update(constructor' ImmutableArray<MethodSymbol>.Empty' arguments' argumentNamesOpt' argumentRefKindsOpt' expanded' argsToParamsOpt' constantValueOpt' initializerExpressionOpt' type); " is 195.
Long Statement,Microsoft.CodeAnalysis.CSharp,BoundExpressionExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpressionExtensions.cs,GetConversion,The length of the statement  "                    return new Conversion(conversionNode.ConversionKind' methodGroupConversionMethod: conversionNode.SymbolOpt' isExtensionMethod: conversionNode.IsExtensionMethod); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,BoundExpressionExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpressionExtensions.cs,IsExpressionOfComImportType,The length of the statement  "            return (object)receiverType != null && receiverType.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)receiverType).IsComImport; " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,BoundQueryClause,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundQueryClause.cs,Update,The length of the statement  "            if (value != this.Value || definedSymbol != this.DefinedSymbol || queryInvocation != this.Operation || castInvocation != this.Cast || binder != this.Binder || unoptimizedForm != this.UnoptimizedForm || type != this.Type) " is 220.
Long Statement,Microsoft.CodeAnalysis.CSharp,BoundQueryClause,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundQueryClause.cs,Update,The length of the statement  "                var result = new BoundQueryClause(this.Syntax' value' definedSymbol' queryInvocation' castInvocation' binder' unoptimizedForm' type' this.HasErrors); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,BoundStatementExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundStatementExtensions.cs,AssertIsLabeledStatement,The length of the statement  "            Debug.Assert(node.Kind == BoundKind.LabelStatement || node.Kind == BoundKind.LabeledStatement || node.Kind == BoundKind.SwitchSection); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,BoundBlock,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\Constructors.cs,SynthesizedNoLocals,The length of the statement  "            return new BoundBlock(syntax' ImmutableArray<LocalSymbol>.Empty' statements.AsImmutableOrNull()) { WasCompilerGenerated = true }; " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,DelegateParameters,The length of the statement  "            return ((object)d == null || (object)d.DelegateInvokeMethod == null) ? ImmutableArray<ParameterSymbol>.Empty : d.DelegateInvokeMethod.Parameters; " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,DelegateNeedsReturn,The length of the statement  "            if (IsAsync && this.binder.Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task) == d.DelegateInvokeMethod.ReturnType) " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyBind,The length of the statement  "            if (_returnInferenceCache.TryGetValue(cacheKey' out returnInferenceLambda) && returnInferenceLambda.InferredFromSingleType) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyBind,The length of the statement  "            lambdaSymbol = new LambdaSymbol(binder.Compilation' binder.ContainingMemberOrLambda' _unboundLambda' parameters' returnType); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyBind,The length of the statement  "            lambdaBodyBinder = new ExecutableCodeBinder(_unboundLambda.Syntax' lambdaSymbol' ParameterBinder(lambdaSymbol' binder)); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyBind,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_AnonymousReturnExpected' lambdaSymbol.Locations[0]' this.MessageID.Localize()' delegateType); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyBind,The length of the statement  "                    // Cannot convert async {0} to delegate type '{1}'. An async {0} may return void' Task or Task&lt;T&gt;' none of which are convertible to '{1}'. " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyBind,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_CantConvAsyncAnonFuncReturns' lambdaSymbol.Locations[0]' lambdaSymbol.MessageID.Localize()' delegateType); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyBind,The length of the statement  "            var result = new BoundLambda(_unboundLambda.Syntax' block' diagnostics.ToReadOnlyAndFree()' lambdaBodyBinder' delegateType' inferReturnType: false) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyInferReturnType,The length of the statement  "            var lambdaSymbol = new LambdaSymbol(binder.Compilation' binder.ContainingMemberOrLambda' _unboundLambda' parameters' returnType: null); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyInferReturnType,The length of the statement  "            Binder lambdaBodyBinder = new ExecutableCodeBinder(_unboundLambda.Syntax' lambdaSymbol' ParameterBinder(lambdaSymbol' binder)); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyInferReturnType,The length of the statement  "            var result = new BoundLambda(_unboundLambda.Syntax' block' diagnostics.ToReadOnlyAndFree()' lambdaBodyBinder' delegateType' inferReturnType: true) " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyInferReturnType,The length of the statement  "            HashSet<DiagnosticInfo> useSiteDiagnostics = null; // TODO: figure out if this should be somehow merged into BoundLambda.Diagnostics. " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,GuessBestBoundLambda,The length of the statement  "                    IEnumerable<BoundLambda> minDiagnosticsGroup = candidates.GroupBy(lambda => lambda.Diagnostics.Length).OrderBy(group => group.Key).First(); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,AttributeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\AttributeSemanticModel.cs,Create,The length of the statement  "            return new AttributeSemanticModel(compilation' syntax' attributeType' aliasOpt' new LocalScopeBinder(executableBinder)); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,AttributeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\AttributeSemanticModel.cs,CreateSpeculative,The length of the statement  "            return new AttributeSemanticModel(parentSemanticModel.Compilation' syntax' attributeType' aliasOpt' rootBinder' parentSemanticModel' position); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionInfo,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\AwaitExpressionInfo.cs,GetHashCode,The length of the statement  "            return Hash.Combine(GetAwaiterMethod' Hash.Combine(IsCompletedProperty' Hash.Combine(GetResultMethod' IsDynamic.GetHashCode()))); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The length of the statement  "                    case UnaryOperatorKind.SByte: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_SByte)); break; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The length of the statement  "                    case UnaryOperatorKind.Short: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Int16)); break; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The length of the statement  "                    case UnaryOperatorKind.UShort: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_UInt16)); break; " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The length of the statement  "                    case UnaryOperatorKind.UInt: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_UInt32)); break; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The length of the statement  "                    case UnaryOperatorKind.ULong: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_UInt64)); break; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The length of the statement  "                    case UnaryOperatorKind.Float: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Single)); break; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The length of the statement  "                    case UnaryOperatorKind.Double: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Double)); break; " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The length of the statement  "                    case UnaryOperatorKind.Decimal: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Decimal)); break; " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The length of the statement  "                    case UnaryOperatorKind.Bool: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Boolean)); break; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetSubmissionResultType,The length of the statement  "            var lastStatement = (GlobalStatementSyntax)tree.GetCompilationUnitRoot().Members.LastOrDefault(decl => decl.Kind() == SyntaxKind.GlobalStatement); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,AddSyntaxTrees,The length of the statement  "                        AddSyntaxTreeToDeclarationMapAndTable(tree' _options' IsSubmission' ref declMap' ref declTable' ref referenceDirectivesChanged); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,AddSyntaxTreeToDeclarationMapAndTable,The length of the statement  "            var lazyRoot = new Lazy<RootSingleNamespaceDeclaration>(() => DeclarationTreeBuilder.ForTree(tree' options.ScriptClassName ?? ""' isSubmission)); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,ReplaceSyntaxTree,The length of the statement  "                // This could be a perf win when editing a script file in the IDE. The services create a new compilation every keystroke  " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,ReplaceSyntaxTree,The length of the statement  "                AddSyntaxTreeToDeclarationMapAndTable(newTree' _options' this.IsSubmission' ref declMap' ref declTable' ref referenceDirectivesChanged); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetMetadataReference,The length of the statement  "            return this.GetBoundReferenceManager().ReferencedAssembliesMap.Where(kvp => object.ReferenceEquals(kvp.Value.Symbol' assemblySymbol)).Select(kvp => kvp.Key).FirstOrDefault(); " is 174.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetExternAliasTarget,The length of the statement  "                ? MergedNamespaceSymbol.Create(new NamespaceExtent(this)' namespacesToMerge: builder.ToImmutableAndFree()' containingNamespace: null' nameOpt: null) " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetExternAliasTarget,The length of the statement  "                : new MissingNamespaceSymbol(new MissingModuleSymbol(new MissingAssemblySymbol(new AssemblyIdentity(System.Guid.NewGuid().ToString()))' ordinal: -1)); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetExternAliasTarget,The length of the statement  "            // Use GetOrAdd in case another thread beat us to the punch (i.e. should return the same object for the same alias' every time). " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,BindScriptClass,The length of the statement  "            var namespaceOrType = this.Assembly.GlobalNamespace.GetNamespaceOrTypeByQualifiedName(_options.ScriptClassName.Split('.')).AsSingleton(); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetTypeByMetadataName,The length of the statement  "            return this.Assembly.GetTypeByMetadataName(fullyQualifiedMetadataName' includeReferences: true' isWellKnownType: false); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,FindEntryPoint,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_Compilation_FindEntryPoint' message: this.AssemblyName' cancellationToken: cancellationToken)) " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,FindEntryPoint,The length of the statement  "                        if ((object)mainType == null || mainType.IsGenericType || (mainType.TypeKind != TypeKind.Class && mainType.TypeKind != TypeKind.Struct)) " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetImports,The length of the statement  "            return GetBinderFactory(declaration.SyntaxReference.SyntaxTree).GetImportsBinder((CSharpSyntaxNode)declaration.SyntaxReference.GetSyntax()).GetImports(); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetSubmissionImports,The length of the statement  "            return ((SourceNamespaceSymbol)SourceModule.GlobalNamespace).GetBoundImportsMerged().SingleOrDefault() ?? Imports.Empty; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,CreateGlobalNamespaceAlias,The length of the statement  "            return AliasSymbol.CreateGlobalNamespaceAlias(this.GlobalNamespace' new InContainerBinder(this.GlobalNamespace' new BuckStopsHereBinder(this))); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,CompleteTree,The length of the statement  "            if (_lazyCompilationUnitCompletedTrees == null) Interlocked.CompareExchange(ref _lazyCompilationUnitCompletedTrees' new HashSet<SyntaxTree>()' null); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetDiagnostics,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_Compilation_GetDiagnostics' message: this.AssemblyName' cancellationToken: cancellationToken)) " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetDiagnostics,The length of the statement  "                            UICultureUtilities.WithCurrentUICulture<int>(i => builder.AddRange(this.SyntaxTrees[i].GetDiagnostics(cancellationToken)))); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,IsDefinedOrImplementedInSourceTree,The length of the statement  "            if (symbol.Kind == SymbolKind.Method && symbol.IsImplicitlyDeclared && ((MethodSymbol)symbol).MethodKind == MethodKind.Constructor) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetDiagnosticsForMethodBodiesInTree,The length of the statement  "            DocumentationCommentCompiler.WriteDocumentationCommentXml(this' null' null' diagnostics' cancellationToken' tree' span); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,FilterDiagnostic,The length of the statement  "            return CSharpDiagnosticFilter.Filter(d' options.WarningLevel' options.GeneralDiagnosticOption' options.SpecificDiagnosticOptions); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetSourceDeclarationDiagnostics,The length of the statement  "            ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree' filterSpanWithinTree' cancellationToken); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetDiagnosticsForSyntaxTree,The length of the statement  "                var declarationDiagnostics = GetSourceDeclarationDiagnostics(syntaxTree' filterSpanWithinTree' FilterDiagnosticsByLocation' cancellationToken); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetDiagnosticsForSyntaxTree,The length of the statement  "                IEnumerable<Diagnostic> methodBodyDiagnostics = GetDiagnosticsForMethodBodiesInTree(syntaxTree' filterSpanWithinTree' cancellationToken); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetDiagnosticsForSyntaxTree,The length of the statement  "                //       GetDiagnosticsForMethodBodiesInTree seems to be returning diagnostics with locations that don't satisfy the filter tree/span' this must be fixed. " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,CompileImpl,The length of the statement  "            // The diagnostics should include syntax and declaration errors. We insert these before calling Emitter.Emit' so that the emitter " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,CompileImpl,The length of the statement  "            bool hasDeclarationErrors = !FilterAndAppendDiagnostics(diagnostics' GetDiagnostics(CompilationStage.Declare' true' cancellationToken)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,CompileImpl,The length of the statement  "            string assemblyName = FileNameUtilities.ChangeExtension(moduleBeingBuilt.EmitOptions.OutputNameOverride' extension: null); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,CompileImpl,The length of the statement  "            DocumentationCommentCompiler.WriteDocumentationCommentXml(this' assemblyName' xmlDocStream' xmlDiagnostics' cancellationToken); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,MakeDebugSourceDocumentForTree,The length of the statement  "            return new Cci.DebugSourceDocument(normalizedPath' Cci.DebugSourceDocument.CorSymLanguageTypeCSharp' () => tree.GetChecksumAndAlgorithm()); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,AnalyzerForLanguage,The length of the statement  "            return new AnalyzerDriver<SyntaxKind>(analyzers' n => n.Kind()' options' continueOnAnalyzerException' cancellationToken); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetWellKnownTypeMember,The length of the statement  "            if (_lazyWellKnownTypeMembers == null || ReferenceEquals(_lazyWellKnownTypeMembers[(int)member]' ErrorTypeSymbol.UnknownResultType)) " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,IsEqualOrDerivedFromWellKnownClass,The length of the statement  "            return type.Equals(wkType' ignoreDynamic: false) || type.IsDerivedFrom(wkType' ignoreDynamic: false' useSiteDiagnostics: ref useSiteDiagnostics); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetRuntimeMember,The length of the statement  "                    !(member.DeclaredAccessibility == Accessibility.Public || ((object)accessWithinOpt != null && Symbol.IsSymbolAccessible(member' accessWithinOpt)))) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetRuntimeMember,The length of the statement  "                            if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDebuggableAttribute,The length of the statement  "            var ignoreSymbolStoreDebuggingMode = (FieldSymbol)GetWellKnownTypeMember(WellKnownMember.System_Diagnostics_DebuggableAttribute_DebuggingModes__IgnoreSymbolStoreSequencePoints); " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDebuggableAttribute,The length of the statement  "            int constantVal = ignoreSymbolStoreDebuggingMode.GetConstantValue(ConstantFieldsInProgress.Empty' earlyDecodingWellKnownAttributes: false).Int32Value; " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDebuggableAttribute,The length of the statement  "                var defaultDebuggingMode = (FieldSymbol)GetWellKnownTypeMember(WellKnownMember.System_Diagnostics_DebuggableAttribute_DebuggingModes__Default); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDebuggableAttribute,The length of the statement  "                var disableOptimizationsDebuggingMode = (FieldSymbol)GetWellKnownTypeMember(WellKnownMember.System_Diagnostics_DebuggableAttribute_DebuggingModes__DisableOptimizations); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDebuggableAttribute,The length of the statement  "                constantVal |= defaultDebuggingMode.GetConstantValue(ConstantFieldsInProgress.Empty' earlyDecodingWellKnownAttributes: false).Int32Value; " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDebuggableAttribute,The length of the statement  "                constantVal |= disableOptimizationsDebuggingMode.GetConstantValue(ConstantFieldsInProgress.Empty' earlyDecodingWellKnownAttributes: false).Int32Value; " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDebuggableAttribute,The length of the statement  "                var enableEncDebuggingMode = (FieldSymbol)GetWellKnownTypeMember(WellKnownMember.System_Diagnostics_DebuggableAttribute_DebuggingModes__EnableEditAndContinue); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDebuggableAttribute,The length of the statement  "                constantVal |= enableEncDebuggingMode.GetConstantValue(ConstantFieldsInProgress.Empty' earlyDecodingWellKnownAttributes: false).Int32Value; " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDynamicAttribute,The length of the statement  "                var boolArray = new ArrayTypeSymbol(booleanType.ContainingAssembly' booleanType' customModifiers: ImmutableArray<CustomModifier>.Empty); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDynamicAttribute,The length of the statement  "                return TrySynthesizeAttribute(WellKnownMember.System_Runtime_CompilerServices_DynamicAttribute__ctorTransformFlags' arguments); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDiagnosticFilter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpDiagnosticFilter.cs,Filter,The length of the statement  "                specificDiagnosticOptions.Keys.Contains(CSharp.MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ALinkWarn))) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDiagnosticFilter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpDiagnosticFilter.cs,Filter,The length of the statement  "                reportAction = GetDiagnosticReport(d.Severity' d.IsEnabledByDefault' d.Id' d.WarningLevel' d.Location as Location' d.Category' warningLevelOption' generalDiagnosticOption' specificDiagnosticOptions); " is 199.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDiagnosticFilter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpDiagnosticFilter.cs,GetDiagnosticReport,The length of the statement  "                ((SyntaxTree)location.SourceTree).GetPragmaDirectiveWarningState(id' location.SourceSpan.Start) == ReportDiagnostic.Suppress) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,CanGetSemanticInfo,The length of the statement  "                    if (!isSpeculative && node.Parent != null && node.Parent.Kind() == SyntaxKind.NameEquals && node.Parent.Parent.Kind() == SyntaxKind.UsingDirective) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativelyBoundExpressionHelper,The length of the statement  "            if (bindingOption == SpeculativeBindingOption.BindAsTypeOrNamespace || binder.Flags.Includes(BinderFlags.CrefParameterOrReturnType)) " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetSymbolInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetCollectionInitializerSymbolInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetSymbolInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetCollectionInitializerSymbolInfo,The length of the statement  "                        return GetCollectionInitializerSymbolInfoWorker((InitializerExpressionSyntax)expression.Parent' expression' cancellationToken); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetSymbolInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetSymbolInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetSymbolInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativeSymbolInfo,The length of the statement  "                BoundNode boundNode = GetSpeculativelyBoundExpression(position' expression' bindingOption' out binder' out crefSymbols); //calls CheckAndAdjustPosition " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativeSymbolInfo,The length of the statement  "                    return crefSymbols.IsDefault ? SymbolInfo.None : GetCrefSymbolInfo(crefSymbols' SymbolInfoOptions.DefaultOptions' hasParameterList: false); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativeSymbolInfo,The length of the statement  "                var symbolInfo = this.GetSymbolInfoForNode(SymbolInfoOptions.DefaultOptions' boundNode' boundNode' boundNodeForSyntacticParent: null' binderOpt: binder); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativeSymbolInfo,The length of the statement  "                var symbolInfo = this.GetSymbolInfoForNode(SymbolInfoOptions.DefaultOptions' boundNode' boundNode' boundNodeForSyntacticParent: null' binderOpt: binder); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativeSymbolInfo,The length of the statement  "                var existingConstructorInitializer = this.Root.FindToken(position).Parent.AncestorsAndSelf().OfType<ConstructorInitializerSyntax>().FirstOrDefault(); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativeSymbolInfo,The length of the statement  "                    var binfo = memberModel.GetSymbolInfoForNode(SymbolInfoOptions.DefaultOptions' bnode' bnode' boundNodeForSyntacticParent: null' binderOpt: binder); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetTypeInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetTypeInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetTypeInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetTypeInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetTypeInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetTypeInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetConversion,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetConversion' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativeTypeInfoWorker,The length of the statement  "                BoundNode boundNode = GetSpeculativelyBoundExpression(position' expression' bindingOption' out binder' out crefSymbols); //calls CheckAndAdjustPosition " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetMemberGroup,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetMemberGroup' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetMemberGroup,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetMemberGroup' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetMemberGroup,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetMemberGroup' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetIndexerGroup,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetIndexerGroup' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetIndexerGroup,The length of the statement  "                    ? StaticCast<IPropertySymbol>.From(this.GetIndexerGroupWorker(expression' SymbolInfoOptions.DefaultOptions' cancellationToken)) " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetConstantValue,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetConstantValue' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetAliasInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetAliasInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetAliasInfo,The length of the statement  "                SymbolInfo info = GetSymbolInfoWorker(nameSyntax' SymbolInfoOptions.PreferTypeToConstructors | SymbolInfoOptions.PreserveAliases' cancellationToken); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativeAliasInfo,The length of the statement  "                BoundNode boundNode = GetSpeculativelyBoundExpression(position' nameSyntax' bindingOption' out binder' out crefSymbols); //calls CheckAndAdjustPosition " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSpeculativeAliasInfo,The length of the statement  "                var symbolInfo = this.GetSymbolInfoForNode(SymbolInfoOptions.PreferTypeToConstructors | SymbolInfoOptions.PreserveAliases' " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,LookupSymbols,The length of the statement  "            return StaticCast<ISymbol>.From(LookupSymbolsInternal(position' ToLanguageSpecific(container)' name' options' useBaseReferenceAccessibility: false)); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,LookupBaseMembers,The length of the statement  "            return StaticCast<ISymbol>.From(LookupSymbolsInternal(position' container: null' name: name' options: LookupOptions.Default' useBaseReferenceAccessibility: true)); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,LookupStaticMembers,The length of the statement  "            return StaticCast<ISymbol>.From(LookupSymbolsInternal(position' ToLanguageSpecific(container)' name' LookupOptions.MustNotBeInstance' useBaseReferenceAccessibility: false)); " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,LookupNamespacesAndTypes,The length of the statement  "            return StaticCast<ISymbol>.From(LookupSymbolsInternal(position' ToLanguageSpecific(container)' name' LookupOptions.NamespacesOrTypesOnly' useBaseReferenceAccessibility: false)); " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,LookupLabels,The length of the statement  "            return StaticCast<ISymbol>.From(LookupSymbolsInternal(position' container: null' name: name' options: LookupOptions.LabelsOnly' useBaseReferenceAccessibility: false)); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,LookupSymbolsInternal,The length of the statement  "                Debug.Assert((options & LookupOptions.UseBaseReferenceAccessibility) == 0' "Use the useBaseReferenceAccessibility parameter."); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,LookupSymbolsInternal,The length of the statement  "                    if (parentExpr != null && !(parentExpr.Parent is XmlNameAttributeSyntax) && !SyntaxFacts.IsInTypeOnlyContext(parentExpr)) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,AppendSymbolsWithNameAndArity,The length of the statement  "                if (lookupResult.Symbols.Any(t => t.Kind == SymbolKind.NamedType || t.Kind == SymbolKind.Namespace || t.Kind == SymbolKind.ErrorType)) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,AppendSymbolsWithNameAndArity,The length of the statement  "                    Symbol singleSymbol = binder.ResultSymbol(lookupResult' name' arity' this.Root' diagnostics' true' out wasError' container' options); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,IsEventUsableAsField,The length of the statement  "            return !ReferenceEquals(eventSymbol' null) && csymbol.HasAssociatedField && this.IsAccessible(position' csymbol.AssociatedField); //calls CheckAndAdjustPosition " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolInfoForNode,The length of the statement  "                var symbols = GetSemanticSymbols(boundExpr' boundNodeForSyntacticParent' binderOpt' options' out isDynamic' out resultKind' out unusedMemberGroup); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolInfoForNode,The length of the statement  "                    ImmutableArray<Symbol> highestSymbols = GetSemanticSymbols(highestBoundExpr' boundNodeForSyntacticParent' binderOpt' options' out highestIsDynamic' out highestResultKind' out unusedHighestMemberGroup); " is 201.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolInfoForNode,The length of the statement  "                            Debug.Assert(ReferenceEquals(lowestBoundNode' highestBoundNode)' "How is it that this operator has the same syntax node as its operand?"); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetTypeInfoForNode,The length of the statement  "                  ((ObjectCreationExpressionSyntax)boundNodeForSyntacticParent.Syntax).Type == boundExpr.Syntax)) // Do not return any type information for a ObjectCreationExpressionSyntax.Type node. " is 181.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetTypeInfoForNode,The length of the statement  "                else if ((boundNodeForSyntacticParent != null) && (boundNodeForSyntacticParent.Kind == BoundKind.DelegateCreationExpression)) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetTypeInfoForNode,The length of the statement  "                                conversion = new Conversion(ConversionKind.MethodGroup' delegateCreation.MethodOpt' delegateCreation.IsExtensionMethod); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetMemberGroupForNode,The length of the statement  "                GetSemanticSymbols(boundExpr' boundNodeForSyntacticParent' binderOpt' options' out isDynamic' out resultKind' out memberGroup); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,TryGetSpeculativeSemanticModelForMethodBody,The length of the statement  "            return TryGetSpeculativeSemanticModelForMethodBodyCore((SyntaxTreeSemanticModel)this' position' method' out speculativeModel); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,TryGetSpeculativeSemanticModelForMethodBody,The length of the statement  "            return TryGetSpeculativeSemanticModelForMethodBodyCore((SyntaxTreeSemanticModel)this' position' accessor' out speculativeModel); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,TryGetSpeculativeSemanticModel,The length of the statement  "            return TryGetSpeculativeSemanticModelCore((SyntaxTreeSemanticModel)this' position' type' bindingOption' out speculativeModel); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,TryGetSpeculativeSemanticModel,The length of the statement  "            return TryGetSpeculativeSemanticModelCore((SyntaxTreeSemanticModel)this' position' expressionBody' out speculativeModel); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,TryGetSpeculativeSemanticModel,The length of the statement  "            return TryGetSpeculativeSemanticModelCore((SyntaxTreeSemanticModel)this' position' constructorInitializer' out speculativeModel); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,TryGetSpeculativeSemanticModel,The length of the statement  "            speculativeModel = AttributeSemanticModel.CreateSpeculative((SyntaxTreeSemanticModel)this' attribute' attributeType' aliasOpt' binder' position); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The length of the statement  "                    symbols = GetMethodGroupSemanticSymbols(boundNode' boundNodeForSyntacticParent' binderOpt' out resultKind' out isDynamic' out memberGroup); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The length of the statement  "                    symbols = GetPropertyGroupSemanticSymbols(boundNode' boundNodeForSyntacticParent' binderOpt' out resultKind' out memberGroup); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The length of the statement  "                        return GetSemanticSymbols(valueExpression' boundNodeForSyntacticParent' binderOpt' options' out isDynamic' out resultKind' out memberGroup); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The length of the statement  "                        symbols = originalIndexersOpt.IsDefault ? ImmutableArray.Create<Symbol>(indexerAccess.Indexer) : StaticCast<Symbol>.From(originalIndexersOpt); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The length of the statement  "                            GetSymbolsAndResultKind(conversion' conversion.SymbolOpt' conversion.OriginalUserDefinedConversionsOpt' out symbols' out resultKind); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The length of the statement  "                    GetSymbolsAndResultKind(@operator' @operator.LogicalOperator' @operator.OriginalUserDefinedOperatorsOpt' out symbols' out resultKind); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The length of the statement  "                        AdjustSymbolsForObjectCreation(attribute' namedType' attribute.Constructor' binderOpt' ref resultKind' ref symbols' ref memberGroup); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The length of the statement  "                        if (query.Operation != null && (object)query.Operation.ExpressionSymbol != null) builder.Add(query.Operation.ExpressionSymbol); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The length of the statement  "                AdjustSymbolsForObjectCreation(boundNode' boundNodeForSyntacticParent' binderOpt' ref resultKind' ref symbols' ref memberGroup); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "            if (operandType == 0 || operandType == UnaryOperatorKind.UserDefined || unaryOperator.ResultKind != LookupResultKind.Viable) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "                    GetSymbolsAndResultKind(unaryOperator' unaryOperator.MethodOpt' unaryOperator.OriginalUserDefinedOperatorsOpt' out symbols' out resultKind); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "                Debug.Assert((object)unaryOperator.MethodOpt == null && unaryOperator.OriginalUserDefinedOperatorsOpt.IsDefaultOrEmpty); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "                symbols = ImmutableArray.Create<Symbol>(new SynthesizedIntrinsicOperatorSymbol(unaryOperator.Operand.Type.StrippedType()' " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "            if (operandType == 0 || operandType == UnaryOperatorKind.UserDefined || increment.ResultKind != LookupResultKind.Viable) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "                    GetSymbolsAndResultKind(increment' increment.MethodOpt' increment.OriginalUserDefinedOperatorsOpt' out symbols' out resultKind); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "            if (operandType == 0 || operandType == BinaryOperatorKind.UserDefined || binaryOperator.ResultKind != LookupResultKind.Viable || binaryOperator.OperatorKind.IsLogical()) " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "                    GetSymbolsAndResultKind(binaryOperator' binaryOperator.MethodOpt' binaryOperator.OriginalUserDefinedOperatorsOpt' out symbols' out resultKind); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "                Debug.Assert((object)binaryOperator.MethodOpt == null && binaryOperator.OriginalUserDefinedOperatorsOpt.IsDefaultOrEmpty); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "            if (operandType == 0 || operandType == BinaryOperatorKind.UserDefined || compoundAssignment.ResultKind != LookupResultKind.Viable) " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "                    GetSymbolsAndResultKind(compoundAssignment' compoundAssignment.Operator.Method' compoundAssignment.OriginalUserDefinedOperatorsOpt' out symbols' out resultKind); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The length of the statement  "                Debug.Assert((object)compoundAssignment.Operator.Method == null && compoundAssignment.OriginalUserDefinedOperatorsOpt.IsDefaultOrEmpty); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,AdjustSymbolsForObjectCreation,The length of the statement  "                AdjustSymbolsForObjectCreation(boundNode' typeSymbol' constructor' binderOpt' ref resultKind' ref symbols' ref memberGroup); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,AdjustSymbolsForObjectCreation,The length of the statement  "                    candidateConstructors = binder.FilterInaccessibleConstructors(instanceConstructors' allowProtectedConstructorsOfBaseType: false' useSiteDiagnostics: ref useSiteDiagnostics); " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetMethodGroupSemanticSymbols,The length of the statement  "                        if (invocation != null && invocation.Expression.SkipParens() == boundNode.Syntax.SkipParens() && (object)call.Method != null) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetNamedArgumentSymbolInfo,The length of the statement  "            SymbolInfo containingInvocationInfo = GetSymbolInfoWorker(containingInvocation' SymbolInfoOptions.PreferConstructorsToType | SymbolInfoOptions.ResolveAliases' cancellationToken); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetNamedArgumentSymbolInfo,The length of the statement  "                return (object)param == null ? SymbolInfo.None : new SymbolInfo(param' ImmutableArray<ISymbol>.Empty' CandidateReason.None); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetNamedArgumentSymbolInfo,The length of the statement  "                    return new SymbolInfo(null' StaticCast<ISymbol>.From(symbols.ToImmutableAndFree())' containingInvocationInfo.CandidateReason); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetReducedAndFilteredMethodGroupSymbols,The length of the statement  "                            binder.CheckViability(method' arity' options' accessThroughType: null' diagnose: false' useSiteDiagnostics: ref useSiteDiagnostics)' " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,CreateReducedExtensionMethodsFromOriginalsIfNecessary,The length of the statement  "                AddReducedAndFilteredMethodGroupSymbol(methodBuilder' filteredMethodBuilder' method' default(ImmutableArray<TypeSymbol>)' extensionThisType); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetEnclosingSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetEnclosingSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,InitializerSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\InitializerSemanticModel.cs,CreateSpeculative,The length of the statement  "            return new InitializerSemanticModel(parentSemanticModel.Compilation' syntax' owner' rootBinder' parentSemanticModel' position); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,InitializerSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\InitializerSemanticModel.cs,Bind,The length of the statement  "                    return binder.BindConstructorInitializer(((ConstructorInitializerSyntax)node).ArgumentList' (MethodSymbol)MemberSymbol' diagnostics); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetEnclosingBinder,The length of the statement  "                                                                   unexpectedAnonymousFunction.Kind() == SyntaxKind.AnonymousMethodExpression ? MessageID.IDS_AnonMethod : MessageID.IDS_Lambda' " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetAwaitExpressionInfo,The length of the statement  "            return new AwaitExpressionInfo(boundAwait.GetAwaiter' boundAwait.IsCompleted' boundAwait.GetResult' boundAwait.IsDynamic); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetForEachStatementInfo,The length of the statement  "                enumeratorInfoOpt.NeedsDisposeMethod ? (MethodSymbol)Compilation.GetSpecialTypeMember(SpecialMember.System_IDisposable__Dispose) : null' " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetQueryClauseInfo,The length of the statement  "            var castInfo = (bound.Cast == null) ? default(SymbolInfo) : GetSymbolInfoForNode(SymbolInfoOptions.DefaultOptions' bound.Cast' bound.Cast' boundNodeForSyntacticParent: null' binderOpt: null); " is 191.
Long Statement,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetSymbolInfoForQuery,The length of the statement  "            return GetSymbolInfoForNode(SymbolInfoOptions.DefaultOptions' operation' operation' boundNodeForSyntacticParent: null' binderOpt: null); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetBoundNodes,The length of the statement  "            if (bindableParent != null && bindableParent.Kind() == SyntaxKind.SimpleMemberAccessExpression && ((MemberAccessExpressionSyntax)bindableParent).Expression == bindableNode) " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetEnclosingBinderInternal,The length of the statement  "                    BoundNode boundOuterExpression = this.Bind(GetEnclosingBinder(outerExpression' position)' outerExpression' _ignoredDiagnostics); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetBindableParentNode,The length of the statement  "            if ((bindableParent.Kind() == SyntaxKind.SimpleMemberAccessExpression) && (bindableParent.Parent.Kind() == SyntaxKind.InvocationExpression)) " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,NodeMapBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.NodeMapBuilder.cs,AddToMap,The length of the statement  "                Debug.Assert(node == null || root == null || !(root.Syntax is StatementSyntax)' "individually added nodes are not supposed to be statements."); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs,CreateSpeculative,The length of the statement  "            return new MethodBodySemanticModel(parentSemanticModel.Compilation' owner' rootBinder' syntax' parentSemanticModel' position); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs,CreateSpeculative,The length of the statement  "            return new MethodBodySemanticModel(parentSemanticModel.Compilation' owner' rootBinder' syntax' parentSemanticModel' position); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs,GetSpeculativeSemanticModelForMethodBody,The length of the statement  "            var executablebinder = new ExecutableCodeBinder(body' methodSymbol' this.RootBinder.Next); // Strip off ExecutableCodeBinder (see ctor). " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,SpeculativeSyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SpeculativeSyntaxTreeSemanticModel.cs,Create,The length of the statement  "            return CreateCore(parentSemanticModel' root' rootBinder' position' bindingOption: SpeculativeBindingOption.BindAsTypeOrNamespace); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,SpeculativeSyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SpeculativeSyntaxTreeSemanticModel.cs,CreateCore,The length of the statement  "            var speculativeModel = new SpeculativeSyntaxTreeSemanticModel(parentSemanticModel' root' rootBinder' position' bindingOption); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,SpeculativeSyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SpeculativeSyntaxTreeSemanticModel.cs,GetSymbolInfoWorker,The length of the statement  "                var aliasSymbol = (AliasSymbol)_parentSemanticModel.GetSpeculativeAliasInfo(_position' expression' this.GetSpeculativeBindingOption(expression)); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,SpeculativeSyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SpeculativeSyntaxTreeSemanticModel.cs,GetSymbolInfoWorker,The length of the statement  "            return _parentSemanticModel.GetSpeculativeSymbolInfo(_position' expression' this.GetSpeculativeBindingOption(expression)); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,SpeculativeSyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SpeculativeSyntaxTreeSemanticModel.cs,GetTypeInfoWorker,The length of the statement  "            return _parentSemanticModel.GetSpeculativeTypeInfoWorker(_position' expression' this.GetSpeculativeBindingOption(expression)); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolInfoFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SymbolInfoFactory.cs,Create,The length of the statement  "                return new SymbolInfo(StaticCast<ISymbol>.From(symbols)' (symbols.Length > 0) ? resultKind.ToCandidateReason() : CandidateReason.None); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetSyntaxDiagnostics,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDiagnostics' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclarationDiagnostics,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDiagnostics' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetMethodBodyDiagnostics,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDiagnostics' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDiagnostics,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDiagnostics' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetEnclosingBinderInternal,The length of the statement  "            return _binderFactory.GetBinder((CSharpSyntaxNode)token.Parent' position).WithAdditionalFlags(BinderFlags.SemanticModel); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetSymbolInfoWorker,The length of the statement  "                if ((object)result.Symbol == null && result.CandidateReason == CandidateReason.None && node is ExpressionSyntax && SyntaxFacts.IsInNamespaceOrTypeContext((ExpressionSyntax)node)) " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetSymbolInfoWorker,The length of the statement  "            else if (node.Parent.Kind() == SyntaxKind.XmlNameAttribute && (attrSyntax = (XmlNameAttributeSyntax)node.Parent).Identifier == node) " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetSymbolInfoWorker,The length of the statement  "                var symbol = GetSemanticInfoSymbolInNonMemberContext(node' bindVarAsAliasFirst: (options & SymbolInfoOptions.PreserveAliases) != 0); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetTypeInfoWorker,The length of the statement  "                var symbol = GetSemanticInfoSymbolInNonMemberContext(node' bindVarAsAliasFirst: false); // Don't care about aliases here. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetIndexerGroupWorker,The length of the statement  "            return model == null ? ImmutableArray<PropertySymbol>.Empty : model.GetIndexerGroupWorker(node' options' cancellationToken); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetQueryClauseInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetQueryClauseInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetSymbolInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetSymbolInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetTypeInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetTypeInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetSymbolInfo,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetSymbolInfo' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetBasesBeingResolved,The length of the statement  "                if (parent is BaseTypeSyntax && parent.Parent != null && parent.Parent.Kind() == SyntaxKind.BaseList && ((BaseTypeSyntax)parent).Type == expression) " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetMemberModel,The length of the statement  "                        // NOTE: not UnknownAccessorDeclaration since there's no corresponding method symbol from which to build a member model. " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetMemberModel,The length of the statement  "                        // NOTE: not UnknownAccessorDeclaration since there's no corresponding method symbol from which to build a member model. " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "                    // Few subtypes of MemberDeclarationSyntax don't declare any symbols or declare multiple symbols' return null for these cases. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclarationName,The length of the statement  "            return ExplicitInterfaceHelpers.GetMemberName(_binderFactory.GetBinder(declaration)' explicitInterfaceSpecifierOpt' memberName); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetMethodParameterSymbol,The length of the statement  "                ((object)method.PartialDefinitionPart == null ? null : GetParameterSymbol(method.PartialDefinitionPart.Parameters' parameter' cancellationToken)); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_SemanticModel_GetDeclaredSymbol' message: this.SyntaxTree.FilePath' cancellationToken: cancellationToken)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredSymbol,The length of the statement  "                                    ((object)methodSymbol.PartialDefinitionPart == null ? null : this.GetTypeParameterSymbol(methodSymbol.PartialDefinitionPart.TypeParameters' typeParameter)); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredTypeMemberContainer,The length of the statement  "            if (memberDeclaration.Kind() == SyntaxKind.NamespaceDeclaration || SyntaxFacts.IsTypeDeclaration(memberDeclaration.Kind())) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,VisitAssembly,The length of the statement  "                System.Diagnostics.Debug.Assert(warningLocation != null || !moduleDeclaredCompliance.HasValue || (i == 0 && _filterTree != null)' " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,HasAcceptableAttributeConstructor,The length of the statement  "                    System.Diagnostics.Debug.Assert(IsAccessibleOutsideAssembly(constructor)' "Should be implied by IsAccessibleIfContainerIsAccessible"); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckForAttributeOnAccessor,The length of the statement  "                        this.AddDiagnostic(ErrorCode.ERR_AttributeNotOnAccessor' attributeLocation' attribute.AttributeClass.Name' attributeUsage.GetValidTargetsErrorArgument()); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,VisitTypeOrMember,The length of the statement  "                else if (GetDeclaredOrInheritedCompliance(symbol.ContainingAssembly) == Compliance.DeclaredTrue && IsTrue(GetInheritedCompliance(symbol))) " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckForNonCompliantAbstractMember,The length of the statement  "            System.Diagnostics.Debug.Assert(!IsTrue(GetDeclaredOrInheritedCompliance(symbol))' "Only call on non-compliant symbols"); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckBaseTypeCompliance,The length of the statement  "                System.Diagnostics.Debug.Assert((object)baseType != null || symbol.SpecialType == SpecialType.System_Object' "Only object has no base."); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckTypeParameterCompliance,The length of the statement  "            System.Diagnostics.Debug.Assert(typeParameters.IsEmpty || IsTrue(GetDeclaredOrInheritedCompliance(context))' "Only call on compliant symbols"); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckParameterCompliance,The length of the statement  "            System.Diagnostics.Debug.Assert(parameters.IsEmpty || IsTrue(GetDeclaredOrInheritedCompliance(context))' "Only call on compliant symbols"); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckMemberDistinctness,The length of the statement  "                foreach (NamedTypeSymbol @interface in type.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics) // NOTE: would be handrolled in a standalone component. " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,IsInaccessibleBecauseOfConstruction,The length of the statement  "            bool sawProtected = type.DeclaredAccessibility == Accessibility.Protected || type.DeclaredAccessibility == Accessibility.ProtectedOrInternal; " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,IsInaccessibleBecauseOfConstruction,The length of the statement  "                    sawProtected = sawProtected || containingType.DeclaredAccessibility == Accessibility.Protected || containingType.DeclaredAccessibility == Accessibility.ProtectedOrInternal; " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,TryGetCollisionErrorCode,The length of the statement  "                sawArrayRankDifference ? ErrorCode.WRN_CLS_OverloadRefOut : // Lumping rank difference with refkind is odd' but matches dev11. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteDocumentationCommentXml,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_DocumentationCommentCompiler_WriteDocumentationCommentXml' message: compilation.AssemblyName' cancellationToken: cancellationToken)) " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteDocumentationCommentXml,The length of the statement  "                    var compiler = new DocumentationCommentCompiler(assemblyName ?? compilation.SourceAssembly.Name' compilation' writer' filterTree' filterSpanWithinTree' " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteDocumentationCommentXml,The length of the statement  "                    UnprocessedDocumentationCommentFinder.ReportUnprocessed(filterTree' filterSpanWithinTree' diagnostics' cancellationToken); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,DefaultVisit,The length of the statement  "            // If there are no doc comments' then no further work is required (other than to report a diagnostic if one is required). " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,DefaultVisit,The length of the statement  "            bool reportParameterOrTypeParameterDiagnostics = GetLocationInTreeReportingDocumentationCommentDiagnostics(symbol) != null; " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,DefaultVisit,The length of the statement  "                TextWriter expanderWriter = isPartialMethodDefinitionPart ? null : _writer; // Don't actually write partial method definition parts. " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,DefaultVisit,The length of the statement  "                    _compilation' ref documentedParameters' ref documentedTypeParameters' ref _includedFileCache' expanderWriter' _diagnostics' _cancellationToken); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,DefaultVisit,The length of the statement  "                // (or should) not be affected.  If we decide that this difference matters' we can run the XDocument through an XmlWriter. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,TryProcessDocumentationCommentTriviaNodes,The length of the statement  "            bool processedDocComment = false; // Even if there are DocumentationCommentTriviaSyntax' we may not need to process any of them. " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,TryProcessDocumentationCommentTriviaNodes,The length of the statement  "            includeElementNodes = _processIncludes ? includeElementNodesBuilder.ToImmutableAndFree() : default(ImmutableArray<CSharpSyntaxNode>); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,TryGetDocumentationCommentNodes,The length of the statement  "                ImmutableArray<DocumentationCommentTriviaSyntax> triviaList = SourceDocumentationCommentUtils.GetDocumentationCommentTriviaFromSyntaxNode((CSharpSyntaxNode)reference.GetSyntax()' _diagnostics); " is 193.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,GetAndEndTemporaryString,The length of the statement  "            Debug.Assert(_indentDepth == t.InitialIndentDepth' $"Temporary strings should be indent-neutral (was {t.InitialIndentDepth}' is {_indentDepth})"); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,GetDescription,The length of the statement  "                string locationString = string.Format(locationTemplate' ""' e.LineNumber' e.LinePosition); // first arg is where the problem description goes " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.DocumentationCommentWalker.cs,GetSubstitutedText,The length of the statement  "                    DocumentationCommentWalker walker = new DocumentationCommentWalker(compilation' diagnostics' symbol' writer' includeElementNodes' documentedParameters' documentedTypeParameters); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp,DocumentationCommentWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.DocumentationCommentWalker.cs,DefaultVisit,The length of the statement  "                        DocumentationCommentXmlNames.ElementEquals(nameSyntax.LocalName.ValueText' DocumentationCommentXmlNames.IncludeElementName)) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,ProcessIncludes,The length of the statement  "                    Debug.Assert(sourceIncludeElementNodes.All(syntax => syntax.SyntaxTree.Options.DocumentationMode < DocumentationMode.Diagnose)' " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,ElementNameIs,The length of the statement  "                return string.IsNullOrEmpty(element.Name.NamespaceName) && DocumentationCommentXmlNames.ElementEquals(element.Name.LocalName' name); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,AttributeNameIs,The length of the statement  "                return string.IsNullOrEmpty(attribute.Name.NamespaceName) && DocumentationCommentXmlNames.AttributeEquals(attribute.Name.LocalName' name); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,RewriteIncludeElement,The length of the statement  "                        _diagnostics.Add(ErrorCode.WRN_FailedInclude' location' filePathValue' xpathValue' new LocalizableErrorArgument(MessageID.IDS_OperationCausedStackOverflow)); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,RewriteIncludeElement,The length of the statement  "                        var subMessage = hasFileAttribute ? MessageID.IDS_XMLMISSINGINCLUDEPATH.Localize() : MessageID.IDS_XMLMISSINGINCLUDEFILE.Localize(); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,RewriteIncludeElement,The length of the statement  "                        includeDiagnostics.Add(ErrorCode.WRN_FailedInclude' location' filePathValue' xpathValue' new CodeAnalysisResourcesLocalizableErrorArgument(nameof(CodeAnalysisResources.XmlReferencesNotSupported))); " is 197.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,RewriteIncludeElement,The length of the statement  "                        includeDiagnostics.Add(ErrorCode.WRN_FailedInclude' location' filePathValue' xpathValue' new CodeAnalysisResourcesLocalizableErrorArgument(nameof(CodeAnalysisResources.FileNotFound))); " is 184.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,RewriteIncludeElement,The length of the statement  "                        includeDiagnostics.Add(ErrorCode.WRN_XMLParseIncludeError' errorLocation' GetDescription(e)); //NOTE: location is in included file. " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,RewriteIncludeElement,The length of the statement  "                            commentMessage = string.Format(ErrorFacts.GetMessage(MessageID.IDS_XMLIGNORED2' CultureInfo.InvariantCulture)' resolvedFilePath); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,BindAndReplaceCref,The length of the statement  "                Binder binder = BinderFactory.MakeCrefBinder(crefSyntax' memberDeclSyntax' _compilation.GetBinderFactory(memberDeclSyntax.SyntaxTree)); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,BindAndReplaceCref,The length of the statement  "                attribute.Value = GetDocumentationCommentId(crefSyntax' binder' crefDiagnostics); // NOTE: mutation (element must be a copy) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,BindName,The length of the statement  "                DocumentationCommentCompiler.BindName(attrSyntax' binder' _memberSymbol' ref _documentedParameters' ref _documentedTypeParameters' nameDiagnostics); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,ParseNameAttribute,The length of the statement  "                SyntaxTriviaList leadingTrivia = SyntaxFactory.ParseLeadingTrivia(commentText' CSharpParseOptions.Default.WithDocumentationMode(DocumentationMode.Diagnose)); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,RecordSyntaxDiagnostics,The length of the statement  "                if (treelessSyntax.ContainsDiagnostics && ((SyntaxTree)sourceLocation.SourceTree).ReportDocumentationCommentDiagnostics()) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,RecordBindingDiagnostics,The length of the statement  "                if (!bindingDiagnostics.IsEmptyWithoutResolution && ((SyntaxTree)sourceLocation.SourceTree).ReportDocumentationCommentDiagnostics()) " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,EntryPointCandidateFinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\EntryPointCandidateFinder.cs,FindCandidatesInNamespace,The length of the statement  "            EntryPointCandidateFinder finder = new EntryPointCandidateFinder(entryPointCandidates' visitNestedTypes: true' cancellationToken: cancellationToken); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,EntryPointCandidateFinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\EntryPointCandidateFinder.cs,FindCandidatesInSingleType,The length of the statement  "            EntryPointCandidateFinder finder = new EntryPointCandidateFinder(entryPointCandidates' visitNestedTypes: false' cancellationToken: cancellationToken); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethodBodies,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_Compiler_CompileMethodBodies' message: compilation.AssemblyName' cancellationToken: cancellationToken)) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethodBodies,The length of the statement  "                if (moduleBeingBuiltOpt != null && methodCompiler._globalHasErrors && !diagnostics.HasAnyErrors() && !hasDeclarationErrors) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethodBodies,The length of the statement  "                MethodSymbol entryPoint = GetEntryPoint(compilation' moduleBeingBuiltOpt' hasDeclarationErrors' diagnostics' cancellationToken); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GetEntryPoint,The length of the statement  "                    ? DefineScriptEntryPoint(compilation' moduleBeingBuilt' compilation.GetSubmissionReturnType()' hasDeclarationErrors' diagnostics) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GetEntryPoint,The length of the statement  "                return DefineScriptEntryPoint(compilation' moduleBeingBuilt' compilation.GetSpecialType(SpecialType.System_Void)' hasDeclarationErrors' diagnostics); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GetEntryPoint,The length of the statement  "            Debug.Assert((object)entryPoint.MethodSymbol != null || entryPoint.Diagnostics.HasAnyErrors() || !compilation.Options.Errors.IsDefaultOrEmpty); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,The length of the statement  "            var synthesizedSubmissionFields = symbol.IsSubmissionClass ? new SynthesizedSubmissionFields(_compilation' symbol) : null; " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,The length of the statement  "                Binder.BindFieldInitializers(sourceTypeSymbol' scriptCtor' sourceTypeSymbol.StaticInitializers' _generateDebugInfo' _diagnostics' ref processedStaticInitializers); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,The length of the statement  "                Binder.BindFieldInitializers(sourceTypeSymbol' scriptCtor' sourceTypeSymbol.InstanceInitializers' _generateDebugInfo' _diagnostics' ref processedInstanceInitializers); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,The length of the statement  "                            if ((object)eventSymbol != null && eventSymbol.HasAssociatedField && !eventSymbol.IsAbstract && compilationState.Emitting) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,The length of the statement  "                                    ConstantValue constantValue = fieldSymbol.GetConstantValue(ConstantFieldsInProgress.Empty' earlyDecodingWellKnownAttributes: false); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,The length of the statement  "            Debug.Assert(symbol.TypeKind != TypeKind.Submission || ((object)scriptCtor != null && scriptCtor.IsSubmissionConstructor)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,The length of the statement  "            if (_moduleBeingBuiltOpt != null && !hasStaticConstructor && !processedStaticInitializers.BoundInitializers.IsDefaultOrEmpty) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,The length of the statement  "                CompileMethod(scriptCtor' submissionCtorOrdinal' ref processedInstanceInitializers' synthesizedSubmissionFields' compilationState); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileSynthesizedMethods,The length of the statement  "                // In case of async lambdas' which synthesize a state machine type during the following rewrite' the containing method has already been uniquely named'  " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileSynthesizedMethods,The length of the statement  "                // so there is no need to produce a unique method ordinal for the corresponding state machine type' whose name includes the (unique) containing method name. " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileSynthesizedMethods,The length of the statement  "                BoundStatement bodyWithoutAsync = AsyncRewriter.Rewrite(methodWithBody.Body' method' methodOrdinal' variableSlotAllocatorOpt' compilationState' diagnosticsThisMethod' out stateMachineType); " is 189.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileFieldLikeEventAccessor,The length of the statement  "                BoundBlock boundBody = MethodBodySynthesizer.ConstructFieldLikeEventAccessorBody(eventSymbol' isAddMethod' _compilation' diagnosticsThisMethod); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileFieldLikeEventAccessor,The length of the statement  "                // we however do not want to continue with generating method body if we have errors in this particular method - generating may crash " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileFieldLikeEventAccessor,The length of the statement  "                // or if had declaration errors - we will fail anyways' but if some types are bad enough' generating may produce duplicate errors about that. " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The length of the statement  "                    BoundTypeOrInstanceInitializers initializerStatements = InitializerRewriter.Rewrite(processedInitializers.BoundInitializers' methodSymbol); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The length of the statement  "                    body = new BoundBlock(initializerStatements.Syntax' ImmutableArray<LocalSymbol>.Empty' initializerStatements.Statements) { WasCompilerGenerated = true }; " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The length of the statement  "                    // with field initializers. Once lowered' these initializers will be stashed in processedInitializers.LoweredInitializers " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The length of the statement  "                            DataFlowPass.Analyze(_compilation' methodSymbol' analyzedInitializers' diagsForCurrentMethod' requireOutParamsAssigned: false); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The length of the statement  "                // If the method is a synthesized static or instance constructor' then debugImports will be null and we will use the value " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The length of the statement  "                    Debug.Assert(processedInitializers.BoundInitializers.IsDefaultOrEmpty || processedInitializers.FirstImportChain != null); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The length of the statement  "                        // Fields must be initialized before constructor initializer (which is the first statement of the analyzed body' if specified)' " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The length of the statement  "                        // so that the initialization occurs before any method overridden by the declaring class can be invoked from the base constructor " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The length of the statement  "                            boundStatements = MethodBodySynthesizer.ConstructScriptConstructorBody(loweredBodyOpt' methodSymbol' previousSubmissionFields' _compilation); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,LowerBodyOrInitializer,The length of the statement  "            BoundStatement bodyWithoutIterators = IteratorRewriter.Rewrite(bodyWithoutLambdas' method' methodOrdinal' lazyVariableSlotAllocator' compilationState' diagnostics' out iteratorStateMachine); " is 190.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,LowerBodyOrInitializer,The length of the statement  "            BoundStatement bodyWithoutAsync = AsyncRewriter.Rewrite(bodyWithoutIterators' method' methodOrdinal' lazyVariableSlotAllocator' compilationState' diagnostics' out asyncStateMachine); " is 182.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GenerateMethodBody,The length of the statement  "            Debug.Assert(!diagnostics.HasAnyErrors()' "Running code generator when errors exist might be dangerous; code generator not expecting errors"); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GenerateMethodBody,The length of the statement  "                var codeGen = new CodeGen.CodeGenerator(method' block' builder' moduleBuilder' diagnosticsForThisMethod' optimizations' generateDebugInfo); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GenerateMethodBody,The length of the statement  "                bool isStateMachineMoveNextMethod = stateMachineMethod != null && method.Name == WellKnownMemberNames.MoveNextMethodName; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GenerateMethodBody,The length of the statement  "                    // The exception handler IL offset is used by the debugger to treat exceptions caught by the marked catch block as "user unhandled". " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GenerateMethodBody,The length of the statement  "                    // but without anything useful on the call stack. Async Task methods on the other hand return exceptions as the result of the Task. " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GenerateMethodBody,The length of the statement  "                    // So it is undesirable to consider these exceptions "user unhandled" since there may well be user code that is awaiting the task. " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GenerateMethodBody,The length of the statement  "                    asyncDebugInfo = new Cci.AsyncMethodBodyDebugInfo(kickoffMethod' kickoffMethod.ReturnsVoid ? asyncCatchHandlerOffset : -1' asyncYieldPoints' asyncResumePoints); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GenerateMethodBody,The length of the statement  "                    GetStateMachineSlotDebugInfo(moduleBuilder.GetSynthesizedFields(stateMachineTypeOpt)' out stateMachineHoistedLocalSlots' out stateMachineAwaiterSlots); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,BindMethodBody,The length of the statement  "                    constructorInitializer = new BoundExpressionStatement(initializerInvocation.Syntax' initializerInvocation) { WasCompilerGenerated = true }; " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,BindMethodBody,The length of the statement  "                    Debug.Assert(initializerInvocation.HasAnyErrors || constructorInitializer.IsConstructorInitializer()' "Please keep this bound node in sync with BoundNodeExtensions.IsConstructorInitializer."); " is 192.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,BindMethodBody,The length of the statement  "            return new BoundBlock(method.GetNonNullSyntaxNode()' ImmutableArray<LocalSymbol>.Empty' statements) { WasCompilerGenerated = true }; " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,BindConstructorInitializer,The length of the statement  "            Binder initializerBinder = outerBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.ConstructorInitializer' constructor); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,GenerateExternalMethodWarnings,The length of the statement  "                var errorCode = (methodSymbol.MethodKind == MethodKind.Constructor || methodSymbol.MethodKind == MethodKind.StaticConstructor) ? " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructScriptConstructorBody,The length of the statement  "            // Script field initializers have to be emitted after the call to the base constructor because they can refer to "this" instance. " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructScriptConstructorBody,The length of the statement  "            // If the base class had a constructor that initializes its state a global variable would access partially initialized object.  " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructScriptConstructorBody,The length of the statement  "            Debug.Assert((object)constructor.ContainingType.BaseTypeNoUseSiteDiagnostics == null || constructor.ContainingType.BaseTypeNoUseSiteDiagnostics.SpecialType == SpecialType.System_Object); " is 186.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructScriptConstructorBody,The length of the statement  "                var submissionInitStatements = MakeSubmissionInitialization(syntax' constructor' previousSubmissionFields' compilation); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,MakeSubmissionInitialization,The length of the statement  "            var submissionArrayReference = new BoundParameter(syntax' submissionConstructor.Parameters[0]) { WasCompilerGenerated = true }; " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,MakeSubmissionInitialization,The length of the statement  "            var thisReference = new BoundThisReference(syntax' submissionConstructor.ContainingType) { WasCompilerGenerated = true }; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,MakeSubmissionInitialization,The length of the statement  "                        ImmutableArray.Create<BoundExpression>(new BoundLiteral(syntax' ConstantValue.Create(slotIndex)' intType) { WasCompilerGenerated = true })' " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,MakeSubmissionInitialization,The length of the statement  "                            new BoundFieldAccess(syntax' thisReference' hostObjectField' ConstantValue.NotAvailable) { WasCompilerGenerated = true }' " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,MakeSubmissionInitialization,The length of the statement  "                                    ImmutableArray.Create<BoundExpression>(new BoundLiteral(syntax' ConstantValue.Create(0)' intType) { WasCompilerGenerated = true })' " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,MakeSubmissionInitialization,The length of the statement  "                                    ImmutableArray.Create<BoundExpression>(new BoundLiteral(syntax' ConstantValue.Create(targetSubmissionIndex)' intType) { WasCompilerGenerated = true })' " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructAutoPropertyAccessorBody,The length of the statement  "            var fieldAccess = new BoundFieldAccess(syntax' thisReference' field' ConstantValue.NotAvailable) { WasCompilerGenerated = true }; " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructAutoPropertyAccessorBody,The length of the statement  "            return new BoundBlock(syntax' ImmutableArray<LocalSymbol>.Empty' ImmutableArray.Create<BoundStatement>(statement)) { WasCompilerGenerated = true }; " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructFieldLikeEventAccessorBody_WinRT,The length of the statement  "                WellKnownMember.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T__GetOrCreateEventRegistrationTokenTable' " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructFieldLikeEventAccessorBody_WinRT,The length of the statement  "            // EventRegistrationTokenTable<Event>.GetOrCreateEventRegistrationTokenTable(ref _tokenTable).AddHandler(value) // or RemoveHandler " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructFieldLikeEventAccessorBody_WinRT,The length of the statement  "                //     return EventRegistrationTokenTable<Event>.GetOrCreateEventRegistrationTokenTable(ref _tokenTable).AddHandler(value); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructFieldLikeEventAccessorBody_Regular,The length of the statement  "            SpecialMember updateMethodId = isAddMethod ? SpecialMember.System_Delegate__Combine : SpecialMember.System_Delegate__Remove; " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructFieldLikeEventAccessorBody_Regular,The length of the statement  "            MethodSymbol compareExchangeMethod = (MethodSymbol)compilation.GetWellKnownTypeMember(WellKnownMember.System_Threading_Interlocked__CompareExchange_T); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,SynthesizedMetadataCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\SynthesizedMetadataCompiler.cs,ProcessSynthesizedMembers,The length of the statement  "            using (Logger.LogBlock(FunctionId.CSharp_Compiler_CompileSynthesizedMethodMetadata' message: compilation.AssemblyName' cancellationToken: cancellationToken)) " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnprocessedDocumentationCommentFinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\UnprocessedDocumentationCommentFinder.cs,ReportUnprocessed,The length of the statement  "                UnprocessedDocumentationCommentFinder finder = new UnprocessedDocumentationCommentFinder(diagnostics' filterSpanWithinTree' cancellationToken); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,UnprocessedDocumentationCommentFinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\UnprocessedDocumentationCommentFinder.cs,VisitTrivia,The length of the statement  "                _diagnostics.Add(ErrorCode.WRN_UnprocessedXMLComment' new SourceLocation(trivia.SyntaxTree' new TextSpan(start' length))); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,WithExtendedCustomDebugInformation,The length of the statement  "            return new CSharpCompilationOptions(this) { ExtendedCustomDebugInformation_internal_protected_set = extendedCustomDebugInformation }; " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,ValidateOptions,The length of the statement  "                    builder.Add(Diagnostic.Create(MessageProvider.Instance' (int)ErrorCode.ERR_BadCompilationOptionValue' "MainTypeName"' MainTypeName)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,ValidateOptions,The length of the statement  "                builder.Add(Diagnostic.Create(MessageProvider.Instance' (int)ErrorCode.ERR_BadCompilationOptionValue' "OutputKind"' OutputKind.ToString())); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,ValidateOptions,The length of the statement  "                builder.Add(Diagnostic.Create(MessageProvider.Instance' (int)ErrorCode.ERR_BadCompilationOptionValue' "OptimizationLevel"' OptimizationLevel.ToString())); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,ValidateOptions,The length of the statement  "                builder.Add(Diagnostic.Create(MessageProvider.Instance' (int)ErrorCode.ERR_BadCompilationOptionValue' "ScriptClassName"' ScriptClassName ?? "null")); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,ValidateOptions,The length of the statement  "                builder.Add(Diagnostic.Create(MessageProvider.Instance' (int)ErrorCode.ERR_BadCompilationOptionValue' "WarningLevel"' WarningLevel)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,ValidateOptions,The length of the statement  "                builder.Add(Diagnostic.Create(MessageProvider.Instance' (int)ErrorCode.ERR_BadCompilationOptionValue' "Usings"' Usings.Where(u => !u.IsValidClrNamespaceName()).First() ?? "null")); " is 180.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,ValidateOptions,The length of the statement  "            if (Platform == Platform.AnyCpu32BitPreferred && OutputKind.IsValid() && !(OutputKind == OutputKind.ConsoleApplication || OutputKind == OutputKind.WindowsApplication || OutputKind == OutputKind.WindowsRuntimeApplication)) " is 221.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpExtensions.cs,ReplaceTrivia,The length of the statement  "            return Syntax.SyntaxReplacer.Replace(token' trivia: new[] { oldTrivia }' computeReplacementTrivia: (o' r) => newTrivia); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,DeclarationTable,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTable.Cache.cs,AddRootDeclaration,The length of the statement  "                return new DeclarationTable(_allOlderRootDeclarations.Add(_latestLazyRootDeclaration.Value)' lazyRootDeclaration' cache: null); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,DeclarationTable,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTable.Cache.cs,RemoveRootDeclaration,The length of the statement  "                return new DeclarationTable(_allOlderRootDeclarations.Remove(lazyRootDeclaration.Value)' _latestLazyRootDeclaration' cache: null); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,DeclarationTable,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTable.Cache.cs,GetMergedReferenceDirectives,The length of the statement  "                return UnionCollection<ReferenceDirective>.Create(cachedReferenceDirectives' _latestLazyRootDeclaration.Value.ReferenceDirectives); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,DeclarationTable,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTable.Cache.cs,GetMergedDiagnostics,The length of the statement  "                return UnionCollection<Diagnostic>.Create(cachedDiagnostics' _latestLazyRootDeclaration.Value.ReferenceDirectiveDiagnostics); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,DeclarationTreeBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTreeBuilder.cs,VisitNamespaceChildren,The length of the statement  "            Debug.Assert(node.Kind() == SyntaxKind.NamespaceDeclaration || (node.Kind() == SyntaxKind.CompilationUnit && _syntaxTree.Options.Kind == SourceCodeKind.Regular)); " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,DeclarationTreeBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTreeBuilder.cs,CreateScriptRootDeclaration,The length of the statement  "            var membernames = GetNonTypeMemberNames(((Syntax.InternalSyntax.CompilationUnitSyntax)(compilationUnit.Green)).Members' ref declFlags); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,DeclarationTreeBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTreeBuilder.cs,VisitCompilationUnit,The length of the statement  "            var children = VisitNamespaceChildren(compilationUnit' compilationUnit.Members' ((Syntax.InternalSyntax.CompilationUnitSyntax)(compilationUnit.Green)).Members); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,DeclarationTreeBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTreeBuilder.cs,AddNonTypeMemberNames,The length of the statement  "                    set.Add(((Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax)member).ImplicitOrExplicitKeyword.Kind == SyntaxKind.ImplicitKeyword " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,SourceDocumentationCommentUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\DocumentationComments\SourceDocumentationCommentUtils.cs,GetAndCacheDocumentationComment,The length of the statement  "                string xmlText = DocumentationCommentCompiler.GetDocumentationCommentXml(symbol' expandIncludes' default(CancellationToken)); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,MessageProvider,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\MessageProvider.cs,ReportInvalidNamedArgument,The length of the statement  "            diagnostics.Add(ErrorCode.ERR_InvalidNamedArgument' node.ArgumentList.Arguments[namedArgumentIndex].Location' parameterName); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,MessageProvider,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\MessageProvider.cs,ReportMarshalUnmanagedTypeNotValidForFields,The length of the statement  "            diagnostics.Add(ErrorCode.ERR_MarshalUnmanagedTypeNotValidForFields' attributeArgumentSyntax.Location' unmanagedTypeName); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,MessageProvider,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\MessageProvider.cs,ReportMarshalUnmanagedTypeOnlyValidForFields,The length of the statement  "            diagnostics.Add(ErrorCode.ERR_MarshalUnmanagedTypeOnlyValidForFields' attributeArgumentSyntax.Location' unmanagedTypeName); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,XmlSyntaxDiagnosticInfo,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\XmlSyntaxDiagnosticInfo.cs,GetMessage,The length of the statement  "            return String.Format(formatProvider' String.Format(formatProvider' messagePrefix' message)' GetArgumentsToUse(formatProvider)); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpControlFlowAnalysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ControlFlowAnalysis.cs,ComputeReachability,The length of the statement  "                RegionReachableWalker.Analyze(_context.Compilation' _context.Member' _context.BoundNode' _context.FirstInRegion' _context.LastInRegion' out startIsReachable' out endIsReachable); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDataFlowAnalysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowAnalysis.cs,AnalyzeReadWrite,The length of the statement  "                ReadWriteWalker.Analyze(_context.Compilation' _context.Member' _context.BoundNode' _context.FirstInRegion' _context.LastInRegion' UnassignedVariableAddressOfSyntaxes' " is 166.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDataFlowAnalysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowAnalysis.cs,AnalyzeReadWrite,The length of the statement  "                readInside = writtenInside = readOutside = writtenOutside = captured = unsafeAddressTaken = ImmutableArray<ISymbol>.Empty; " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,ReportUnassignedOutParameter,The length of the statement  "                    // if it is a "this" parameter in a struct constructor' we use a different diagnostic reflecting which pieces are not assigned " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,Analyze,The length of the statement  "                        Debug.Assert(captured.Kind == SymbolKind.Parameter || captured.Kind == SymbolKind.Local || captured.Kind == SymbolKind.RangeVariable); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,NoteWrite,The length of the statement  "                                _sourceAssembly.NoteFieldAccess(field' read: value == null || WriteConsideredUse(fieldAccess.FieldSymbol.Type' value)' write: true); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,NoteWrite,The length of the statement  "                                    _sourceAssembly.NoteFieldAccess(field' read: value == null || WriteConsideredUse(associatedField.Type' value)' write: true); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,MakeSlot,The length of the statement  "                        if (fieldSymbol.IsStatic || receiverOpt == null || receiverOpt.Kind == BoundKind.TypeExpression) return -1; // access of static field " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,MakeSlot,The length of the statement  "                        if (eventSymbol.IsStatic || receiverOpt == null || receiverOpt.Kind == BoundKind.TypeExpression) return -1; // access of static event " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,MakeSlot,The length of the statement  "                                if (propSymbol.IsStatic || receiverOpt == null || receiverOpt.Kind == BoundKind.TypeExpression) return -1; // access of static property " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,MakeSlot,The length of the statement  "                                if ((object)receiverOpt.Type == null || receiverOpt.Type.TypeKind != TypeKind.Struct) return -1; // property of non-struct " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,ReportUnassigned,The length of the statement  "            if (symbol.Kind == SymbolKind.Local && (symbol.Locations.Length == 0 || node.Span.End < symbol.Locations[0].SourceSpan.Start)) " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,IsAssigned,The length of the statement  "                        if (!MayRequireTracking(fieldAccess.ReceiverOpt' fieldAccess.FieldSymbol) || IsAssigned(fieldAccess.ReceiverOpt' out unassignedSlot)) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,IsAssigned,The length of the statement  "                        if (!MayRequireTracking(eventAccess.ReceiverOpt' eventAccess.EventSymbol.AssociatedField) || IsAssigned(eventAccess.ReceiverOpt' out unassignedSlot)) " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,IsAssigned,The length of the statement  "                                if (!MayRequireTracking(propertyAccess.ReceiverOpt' backingField) || IsAssigned(propertyAccess.ReceiverOpt' out unassignedSlot)) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,ReportIfUnused,The length of the statement  "                    Diagnostics.Add(assigned && _writtenVariables.Contains(symbol) ? ErrorCode.WRN_UnreferencedVarAssg : ErrorCode.WRN_UnreferencedVar' symbol.Locations[0]' symbol.Name); " is 166.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,VisitLocal,The length of the statement  "            if (localSymbol.IsFixed && this.currentMethodOrLambda.MethodKind == MethodKind.AnonymousFunction && _capturedVariables.Contains(localSymbol)) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,VariableIdentifier,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.VariableIdentifier.cs,Equals,The length of the statement  "                return ((object)Symbol == null ? (object)other.Symbol == null : Symbol.Equals(other.Symbol)) && ContainingSlot == other.ContainingSlot; " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowsInWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsInWalker.cs,Analyze,The length of the statement  "            var walker = new DataFlowsInWalker(compilation' member' node' firstInRegion' lastInRegion' unassignedVariables' unassignedVariableAddressOfSyntaxes); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowsInWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsInWalker.cs,NoteBranch,The length of the statement  "            if (!gotoStmt.WasCompilerGenerated && !targetStmt.WasCompilerGenerated && !RegionContains(gotoStmt.Syntax.Span) && RegionContains(targetStmt.Syntax.Span)) " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowsOutWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsOutWalker.cs,Analyze,The length of the statement  "            var walker = new DataFlowsOutWalker(compilation' member' node' firstInRegion' lastInRegion' unassignedVariables' dataFlowsIn); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,DataFlowsOutWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsOutWalker.cs,FlowsOut,The length of the statement  "            return (object)param != null && param.RefKind != RefKind.None && !param.IsImplicitlyDeclared && !RegionContains(param.Locations[0].SourceSpan); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,EmptyStructTypeCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\EmptyStructTypeCache.cs,GetActualInstanceField,The length of the statement  "                        return (!eventSymbol.HasAssociatedField || ShouldIgnoreStructField(eventSymbol' eventSymbol.Type)) ? null : eventSymbol.AssociatedField.AsMember(type); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,EmptyStructTypeCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\EmptyStructTypeCache.cs,ShouldIgnoreStructField,The length of the statement  "            return _dev12CompilerCompatibility &&                             // when we're trying to be compatible with the native compiler' we ignore " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,EmptyStructTypeCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\EmptyStructTypeCache.cs,ShouldIgnoreStructField,The length of the statement  "                   IsIgnorableType(memberType) &&                                 // of reference type (but not type parameters' looking through arrays) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,EntryPointsWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\EntryPointsWalker.cs,NoteBranch,The length of the statement  "            if (!gotoStmt.WasCompilerGenerated && !targetStmt.WasCompilerGenerated && RegionContains(targetStmt.Syntax.Span) && !RegionContains(gotoStmt.Syntax.Span)) " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,FlowAnalysisPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\FlowAnalysisPass.cs,Rewrite,The length of the statement  "                    block = AppendImplicitReturn(block' method' ((object)sourceMethod != null) ? sourceMethod.BodySyntax as BlockSyntax : null); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,PreciseAbstractFlowPass<LocalState>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\PreciseAbstractFlowPass.AbstractLocalState.cs,VisitReceiverAfterCall,The length of the statement  "            if (receiverOpt != null && ((object)method == null || method.MethodKind == MethodKind.Constructor || (object)(containingType = method.ContainingType) != null && !method.IsStatic && !containingType.IsReferenceType && !TypeIsImmutable(containingType))) " is 250.
Long Statement,Microsoft.CodeAnalysis.CSharp,PreciseAbstractFlowPass<LocalState>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\PreciseAbstractFlowPass.AbstractLocalState.cs,VisitReceiverAfterCall,The length of the statement  "                WriteArgument(receiverOpt' (object)method != null && method.MethodKind == MethodKind.Constructor ? RefKind.Out : RefKind.Ref' method); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,PreciseAbstractFlowPass<LocalState>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\PreciseAbstractFlowPass.AbstractLocalState.cs,VisitMethodGroup,The length of the statement  "                // An explicit or implicit receiver' for example in an expression such as (x.Foo is Action' or Foo is Action)' is condidered to be read. " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReadWriteWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ReadWriteWalker.cs,Analyze,The length of the statement  "            var walker = new ReadWriteWalker(compilation' member' node' firstInRegion' lastInRegion' unassignedVariableAddressOfSyntaxes); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReadWriteWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ReadWriteWalker.cs,Analyze,The length of the statement  "                    readInside = writtenInside = readOutside = writtenOutside = captured = unsafeAddressTaken = ImmutableArray<ISymbol>.Empty; " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncExceptionHandlerRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncExceptionHandlerRewriter.cs,Rewrite,The length of the statement  "            var rewriter = new AsyncExceptionHandlerRewriter(containingSymbol' containingType' factory' compilation' diagnostics' analysis); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncExceptionHandlerRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncExceptionHandlerRewriter.cs,VisitTryStatement,The length of the statement  "            var pendingExceptionLocal = new SynthesizedLocal(_F.CurrentMethod' exceptionType' SynthesizedLocalKind.TryAwaitPendingException' tryStatementSyntax); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncExceptionHandlerRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncExceptionHandlerRewriter.cs,VisitTryStatement,The length of the statement  "            var pendingBranchVar = new SynthesizedLocal(_F.CurrentMethod' _F.SpecialType(SpecialType.System_Int32)' SynthesizedLocalKind.TryAwaitPendingBranch' tryStatementSyntax); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncExceptionHandlerRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncExceptionHandlerRewriter.cs,Rethrow,The length of the statement  "            var exceptionDispatchInfoCapture = _F.WellKnownMethod(WellKnownMember.System_Runtime_ExceptionServices_ExceptionDispatchInfo__Capture' isOptional: true); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncExceptionHandlerRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncExceptionHandlerRewriter.cs,Rethrow,The length of the statement  "            var exceptionDispatchInfoThrow = _F.WellKnownMethod(WellKnownMember.System_Runtime_ExceptionServices_ExceptionDispatchInfo__Throw' isOptional: true); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncExceptionHandlerRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncExceptionHandlerRewriter.cs,PushFrame,The length of the statement  "            var newFrame = new AwaitFinallyFrame(_currentAwaitFinallyFrame' _analysis.Labels(statement)' (TryStatementSyntax)statement.Syntax); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitFinallyFrame,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncExceptionHandlerRewriter.cs,ProxyReturnIfNeeded,The length of the statement  "                        this.returnValue = returnValue = new SynthesizedLocal(containingMethod' valueOpt.Type' SynthesizedLocalKind.AsyncMethodReturnValue' _tryStatementSyntaxOpt); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitCatchFrame,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncExceptionHandlerRewriter.cs,HoistLocal,The length of the statement  "                var newLocal = F.SynthesizedLocal(local.Type' pendingCatch.SyntaxOpt' kind: SynthesizedLocalKind.ExceptionFilterAwaitHoistedExceptionLocal); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncMethodBuilderMemberCollection,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodBuilderMemberCollection.cs,TryCreate,The length of the statement  "                if (!TryGetWellKnownPropertyAsMember(F' WellKnownMember.System_Runtime_CompilerServices_AsyncTaskMethodBuilder__Task' builderType' out task)) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncMethodBuilderMemberCollection,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodBuilderMemberCollection.cs,TryCreate,The length of the statement  "                NamedTypeSymbol builderType = F.WellKnownType(WellKnownType.System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T).Construct(resultType); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncMethodBuilderMemberCollection,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodBuilderMemberCollection.cs,TryCreate,The length of the statement  "                if (!TryGetWellKnownPropertyAsMember(F' WellKnownMember.System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__Task' builderType' out task)) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncMethodBuilderMemberCollection,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodBuilderMemberCollection.cs,TryCreate,The length of the statement  "                    awaitUnsafeOnCompleted: WellKnownMember.System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__AwaitUnsafeOnCompleted' " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncMethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodToStateMachineRewriter.cs,GetAwaiterField,The length of the statement  "                if (slotAllocatorOpt == null || !slotAllocatorOpt.TryGetPreviousAwaiterSlotIndex((Cci.ITypeReference)awaiterType' out slotIndex)) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncMethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodToStateMachineRewriter.cs,VisitAwaitExpression,The length of the statement  "            MethodSymbol isCompletedMethod = ((object)node.IsCompleted != null) ? VisitMethodSymbol(node.IsCompleted.GetMethod) : null; " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncMethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodToStateMachineRewriter.cs,VisitAwaitExpression,The length of the statement  "            // The lifespan of awaiter temp doesn't cross sequence points (user code in between awaits)' so it doesn't need to be named. " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncMethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodToStateMachineRewriter.cs,GenerateAwaitForIncompleteTask,The length of the statement  "                    F.Assignment(F.Field(F.This()' stateField)' F.AssignmentExpression(F.Local(cachedState)' F.Literal(StateMachineStates.NotStartedStateMachine)))); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,Rewrite,The length of the statement  "            // The CLR doesn't support adding fields to structs' so in order to enable EnC in an async method we need to generate a class. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,Rewrite,The length of the statement  "            var rewriter = new AsyncRewriter(bodyWithAwaitLifted' (SourceMethodSymbol)method' methodOrdinal' stateMachineType' slotAllocatorOpt' compilationState' diagnostics); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,GenerateControlFields,The length of the statement  "            this.stateField = F.StateMachineField(F.SpecialType(SpecialType.System_Int32)' GeneratedNames.MakeStateMachineStateFieldName()' isPublic: true); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,GenerateControlFields,The length of the statement  "            _builderField = F.StateMachineField(_asyncMethodBuilderMemberCollection.BuilderType' GeneratedNames.AsyncBuilderFieldName()' isPublic: true); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,GenerateMethodImplementations,The length of the statement  "            var IAsyncStateMachine_MoveNext = F.WellKnownMethod(WellKnownMember.System_Runtime_CompilerServices_IAsyncStateMachine_MoveNext); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,GenerateMethodImplementations,The length of the statement  "            var IAsyncStateMachine_SetStateMachine = F.WellKnownMethod(WellKnownMember.System_Runtime_CompilerServices_IAsyncStateMachine_SetStateMachine); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,AsyncRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs,GenerateMethodImplementations,The length of the statement  "            // SetStateMachine is used to initialize the underlying AsyncMethodBuilder's reference to the boxed copy of the state machine. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,VisitExpression,The length of the statement  "                var replacement = _F.StoreToTemp(awaitExpression' out assignToTemp' kind: SynthesizedLocalKind.AwaitSpill' syntaxOpt: syntax); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,Spill,The length of the statement  "                        var newArgs = VisitExpressionList(ref builder' argumentList.Arguments' argumentList.ArgumentRefKindsOpt' forceSpill: true); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,Spill,The length of the statement  "                            var receiver = Spill(builder' field.ReceiverOpt' (refKind != RefKind.None && field.FieldSymbol.Type.IsReferenceType) ? refKind : RefKind.None' sideEffectsOnly); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,VisitExpressionList,The length of the statement  "                var refKind = (!refKinds.IsDefaultOrEmpty && refKinds.Length > i && refKinds[i] != RefKind.None) ? RefKind.Ref : RefKind.None; " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,VisitSwitchStatement,The length of the statement  "            return UpdateStatement(builder' node.Update(boundExpression' node.ConstantTargetOpt' node.InnerLocals' switchSections' node.BreakLabel' node.StringEquality)' substituteTemps: true); " is 181.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,VisitExpressionStatement,The length of the statement  "                expr = awaitExpression.Update(expression' awaitExpression.GetAwaiter' awaitExpression.IsCompleted' awaitExpression.GetResult' awaitExpression.Type); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,VisitBinaryOperator,The length of the statement  "            return UpdateExpression(builder' node.Update(node.OperatorKind' left' right' node.ConstantValue' node.MethodOpt' node.ResultKind' node.Type)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,VisitConditionalOperator,The length of the statement  "                return UpdateExpression(conditionBuilder' node.Update(condition' consequence' alternative' node.ConstantValueOpt' node.Type)); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,VisitFieldAccess,The length of the statement  "            return UpdateExpression(builder' node.Update(receiver' node.FieldSymbol' node.ConstantValueOpt' node.ResultKind' node.Type)); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,VisitObjectCreationExpression,The length of the statement  "            return UpdateExpression(builder' node.Update(node.Constructor' arguments' node.ArgumentNamesOpt' node.ArgumentRefKindsOpt' node.Expanded' node.ArgsToParamsOpt' node.ConstantValueOpt' node.InitializerExpressionOpt' node.Type)); " is 226.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,VisitSequence,The length of the statement  "            var sideEffects = VisitExpressionList(ref builder' node.SideEffects' forceSpill: valueBuilder != null' sideEffectsOnly: true); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,VisitUnaryOperator,The length of the statement  "            return UpdateExpression(builder' node.Update(node.OperatorKind' operand' node.ConstantValueOpt' node.MethodOpt' node.ResultKind' node.Type)); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,BoundSpillSequenceBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,GetStatements,The length of the statement  "                return _statements.SelectAsArray((statement' substituter) => (BoundStatement)substituter.Visit(statement)' substituterOpt); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,VisitAssignmentOperator,The length of the statement  "            if (!CheckForAssignmentToSelf(node) && _inExpressionLambda && node.Left.Kind != BoundKind.ObjectInitializerMember && node.Left.Kind != BoundKind.DynamicObjectInitializerMember) " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,VisitEventAccess,The length of the statement  "                Binder.ReportDiagnosticsIfObsolete(_diagnostics' node.EventSymbol.AssociatedField' node.Syntax' hasBaseReceiver' _containingSymbol' _containingSymbol.ContainingType' BinderFlags.None); " is 184.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,VisitEventAssignmentOperator,The length of the statement  "            Binder.ReportDiagnosticsIfObsolete(_diagnostics' node.Event' ((AssignmentExpressionSyntax)node.Syntax).Left' hasBaseReceiver' _containingSymbol' _containingSymbol.ContainingType' BinderFlags.None); " is 197.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,VisitCall,The length of the statement  "                else if (arguments.Length < (((object)propertyAccess != null) ? propertyAccess.ParameterCount : method.ParameterCount) + (expanded ? -1 : 0)) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,VisitCollectionElementInitializer,The length of the statement  "            VisitCall(node.AddMethod' null' node.Arguments' default(ImmutableArray<RefKind>)' default(ImmutableArray<string>)' node.Expanded' node); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,VisitObjectCreationExpression,The length of the statement  "            VisitCall(node.Constructor' null' node.Arguments' node.ArgumentRefKindsOpt' node.ArgumentNamesOpt' node.Expanded' node); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,IsComCallWithRefOmitted,The length of the statement  "                if (method.Parameters[i].RefKind != RefKind.None && (argumentRefKindsOpt.IsDefault || argumentRefKindsOpt[i] == RefKind.None)) return true; " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckRelationals,The length of the statement  "                if (node.Left.Type.SpecialType == SpecialType.System_Object && !IsExplicitCast(node.Left) && !(node.Left.ConstantValue != null && node.Left.ConstantValue.IsNull) && ConvertedHasEqual(node.OperatorKind' node.Right' out t)) " is 221.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckRelationals,The length of the statement  "                else if (node.Right.Type.SpecialType == SpecialType.System_Object && !IsExplicitCast(node.Right) && !(node.Right.ConstantValue != null && node.Right.ConstantValue.IsNull) && ConvertedHasEqual(node.OperatorKind' node.Left' out t)) " is 229.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,ConvertedHasEqual,The length of the statement  "            string opName = (oldOperatorKind == BinaryOperatorKind.ObjectEqual) ? WellKnownMemberNames.EqualityOperatorName : WellKnownMemberNames.InequalityOperatorName; " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckOr,The length of the statement  "            // (ulong)0xFFFFFFFFFFFFFFFF | y -- suppresses the warning' because 0xFFFFFFFFFFFFFFFF as a signed long fits into a short. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckNullableNullBinOp,The length of the statement  "                    // CS0472: The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}' " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckLiftedBinOp,The length of the statement  "                    // CS0472: The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}' " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckLiftedBinOp,The length of the statement  "                        Error(node.OperatorKind.IsUserDefined() ? ErrorCode.WRN_NubExprIsConstBool2 : ErrorCode.WRN_NubExprIsConstBool' node' always' node.Left.Type.GetNullableUnderlyingType()' GetTypeForLiftedComparisonWarning(node.Right)); " is 217.
Long Statement,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckLiftedBinOp,The length of the statement  "                        Error(node.OperatorKind.IsUserDefined() ? ErrorCode.WRN_NubExprIsConstBool2 : ErrorCode.WRN_NubExprIsConstBool' node' always' node.Right.Type.GetNullableUnderlyingType()' GetTypeForLiftedComparisonWarning(node.Left)); " is 217.
Long Statement,Microsoft.CodeAnalysis.CSharp,InitializerRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\InitializerRewriter.cs,Rewrite,The length of the statement  "                        if (constructor.IsSubmissionConstructor && i == boundInitializers.Length - 1 && stmtInit.Statement.Kind == BoundKind.ExpressionStatement) " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorConstructor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorConstructor.cs,AddSynthesizedAttributes,The length of the statement  "            AddSynthesizedAttribute(ref attributes' compilation.TrySynthesizeAttribute(WellKnownMember.System_Diagnostics_DebuggerHiddenAttribute__ctor)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorMethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorMethodToStateMachineRewriter.IteratorFinallyFrame.cs,VisitGotoStatement,The length of the statement  "            Debug.Assert(node.Label == proxyLabel || !(F.CurrentMethod is IteratorFinallyMethodSymbol)' "should not be proxying branches in finally"); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorMethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorMethodToStateMachineRewriter.IteratorFinallyFrame.cs,PushFrame,The length of the statement  "            var newFrame = new IteratorFinallyFrame(_currentFinallyFrame' state' finallyMethod' _yieldsInTryAnalysis.Labels(statement)); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorMethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorMethodToStateMachineRewriter.IteratorFinallyFrame.cs,MakeSynthesizedFinally,The length of the statement  "            var finallyMethod = new IteratorFinallyMethodSymbol(stateMachineType' GeneratedNames.MakeIteratorFinallyMethodName(state)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,Rewrite,The length of the statement  "            stateMachineType = new IteratorStateMachine(slotAllocatorOpt' compilationState' method' methodOrdinal' isEnumerable' elementType); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,Rewrite,The length of the statement  "            return new IteratorRewriter(body' method' isEnumerable' stateMachineType' slotAllocatorOpt' compilationState' diagnostics).Rewrite(); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateControlFields,The length of the statement  "            this.stateField = F.StateMachineField(F.SpecialType(SpecialType.System_Int32)' GeneratedNames.MakeStateMachineStateFieldName()); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumeratorImplementation,The length of the statement  "            var IEnumeratorOfElementType = F.SpecialType(SpecialType.System_Collections_Generic_IEnumerator_T).Construct(_elementType); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumeratorImplementation,The length of the statement  "            var IEnumeratorOfElementType_get_Current = F.SpecialProperty(SpecialMember.System_Collections_Generic_IEnumerator_T__Current).GetMethod.AsMember(IEnumeratorOfElementType); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumeratorImplementation,The length of the statement  "                OpenMethodImplementation(IEnumerator_Reset' debuggerHidden: true' generateDebugInfo: false' hasMethodBodyDependency: false); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumerableImplementation,The length of the statement  "            var IEnumerableOfElementType = F.SpecialType(SpecialType.System_Collections_Generic_IEnumerable_T).Construct(_elementType); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumerableImplementation,The length of the statement  "            var IEnumerableOfElementType_GetEnumerator = F.SpecialMethod(SpecialMember.System_Collections_Generic_IEnumerable_T__GetEnumerator).AsMember(IEnumerableOfElementType); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumerableImplementation,The length of the statement  "            BoundStatement makeIterator = F.Assignment(F.Local(resultVariable)' F.New(stateMachineType.Constructor' F.Literal(0))); // result = new IteratorClass(0) " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumerableImplementation,The length of the statement  "                PropertySymbol currentManagedThreadIdProperty = F.WellKnownMember(WellKnownMember.System_Environment__CurrentManagedThreadId' isOptional: true) as PropertySymbol; " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumerableImplementation,The length of the statement  "                    managedThreadId = F.Property(F.Property(WellKnownMember.System_Threading_Thread__CurrentThread)' WellKnownMember.System_Threading_Thread__ManagedThreadId); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumerableImplementation,The length of the statement  "                    condition: F.LogicalAnd(                                   // if (this.state == -2 && this.initialThreadId == Thread.CurrentThread.ManagedThreadId) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumerableImplementation,The length of the statement  "                            method.IsStatic || method.ThisParameter.Type.IsReferenceType ?   // if this is a reference type' no need to copy it since it is not assignable " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateEnumerableImplementation,The length of the statement  "            var getEnumerator = OpenMethodImplementation(IEnumerable_GetEnumerator' debuggerHidden: true' generateDebugInfo: false); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\IteratorRewriter\IteratorRewriter.cs,GenerateConstructor,The length of the statement  "            bodyBuilder.Add(F.Assignment(F.Field(F.This()' stateField)' F.Parameter(F.CurrentMethod.Parameters[0]))); // this.state = state; " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,VisitInternal,The length of the statement  "                    return VisitBinaryOperator(userDefCondLogOp.OperatorKind' userDefCondLogOp.LogicalOperator' userDefCondLogOp.Type' userDefCondLogOp.Left' userDefCondLogOp.Right); " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,VisitArrayCreation,The length of the statement  "                    return new BoundBadExpression(node.Syntax' default(LookupResultKind)' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(node)' ExpressionType); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,VisitBaseReference,The length of the statement  "            return new BoundBadExpression(node.Syntax' 0' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(node)' ExpressionType); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,MakeBinary,The length of the statement  "                    requiresLifted ? ExprFactory(opName' loweredLeft' loweredRight' _bound.Literal(isLifted && methodOpt.ReturnType != type)' _bound.MethodInfo(methodOpt)) : " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,Demote,The length of the statement  "                if (e.TypeKind == TypeKind.Enum || e.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T && e.TypeArgumentsNoUseSiteDiagnostics[0].TypeKind == TypeKind.Enum) " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,Demote,The length of the statement  "                var promotedType = e.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T ? _nullableType.Construct(PromotedType((NamedTypeSymbol)e.TypeArgumentsNoUseSiteDiagnostics[0])) : PromotedType(e); " is 200.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,VisitConversion,The length of the statement  "                            strippedOperandType != ((node.ConversionKind == ConversionKind.ExplicitUserDefined) ? conversionInputType : conversionInputType.StrippedType()); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,VisitConversion,The length of the statement  "                        var resultType = (isLifted && method.ReturnType.IsNonNullableValueType() && node.Type.IsNullableType()) ? _nullableType.Construct(method.ReturnType) : method.ReturnType; " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,DelegateCreation,The length of the statement  "            receiver = staticMember ? nullObject : receiver.Type.IsReferenceType ? receiver : _bound.Convert(_objectType' receiver); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,DelegateCreation,The length of the statement  "            var createDelegate = _bound.WellKnownMethod(WellKnownMember.System_Reflection_MethodInfo__CreateDelegate' isOptional: true); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,DelegateCreation,The length of the statement  "                unquoted = _bound.StaticCall(_bound.SpecialType(SpecialType.System_Delegate)' "CreateDelegate"' _bound.Typeof(delegateType)' receiver' _bound.MethodInfo(method)); " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,VisitDelegateCreationExpression,The length of the statement  "                return DelegateCreation(mg.ReceiverOpt' node.MethodOpt' node.Type' node.MethodOpt.IsStatic && !mg.SearchExtensionMethods); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,VisitPointerIndirectionOperator,The length of the statement  "            return new BoundBadExpression(node.Syntax' default(LookupResultKind)' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(node)' node.Type); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,VisitPointerElementAccess,The length of the statement  "            return new BoundBadExpression(node.Syntax' default(LookupResultKind)' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(node)' node.Type); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,VisitSizeOfOperator,The length of the statement  "            return new BoundBadExpression(node.Syntax' default(LookupResultKind)' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(node)' node.Type); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,AddStatementsIfNeeded,The length of the statement  "                body = new BoundBlock(body.Syntax' _addedLocals.ToImmutableAndFree()' _addedStatements.ToImmutableAndFree()) { WasCompilerGenerated = true }; " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,MakeFrames,The length of the statement  "                        // CS4013: Instance of type '{0}' cannot be used inside an anonymous function' query expression' iterator block or async method " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,GetStaticFrame,The length of the statement  "                        methodId = new MethodDebugId(MethodDebugId.UndefinedOrdinal' CompilationState.ModuleBuilderOpt.CurrentGenerationOrdinal); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,GetStaticFrame,The length of the statement  "                        methodId = slotAllocatorOpt?.PreviousMethodId ?? new MethodDebugId(_topLevelMethodOrdinal' CompilationState.ModuleBuilderOpt.CurrentGenerationOrdinal); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,GetStaticFrame,The length of the statement  "                    _lazyStaticLambdaFrame = new LambdaFrame(slotAllocatorOpt' _topLevelMethod' methodId' scopeSyntaxOpt: null' closureOrdinal: -1); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,IntroduceFrame,The length of the statement  "            LocalSymbol framePointer = new SynthesizedLocal(_topLevelMethod' frameType' SynthesizedLocalKind.LambdaDisplayClass' frame.ScopeSyntaxOpt); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,IntroduceFrame,The length of the statement  "                    BoundExpression left = new BoundFieldAccess(syntax' new BoundLocal(syntax' framePointer' null' frameType)' frameParent' null); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,IntroduceFrame,The length of the statement  "                    if (_currentMethod.MethodKind == MethodKind.Constructor && capturedFrame.Type == _currentMethod.ContainingType && !_seenBaseCall) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,GetLambdaId,The length of the statement  "            int syntaxOffset = _topLevelMethod.CalculateLocalSyntaxOffset(lambdaOrLambdaBodySyntax.SpanStart' lambdaOrLambdaBodySyntax.SyntaxTree); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,GetLambdaId,The length of the statement  "                topLevelMethodId = new MethodDebugId(_topLevelMethodOrdinal' CompilationState.ModuleBuilderOpt.CurrentGenerationOrdinal); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,RewriteLambdaConversion,The length of the statement  "                var result0 = wasInExpressionLambda ? node : ExpressionLambdaRewriter.RewriteLambda(node' CompilationState' TypeMap' Diagnostics); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,RewriteLambdaConversion,The length of the statement  "            var synthesizedMethod = new SynthesizedLambdaMethod(translatedLambdaContainer' closureKind' _topLevelMethod' topLevelMethodId' node' lambdaOrdinal); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,RewriteLambdaConversion,The length of the statement  "                        // If we are generating the field into a display class created exclusively for the lambda the lambdaOrdinal itself is unique already'  " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,RewriteLambdaConversion,The length of the statement  "                        var cacheField = new SynthesizedLambdaCacheFieldSymbol(translatedLambdaContainer' cacheVariableType' cacheVariableName' _topLevelMethod' isReadOnly: false' isStatic: closureKind == ClosureKind.Static); " is 201.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,RewriteLambdaConversion,The length of the statement  "                        cache = F.Field(receiver' cacheField.AsMember(constructedFrame)); //NOTE: the field was added to the unconstructed frame type. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,RewriteLambdaConversion,The length of the statement  "                    return new BoundBadExpression(F.Syntax' LookupResultKind.Empty' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(node)' node.Type); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,SynthesizedLambdaMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\SynthesizedLambdaMethod.cs,MakeName,The length of the statement  "            // Lambda method name must contain the declaring method ordinal to be unique unless the method is emitted into a closure class exclusive to the declaring method. " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,Rewrite,The length of the statement  "                var localRewriter = new LocalRewriter(compilation' method' methodOrdinal' containingType' factory' previousSubmissionFields' allowOmissionOfConditionalCalls' diagnostics); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitExpressionImpl,The length of the statement  "            Debug.Assert(visited == null || visited.HasErrors || ReferenceEquals(visited.Type' node.Type) || visited.Type.Equals(node.Type' ignoreDynamic: true)); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,BadExpression,The length of the statement  "            return new BoundBadExpression(node.Syntax' LookupResultKind.NotReferencable' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(node)' node.Type); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TryGetWellKnownTypeMember,The length of the statement  "            symbol = (TSymbol)Binder.GetWellKnownTypeMember(_compilation' member' _diagnostics' syntax: syntax' isOptional: isOptional); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetSpecialTypeMethod,The length of the statement  "                TypeSymbol returnType = new ExtendedErrorTypeSymbol(compilation: _compilation' name: descriptor.Name' errorInfo: null' arity: descriptor.Arity); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TryGetSpecialTypeMember,The length of the statement  "                _diagnostics.Add(ErrorCode.ERR_MissingPredefinedMember' syntax.Location' descriptor.DeclaringTypeMetadataName' descriptor.Name); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeAsOperator,The length of the statement  "                ConstantValue constantValue = Binder.GetAsOperatorConstantResult(rewrittenOperand.Type' rewrittenType' conversion.Kind' rewrittenOperand.ConstantValue); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeAsOperator,The length of the statement  "                    BoundExpression result = rewrittenType.IsNullableType() ? new BoundDefaultOperator(syntax' rewrittenType) : MakeLiteral(syntax' constantValue' rewrittenType); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakePropertyAssignment,The length of the statement  "            // such as generating a params array' re-ordering arguments based on argsToParamsOpt map' inserting arguments for optional parameters' etc. " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakePropertyAssignment,The length of the statement  "            rewrittenArguments = MakeArguments(syntax' rewrittenArguments' property' setMethod' expanded' argsToParamsOpt' ref argumentRefKindsOpt' out argTemps' enableCallerInfo: ThreeState.True); " is 185.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TryFoldWithConditionalAccess,The length of the statement  "                            accessExpression = _factory.Sequence(accessExpression' MakeBooleanConstant(syntax' operatorKind == BinaryOperatorKind.NullableNullNotEqual)); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TryFoldWithConditionalAccess,The length of the statement  "                        accessExpression = node.Update(unliftedOperatorKind' accessExpression' rightAlwaysHasValue' null' node.MethodOpt' node.ResultKind' node.Type); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TryFoldWithConditionalAccess,The length of the statement  "                        var whenNull = unliftedOperatorKind.Operator() == BinaryOperatorKind.NotEqual ? MakeBooleanConstant(syntax' true) : null; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitUserDefinedConditionalLogicalOperator,The length of the statement  "                return node.Update(operatorKind' loweredLeft' loweredRight' node.LogicalOperator' node.TrueOperator' node.FalseOperator' node.ResultKind' type); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitUserDefinedConditionalLogicalOperator,The length of the statement  "            var falseOperatorCall = BoundCall.Synthesized(syntax' null' operatorKind.Operator() == BinaryOperatorKind.And ? node.FalseOperator : node.TrueOperator' boundTemp); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitUserDefinedConditionalLogicalOperator,The length of the statement  "            var andOperatorCall = LowerUserDefinedBinaryOperator(syntax' operatorKind & ~BinaryOperatorKind.Logical' boundTemp' loweredRight' type' node.LogicalOperator); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitBinaryOperator,The length of the statement  "                loweredLeft = MakeBinaryOperator(original' original.Syntax' original.OperatorKind' loweredLeft' loweredRight' original.Type' original.MethodOpt' " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "            return MakeBinaryOperator(null' syntax' operatorKind' loweredLeft' loweredRight' type' method' isPointerElementAccess' isCompoundAssignment' applyParentUnaryOperator); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__Combine); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__Remove); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__op_Equality); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__op_Inequality); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                    return MakeDynamicLogicalBinaryOperator(syntax' operatorKind' loweredLeft' loweredRight' method' type' isCompoundAssignment' applyParentUnaryOperator); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                    return _dynamicFactory.MakeDynamicBinaryOperator(operatorKind' loweredLeft' loweredRight' isCompoundAssignment' type).ToExpression(); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewriteStringEquality(oldNode' syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_String__op_Equality); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewriteStringEquality(oldNode' syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_String__op_Inequality); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__Combine); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__Remove); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__op_Equality); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__op_Inequality); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewritePointerNumericOperator(syntax' operatorKind' loweredLeft' loweredRight' type' isPointerElementAccess' isLeftPointer: true); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                        return RewritePointerNumericOperator(syntax' operatorKind' loweredLeft' loweredRight' type' isPointerElementAccess' isLeftPointer: false); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The length of the statement  "                oldNode.Update(operatorKind' loweredLeft' loweredRight' oldNode.ConstantValueOpt' oldNode.MethodOpt' oldNode.ResultKind' type) : " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicLogicalBinaryOperator,The length of the statement  "            // VisitUnaryOperator ensures we are never called with parentUnaryOperator != null when we can't perform the optimization. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicLogicalBinaryOperator,The length of the statement  "            var op = _dynamicFactory.MakeDynamicBinaryOperator(operatorKind' loweredLeft' loweredRight' isCompoundAssignment' type).ToExpression(); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicLogicalBinaryOperator,The length of the statement  "                    BoundExpression leftTest = MakeTruthTestForDynamicLogicalOperator(syntax' loweredLeft' boolean' leftTruthOperator' negative: isAnd); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicLogicalBinaryOperator,The length of the statement  "                    BoundExpression leftTest = MakeTruthTestForDynamicLogicalOperator(syntax' loweredLeft' boolean' leftTruthOperator' negative: isAnd); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicLogicalBinaryOperator,The length of the statement  "                return _factory.Sequence(ImmutableArray.Create(temp.LocalSymbol)' ImmutableArray.Create<BoundExpression>(tempAssignment)' result); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeTruthTestForDynamicLogicalOperator,The length of the statement  "                return _dynamicFactory.MakeDynamicUnaryOperator(negative ? UnaryOperatorKind.DynamicFalse : UnaryOperatorKind.DynamicTrue' loweredLeft' boolean).ToExpression(); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeTruthTestForDynamicLogicalOperator,The length of the statement  "            var conversion = _compilation.Conversions.ClassifyConversionFromExpression(loweredLeft' boolean' ref useSiteDiagnostics); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeTruthTestForDynamicLogicalOperator,The length of the statement  "                    return new BoundUnaryOperator(syntax' UnaryOperatorKind.BoolLogicalNegation' converted' ConstantValue.NotAvailable' MethodSymbol.None' LookupResultKind.Viable' boolean) " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TrivialLiftedComparisonOperatorOptimizations,The length of the statement  "                BoundExpression literal = MakeLiteral(syntax' ConstantValue.Create(operatorKind == BinaryOperatorKind.NotEqual)' boolType); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeOptimizedGetValueOrDefault,The length of the statement  "                return BoundCall.Synthesized(syntax' expression' GetNullableMethod(syntax' expression.Type' SpecialMember.System_Nullable_T_GetValueOrDefault)); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeOptimizedHasValue,The length of the statement  "                return BoundCall.Synthesized(syntax' expression' GetNullableMethod(syntax' expression.Type' SpecialMember.System_Nullable_T_get_HasValue)); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedBuiltInComparisonOperator,The length of the statement  "            BoundExpression optimized = TrivialLiftedComparisonOperatorOptimizations(syntax' kind' loweredLeft' loweredRight' null); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedUserDefinedComparisonOperator,The length of the statement  "            BoundExpression optimized = TrivialLiftedComparisonOperatorOptimizations(syntax' kind' loweredLeft' loweredRight' method); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedBinaryArithmeticOperator,The length of the statement  "            BoundExpression condition = MakeBinaryOperator(syntax' BinaryOperatorKind.BoolAnd' callX_HasValue' callY_HasValue' boolType' null); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedBinaryArithmeticOperator,The length of the statement  "            BoundExpression consequence = MakeLiftedBinaryOperatorConsequence(syntax' kind' callX_GetValueOrDefault' callY_GetValueOrDefault' type' method); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,OptimizeLiftedBooleanOperatorOneNonNull,The length of the statement  "            Debug.Assert(leftNonNull == null || rightNonNull == null); // We've already optimized the case where they are both non-null. " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,OptimizeLiftedBooleanOperatorOneNonNull,The length of the statement  "            Debug.Assert(!NullableNeverHasValue(left) && !NullableNeverHasValue(right)); // We've already optimized the case where one is null. " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedBooleanOperator,The length of the statement  "            MethodSymbol getValueOrDefaultX = GetNullableMethod(syntax' boundTempX.Type' SpecialMember.System_Nullable_T_GetValueOrDefault); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedBooleanOperator,The length of the statement  "            MethodSymbol getValueOrDefaultY = GetNullableMethod(syntax' boundTempY.Type' SpecialMember.System_Nullable_T_GetValueOrDefault); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteNullableNullEquality,The length of the statement  "                new BoundUnaryOperator(syntax' UnaryOperatorKind.BoolLogicalNegation' call' ConstantValue.NotAvailable' null' LookupResultKind.Viable' returnType); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetTruthOperator,The length of the statement  "            Debug.Assert(false' "How did we bind a user-defined logical operator or dynamic logical Boolean operator without operator false or operator true?"); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringEquality,The length of the statement  "            if (oldNode != null && (loweredLeft.ConstantValue == ConstantValue.Null || loweredRight.ConstantValue == ConstantValue.Null)) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringEquality,The length of the statement  "                return oldNode.Update(operatorKind' loweredLeft' loweredRight' oldNode.ConstantValueOpt' oldNode.MethodOpt' oldNode.ResultKind' type); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteDelegateOperation,The length of the statement  "                    return new BoundBinaryOperator(syntax' operatorKind' loweredLeft' loweredRight' default(ConstantValue)' null' LookupResultKind.Empty' type); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteDelegateOperation,The length of the statement  "                ? new BoundBinaryOperator(syntax' operatorKind' loweredLeft' loweredRight' null' method' default(LookupResultKind)' method.ReturnType) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeNullCheck,The length of the statement  "                        return MakeLiteral(syntax' ConstantValue.Create(rewrittenExpr.ConstantValue.IsNull' ConstantValueTypeDiscriminator.Boolean)' boolType); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeNullCheck,The length of the statement  "                        return MakeLiteral(syntax' ConstantValue.Create(!rewrittenExpr.ConstantValue.IsNull' ConstantValueTypeDiscriminator.Boolean)' boolType); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSizeOfMultiplication,The length of the statement  "                : _factory.Convert(convertedMultiplicationResultType' multiplication' Conversion.IntegerToPointer); // NOTE: for some reason' dev10 doesn't check this conversion. " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitDynamicInvocation,The length of the statement  "                    return _dynamicFactory.MakeDynamicInvocation(loweredExpression' loweredArguments' node.ArgumentNamesOpt' node.ArgumentRefKindsOpt' resultDiscarded).ToExpression(); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitCall,The length of the statement  "            // NOTE: We may need additional argument rewriting such as generating a params array' re-ordering arguments based on argsToParamsOpt map' inserting arguments for optional parameters' etc. " is 187.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCall,The length of the statement  "            // such as generating a params array' re-ordering arguments based on argsToParamsOpt map' inserting arguments for optional parameters' etc. " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCall,The length of the statement  "            rewrittenArguments = MakeArguments(syntax' rewrittenArguments' method' method' expanded' argsToParamsOpt' ref argumentRefKindsOpt' out temps' invokedAsExtensionMethod); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCall,The length of the statement  "            return MakeCall(nodeOpt' syntax' rewrittenReceiver' method' rewrittenArguments' argumentRefKindsOpt' invokedAsExtensionMethod' resultKind' type' temps); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeArguments,The length of the statement  "            BoundExpression[] actualArguments = new BoundExpression[parameters.Length]; // The actual arguments that will be passed; one actual argument per formal parameter. " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeArguments,The length of the statement  "            ArrayBuilder<BoundAssignmentOperator> storesToTemps = ArrayBuilder<BoundAssignmentOperator>.GetInstance(rewrittenArguments.Length); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeArguments,The length of the statement  "            BuildStoresToTemps(expanded' argsToParamsOpt' argumentRefKindsOpt' rewrittenArguments' actualArguments' refKinds' storesToTemps); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeArguments,The length of the statement  "                actualArguments[actualArguments.Length - 1] = BuildParamsArray(syntax' methodOrIndexer' argsToParamsOpt' rewrittenArguments' parameters' actualArguments[actualArguments.Length - 1]); " is 182.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,BuildParamsArray,The length of the statement  "            if (arrayArgs.Length == 0) // if this is a zero-length array' rather than using "new T[0]"' optimize with "Array.Empty<T>()" if it's available " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterValue,The length of the statement  "            // TODO: Ideally' the enableCallerInfo parameter would be of just bool type with only 'true' and 'false' values' and all callers " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterValue,The length of the statement  "            // explicitly provided one of those values' so that we do not rely on shape of syntax nodes in the rewriter. There are not many immediate callers'  " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterValue,The length of the statement  "            // but often the immediate caller does not have the required information' so all possible call chains should be analyzed and possibly updated " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterValue,The length of the statement  "                BoundExpression lineLiteral = MakeLiteral(syntax' ConstantValue.Create(line)' _compilation.GetSpecialType(SpecialType.System_Int32)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterValue,The length of the statement  "                string path = callerSourceLocation.SourceTree.GetDisplayPath(callerSourceLocation.SourceSpan' _compilation.Options.SourceReferenceResolver); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterValue,The length of the statement  "                BoundExpression memberNameLiteral = MakeLiteral(syntax' ConstantValue.Create(path)' _compilation.GetSpecialType(SpecialType.System_String)); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterValue,The length of the statement  "            else if (parameter.IsCallerMemberName && ((callerSourceLocation = GetCallerLocation(syntax' enableCallerInfo)) != null)) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterValue,The length of the statement  "                        // See if the code is actually part of a field' field-like event or property initializer and return the name of the corresponding member. " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterValue,The length of the statement  "                BoundExpression memberNameLiteral = MakeLiteral(syntax' ConstantValue.Create(memberName)' _compilation.GetSpecialType(SpecialType.System_String)); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterValue,The length of the statement  "                defaultValue = MakeConversion(defaultValue' parameterType.GetNullableUnderlyingType()' @checked: false' acceptFailingConversion: true); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterSpecial,The length of the statement  "                var methodSymbol = (MethodSymbol)_compilation.GetWellKnownTypeMember(WellKnownMember.System_Runtime_InteropServices_UnknownWrapper__ctor); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetDefaultParameterSpecial,The length of the statement  "                var methodSymbol = (MethodSymbol)_compilation.GetWellKnownTypeMember(WellKnownMember.System_Runtime_InteropServices_DispatchWrapper__ctor); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitCompoundAssignmentOperator,The length of the statement  "            //   IsEvent("Member"' dyn) ? InvokeMember("{add|remove}_Member"' dyn' RHS) : SetMember(BinaryOperation("op="' GetMember("Member"' dyn))' RHS) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitCompoundAssignmentOperator,The length of the statement  "            BoundExpression operand = MakeBinaryOperator(syntax' node.Operator.Kind' opLHS' loweredRight' node.Operator.ReturnType' node.Operator.Method' isCompoundAssignment: true); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitCompoundAssignmentOperator,The length of the statement  "            BoundExpression rewrittenAssignment = MakeAssignmentOperator(syntax' transformedLHS' opFinal' node.Left.Type' used: used' isChecked: isChecked' isCompoundAssignment: true); " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitCompoundAssignmentOperator,The length of the statement  "                rewrittenAssignment = _factory.Conditional(isEventCondition.ToExpression()' invokeEventAccessor.ToExpression()' rewrittenAssignment' rewrittenAssignment.Type); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        // If the property is static or if the receiver is of kind "Base" or "this"' then we can just generate prop = prop + value " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        // SPEC VIOLATION: It is not very clear when receiver of constrained callvirt is dereferenced - when pushed (in lexical order)' " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        // SPEC VIOLATION: or when actual call is executed. The actual behavior seems to be implementation specific in different JITs. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        // SPEC VIOLATION: when variable has reference type (regular temp)' and store variable's location when it has a value type. (ref temp) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        // SPEC VIOLATION: in a case of unconstrained generic type parameter a runtime test (default(T) == null) would be needed " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        // SPEC VIOLATION: However' for compatibility with Dev12 we will continue treating all generic type parameters' constrained or not' " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        var variableRepresentsLocation = rewrittenReceiver.Type.IsValueType || rewrittenReceiver.Type.Kind == SymbolKind.TypeParameter; " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        var receiverTemp = _factory.StoreToTemp(rewrittenReceiver' out assignmentToTemp' refKind: variableRepresentsLocation ? RefKind.Ref : RefKind.None); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        // Mitigation: this will only produce short-lived garbage for compound assignments and increments/decrements of properties. " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        return new BoundDynamicMemberAccess(memberAccess.Syntax' receiverTemp' memberAccess.TypeArgumentsOpt' memberAccess.Name' memberAccess.Invoked' memberAccess.Indexed' memberAccess.Type); " is 184.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                            // SPEC VIOLATION: It is not very clear when receiver of constrained callvirt is dereferenced - when pushed (in lexical order)' " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                            // SPEC VIOLATION: or when actual call is executed. The actual behavior seems to be implementation specific in different JITs. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                            // SPEC VIOLATION: when variable has reference type (regular temp)' and store variable's location when it has a value type. (ref temp) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                            // SPEC VIOLATION: in a case of unconstrained generic type parameter a runtime test (default(T) == null) would be needed " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                            // SPEC VIOLATION: However' for compatibility with Dev12 we will continue treating all generic type parameters' constrained or not' " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                            var variableRepresentsLocation = rewrittenReceiver.Type.IsValueType || rewrittenReceiver.Type.Kind == SymbolKind.TypeParameter; " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                            var receiverTemp = _factory.StoreToTemp(rewrittenReceiver' out assignmentToTemp' refKind: variableRepresentsLocation ? RefKind.Ref : RefKind.None); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        BoundExpression[] actualArguments = new BoundExpression[parameters.Length]; // The actual arguments that will be passed; one actual argument per formal parameter. " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        ArrayBuilder<BoundAssignmentOperator> storesToTemps = ArrayBuilder<BoundAssignmentOperator>.GetInstance(rewrittenArguments.Length); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        BuildStoresToTemps(expanded' argsToParamsOpt' argumentRefKinds' rewrittenArguments' actualArguments' refKinds' storesToTemps); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                            BoundExpression array = BuildParamsArray(syntax' indexer' argsToParamsOpt' rewrittenArguments' parameters' actualArguments[actualArguments.Length - 1]); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        // Mitigation: this will only produce short-lived garbage for compound assignments and increments/decrements of indexers. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        //If the receiver is static or is the receiver is of kind "Base" or "this"' then we can just generate field = field + value " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                                var temp = _factory.StoreToTemp(VisitExpression(arguments[i])' out assignmentToTemp' refKind: indexerAccess.ArgumentRefKindsOpt.RefKinds(i)); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TransformCompoundAssignmentLHS,The length of the statement  "                        // T is Object in such case and we can't take a read-write pointer of type Object& to an array element of non-object type. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteConditionalAccess,The length of the statement  "                        BoundExpression captureRef = _factory.AssignmentExpression(_factory.Local(temp)' loweredReceiver' refKind: RefKind.Ref); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitConversion,The length of the statement  "            _inExpressionLambda = _inExpressionLambda || (node.ConversionKind == ConversionKind.AnonymousFunction && !wasInExpressionLambda && rewrittenType.IsExpressionTree()); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitConversion,The length of the statement  "            // 4.1.6 C# spec: To force a value of a floating point type to the exact precision of its type' an explicit cast can be used. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The length of the statement  "                    //   This conversion exists such that an entity that already has a required type can be said to be convertible to that type. " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The length of the statement  "                    if (_inExpressionLambda || !rewrittenOperand.Type.Equals(rewrittenType' ignoreCustomModifiers: false' ignoreDynamic: false)) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The length of the statement  "                    // 4.1.6 C# spec: To force a value of a floating point type to the exact precision of its type' an explicit cast can be used. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The length of the statement  "                    if (rewrittenType.SpecialType == SpecialType.System_Decimal || rewrittenOperand.Type.SpecialType == SpecialType.System_Decimal) " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The length of the statement  "                        var rewrittenNode = RewriteDecimalConversion(oldNode' syntax' rewrittenOperand' rewrittenOperand.Type' underlyingTypeTo); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The length of the statement  "                    return _dynamicFactory.MakeDynamicConversion(rewrittenOperand' explicitCastInCode || conversionKind == ConversionKind.ExplicitDynamic' isArrayIndex' @checked' rewrittenType).ToExpression(); " is 189.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,NeedsChecked,The length of the statement  "                sourceIsNumeric && targetIsNumeric && s_needsChecked[sourceST - SpecialType.System_Char' targetST - SpecialType.System_Char]; " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The length of the statement  "            Conversion conversion = _compilation.Conversions.ClassifyConversion(rewrittenOperand.Type' rewrittenType' ref useSiteDiagnostics); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeImplicitConversion,The length of the statement  "            Conversion conversion = _compilation.Conversions.ClassifyConversion(rewrittenOperand.Type' rewrittenType' ref useSiteDiagnostics); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The length of the statement  "            Debug.Assert(!conversionKind.IsUserDefinedConversion()' "Use the other overload which takes a 'Conversion' parameter for generating synthesized user defined conversions."); " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The length of the statement  "            return MakeConversion(syntax' rewrittenOperand' new Conversion(conversionKind)' rewrittenType' @checked' explicitCastInCode: false' constantValueOpt: constantValueOpt); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteNullableConversion,The length of the statement  "            return RewriteNullableConversion(syntaxNode' rewrittenOperand' ConversionKind.ExplicitNullable' false' false' rewrittenType); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteNullableConversion,The length of the statement  "                return RewriteLiftedConversionInExpressionTree(syntax' rewrittenOperand' conversionKind' @checked' explicitCastInCode' rewrittenType); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteNullableConversion,The length of the statement  "                BoundExpression rewrittenConversion = MakeConversion(rewrittenOperand' rewrittenType.GetNullableUnderlyingType()' @checked); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedConversionInExpressionTree,The length of the statement  "            if (typeFrom != typeTo && (typeFrom.SpecialType == SpecialType.System_Decimal || typeTo.SpecialType == SpecialType.System_Decimal)) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedConversionInExpressionTree,The length of the statement  "                    rewrittenOperandType = rewrittenOperandType.IsNullableType() ? ((NamedTypeSymbol)rewrittenOperandType.OriginalDefinition).Construct(typeFromUnderlying) : typeFromUnderlying; " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedConversionInExpressionTree,The length of the statement  "                    rewrittenOperand = BoundConversion.SynthesizedNonUserDefined(syntax' rewrittenOperand' ConversionKind.ImplicitEnumeration' rewrittenOperandType); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedConversionInExpressionTree,The length of the statement  "                var method = (MethodSymbol)_compilation.Assembly.GetSpecialTypeMember(DecimalConversionMethod(typeFromUnderlying' typeToUnderlying)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedConversionInExpressionTree,The length of the statement  "                conversionKind = conversionKind.IsImplicitConversion() ? ConversionKind.ImplicitUserDefined : ConversionKind.ExplicitUserDefined; " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedConversionInExpressionTree,The length of the statement  "                var result = new BoundConversion(syntax' rewrittenOperand' new Conversion(conversionKind' method' false)' @checked' explicitCastInCode' default(ConstantValue)' rewrittenType); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedConversionInExpressionTree,The length of the statement  "                return new BoundConversion(syntax' rewrittenOperand' new Conversion(conversionKind)' @checked' explicitCastInCode' default(ConstantValue)' rewrittenType); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteFullyLiftedBuiltInConversion,The length of the statement  "            MethodSymbol getValueOrDefault = GetNullableMethod(syntax' boundTemp.Type' SpecialMember.System_Nullable_T_GetValueOrDefault); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,DistributeLiftedConversionIntoLiftedOperand,The length of the statement  "                                MakeConversion(null' syntax' conditional.Consequence' kind' method' @checked' false' false' false' ConstantValue.NotAvailable' type)' " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,DistributeLiftedConversionIntoLiftedOperand,The length of the statement  "                                MakeConversion(null' syntax' conditional.Alternative' kind' method' @checked' false' false' false' ConstantValue.NotAvailable' type)' " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteUserDefinedConversion,The length of the statement  "                ? BoundConversion.Synthesized(syntax' rewrittenOperand' MakeConversion(syntax' conv' rewrittenOperand.Type' rewrittenType)' false' true' default(ConstantValue)' rewrittenType) " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedUserDefinedConversion,The length of the statement  "                Conversion conv = MakeConversion(syntax' new Conversion(conversionKind' method' false)' rewrittenOperand.Type' rewrittenType); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedUserDefinedConversion,The length of the statement  "            BoundExpression optimized = OptimizeLiftedUserDefinedConversion(syntax' rewrittenOperand' conversionKind' method' rewrittenType); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLiftedUserDefinedConversion,The length of the statement  "            MethodSymbol getValueOrDefault = GetNullableMethod(syntax' boundTemp.Type' SpecialMember.System_Nullable_T_GetValueOrDefault); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteIntPtrConversion,The length of the statement  "                return BoundConversion.Synthesized(syntax' rewrittenOperand' new Conversion(conversionKind' method' false)' @checked' explicitCastInCode' constantValueOpt' rewrittenType); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteIntPtrConversion,The length of the statement  "                ? new BoundConversion(syntax' rewrittenOperand' new Conversion(conversionKind' method' false)' @checked' explicitCastInCode' constantValueOpt' returnType) " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteDecimalConversion,The length of the statement  "                ConversionKind conversionKind = oldNode.ConversionKind.IsImplicitConversion() ? ConversionKind.ImplicitUserDefined : ConversionKind.ExplicitUserDefined; " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The length of the statement  "                        Conversion fromConversion = MakeConversion(syntax' conversion.UserDefinedFromConversion' fromType' meth.Parameters[0].Type); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The length of the statement  "            var result = MakeConversion(syntax' _compilation.Conversions.ClassifyConversion(fromType' toType' ref useSiteDiagnostics)' fromType' toType); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitDelegateCreationExpression,The length of the statement  "                var loweredReceiver = _dynamicFactory.MakeDynamicConversion(loweredArgument' isExplicit: false' isArrayIndex: false' isChecked: false' resultType: node.Type).ToExpression(); " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitDelegateCreationExpression,The length of the statement  "                return new BoundDelegateCreationExpression(node.Syntax' loweredReceiver' methodOpt: null' isExtensionMethod: false' type: node.Type); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitDoStatement,The length of the statement  "            BoundStatement ifConditionGotoStart = new BoundConditionalGoto(syntax' AddConditionSequencePoint(rewrittenCondition' node)' true' startLabel); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitEventAssignmentOperator,The length of the statement  "            if (rewrittenReceiverOpt != null && node.Event.ContainingAssembly.IsLinked && node.Event.ContainingType.IsInterfaceType()) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitEventAssignmentOperator,The length of the statement  "                return RewriteWindowsRuntimeEventAssignmentOperator(node.Syntax' node.Event' kind' node.IsDynamic' rewrittenReceiverOpt' rewrittenArgument); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWindowsRuntimeEventAssignmentOperator,The length of the statement  "            NamedTypeSymbol tokenType = _factory.WellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationToken); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWindowsRuntimeEventAssignmentOperator,The length of the statement  "            NamedTypeSymbol marshalType = _factory.WellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_WindowsRuntimeMarshal); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWindowsRuntimeEventAssignmentOperator,The length of the statement  "                if (TryGetWellKnownTypeMember(syntax' WellKnownMember.System_Runtime_InteropServices_WindowsRuntime_WindowsRuntimeMarshal__RemoveAllEventHandlers' out clearMethod)) " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWindowsRuntimeEventAssignmentOperator,The length of the statement  "                    clearCall = new BoundBadExpression(syntax' LookupResultKind.NotInvocable' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(removeDelegate)' ErrorTypeSymbol.UnknownResultType); " is 189.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWindowsRuntimeEventAssignmentOperator,The length of the statement  "                marshalCall = new BoundBadExpression(syntax' LookupResultKind.NotInvocable' ImmutableArray<Symbol>.Empty' StaticCast<BoundNode>.From(marshalArguments)' ErrorTypeSymbol.UnknownResultType); " is 187.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitEventAccess,The length of the statement  "            return MakeEventAccess(node.Syntax' rewrittenReceiver' node.EventSymbol' node.ConstantValue' node.ResultKind' node.Type); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeEventAccess,The length of the statement  "            if (TryGetWellKnownTypeMember(syntax' WellKnownMember.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T__GetOrCreateEventRegistrationTokenTable' out getOrCreateMethod)) " is 194.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeEventAccess,The length of the statement  "                getOrCreateCall = new BoundBadExpression(syntax' LookupResultKind.NotInvocable' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(fieldAccess)' ErrorTypeSymbol.UnknownResultType); " is 192.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeEventAccess,The length of the statement  "            if (TryGetWellKnownTypeMember(syntax' WellKnownMember.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T__InvocationList' out invocationListProperty)) " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeEventAccess,The length of the statement  "                    _diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_MissingPredefinedMember' invocationListProperty.ContainingType' accessorName)' syntax.Location); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeEventAccess,The length of the statement  "            return new BoundBadExpression(syntax' LookupResultKind.NotInvocable' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(getOrCreateCall)' ErrorTypeSymbol.UnknownResultType); " is 185.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteNoPiaEventAssignmentOperator,The length of the statement  "                var addRemove = _factory.WellKnownMethod(node.IsAddition ? WellKnownMember.System_Runtime_InteropServices_ComAwareEventInfo__AddEventHandler : " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteNoPiaEventAssignmentOperator,The length of the statement  "                    BoundExpression eventInfo = _factory.New(ctor' _factory.Typeof(node.Event.ContainingType)' _factory.Literal(node.Event.MetadataName)); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteNoPiaEventAssignmentOperator,The length of the statement  "                module.EmbeddedTypesManagerOpt.EmbedEventIfNeedTo(node.Event' node.Syntax' _diagnostics' isUsedForComAwareEventBinding: true); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitFieldAccess,The length of the statement  "            return MakeFieldAccess(node.Syntax' rewrittenReceiver' node.FieldSymbol' node.ConstantValue' node.ResultKind' node.Type' node); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeFieldAccess,The length of the statement  "                    new BoundAddressOfOperator(syntax' result' syntax != null && SyntaxFacts.IsFixedStatementExpression(syntax)' type' false)' " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitFixedStatement,The length of the statement  "            var statementBuilder = ArrayBuilder<BoundStatement>.GetInstance(numFixedLocals + 1 + 1); //+1 for body' +1 for hidden seq point " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementStringLocal,The length of the statement  "            stringTemp = factory.SynthesizedLocal(initializerType' syntax: declarator' isPinned: true' kind: SynthesizedLocalKind.FixedString); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementStringLocal,The length of the statement  "            if (TryGetWellKnownTypeMember(fixedInitializer.Syntax' WellKnownMember.System_Runtime_CompilerServices_RuntimeHelpers__get_OffsetToStringData' out offsetMethod)) " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementStringLocal,The length of the statement  "                helperCall = new BoundBadExpression(fixedInitializer.Syntax' LookupResultKind.NotInvocable' ImmutableArray<Symbol>.Empty' ImmutableArray<BoundNode>.Empty' ErrorTypeSymbol.UnknownResultType); " is 190.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementStringLocal,The length of the statement  "            BoundExpression addition = factory.Binary(BinaryOperatorKind.PointerAndIntAddition' localType' factory.Local(localSymbol)' helperCall); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementArrayLocal,The length of the statement  "                    lengthCall = new BoundBadExpression(fixedInitializer.Syntax' LookupResultKind.NotInvocable' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(factory.Local(arrayTemp))' ErrorTypeSymbol.UnknownResultType); " is 217.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementArrayLocal,The length of the statement  "            BoundExpression lengthCheck = factory.Binary(BinaryOperatorKind.IntNotEqual' factory.SpecialType(SpecialType.System_Boolean)' lengthCall' factory.Literal(0)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementArrayLocal,The length of the statement  "            BoundExpression condition = factory.Binary(BinaryOperatorKind.LogicalBoolAnd' factory.SpecialType(SpecialType.System_Boolean)' notNullCheck' lengthCheck); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementArrayLocal,The length of the statement  "            BoundExpression firstElementAddress = new BoundAddressOfOperator(factory.Syntax' firstElement' isFixedStatementAddressOf: true' type: new PointerTypeSymbol(arrayElementType)); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementArrayLocal,The length of the statement  "            BoundExpression consequenceAssignment = factory.AssignmentExpression(factory.Local(localSymbol)' convertedFirstElementAddress); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementArrayLocal,The length of the statement  "            BoundExpression alternativeAssignment = factory.AssignmentExpression(factory.Local(localSymbol)' factory.Null(localType)); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,InitializeFixedStatementArrayLocal,The length of the statement  "                new BoundConditionalOperator(factory.Syntax' condition' consequenceAssignment' alternativeAssignment' ConstantValue.NotAvailable' localType)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteEnumeratorForEachStatement,The length of the statement  "            LocalSymbol enumeratorVar = _factory.SynthesizedLocal(enumeratorType' syntax: forEachSyntax' kind: SynthesizedLocalKind.ForEachEnumerator); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteEnumeratorForEachStatement,The length of the statement  "            BoundExpression enumeratorVarInitValue = SynthesizeCall(forEachSyntax' rewrittenExpression' enumeratorInfo.GetEnumeratorMethod' enumeratorInfo.CollectionConversion' enumeratorInfo.CollectionType); " is 196.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteEnumeratorForEachStatement,The length of the statement  "            if (enumeratorInfo.NeedsDisposeMethod && TryGetSpecialTypeMember(forEachSyntax' SpecialMember.System_IDisposable__Dispose' out disposeMethod)) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteEnumeratorForEachStatement,The length of the statement  "                var isImplicit = conversions.ClassifyImplicitConversion(enumeratorType' idisposableTypeSymbol' ref useSiteDiagnostics).IsImplicit; " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteEnumeratorForEachStatement,The length of the statement  "                        expression: SynthesizeCall(forEachSyntax' boundEnumeratorVar' disposeMethod' receiverConversion' idisposableTypeSymbol)); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringForEachStatement,The length of the statement  "            LocalSymbol stringVar = _factory.SynthesizedLocal(stringType' syntax: forEachSyntax' kind: SynthesizedLocalKind.ForEachArray); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringForEachStatement,The length of the statement  "            LocalSymbol positionVar = _factory.SynthesizedLocal(intType' syntax: forEachSyntax' kind: SynthesizedLocalKind.ForEachArrayIndex); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteSingleDimensionalArrayForEachStatement,The length of the statement  "            LocalSymbol arrayVar = _factory.SynthesizedLocal(arrayType' syntax: forEachSyntax' kind: SynthesizedLocalKind.ForEachArray); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteSingleDimensionalArrayForEachStatement,The length of the statement  "            LocalSymbol positionVar = _factory.SynthesizedLocal(intType' syntax: forEachSyntax' kind: SynthesizedLocalKind.ForEachArrayIndex); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteMultiDimensionalArrayForEachStatement,The length of the statement  "            LocalSymbol arrayVar = _factory.SynthesizedLocal(arrayType' syntax: forEachSyntax' kind: SynthesizedLocalKind.ForEachArray); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteMultiDimensionalArrayForEachStatement,The length of the statement  "                upperVar[dimension] = _factory.SynthesizedLocal(intType' syntax: forEachSyntax' kind: SynthesizedLocalKind.ForEachArrayLimit); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteMultiDimensionalArrayForEachStatement,The length of the statement  "                BoundExpression currentDimensionUpperBound = BoundCall.Synthesized(forEachSyntax' boundArrayVar' getUpperBoundMethod' dimensionArgument); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteMultiDimensionalArrayForEachStatement,The length of the statement  "                positionVar[dimension] = _factory.SynthesizedLocal(intType' syntax: forEachSyntax' kind: SynthesizedLocalKind.ForEachArrayIndex); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteMultiDimensionalArrayForEachStatement,The length of the statement  "                BoundExpression currentDimensionLowerBound = BoundCall.Synthesized(forEachSyntax' boundArrayVar' getLowerBoundMethod' dimensionArgument); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteMultiDimensionalArrayForEachStatement,The length of the statement  "                BoundStatement positionVarDecl = MakeLocalDeclaration(forEachSyntax' positionVar[dimension]' currentDimensionLowerBound); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakePositionIncrement,The length of the statement  "                            operatorKind: BinaryOperatorKind.IntAddition' // unchecked' never overflows since array/string index can't be >= Int32.MaxValue " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddForEachKeywordSequencePoint,The length of the statement  "                BoundSequencePointWithSpan foreachKeywordSequencePoint = new BoundSequencePointWithSpan(forEachSyntax' null' forEachSyntax.ForEachKeyword.Span); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddForEachKeywordSequencePoint,The length of the statement  "                result = new BoundStatementList(forEachSyntax' ImmutableArray.Create<BoundStatement>(foreachKeywordSequencePoint' result)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitIfStatement,The length of the statement  "            var result = RewriteIfStatement(syntax' AddConditionSequencePoint(rewrittenCondition' node)' rewrittenConsequence' rewrittenAlternative' node.HasErrors); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicIndexerAccessReceiver,The length of the statement  "                // "If we don't do this' then the calling object is statically typed and we pass the UseCompileTimeType to the runtime binder." " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicIndexerAccessReceiver,The length of the statement  "                // loweredReceiver = BoundConversion.Synthesized(loweredReceiver.Syntax' loweredReceiver' Conversion.Identity' false' false' null' DynamicTypeSymbol.Instance); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicIndexerAccessReceiver,The length of the statement  "                result = _dynamicFactory.MakeDynamicGetMember(loweredReceiver' indexedPropertyName' resultIndexed: true).ToExpression(); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitIndexerAccess,The length of the statement  "            // NOTE: We may need additional argument rewriting such as generating a params array' re-ordering arguments based on argsToParamsOpt map' inserting arguments for optional parameters' etc. " is 187.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeIndexerAccess,The length of the statement  "                    oldNodeOpt.Update(rewrittenReceiver' indexer' rewrittenArguments' argumentNamesOpt' argumentRefKindsOpt' expanded' argsToParamsOpt' type) : " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeIndexerAccess,The length of the statement  "                    new BoundIndexerAccess(syntax' rewrittenReceiver' indexer' rewrittenArguments' argumentNamesOpt' argumentRefKindsOpt' expanded' argsToParamsOpt' type); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeIndexerAccess,The length of the statement  "                // such as generating a params array' re-ordering arguments based on argsToParamsOpt map' inserting arguments for optional parameters' etc. " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeIndexerAccess,The length of the statement  "                rewrittenArguments = MakeArguments(syntax' rewrittenArguments' indexer' getMethod' expanded' argsToParamsOpt' ref argumentRefKindsOpt' out temps' enableCallerInfo: ThreeState.True); " is 181.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeIsOperator,The length of the statement  "                ConstantValue constantValue = Binder.GetIsOperatorConstantResult(operandType' targetType' conversion.Kind' rewrittenOperand.ConstantValue); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDecimalLiteral,The length of the statement  "                arguments.Add(new BoundLiteral(syntax' ConstantValue.Create((int)value)' _compilation.GetSpecialType(SpecialType.System_Int32))); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDecimalLiteral,The length of the statement  "                arguments.Add(new BoundLiteral(syntax' ConstantValue.Create((uint)value)' _compilation.GetSpecialType(SpecialType.System_UInt32))); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDecimalLiteral,The length of the statement  "                arguments.Add(new BoundLiteral(syntax' ConstantValue.Create((long)value)' _compilation.GetSpecialType(SpecialType.System_Int64))); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDecimalLiteral,The length of the statement  "                arguments.Add(new BoundLiteral(syntax' ConstantValue.Create((ulong)value)' _compilation.GetSpecialType(SpecialType.System_UInt64))); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDecimalLiteral,The length of the statement  "                arguments.Add(new BoundLiteral(syntax' ConstantValue.Create(parts.Low)' _compilation.GetSpecialType(SpecialType.System_Int32))); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDecimalLiteral,The length of the statement  "                arguments.Add(new BoundLiteral(syntax' ConstantValue.Create(parts.Mid)' _compilation.GetSpecialType(SpecialType.System_Int32))); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDecimalLiteral,The length of the statement  "                arguments.Add(new BoundLiteral(syntax' ConstantValue.Create(parts.High)' _compilation.GetSpecialType(SpecialType.System_Int32))); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDecimalLiteral,The length of the statement  "                arguments.Add(new BoundLiteral(syntax' ConstantValue.Create(parts.IsNegative)' _compilation.GetSpecialType(SpecialType.System_Boolean))); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDecimalLiteral,The length of the statement  "                arguments.Add(new BoundLiteral(syntax' ConstantValue.Create(parts.Scale)' _compilation.GetSpecialType(SpecialType.System_Byte))); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDateTimeLiteral,The length of the statement  "            arguments.Add(new BoundLiteral(syntax' ConstantValue.Create(constantValue.DateTimeValue.Ticks)' _compilation.GetSpecialType(SpecialType.System_Int64))); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitLocalDeclaration,The length of the statement  "            return RewriteLocalDeclaration(node.Syntax' node.LocalSymbol' VisitExpression(node.InitializerOpt)' node.WasCompilerGenerated' node.HasErrors); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteLocalDeclaration,The length of the statement  "            return AddLocalDeclarationSequencePointIfNecessary(syntax' localSymbol' rewrittenLocalDeclaration' wasCompilerGenerated); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddLocalDeclarationSequencePointIfNecessary,The length of the statement  "            if (this.GenerateDebugInfo && !wasCompilerGenerated && !localSymbol.IsConst && syntax.Kind() == SyntaxKind.VariableDeclarator) " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitLockStatement,The length of the statement  "            BoundLocal boundLockTemp = _factory.StoreToTemp(rewrittenArgument' out assignmentToLockTemp' syntaxOpt: lockSyntax' kind: SynthesizedLocalKind.Lock); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitLockStatement,The length of the statement  "                exitCallExpr = new BoundBadExpression(lockSyntax' LookupResultKind.NotInvocable' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(boundLockTemp)' ErrorTypeSymbol.UnknownResultType); " is 195.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitLockStatement,The length of the statement  "            if ((TryGetWellKnownTypeMember(lockSyntax' WellKnownMember.System_Threading_Monitor__Enter2' out enterMethod' isOptional: true) || " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitLockStatement,The length of the statement  "                 TryGetWellKnownTypeMember(lockSyntax' WellKnownMember.System_Threading_Monitor__Enter' out enterMethod)) && // If we didn't find the overload introduced in .NET 4.0' then use the older one.  " is 189.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitLockStatement,The length of the statement  "                // Monitor.Enter($lock);           // NB: before try-finally so we don't Exit if an exception prevents us from acquiring the lock. " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitLockStatement,The length of the statement  "                    enterCallExpr = new BoundBadExpression(lockSyntax' LookupResultKind.NotInvocable' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(boundLockTemp)' ErrorTypeSymbol.UnknownResultType); " is 196.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeInitialLockSequencePoint,The length of the statement  "                new BoundSequencePointWithSpan(lockSyntax' statement' TextSpan.FromBounds(lockSyntax.LockKeyword.SpanStart' lockSyntax.CloseParenToken.Span.End)) : " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitNullCoalescingOperator,The length of the statement  "            return MakeNullCoalescingOperator(node.Syntax' rewrittenLeft' rewrittenRight' node.LeftConversion' rewrittenResultType); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeNullCoalescingOperator,The length of the statement  "                return new BoundNullCoalescingOperator(syntax' rewrittenLeft' rewrittenRight' rewrittenConversion' rewrittenResultType); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeNullCoalescingOperator,The length of the statement  "                    rewrittenLeft = MakeConversion(rewrittenLeft.Syntax' rewrittenLeft' leftConversion' rewrittenResultType' @checked: false); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeNullCoalescingOperator,The length of the statement  "                return new BoundNullCoalescingOperator(syntax' rewrittenLeft' rewrittenRight' Conversion.Identity' rewrittenResultType); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeNullCoalescingOperator,The length of the statement  "            BoundExpression convertedLeft = GetConvertedLeftForNullCoalescingOperator(boundTemp' leftConversion' rewrittenResultType); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetConvertedLeftForNullCoalescingOperator,The length of the statement  "            // Native compiler violates the specification for the case where result type is right operand type and left operand is nullable. " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetConvertedLeftForNullCoalescingOperator,The length of the statement  "            // For this case' we need to insert an extra explicit nullable conversion from the left operand to its underlying nullable type " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetConvertedLeftForNullCoalescingOperator,The length of the statement  "            // See comments in Binder.BindNullCoalescingOperator referring to GetConvertedLeftForNullCoalescingOperator for more details. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetConvertedLeftForNullCoalescingOperator,The length of the statement  "                MethodSymbol getValueOrDefault = GetNullableMethod(rewrittenLeft.Syntax' rewrittenLeftType' SpecialMember.System_Nullable_T_GetValueOrDefault); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitDynamicObjectCreationExpression,The length of the statement  "            return _dynamicFactory.MakeDynamicConstructorInvocation(node.Syntax' node.Type' loweredArguments' node.ArgumentNamesOpt' node.ArgumentRefKindsOpt).ToExpression(); " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitObjectCreationExpression,The length of the statement  "            // such as generating a params array' re-ordering arguments based on argsToParamsOpt map' inserting arguments for optional parameters' etc. " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitObjectCreationExpression,The length of the statement  "            rewrittenArguments = MakeArguments(node.Syntax' rewrittenArguments' node.Constructor' node.Constructor' node.Expanded' node.ArgsToParamsOpt' ref argumentRefKindsOpt' out temps); " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitObjectCreationExpression,The length of the statement  "                rewrittenObjectCreation = node.UpdateArgumentsAndInitializer(rewrittenArguments' MakeObjectCreationInitializerForExpressionTree(node.InitializerExpressionOpt)' changeTypeOpt: node.Constructor.ContainingType); " is 208.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitObjectCreationExpression,The length of the statement  "            rewrittenObjectCreation = node.UpdateArgumentsAndInitializer(rewrittenArguments' newInitializerExpression: null' changeTypeOpt: node.Constructor.ContainingType); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitObjectCreationExpression,The length of the statement  "            return MakeObjectCreationWithInitializer(node.Syntax' rewrittenObjectCreation' node.InitializerExpressionOpt' node.Type); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeObjectCreationWithInitializer,The length of the statement  "            AddObjectOrCollectionInitializers(ref dynamicSiteInitializers' ref temps' loweredInitializers' value' initializerExpression); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitNewT,The length of the statement  "            return MakeObjectCreationWithInitializer(node.Syntax' rewrittenNewT' node.InitializerExpressionOpt' rewrittenNewT.Type); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitNoPiaObjectCreationExpression,The length of the statement  "                newGuid = new BoundBadExpression(node.Syntax' LookupResultKind.NotCreatable' ImmutableArray<Symbol>.Empty' ImmutableArray<BoundNode>.Empty' ErrorTypeSymbol.UnknownResultType); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitNoPiaObjectCreationExpression,The length of the statement  "            var getTypeFromCLSID = _factory.WellKnownMethod(WellKnownMember.System_Runtime_InteropServices_Marshal__GetTypeFromCLSID' isOptional: true); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitNoPiaObjectCreationExpression,The length of the statement  "                callGetTypeFromCLSID = new BoundBadExpression(node.Syntax' LookupResultKind.OverloadResolutionFailure' ImmutableArray<Symbol>.Empty' ImmutableArray<BoundNode>.Empty' ErrorTypeSymbol.UnknownResultType); " is 201.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitNoPiaObjectCreationExpression,The length of the statement  "                rewrittenObjectCreation = new BoundBadExpression(node.Syntax' LookupResultKind.OverloadResolutionFailure' ImmutableArray<Symbol>.Empty' ImmutableArray<BoundNode>.Empty' node.Type); " is 180.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitNoPiaObjectCreationExpression,The length of the statement  "            return MakeObjectCreationWithInitializer(node.Syntax' rewrittenObjectCreation' node.InitializerExpressionOpt' node.Type); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,UpdateInitializers,The length of the statement  "                return ((BoundCollectionInitializerExpression)initializerExpression).Update(newInitializers' initializerExpression.Type); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectOrCollectionInitializers,The length of the statement  "                    AddObjectInitializers(ref dynamicSiteInitializers' ref temps' result' rewrittenReceiver' ((BoundObjectInitializerExpression)initializerExpression).Initializers); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectOrCollectionInitializers,The length of the statement  "                    AddCollectionInitializers(ref dynamicSiteInitializers' result' rewrittenReceiver' ((BoundCollectionInitializerExpression)initializerExpression).Initializers); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeObjectOrCollectionInitializersForExpressionTree,The length of the statement  "                    AddCollectionInitializers(ref dynamicSiteInitializers' result' null' ((BoundCollectionInitializerExpression)initializerExpression).Initializers); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddCollectionInitializers,The length of the statement  "                    rewrittenInitializer = MakeDynamicCollectionInitializer(rewrittenReceiver' (BoundDynamicCollectionElementInitializer)initializer); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCollectionInitializer,The length of the statement  "            // such as generating a params array' re-ordering arguments based on argsToParamsOpt map' inserting arguments for optional parameters' etc. " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCollectionInitializer,The length of the statement  "            rewrittenArguments = MakeArguments(syntax' rewrittenArguments' addMethod' addMethod' initializer.Expanded' initializer.ArgsToParamsOpt' ref argumentRefKindsOpt' out temps' enableCallerInfo: ThreeState.True); " is 207.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCollectionInitializer,The length of the statement  "                // the add method was found as an extension method.  Replace the implicit receiver (first argument) with the rewritten receiver. " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCollectionInitializer,The length of the statement  "                return initializer.Update(addMethod' rewrittenArguments' false' default(ImmutableArray<int>)' initializer.InvokedAsExtensionMethod' initializer.ResultKind' rewrittenType); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCollectionInitializer,The length of the statement  "            return MakeCall(null' syntax' rewrittenReceiver' addMethod' rewrittenArguments' default(ImmutableArray<RefKind>)' initializer.InvokedAsExtensionMethod' initializer.ResultKind' addMethod.ReturnType' temps); " is 205.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectInitializers,The length of the statement  "                AddObjectInitializer(ref dynamicSiteInitializers' ref temps' result' rewrittenReceiver' (BoundAssignmentOperator)initializer); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectInitializer,The length of the statement  "            bool isRhsNestedInitializer = rhsKind == BoundKind.ObjectInitializerExpression || rhsKind == BoundKind.CollectionInitializerExpression; " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectInitializer,The length of the statement  "                                result.Add(MakeStaticAssignmentOperator(assignment.Syntax' rewrittenAccess' rewrittenRight' assignment.Type' used: false)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectInitializer,The length of the statement  "                        var getMember = _dynamicFactory.MakeDynamicGetMember(rewrittenReceiver' initializerMember.MemberName' resultIndexed: false); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectInitializer,The length of the statement  "                            result.Add(MakeStaticAssignmentOperator(assignment.Syntax' rewrittenAccess' rewrittenRight' assignment.Type' used: false)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddObjectInitializer,The length of the statement  "                            result.Add(MakeStaticAssignmentOperator(assignment.Syntax' rewrittenAccess' rewrittenRight' assignment.Type' used: false)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeObjectInitializerMemberAccess,The length of the statement  "            Debug.Assert(memberSymbol != null && _compilation.Conversions.ClassifyConversion(rewrittenReceiver.Type' memberSymbol.ContainingType' ref useSiteDiagnostics).IsImplicit); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeObjectInitializerMemberAccess,The length of the statement  "            // It is possible there are use site diagnostics from the above' but none that we need report as we aren't generating code for the conversion " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeObjectInitializerMemberAccess,The length of the statement  "                    return MakeFieldAccess(rewrittenLeft.Syntax' rewrittenReceiver' fieldSymbol' null' rewrittenLeft.ResultKind' fieldSymbol.Type); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeObjectInitializerMemberAccess,The length of the statement  "                    return MakeEventAccess(rewrittenLeft.Syntax' rewrittenReceiver' eventSymbol' null' rewrittenLeft.ResultKind' eventSymbol.Type); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitPropertyAccess,The length of the statement  "            return MakePropertyAccess(node.Syntax' rewrittenReceiverOpt' node.PropertySymbol' node.ResultKind' node.Type' isLeftOfAssignment' node); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakePropertyAccess,The length of the statement  "                        !_inExpressionLambda && ReferenceEquals(propertySymbol' _compilation.GetSpecialTypeMember(SpecialMember.System_Array__LongLength))) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakePropertyGetAccess,The length of the statement  "            return MakePropertyGetAccess(syntax' rewrittenReceiver' property' ImmutableArray<BoundExpression>.Empty' null' oldNodeOpt); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,CreateSpanForConstructorDeclaration,The length of the statement  "            return CreateSpan(constructorSyntax.Modifiers' constructorSyntax.Identifier' constructorSyntax.ParameterList.CloseParenToken); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddConditionSequencePoint,The length of the statement  "            var local = _factory.SynthesizedLocal(condition.Type' containingStatement.Syntax' kind: SynthesizedLocalKind.ConditionalBranchDiscriminator); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitStackAllocArrayCreation,The length of the statement  "            BinaryOperatorKind multiplicationKind = BinaryOperatorKind.Checked | BinaryOperatorKind.UIntMultiplication; //"UInt" just to make it unsigned " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,FlattenConcatArg,The length of the statement  "                            (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatStringStringStringString) || " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringConcatenationTwoExprs,The length of the statement  "            SpecialMember member = (loweredLeft.Type.SpecialType == SpecialType.System_String && loweredRight.Type.SpecialType == SpecialType.System_String) ? " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringConcatenationManyExprs,The length of the statement  "            Debug.Assert(loweredArgs.All(a => a.Type.SpecialType == SpecialType.System_Object || a.Type.SpecialType == SpecialType.System_String)); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringConcatInExpressionLambda,The length of the statement  "            return new BoundBinaryOperator(syntax' operatorKind' loweredLeft' loweredRight' default(ConstantValue)' method' default(LookupResultKind)' type); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteInterpolatedStringConversion,The length of the statement  "                allowUnexpandedForm: false // if an interpolation expression is the null literal' it should not match a params parameter. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitInterpolatedString,The length of the statement  "                allowUnexpandedForm: false // if an interpolation expression is the null literal' it should not match a params parameter. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitSwitchStatement,The length of the statement  "            var rewrittenStatement = MakeSwitchStatement(syntax' AddConditionSequencePoint(rewrittenExpression' node)' rewrittenSections' node.ConstantTargetOpt' node.InnerLocals' node.BreakLabel' node); " is 191.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSwitchStatement,The length of the statement  "                MakeSwitchStatementWithNullableExpression(syntax' rewrittenExpression' rewrittenSections' constantTargetOpt' locals' breakLabel' oldNode) : " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSwitchStatement,The length of the statement  "                MakeSwitchStatementWithNonNullableExpression(syntax' rewrittenExpression' rewrittenSections' constantTargetOpt' locals' breakLabel' oldNode); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSwitchStatementWithNullableExpression,The length of the statement  "            // Rewrite the nullable expression to a temp as we might have a user defined conversion from source expression to switch governing type. " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSwitchStatementWithNullableExpression,The length of the statement  "            // Generate a BoundConditionalGoto with null check as the conditional expression and appropriate switch label as the target: null' default or exit label. " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSwitchStatementWithNullableExpression,The length of the statement  "            MethodSymbol getValueOrDefault = GetNullableMethod(syntax' exprNullableType' SpecialMember.System_Nullable_T_GetValueOrDefault); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeSwitchStatementWithNullableExpression,The length of the statement  "            return new BoundBlock(syntax' locals: (object)tempLocal == null ? ImmutableArray<LocalSymbol>.Empty : ImmutableArray.Create<LocalSymbol>(tempLocal)' statements: statementBuilder.ToImmutableAndFree()); " is 200.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitUnaryOperator,The length of the statement  "                if (node.OperatorKind == UnaryOperatorKind.DynamicTrue && binaryOperator.OperatorKind == BinaryOperatorKind.DynamicLogicalOr || " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitUnaryOperator,The length of the statement  "                    node.OperatorKind == UnaryOperatorKind.DynamicFalse && binaryOperator.OperatorKind == BinaryOperatorKind.DynamicLogicalAnd) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeUnaryOperator,The length of the statement  "                Debug.Assert(kind == UnaryOperatorKind.DynamicTrue && type.SpecialType == SpecialType.System_Boolean || type.IsDynamic()); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,LowerLiftedUnaryOperator,The length of the statement  "            MethodSymbol getValueOrDefault = GetNullableMethod(syntax' boundTemp.Type' SpecialMember.System_Nullable_T_GetValueOrDefault); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitIncrementOperator,The length of the statement  "            BoundExpression transformedLHS = TransformCompoundAssignmentLHS(node.Operand' tempInitializers' tempSymbols' isDynamic); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitIncrementOperator,The length of the statement  "            var newValue = MakeIncrementOperator(node' rewrittenValueToIncrement: (isPrefix ? MakeRValue(transformedLHS) : boundTemp)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitIncrementOperator,The length of the statement  "                return RewriteWithRefOperand(isPrefix' isChecked' tempSymbols' tempInitializers' syntax' transformedLHS' operandType' boundTemp' newValue); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitIncrementOperator,The length of the statement  "                return RewriteWithNotRefOperand(isPrefix' isChecked' tempSymbols' tempInitializers' syntax' transformedLHS' operandType' boundTemp' newValue); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWithNotRefOperand,The length of the statement  "                MakeAssignmentOperator(syntax' boundTemp' isPrefix ? newValue : MakeRValue(transformedLHS)' operandType' used: false' isChecked: isChecked' isCompoundAssignment: false)' " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWithNotRefOperand,The length of the statement  "                MakeAssignmentOperator(syntax' transformedLHS' isPrefix ? boundTemp : newValue' operandType' used: false' isChecked: isChecked' isCompoundAssignment: false)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWithRefOperand,The length of the statement  "            var tempAssignment = MakeAssignmentOperator(syntax' boundTemp' tempValue' operandType' used: false' isChecked: isChecked' isCompoundAssignment: false); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWithRefOperand,The length of the statement  "            BoundExpression operandAssignment = MakeAssignmentOperator(syntax' operand' tempAssignedAndOperandValue' operandType' used: false' isChecked: isChecked' isCompoundAssignment: false); " is 182.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeIncrementOperator,The length of the statement  "                return _dynamicFactory.MakeDynamicUnaryOperator(node.OperatorKind' rewrittenValueToIncrement' node.Type).ToExpression(); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBuiltInIncrementOperator,The length of the statement  "            else if (unaryOperandType.IsNullableType() && unaryOperandType.GetNullableUnderlyingType().SpecialType == SpecialType.System_Decimal) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeLiftedDecimalIncDecOperator,The length of the statement  "            Debug.Assert(operand.Type.IsNullableType() && operand.Type.GetNullableUnderlyingType().SpecialType == SpecialType.System_Decimal); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeLiftedDecimalIncDecOperator,The length of the statement  "            MethodSymbol getValueOrDefault = GetNullableMethod(syntax' operand.Type' SpecialMember.System_Nullable_T_GetValueOrDefault); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeLiftedDecimalIncDecOperator,The length of the statement  "            return RewriteConditionalOperator(syntax' condition' consequence' alternative' ConstantValue.NotAvailable' operand.Type); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeRValue,The length of the statement  "                    return MakePropertyGetAccess(transformedExpression.Syntax' propertyAccess.ReceiverOpt' propertyAccess.PropertySymbol' propertyAccess); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeRValue,The length of the statement  "                    return _dynamicFactory.MakeDynamicGetMember(dynamicMemberAccess.Receiver' dynamicMemberAccess.Name' resultIndexed: false).ToExpression(); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeRValue,The length of the statement  "                    return MakePropertyGetAccess(transformedExpression.Syntax' indexerAccess.ReceiverOpt' indexerAccess.Indexer' indexerAccess.Arguments); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteExpressionUsingStatement,The length of the statement  "                boundTemp = _factory.StoreToTemp(rewrittenExpression' out tempAssignment' syntaxOpt: usingSyntax' kind: SynthesizedLocalKind.Using); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteDeclarationUsingStatement,The length of the statement  "            BoundLocal boundLocal = new BoundLocal(declarationSyntax' localSymbol' localDeclaration.InitializerOpt.ConstantValue' localType); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteUsingStatementTryFinally,The length of the statement  "                MethodSymbol getValueOrDefault = GetNullableMethod(syntax' local.Type' SpecialMember.System_Nullable_T_GetValueOrDefault); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteUsingStatementTryFinally,The length of the statement  "                disposeCall = new BoundBadExpression(syntax' LookupResultKind.NotInvocable' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(disposedExpression)' ErrorTypeSymbol.UnknownResultType); " is 195.
Long Statement,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWhileStatement,The length of the statement  "            BoundStatement ifConditionGotoStart = new BoundConditionalGoto(rewrittenCondition.Syntax' rewrittenCondition' true' startLabel); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperation.cs,Bad,The length of the statement  "            var bad = new BoundBadExpression(children[0].Syntax' LookupResultKind.Empty' ImmutableArray<Symbol>.Empty' children' resultType); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicConversion,The length of the statement  "            return MakeDynamicOperation(binderConstruction' null' RefKind.None' loweredArguments' ImmutableArray<RefKind>.Empty' null' resultType); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicUnaryOperator,The length of the statement  "            var binderConstruction = ((object)argumentInfoFactory != null) ? MakeBinderConstruction(WellKnownMember.Microsoft_CSharp_RuntimeBinder_Binder__UnaryOperation' new[] " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicUnaryOperator,The length of the statement  "            return MakeDynamicOperation(binderConstruction' null' RefKind.None' loweredArguments' ImmutableArray<RefKind>.Empty' null' resultType); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicBinaryOperator,The length of the statement  "            var binderConstruction = ((object)argumentInfoFactory != null) ? MakeBinderConstruction(WellKnownMember.Microsoft_CSharp_RuntimeBinder_Binder__BinaryOperation' new[] " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicBinaryOperator,The length of the statement  "            return MakeDynamicOperation(binderConstruction' null' RefKind.None' loweredArguments' ImmutableArray<RefKind>.Empty' null' resultType); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicMemberInvocation,The length of the statement  "            var binderConstruction = ((object)argumentInfoFactory != null) ? MakeBinderConstruction(WellKnownMember.Microsoft_CSharp_RuntimeBinder_Binder__InvokeMember' new[] " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicMemberInvocation,The length of the statement  "                MakeCallSiteArgumentInfos(argumentInfoFactory' loweredArguments' argumentNames' refKinds' loweredReceiver' receiverRefKind' receiverIsStaticType) " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicMemberInvocation,The length of the statement  "            return MakeDynamicOperation(binderConstruction' loweredReceiver' receiverRefKind' loweredArguments' refKinds' null' resultType); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicEventAccessorInvocation,The length of the statement  "            var binderConstruction = ((object)argumentInfoFactory != null) ? MakeBinderConstruction(WellKnownMember.Microsoft_CSharp_RuntimeBinder_Binder__InvokeMember' new[] " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicEventAccessorInvocation,The length of the statement  "                MakeCallSiteArgumentInfos(argumentInfoFactory' loweredArguments' loweredReceiver: loweredReceiver' loweredRight: loweredHandler) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicEventAccessorInvocation,The length of the statement  "            return MakeDynamicOperation(binderConstruction' loweredReceiver' RefKind.None' loweredArguments' ImmutableArray<RefKind>.Empty' loweredHandler' resultType); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicInvocation,The length of the statement  "            var binderConstruction = ((object)argumentInfoFactory != null) ? MakeBinderConstruction(WellKnownMember.Microsoft_CSharp_RuntimeBinder_Binder__Invoke' new[] " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicInvocation,The length of the statement  "            return MakeDynamicOperation(binderConstruction' loweredReceiver' RefKind.None' loweredArguments' refKinds' null' resultType); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicConstructorInvocation,The length of the statement  "            var binderConstruction = ((object)argumentInfoFactory != null) ? MakeBinderConstruction(WellKnownMember.Microsoft_CSharp_RuntimeBinder_Binder__InvokeConstructor' new[] " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicConstructorInvocation,The length of the statement  "                MakeCallSiteArgumentInfos(argumentInfoFactory' loweredArguments' argumentNames' refKinds' loweredReceiver' receiverIsStaticType: true) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicGetMember,The length of the statement  "            var binderConstruction = ((object)argumentInfoFactory != null) ? MakeBinderConstruction(WellKnownMember.Microsoft_CSharp_RuntimeBinder_Binder__GetMember' new[] " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicGetMember,The length of the statement  "            return MakeDynamicOperation(binderConstruction' loweredReceiver' RefKind.None' loweredArguments' ImmutableArray<RefKind>.Empty' null' resultType); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicSetMember,The length of the statement  "            var binderConstruction = ((object)argumentInfoFactory != null) ? MakeBinderConstruction(WellKnownMember.Microsoft_CSharp_RuntimeBinder_Binder__SetMember' new[] " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicSetMember,The length of the statement  "                MakeCallSiteArgumentInfos(argumentInfoFactory' loweredArguments' loweredReceiver: loweredReceiver' loweredRight: loweredRight) " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicSetMember,The length of the statement  "            return MakeDynamicOperation(binderConstruction' loweredReceiver' RefKind.None' loweredArguments' ImmutableArray<RefKind>.Empty' loweredRight' AssemblySymbol.DynamicType); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicGetIndex,The length of the statement  "            var binderConstruction = ((object)argumentInfoFactory != null) ? MakeBinderConstruction(WellKnownMember.Microsoft_CSharp_RuntimeBinder_Binder__GetIndex' new[] " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicGetIndex,The length of the statement  "                MakeCallSiteArgumentInfos(argumentInfoFactory' loweredArguments' argumentNames' refKinds' loweredReceiver: loweredReceiver) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicGetIndex,The length of the statement  "            return MakeDynamicOperation(binderConstruction' loweredReceiver' RefKind.None' loweredArguments' refKinds' null' resultType); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicSetIndex,The length of the statement  "            var binderConstruction = ((object)argumentInfoFactory != null) ? MakeBinderConstruction(WellKnownMember.Microsoft_CSharp_RuntimeBinder_Binder__SetIndex' new[] " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicSetIndex,The length of the statement  "                MakeCallSiteArgumentInfos(argumentInfoFactory' loweredArguments' argumentNames' refKinds' loweredReceiver' loweredReceiverRefKind' loweredRight: loweredRight) " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicSetIndex,The length of the statement  "            return MakeDynamicOperation(binderConstruction' loweredReceiver' loweredReceiverRefKind' loweredArguments' refKinds' loweredRight' resultType); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicIsEventTest,The length of the statement  "            return MakeDynamicOperation(binderConstruction' loweredReceiver' RefKind.None' ImmutableArray<BoundExpression>.Empty' ImmutableArray<RefKind>.Empty' null' resultType); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,GetArgumentInfoFactory,The length of the statement  "            return _factory.WellKnownMethod(WellKnownMember.Microsoft_CSharp_RuntimeBinder_CSharpArgumentInfo__Create' isOptional: false); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeCallSiteArgumentInfos,The length of the statement  "            var infos = new BoundExpression[(loweredReceiver != null ? 1 : 0) + loweredArguments.Length + (loweredRight != null ? 1 : 0)]; " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicOperation,The length of the statement  "            NamedTypeSymbol delegateTypeOverMethodTypeParameters = GetDelegateType(loweredReceiver' receiverRefKind' loweredArguments' refKinds' loweredRight' resultType); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicOperation,The length of the statement  "            MethodSymbol callSiteFactoryGeneric = _factory.WellKnownMethod(WellKnownMember.System_Runtime_CompilerServices_CallSite_T__Create); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicOperation,The length of the statement  "            FieldSymbol callSiteTargetFieldGeneric = (FieldSymbol)_factory.WellKnownMember(WellKnownMember.System_Runtime_CompilerServices_CallSite_T__Target); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicOperation,The length of the statement  "            var callSiteField = DefineCallSiteStorageSymbol(containerDef' delegateTypeOverMethodTypeParameters' methodToContainerTypeParametersMap); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,DefineCallSiteStorageSymbol,The length of the statement  "            var delegateTypeOverContainerTypeParameters = methodToContainerTypeParametersMap.SubstituteNamedType(delegateTypeOverMethodTypeParameters); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,DefineCallSiteStorageSymbol,The length of the statement  "            var callSiteType = _factory.Compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_CallSite_T).Construct(new[] { delegateTypeOverContainerTypeParameters }); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,GetDelegateType,The length of the statement  "            var delegateSignature = MakeCallSiteDelegateSignature(callSiteType' loweredReceiver' loweredArguments' loweredRight' resultType); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,GetDelegateType,The length of the statement  "                byRefs = BitArray.Create(1 + (loweredReceiver != null ? 1 : 0) + loweredArguments.Length + (loweredRight != null ? 1 : 0)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,GetDelegateType,The length of the statement  "            return _factory.Compilation.AnonymousTypeManager.SynthesizeDelegate(parameterCount' byRefs' returnsVoid).Construct(delegateSignature); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeCallSiteDelegateSignature,The length of the statement  "            var result = new TypeSymbol[1 + (receiver != null ? 1 : 0) + arguments.Length + (right != null ? 1 : 0) + (resultType.SpecialType == SpecialType.System_Void ? 0 : 1)]; " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorAndAsyncCaptureWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\IteratorAndAsyncCaptureWalker.cs,Analyze,The length of the statement  "            var walker = new IteratorAndAsyncCaptureWalker(compilation' method' node' new NeverEmptyStructTypeCache()' initiallyAssignedVariables); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,IteratorAndAsyncCaptureWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\IteratorAndAsyncCaptureWalker.cs,Analyze,The length of the statement  "                        // CS4013: Instance of type '{0}' cannot be used inside an anonymous function' query expression' iterator block or async method " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,PossibleIteratorScope,The length of the statement  "                    proxy = new CapturedToStateMachineFieldReplacement(GetOrAllocateReusableHoistedField(TypeMap.SubstituteType(local.Type))' isReusable: true); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,PossibleIteratorScope,The length of the statement  "                translatedStatement = F.Block(new BoundStateMachineScope(F.Syntax' hoistedLocalsWithDebugScopes.ToImmutable()' translatedStatement)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,MightContainReferences,The length of the statement  "            if (!type.IsFromCompilation(this.CompilationState.ModuleBuilderOpt.Compilation)) return true; // perhaps from ref assembly " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,GetOrAllocateReusableHoistedField,The length of the statement  "            if (_lazyAvailableReusableHoistedFields != null && _lazyAvailableReusableHoistedFields.TryGetValue(type' out fields) && fields.Count > 0) " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,FreeReusableHoistedField,The length of the statement  "            if (_lazyAvailableReusableHoistedFields == null || !_lazyAvailableReusableHoistedFields.TryGetValue(field.Type' out fields)) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,FreeReusableHoistedField,The length of the statement  "                    _lazyAvailableReusableHoistedFields = new Dictionary<TypeSymbol' ArrayBuilder<StateMachineFieldSymbol>>(TypeSymbol.EqualsIgnoringDynamicComparer); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,HoistRefInitialization,The length of the statement  "            var replacement = HoistExpression(right' awaitSyntaxOpt' syntaxOffset' true' sideEffects' hoistedFields' ref needsSacrificialEvaluation); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,HoistRefInitialization,The length of the statement  "            proxies.Add(local' new CapturedToExpressionSymbolReplacement(replacement' hoistedFields.ToImmutableAndFree()' isReusable: true)); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,HoistRefInitialization,The length of the statement  "                return F.Sequence(ImmutableArray.Create(sacrificalTemp)' sideEffects.ToImmutableAndFree()' F.AssignmentExpression(F.Local(sacrificalTemp)' replacement' refKind: RefKind.Ref)); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,HoistExpression,The length of the statement  "                        BoundExpression expression = HoistExpression(array.Expression' awaitSyntaxOpt' syntaxOffset' false' sideEffects' hoistedFields' ref needsSacrificialEvaluation); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,HoistExpression,The length of the statement  "                            indices.Add(HoistExpression(index' awaitSyntaxOpt' syntaxOffset' false' sideEffects' hoistedFields' ref needsSacrificialEvaluation)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,HoistExpression,The length of the statement  "                        var receiver = HoistExpression(field.ReceiverOpt' awaitSyntaxOpt' syntaxOffset' isFieldOfStruct' sideEffects' hoistedFields' ref needsSacrificialEvaluation); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,HoistExpression,The length of the statement  "                        if (slotAllocatorOpt == null || !slotAllocatorOpt.TryGetPreviousHoistedLocalSlotIndex(awaitSyntaxOpt' (Cci.ITypeReference)fieldType' kind' id' out slotIndex)) " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp,MethodToStateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs,VisitTryStatement,The length of the statement  "                        F.Assignment(F.Field(F.This()' stateField)' F.AssignmentExpression(F.Local(cachedState)' F.Literal(StateMachineStates.NotStartedStateMachine)))' " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,StateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineRewriter.cs,CreateNonReusableLocalProxies,The length of the statement  "                            // EnC: When emitting the baseline (gen 0) the id is stored in a custom debug information attached to the kickoff method. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,StateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineRewriter.cs,CreateNonReusableLocalProxies,The length of the statement  "                            if (mapToPreviousFields && slotAllocatorOpt.TryGetPreviousHoistedLocalSlotIndex(declaratorSyntax' (Cci.ITypeReference)fieldType' synthesizedKind' id' out previousSlotIndex)) " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp,StateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineRewriter.cs,CreateNonReusableLocalProxies,The length of the statement  "                        var proxyField = F.StateMachineField(typeMap.SubstituteType(parameter.Type)' parameter.Name' isPublic: !PreserveInitialParameterValues); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,StateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineRewriter.cs,CreateNonReusableLocalProxies,The length of the statement  "                            var field = F.StateMachineField(typeMap.SubstituteType(parameter.Type)' GeneratedNames.StateMachineParameterProxyFieldName(parameter.Name)' isPublic: true); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,StateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineRewriter.cs,OpenMethodImplementation,The length of the statement  "            var result = new SynthesizedStateMachineMethod(methodName' methodToImplement' (StateMachineTypeSymbol)F.CurrentType' null' debuggerHidden' generateDebugInfo' hasMethodBodyDependency); " is 183.
Long Statement,Microsoft.CodeAnalysis.CSharp,StateMachineRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineRewriter.cs,OpenPropertyImplementation,The length of the statement  "            var prop = new SynthesizedStateMachineProperty(getterToImplement' (StateMachineTypeSymbol)F.CurrentType' debuggerHidden' hasMethodBodyDependency); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,StateMachineTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineTypeSymbol.cs,MakeName,The length of the statement  "                   GeneratedNames.MakeStateMachineTypeName(kickoffMethod.Name' kickoffMethodOrdinal' compilationState.ModuleBuilderOpt.CurrentGenerationOrdinal); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Base,The length of the statement  "            return new BoundBaseReference(Syntax' CurrentMethod.ThisParameter.Type.BaseTypeNoUseSiteDiagnostics) { WasCompilerGenerated = true }; " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Field,The length of the statement  "            return new BoundFieldAccess(Syntax' receiver' f' ConstantValue.NotAvailable' LookupResultKind.Viable' f.Type) { WasCompilerGenerated = true }; " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Property,The length of the statement  "            return Call(receiver' property.GetMethod); // TODO: should we use property.GetBaseProperty().GetMethod to ensure we generate a call to the overridden method? " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,WellKnownMember,The length of the statement  "                var diagnostic = new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_MissingPredefinedMember' memberDescriptor.DeclaringTypeMetadataName' memberDescriptor.Name)' Syntax.Location); " is 179.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,SpecialMember,The length of the statement  "                var diagnostic = new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_MissingPredefinedMember' memberDescriptor.DeclaringTypeMetadataName' memberDescriptor.Name)' Syntax.Location); " is 179.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Return,The length of the statement  "                var conversion = Compilation.Conversions.ClassifyConversion(expression.Type' CurrentMethod.ReturnType' ref useSiteDiagnostics); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Return,The length of the statement  "                    expression = BoundConversion.Synthesized(Syntax' expression' conversion' false' false' ConstantValue.NotAvailable' CurrentMethod.ReturnType); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,SynthesizedLocal,The length of the statement  "            return new SynthesizedLocal(CurrentMethod' type' kind' syntax' isPinned' refKind' createdAtLineNumber' createdAtFilePath); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Binary,The length of the statement  "            return new BoundBinaryOperator(this.Syntax' kind' left' right' ConstantValue.NotAvailable' null' LookupResultKind.Viable' type) { WasCompilerGenerated = true }; " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,As,The length of the statement  "            return new BoundAsOperator(this.Syntax' operand' Type(type)' Conversion.ExplicitReference' type) { WasCompilerGenerated = true }; " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,LogicalAnd,The length of the statement  "            return Binary(BinaryOperatorKind.LogicalBoolAnd' SpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean)' left' right); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,IntEqual,The length of the statement  "            return Binary(BinaryOperatorKind.IntEqual' SpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean)' left' right); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,ObjectEqual,The length of the statement  "            return Binary(BinaryOperatorKind.ObjectEqual' SpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean)' left' right); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,ObjectNotEqual,The length of the statement  "            return Binary(BinaryOperatorKind.ObjectNotEqual' SpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean)' left' right); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,IntNotEqual,The length of the statement  "            return Binary(BinaryOperatorKind.IntNotEqual' SpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean)' left' right); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,IntLessThan,The length of the statement  "            return Binary(BinaryOperatorKind.IntLessThan' SpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean)' left' right); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Literal,The length of the statement  "            return new BoundLiteral(Syntax' ConstantValue.Create(value)' SpecialType(Microsoft.CodeAnalysis.SpecialType.System_Int32)) { WasCompilerGenerated = true }; " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Literal,The length of the statement  "            return new BoundLiteral(Syntax' ConstantValue.Create(value)' SpecialType(Microsoft.CodeAnalysis.SpecialType.System_UInt32)) { WasCompilerGenerated = true }; " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,StaticCall,The length of the statement  "            return SyntheticBinder.MakeInvocationExpression(this.Syntax' this.Type(receiver)' name' args.ToImmutableArray()' this.Diagnostics); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,StaticCall,The length of the statement  "            return SyntheticBinder.MakeInvocationExpression(this.Syntax' this.Type(receiver)' name' args' this.Diagnostics' allowUnexpandedForm: allowUnexpandedForm); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,StaticCall,The length of the statement  "            return SyntheticBinder.MakeInvocationExpression(this.Syntax' this.Type(receiver)' name' args.ToImmutableArray()' this.Diagnostics' typeArgs); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,StaticCall,The length of the statement  "                return new BoundBadExpression(Syntax' default(LookupResultKind)' ImmutableArray<Symbol>.Empty' ((BoundNode[])args).AsImmutableOrNull()' receiver); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Conditional,The length of the statement  "            return new BoundConditionalOperator(Syntax' condition' consequence' alternative' default(ConstantValue)' type) { WasCompilerGenerated = true }; " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Coalesce,The length of the statement  "            return new BoundNullCoalescingOperator(Syntax' left' right' Conversion.Identity' left.Type) { WasCompilerGenerated = true }; " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Sequence,The length of the statement  "            return new BoundSequence(Syntax' ImmutableArray<LocalSymbol>.Empty' sideEffects.AsImmutableOrNull()' result' type ?? result.Type) { WasCompilerGenerated = true }; " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Switch,The length of the statement  "            Debug.Assert(ex.Type.SpecialType != Microsoft.CodeAnalysis.SpecialType.System_String); // BoundSwitchStatement.StringEquality not set " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,SwitchSection,The length of the statement  "            return new BoundSwitchSection(Syntax' ImmutableArray.Create<BoundSwitchLabel>(switchLabel)' ImmutableArray.Create<BoundStatement>(statements)) { WasCompilerGenerated = true }; " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,SwitchSection,The length of the statement  "            return new BoundSwitchSection(Syntax' builder.ToImmutableAndFree()' ImmutableArray.Create<BoundStatement>(statements)) { WasCompilerGenerated = true }; " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Literal,The length of the statement  "            return new BoundLiteral(Syntax' ConstantValue.Create(value)' SpecialType(Microsoft.CodeAnalysis.SpecialType.System_Boolean)) { WasCompilerGenerated = true }; " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,StringLiteral,The length of the statement  "            return new BoundLiteral(Syntax' stringConst' SpecialType(Microsoft.CodeAnalysis.SpecialType.System_String)) { WasCompilerGenerated = true }; " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,ArrayAccessFirstElement,The length of the statement  "            ImmutableArray<BoundExpression> firstElementIndices = ArrayBuilder<BoundExpression>.GetInstance(rank' Literal(0)).ToImmutableAndFree(); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,BaseInitialization,The length of the statement  "            var ctor = CurrentMethod.ThisParameter.Type.BaseTypeNoUseSiteDiagnostics.InstanceConstructors.Single(c => c.ParameterCount == 0); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Sizeof,The length of the statement  "            return new BoundSizeOfOperator(Syntax' Type(type)' Binder.GetConstantSizeOf(type)' SpecialType(Microsoft.CodeAnalysis.SpecialType.System_Int32)) { WasCompilerGenerated = true }; " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,MethodInfo,The length of the statement  "            if (!method.ContainingType.IsValueType || !Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.MayUseCallForStructMethod(method)) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Catch,The length of the statement  "            return new BoundCatchBlock(Syntax' local' source' source.Type' exceptionFilterOpt: null' body: block' isSynthesizedAsyncCatchAll: false); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Catch,The length of the statement  "            return new BoundCatchBlock(Syntax' null' source' source.Type' exceptionFilterOpt: null' body: block' isSynthesizedAsyncCatchAll: false); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Fault,The length of the statement  "            return new BoundTryStatement(Syntax' tryBlock' ImmutableArray<BoundCatchBlock>.Empty' faultBlock' preferFaultHandler: true); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBoundNodeFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,Not,The length of the statement  "            return new BoundUnaryOperator(expression.Syntax' UnaryOperatorKind.BoolLogicalNegation' expression' null' null' LookupResultKind.Viable' expression.Type); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBinderImpl,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,IsAccessible,The length of the statement  "                return AccessCheck.IsSymbolAccessible(symbol' _factory.CurrentType' accessThroughType' out failedThroughTypeCheck' ref useSiteDiagnostics' basesBeingResolved); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntheticBinderImpl,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SyntheticBoundNodeFactory.cs,MakeInvocationExpression,The length of the statement  "                return MakeInvocationExpression(node' receiver' methodName' args' diagnostics' typeArgs: typeArgs' allowFieldsAndProperties: false' allowUnexpandedForm: allowUnexpandedForm); " is 174.
Long Statement,Microsoft.CodeAnalysis.CSharp,ObjectDisplay,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\ObjectDisplay.cs,FormatLiteral,The length of the statement  "            return FormatString(value' options.IncludesOption(ObjectDisplayOptions.UseQuotes) ? '"' : '\0'' escapeNonPrintable: true); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,ObjectDisplay,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\ObjectDisplay.cs,FormatLiteral,The length of the statement  "                var codepoint = options.IncludesOption(ObjectDisplayOptions.UseHexadecimalNumbers) ? "0x" + ((int)c).ToString("x4") : ((int)c).ToString(); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,ObjectDisplay,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\ObjectDisplay.cs,ValidateOptions,The length of the statement  "            Debug.Assert(!(options.IncludesOption(ObjectDisplayOptions.UseQuotes) && options.IncludesOption(ObjectDisplayOptions.UseHexadecimalNumbers))); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddAccessibilityIfRequired,The length of the statement  "            // this method is only called for members and they should have a containingType or a containing symbol should be a TypeSymbol. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,IncludeNamedType,The length of the statement  "                (!namedType.IsScriptClass || format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeScriptType)); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitMethod,The length of the statement  "            else if (symbol is SynthesizedGlobalMethodSymbol) // It would be nice to handle VB symbols too' but it's not worth the effort. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitMethod,The length of the statement  "                if (symbol.MethodKind == MethodKind.ReducedExtension && format.ExtensionMethodStyle == SymbolDisplayExtensionMethodStyle.StaticMethod) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitMethod,The length of the statement  "                else if (symbol.MethodKind != MethodKind.ReducedExtension && format.ExtensionMethodStyle == SymbolDisplayExtensionMethodStyle.InstanceMethod) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitMethod,The length of the statement  "                    var name = format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseMetadataMethodNames) || symbol.ContainingType == null || symbol.ContainingType.IsAnonymousType " is 191.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitMethod,The length of the statement  "                    // Note: we are using the metadata name also in the case that symbol.containingType is null' which should never be the case here. " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitMethod,The length of the statement  "                    if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseMetadataMethodNames) || symbol.ContainingType == null) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddExplicitInterfaceIfRequired,The length of the statement  "            if (format.MemberOptions.IncludesOption(SymbolDisplayMemberOptions.IncludeExplicitInterface) && !implementedMethods.IsEmpty) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddCustomModifiersIfRequired,The length of the statement  "            if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddCustomModifiersIfRequired,The length of the statement  "                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other' null' customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ)); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddArrayRank,The length of the statement  "            bool insertStars = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseAsterisksInMultiDimensionalArrays); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddNameAndTypeArgumentsOrParameters,The length of the statement  "                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol. " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddNameAndTypeArgumentsOrParameters,The length of the statement  "            // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol. " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddTypeArguments,The length of the statement  "            if (typeArguments.Length > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddTypeParameterConstraints,The length of the statement  "            if (this.isFirstSymbolVisited && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeConstraints)) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddConstantValue,The length of the statement  "            else if (type.IsReferenceType || type.TypeKind == TypeKind.Pointer || type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T) " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreateAssemblyDataForCompilation,The length of the statement  "                    throw new NotSupportedException(string.Format(CSharpResources.CantReferenceCompilationOf' compilationReference.GetType()' "C#")); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CheckPropertiesConsistency,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_AssemblySpecifiedForLinkAndRef' NoLocation.Singleton' duplicateReference.Display' primaryReference.Display); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreatePEAssemblyForAssemblyMetadata,The length of the statement  "                var peReferences = assembly.AssemblyReferences.SelectAsArray(MapAssemblyIdentityToResolvedSymbol' referencedAssembliesByIdentity); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreatePEAssemblyForAssemblyMetadata,The length of the statement  "                var assemblySymbol = new PEAssemblySymbol(assembly' DocumentationProvider.Default' isLinked: false' importOptions: importOptions); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreatePEAssemblyForAssemblyMetadata,The length of the statement  "                var unifiedAssemblies = this.UnifiedAssemblies.WhereAsArray(unified => referencedAssembliesByIdentity.ContainsKey(unified.OriginalReference)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreateAndSetSourceAssemblyReuseData,The length of the statement  "                var assemblySymbol = new SourceAssemblySymbol(compilation' this.SimpleAssemblyName' moduleName' this.ReferencedModules); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,InitializeAssemblyReuseData,The length of the statement  "                var sourceModuleReferences = new ModuleReferences<AssemblySymbol>(referencedAssemblies.SelectAsArray(a => a.Identity)' referencedAssemblies' unifiedAssemblies); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreateAndSetSourceAssemblyFullBind,The length of the statement  "                var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName)' referencedAssemblies' modules); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreateAndSetSourceAssemblyFullBind,The length of the statement  "                assemblySymbol = new SourceAssemblySymbol(compilation' SimpleAssemblyName' compilation.MakeSourceModuleName()' netModules: modules); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreateAndSetSourceAssemblyFullBind,The length of the statement  "                SetupReferencesForSourceAssembly(assemblySymbol' assemblyBeingBuiltData' bindingResult' ref missingAssemblies' out moduleReferences); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,CreateAndSetSourceAssemblyFullBind,The length of the statement  "                        referencedAssembliesMap.Add(references[i]' new ReferencedAssembly(referencedAssemblySymbols[assemblyIndex]' referenceMap[i].Aliases)); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,InitializeNewSymbols,The length of the statement  "                        SetupReferencesForRetargetingAssembly(bindingResult' i' ref missingAssemblies' sourceAssemblyDebugOnly: sourceAssembly); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,InitializeNewSymbols,The length of the statement  "                        SetupReferencesForFileAssembly(fileData' bindingResult' i' ref missingAssemblies' sourceAssemblyDebugOnly: sourceAssembly); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,SetupReferencesForRetargetingAssembly,The length of the statement  "                var retargetingAssemblySymbol = (Symbols.Retargeting.RetargetingAssemblySymbol)bindingResult[bindingIndex].AssemblySymbol; " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,SetupReferencesForRetargetingAssembly,The length of the statement  "                    var moduleReferences = new ModuleReferences<AssemblySymbol>(referencedAssemblies' symbols.AsImmutableOrNull()' unifiedAssemblies.AsImmutableOrEmpty()); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,ReferenceManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,SetupReferencesForFileAssembly,The length of the statement  "                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull()' symbols.AsImmutableOrNull()' unifiedAssemblies.AsImmutableOrEmpty()); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,AssemblyDataForMetadataOrCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReferenceManager.cs,BindAssemblyReferences,The length of the statement  "                    return ReferenceManager.ResolveReferencedAssemblies(referencedAssemblies' assemblies' assemblyIdentityComparer' okToResolveAgainstCompilationBeingCreated: true); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,SymbolDistinguisher,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SymbolDistinguisher.cs,GetLocationString,The length of the statement  "                    PortableExecutableReference metadataReference = compilation.GetMetadataReference(containingAssembly) as PortableExecutableReference; " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeUnification,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeUnification.cs,CanUnifyHelper,The length of the statement  "                            if (!CanUnifyHelper(nt1.TypeArgumentsNoUseSiteDiagnostics[i]' nt2.TypeArgumentsNoUseSiteDiagnostics[i]' ref substitution)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxNode,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxNode.cs,HasErrorsSlow,The length of the statement  "            return new Syntax.InternalSyntax.SyntaxDiagnosticInfoList(this.Green).Any((info) => info.Severity == DiagnosticSeverity.Error); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxNode,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxNode.cs,SerializeTo,The length of the statement  "                using (var writer = new ObjectWriter(stream' GetDefaultObjectWriterData()' binder: s_defaultBinder' cancellationToken: cancellationToken)) " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxNode,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxNode.cs,ChildThatContainsPosition,The length of the statement  "            Debug.Assert(childNodeOrToken.FullSpan.Contains(position)' "ChildThatContainsPosition's return value does not contain the requested position."); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxNode,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxNode.cs,ReplaceCore,The length of the statement  "            return SyntaxReplacer.Replace(this' nodes' computeReplacementNode' tokens' computeReplacementToken' trivia' computeReplacementTrivia); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxRewriter.cs,VisitToken,The length of the statement  "                    // Also avoid node.Width because it makes a virtual call to GetText. Instead use node.FullWidth - trailingTrivia.FullWidth. " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxRewriter.cs,VisitToken,The length of the statement  "                    var trailing = this.VisitList(new SyntaxTriviaList(token' trailingTrivia' token.Position + node.FullWidth - trailingTrivia.FullWidth' index)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxRewriter.cs,VisitToken,The length of the statement  "                // Also avoid node.Width because it makes a virtual call to GetText. Instead use node.FullWidth - trailingTrivia.FullWidth. " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxRewriter.cs,VisitToken,The length of the statement  "                var trailing = this.VisitList(new SyntaxTriviaList(token' trailingTrivia' token.Position + node.FullWidth - trailingTrivia.FullWidth' index: 0)); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxTree,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxTree.cs,ParseText,The length of the statement  "                    using (var parser = new InternalSyntax.LanguageParser(lexer' oldTree: null' changes: null' cancellationToken: cancellationToken)) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxTree,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxTree.cs,ParseText,The length of the statement  "                        var tree = new ParsedSyntaxTree(text' text.Encoding' text.ChecksumAlgorithm' path' options' compilationUnit' parser.Directives); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxTree,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxTree.cs,WithChanges,The length of the statement  "                var tree = new ParsedSyntaxTree(newText' newText.Encoding' newText.ChecksumAlgorithm' this.FilePath' this.Options' compilationUnit' parser.Directives); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp,ParsedSyntaxTree,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxTree.ParsedSyntaxTree.cs,GetText,The length of the statement  "                    using (Logger.LogBlock(FunctionId.CSharp_SyntaxTree_GetText' message: this.FilePath' cancellationToken: cancellationToken)) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,ParsedSyntaxTree,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpSyntaxTree.ParsedSyntaxTree.cs,GetText,The length of the statement  "                        Interlocked.CompareExchange(ref _lazyText' this.GetRoot(cancellationToken).GetText(_encodingOpt' _checksumAlgorithm)' null); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,AnonymousMethodExpression,The length of the statement  "            return SyntaxFactory.AnonymousMethodExpression(default(SyntaxToken)' SyntaxFactory.Token(SyntaxKind.DelegateKeyword)' default(ParameterListSyntax)' SyntaxFactory.Block()); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Token,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' kind' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 198.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Token,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node' kind' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Token,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Token((InternalSyntax.CSharpSyntaxNode)leading.Node' kind' text' valueText' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 184.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,MissingToken,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' kind' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 205.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,MissingToken,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.MissingToken((InternalSyntax.CSharpSyntaxNode)leading.Node' kind' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 174.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Identifier,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' text' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 203.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Identifier,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier((InternalSyntax.CSharpSyntaxNode)leading.Node' text' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,VerbatimIdentifier,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(SyntaxKind.IdentifierName' (InternalSyntax.CSharpSyntaxNode)leading.Node' "@" + text' valueText' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 216.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Identifier,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Identifier(contextualKind' (InternalSyntax.CSharpSyntaxNode)leading.Node' text' valueText' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 199.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' text' value' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 207.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' text' value' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 207.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' text' value' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 207.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' text' value' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 207.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' text' value' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 207.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' text' value' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 207.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' text' value' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 207.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' text' value' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 207.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode' text' value' (InternalSyntax.CSharpSyntaxNode)ElasticMarker.UnderlyingNode)); " is 207.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Literal,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.Literal((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,BadToken,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.BadToken((InternalSyntax.CSharpSyntaxNode)leading.Node' text' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,XmlTextLiteral,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextLiteral((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 183.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,XmlTextNewLine,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlTextNewLine((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 183.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,XmlEntity,The length of the statement  "            return new SyntaxToken(Syntax.InternalSyntax.SyntaxFactory.XmlEntity((InternalSyntax.CSharpSyntaxNode)leading.Node' text' value' (InternalSyntax.CSharpSyntaxNode)trailing.Node)); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,List,The length of the statement  "                var builder = (collection != null) ? new SyntaxListBuilder<TNode>(collection.Count) : SyntaxListBuilder<TNode>.Create(); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,SeparatedList,The length of the statement  "            // Interleave the nodes and the separators.  The number of separators must be equal to or 1 less than the number of nodes or " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,ParseCref,The length of the statement  "            SyntaxTriviaList leadingTrivia = ParseLeadingTrivia(commentText' CSharpParseOptions.Default.WithDocumentationMode(DocumentationMode.Diagnose)); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,GetNonGenericExpression,The length of the statement  "                            return SyntaxFactory.BinaryExpression(expression.Kind()' max.Expression' max.OperatorToken' SyntaxFactory.IdentifierName(gn.Identifier)); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,IsCompleteSubmission,The length of the statement  "            if (lastNode.HasTrailingTrivia && lastNode.ContainsDiagnostics && HasUnterminatedMultiLineComment(lastNode.GetTrailingTrivia())) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,IsCompleteSubmission,The length of the statement  "            // All top-level constructs but global statement (i.e. extern alias' using directive' global attribute' and declarations) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,IsCompleteSubmission,The length of the statement  "                var closingToken = lastNode.GetLastToken(includeZeroWidth: true' includeSkipped: true' includeDirectives: true' includeDocumentationComments: true); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,IsCompleteSubmission,The length of the statement  "            var token = lastNode.GetLastToken(includeZeroWidth: true' includeSkipped: true' includeDirectives: true' includeDocumentationComments: true); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,CaseSwitchLabel,The length of the statement  "            return SyntaxFactory.CaseSwitchLabel(SyntaxFactory.Token(SyntaxKind.CaseKeyword)' value' SyntaxFactory.Token(SyntaxKind.ColonToken)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,DefaultSwitchLabel,The length of the statement  "            return SyntaxFactory.DefaultSwitchLabel(SyntaxFactory.Token(SyntaxKind.DefaultKeyword)' SyntaxFactory.Token(SyntaxKind.ColonToken)); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,TypeDeclaration,The length of the statement  "                    return SyntaxFactory.ClassDeclaration(attributes' modifiers' keyword' identifier' typeParameterList' baseList' constraintClauses' openBraceToken' members' closeBraceToken' semicolonToken); " is 188.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,TypeDeclaration,The length of the statement  "                    return SyntaxFactory.StructDeclaration(attributes' modifiers' keyword' identifier' typeParameterList' baseList' constraintClauses' openBraceToken' members' closeBraceToken' semicolonToken); " is 189.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,TypeDeclaration,The length of the statement  "                    return SyntaxFactory.InterfaceDeclaration(attributes' modifiers' keyword' identifier' typeParameterList' baseList' constraintClauses' openBraceToken' members' closeBraceToken' semicolonToken); " is 192.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxExtensions.cs,GetElementKind,The length of the statement  "            else if (DocumentationCommentXmlNames.ElementEquals(parentName' DocumentationCommentXmlNames.ParameterReferenceElementName)) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,SyntaxExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxExtensions.cs,GetElementKind,The length of the statement  "            else if (DocumentationCommentXmlNames.ElementEquals(parentName' DocumentationCommentXmlNames.TypeParameterReferenceElementName)) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,GetDeclarationsInNode,The length of the statement  "            ComputeDeclarations(model' node' (n' level) => InvalidLevel(level)' getSymbol' builder' levelsToCompute' cancellationToken); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,ComputeDeclarations,The length of the statement  "                        foreach (var decl in ns.Members) ComputeDeclarations(model' decl' shouldSkip' getSymbol' builder' newLevel' cancellationToken); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,ComputeDeclarations,The length of the statement  "                        foreach (var decl in t.Members) ComputeDeclarations(model' decl' shouldSkip' getSymbol' builder' newLevel' cancellationToken); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,ComputeDeclarations,The length of the statement  "                        foreach (var decl in t.Members) ComputeDeclarations(model' decl' shouldSkip' getSymbol' builder' newLevel' cancellationToken); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,ComputeDeclarations,The length of the statement  "                        foreach (var decl in t.AccessorList.Accessors) ComputeDeclarations(model' decl' shouldSkip' getSymbol' builder' newLevel' cancellationToken); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,ComputeDeclarations,The length of the statement  "                            foreach (var decl in t.AccessorList.Accessors) ComputeDeclarations(model' decl' shouldSkip' getSymbol' builder' newLevel' cancellationToken); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,ComputeDeclarations,The length of the statement  "                        var codeBlocks = t.ParameterList != null ? t.ParameterList.Parameters.Select(p => p.Default) : SpecializedCollections.EmptyEnumerable<SyntaxNode>(); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,ComputeDeclarations,The length of the statement  "                        var codeBlocks = t.ParameterList != null ? t.ParameterList.Parameters.Select(p => p.Default) : SpecializedCollections.EmptyEnumerable<SyntaxNode>(); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpDeclarationComputer,C:\repos\mono_roslyn\src\Compilers\CSharp\CSharpAnalyzerDriver\CSharpDeclarationComputer.cs,ComputeDeclarations,The length of the statement  "                        foreach (var decl in t.Members) ComputeDeclarations(model' decl' shouldSkip' getSymbol' builder' newLevel' cancellationToken); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitMultidimensionalElementInitializers,The length of the statement  "            // This algorithm requires the IEnumerable to be from bottom to top. See extensions for List in CollectionExtensions.vb. " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitMethodGroupConversion,The length of the statement  "            EmitDelegateCreation(conversion' group.InstanceOpt' conversion.IsExtensionMethod' conversion.SymbolOpt' conversion.Type' used); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitSequenceExpression,The length of the statement  "            // CONSIDER:    LocalRewriter.RewriteNestedObjectOrCollectionInitializerExpression may create a bound sequence with an unused BoundTypeExpression as the value' " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitSequenceExpression,The length of the statement  "            // CONSIDER:    which must be ignored by codegen. See comments in RewriteNestedObjectOrCollectionInitializerExpression for details and an example. " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitSequenceExpression,The length of the statement  "            // CONSIDER:    We may want to instead consider making the Value field of BoundSequence node optional to allow a sequence with " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitArguments,The length of the statement  "            Debug.Assert(arguments.Length == parameters.Length || arguments.Length == parameters.Length + 1' "argument count must match parameter count"); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitArrayElementLoad,The length of the statement  "                _builder.EmitArrayElementLoad(Emit.PEModuleBuilder.Translate((ArrayTypeSymbol)arrayAccess.Expression.Type)' arrayAccess.Expression.Syntax' _diagnostics); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitCallExpression,The length of the statement  "                // In reality we would typically have one method calling another method in the same class (one GetEnumerator calling another). " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitArrayLength,The length of the statement  "            // Emitting checked conversion however results in redundant overflow checks on 64bit and also inhibits range check hoisting in loops. " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitObjectCreationExpression,The length of the statement  "                    expression.Constructor.OriginalDefinition == _module.Compilation.GetSpecialTypeMember(SpecialMember.System_Nullable_T__ctor)) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitAssignmentPreamble,The length of the statement  "                        lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value' assignmentOperator.Right' assignmentOperator.RefKind' assignmentOperator.Type)); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitAssignmentValue,The length of the statement  "                Debug.Assert(temp == null || ((SynthesizedLocal)assignmentOperator.Left.ExpressionSymbol).SynthesizedKind == SynthesizedLocalKind.LoweringTemp); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,IsVarianceCast,The length of the statement  "                   (to.IsInterfaceType() && from.IsInterfaceType() && !from.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains((NamedTypeSymbol)to)); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitUnaryCheckedOperatorExpression,The length of the statement  "            // then the mathematical negation of x is not representable within the operand type. If this occurs within a checked context'  " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitConversionToEnumUnderlyingType,The length of the statement  "                    _builder.EmitNumericConversion(Microsoft.Cci.PrimitiveTypeCode.Int32' Microsoft.Cci.PrimitiveTypeCode.UInt16' @checked); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,CanHandleReturnLabel,The length of the statement  "                    (boundReturnStatement.Syntax.Kind() == SyntaxKind.Block || (((object)_method != null) && _method.IsImplicitConstructor)) && " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitCatchBlock,The length of the statement  "                var localSyntax = !declaringReferences.IsEmpty ? (CSharpSyntaxNode)declaringReferences[0].GetSyntax() : catchBlock.Syntax; " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitSwitchStatement,The length of the statement  "                // CONSIDER: If this requirement changes' we may want to pass in ArrayBuilder<KeyValuePair<ConstantValue' object>> instead. " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitSwitchHeader,The length of the statement  "                _builder.EmitIntegerSwitchJumpTable(switchCaseLabels' fallThroughLabel' key' expression.Type.EnumUnderlyingType().PrimitiveTypeCode); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitStringSwitchJumpTable,The length of the statement  "                Cci.IReference stringHashMethodRef = privateImplClass.GetMethod(PrivateImplementationDetails.SynthesizedStringHashFunctionName); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitStringCompareAndBranch,The length of the statement  "            Debug.Assert(stringEqualityMethodRef == _module.Translate((MethodSymbol)_module.Compilation.GetSpecialTypeMember(SpecialMember.System_String__op_Equality)' (CSharpSyntaxNode)syntaxNode' assertDiagnostics)); " is 206.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,DefineLocal,The length of the statement  "                LocalConstantDefinition localConstantDef = new LocalConstantDefinition(local.Name' local.Locations.FirstOrDefault() ?? Location.None' compileTimeValue' isDynamicSourceLocal' transformFlags); " is 190.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,DefineLocal,The length of the statement  "            if (local.DeclarationKind == LocalDeclarationKind.FixedVariable && local.IsPinned) // Excludes pointer local and string local in fixed string case. " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,DefineLocal,The length of the statement  "            // Also' requesting the token has side-effect of registering types used' which is critical for embedded types (NoPia' VBCore' etc). " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,FinallyCloner,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs,VisitSwitchStatement,The length of the statement  "                ImmutableArray<BoundSwitchSection> switchSections = (ImmutableArray<BoundSwitchSection>)this.VisitList(node.SwitchSections); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,FinallyCloner,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs,VisitSwitchStatement,The length of the statement  "                return node.Update(boundExpression' node.ConstantTargetOpt' node.InnerLocals' switchSections' breakLabelClone' node.StringEquality); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitSequence,The length of the statement  "            //      prefix:  Seq{var temp' ref operand; operand initializers; *operand = Seq{temp = (T)(operand + 1);  temp;}          result: temp} " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitSequence,The length of the statement  "            //      postfix: Seq{var temp' ref operand; operand initializers; *operand = Seq{temp = operand;        ;  (T)(temp + 1);} result: temp} " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitSequence,The length of the statement  "            //  1) temp is used as the result of the sequence (and that is the only reason why it is declared in the outer sequence). " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitAssignmentOperator,The length of the statement  "            Debug.Assert(_context != ExprContext.AssignmentTarget' "assignment expression cannot be a target of another assignment"); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitArguments,The length of the statement  "                ExprContext context = (i == parameters.Length || parameters[i].RefKind == RefKind.None) ? ExprContext.Value : ExprContext.Address; " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitSwitchStatement,The length of the statement  "            var result = node.Update(boundExpression' node.ConstantTargetOpt' node.InnerLocals' switchSections' breakLabel' node.StringEquality); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitCatchBlock,The length of the statement  "                    Debug.Assert(_evalStack == prevStack + (LhsUsesStackWhenAssignedTo(exceptionSourceOpt' ExprContext.AssignmentTarget) ? 1 : 0)); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitCatchBlock,The length of the statement  "            return node.Update(local' exceptionSourceOpt' exceptionTypeOpt' boundFilter' boundBlock' node.IsSynthesizedAsyncCatchAll); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,DeclareLocal,The length of the statement  "                        Debug.Assert(local.SynthesizedKind == SynthesizedLocalKind.LoweringTemp' "only lowering temps may be sometimes reused"); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass2,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitObjectCreationExpression,The length of the statement  "            return node.Update(node.Constructor' arguments' node.ArgumentNamesOpt' node.ArgumentRefKindsOpt' node.Expanded' node.ArgsToParamsOpt' node.ConstantValueOpt' null' type); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,ReportMissingOrErroneousSymbols,The length of the statement  "            ReportErrorOnSpecialMember(System_Object__GetHashCode' SpecialMember.System_Object__GetHashCode' diagnostics' ref hasErrors); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,ReportMissingOrErroneousSymbols,The length of the statement  "            ReportErrorOnWellKnownMember(System_String__Format_IFormatProvider' WellKnownMember.System_String__Format_IFormatProvider' diagnostics' ref hasErrors); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,ReportMissingOrErroneousSymbols,The length of the statement  "            Debug.Assert(WellKnownMembers.IsSynthesizedAttributeOptional(WellKnownMember.System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor)); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,ReportMissingOrErroneousSymbols,The length of the statement  "            Debug.Assert(WellKnownMembers.IsSynthesizedAttributeOptional(WellKnownMember.System_Diagnostics_DebuggerHiddenAttribute__ctor)); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,ReportMissingOrErroneousSymbols,The length of the statement  "            Debug.Assert(WellKnownMembers.IsSynthesizedAttributeOptional(WellKnownMember.System_Diagnostics_DebuggerBrowsableAttribute__ctor)); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,GetAnonymousTypeMap,The length of the statement  "            var result = new Dictionary<Microsoft.CodeAnalysis.Emit.AnonymousTypeKey' Microsoft.CodeAnalysis.Emit.AnonymousTypeValue>(); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeEqualsMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,GenerateMethodBody,The length of the statement  "                //             && System.Collections.Generic.EqualityComparer<T_1>.Default.Equals(this.backingFld_1' local.backingFld_1) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeEqualsMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,GenerateMethodBody,The length of the statement  "                //             && System.Collections.Generic.EqualityComparer<T_N>.Default.Equals(this.backingFld_N' local.backingFld_N); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeGetHashCodeMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,GenerateMethodBody,The length of the statement  "                //      return (...((INITIAL_HASH * HASH_FACTOR) + EqualityComparer<T_1>.Default.GetHashCode(this.backingFld_1)) * HASH_FACTOR " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeGetHashCodeMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,GenerateMethodBody,The length of the statement  "                //                                               + EqualityComparer<T_2>.Default.GetHashCode(this.backingFld_2)) * HASH_FACTOR " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeToStringMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,GenerateMethodBody,The length of the statement  "                    retExpression = F.StaticCall(manager.System_String' formatMethod' F.Null(formatMethod.Parameters[0].Type)' format' F.Array(manager.System_Object' arguments)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedStringSwitchHashMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,GenerateMethodBody,The length of the statement  "            SyntheticBoundNodeFactory F = new SyntheticBoundNodeFactory(this' this.GetNonNullSyntaxNode()' compilationState' diagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedExplicitImplementationForwardingMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,GenerateMethodBody,The length of the statement  "            SyntheticBoundNodeFactory F = new SyntheticBoundNodeFactory(this' this.GetNonNullSyntaxNode()' compilationState' diagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedSealedPropertyAccessor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,GenerateMethodBody,The length of the statement  "            SyntheticBoundNodeFactory F = new SyntheticBoundNodeFactory(this' this.GetNonNullSyntaxNode()' compilationState' diagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedSealedPropertyAccessor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,GenerateMethodBody,The length of the statement  "                F.CloseMethod(MethodBodySynthesizer.ConstructSingleInvocationMethodBody(F' this.OverriddenAccessor' useBaseReference: true)); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodToClassRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,VisitSwitchStatement,The length of the statement  "            ImmutableArray<BoundSwitchSection> switchSections = (ImmutableArray<BoundSwitchSection>)this.VisitList(node.SwitchSections); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodToClassRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,VisitSwitchStatement,The length of the statement  "            return node.Update(boundExpression' node.ConstantTargetOpt' newInnerLocals' switchSections' node.BreakLabel' node.StringEquality); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodToClassRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,VisitAwaitExpression,The length of the statement  "            return node.Update(expression' VisitMethodSymbol(node.GetAwaiter)' VisitPropertySymbol(node.IsCompleted)' VisitMethodSymbol(node.GetResult)' type); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodToClassRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,VisitAssignmentOperator,The length of the statement  "                SyntheticBoundNodeFactory factory = new SyntheticBoundNodeFactory(this.CurrentMethod' rewrittenLeft.Syntax' this.CompilationState' this.Diagnostics); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,BaseMethodWrapperSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,GenerateMethodBody,The length of the statement  "                SyntheticBoundNodeFactory F = new SyntheticBoundNodeFactory(this' this.GetNonNullSyntaxNode()' compilationState' diagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,BaseMethodWrapperSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,GenerateMethodBody,The length of the statement  "                    BoundBlock body = MethodBodySynthesizer.ConstructSingleInvocationMethodBody(F' methodBeingWrapped' useBaseReference: true); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ArrayTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\ArrayTypeSymbolAdapter.cs,GetElementType,The length of the statement  "            var type = moduleBeingBuilt.Translate(this.ElementType' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ArrayTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\ArrayTypeSymbolAdapter.cs,GetArrayInterfaces,The length of the statement  "                    constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT' ImmutableArray.Create<TypeSymbol>(elementType))); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ArrayTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\ArrayTypeSymbolAdapter.cs,Equals,The length of the statement  "            if ((object)other == null || other.Rank != Rank || !other.ElementType.Equals(ElementType' ignoreCustomModifiers' ignoreDynamic)) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ArrayTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\ArrayTypeSymbolAdapter.cs,GetUnificationUseSiteDiagnosticRecursive,The length of the statement  "                   ((object)_baseType != null && _baseType.GetUnificationUseSiteDiagnosticRecursive(ref result' owner' ref checkedTypes)) || " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,Constructor,The length of the statement  "            return (Cci.IMethodReference)moduleBeingBuilt.Translate(this.AttributeConstructor' (CSharpSyntaxNode)context.SyntaxNodeOpt' context.Diagnostics); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,GetType,The length of the statement  "            return moduleBeingBuilt.Translate(this.AttributeClass' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,CreateMetadataConstant,The length of the statement  "            return moduleBeingBuilt.CreateConstant((TypeSymbol)type' value' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,CreateMetadataNamedArgument,The length of the statement  "            return new MetadataNamedArgument(symbol' moduleBeingBuilt.Translate(type' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics)' value); " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,IsSecurityAttribute,The length of the statement  "                // SPEC:    If the attribute's type is derived (directly or indirectly) from System.Security.Permissions.SecurityAttribute then " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,IsSecurityAttribute,The length of the statement  "                // NOTE:    See Devdiv Bug #13762 "Custom security attributes deriving from SecurityAttribute are not treated as security attributes" for details. " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,IsSecurityAttribute,The length of the statement  "                _lazyIsSecurityAttribute = AttributeClass.IsDerivedFrom(wellKnownType' ignoreDynamic: false' useSiteDiagnostics: ref useSiteDiagnostics).ToThreeState(); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttribute,The length of the statement  "            Cci.SecurityAction action = DecodeSecurityAttributeAction(targetSymbol' compilation' arguments.AttributeSyntaxOpt' out hasErrors' arguments.Diagnostics); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttribute,The length of the statement  "                    string resolvedPathForFixup = DecodePermissionSetAttribute(compilation' arguments.AttributeSyntaxOpt' arguments.Diagnostics); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttributeAction,The length of the statement  "            Debug.Assert(targetSymbol.Kind == SymbolKind.Assembly || targetSymbol.Kind == SymbolKind.NamedType || targetSymbol.Kind == SymbolKind.Method); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttributeAction,The length of the statement  "                // NOTE:    Ideally' we should always generate 'CS7048: First argument to a security attribute must be a valid SecurityAction' for this case. " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttributeAction,The length of the statement  "                // NOTE:    However' native compiler allows applying System.Security.Permissions.HostProtectionAttribute attribute without any argument and uses  " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttributeAction,The length of the statement  "                // NOTE:    SecurityAction.LinkDemand as the default SecurityAction in this case. We maintain compatibility with the native compiler for this case. " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttributeAction,The length of the statement  "                // BREAKING CHANGE: Even though the native compiler intends to allow only HostProtectionAttribute to be applied without any arguments' " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttributeAction,The length of the statement  "                // The implementation issue leads to the native compiler allowing any user defined security attribute with a parameterless constructor and a named property argument as the first " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttributeAction,The length of the statement  "                // attribute argument to have the above mentioned behavior' even though the comment clearly mentions that this behavior was intended only for the HostProtectionAttribute. " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttributeAction,The length of the statement  "                // We currently allow this case only for the HostProtectionAttribute. In future if need arises' we can exactly match native compiler's behavior. " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttributeAction,The length of the statement  "                if ((object)firstArgType != null && firstArgType.Equals(compilation.GetWellKnownType(WellKnownType.System_Security_Permissions_SecurityAction))) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeSecurityAttributeAction,The length of the statement  "            diagnostics.Add(ErrorCode.ERR_SecurityAttributeMissingAction' nodeOpt != null ? nodeOpt.Name.Location : NoLocation.Singleton); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,ValidateSecurityAction,The length of the statement  "            Debug.Assert(targetSymbol.Kind == SymbolKind.Assembly || targetSymbol.Kind == SymbolKind.NamedType || targetSymbol.Kind == SymbolKind.Method); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,ValidateSecurityAction,The length of the statement  "                // Native compiler allows security action value 1 for security attributes on types/methods' even though there is no corresponding field in System.Security.Permissions.SecurityAction enum. " is 187.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,ValidateSecurityAction,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_SecurityAttributeInvalidAction' syntaxLocation' nodeOpt != null ? nodeOpt.GetErrorDisplayName() : ""' displayString); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodePermissionSetAttribute,The length of the statement  "                        Location argSyntaxLocation = nodeOpt != null ? nodeOpt.GetNamedArgumentSyntax(filePropName).Location : NoLocation.Singleton; " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodePermissionSetAttribute,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_PermissionSetAttributeInvalidFile' argSyntaxLocation' fileName ?? "<null>"' filePropName); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodePermissionSetAttribute,The length of the statement  "                        // Native compiler still emits the file content as named assignment to 'Hex' property' but this leads to a runtime exception. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeClassInterfaceAttribute,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_InvalidAttributeArgument' attributeArgumentSyntaxLocation' nodeOpt != null ? nodeOpt.GetErrorDisplayName() : ""); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,DecodeGuidAttribute,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_InvalidAttributeArgument' attributeArgumentSyntaxLocation' nodeOpt != null ? nodeOpt.GetErrorDisplayName() : ""); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpCustomModifier,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\CustomModifierAdapter.cs,GetModifier,The length of the statement  "            return ((PEModuleBuilder)context.Module).Translate(this.Modifier' (CSharpSyntaxNode)context.SyntaxNodeOpt' context.Diagnostics); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,EventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\EventSymbolAdapter.cs,GetType,The length of the statement  "            return ((PEModuleBuilder)context.Module).Translate(this.Type' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,EventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\EventSymbolAdapter.cs,AsMember,The length of the statement  "            return (newOwner == this.ContainingSymbol) ? this : new SubstitutedEventSymbol(newOwner as SubstitutedNamedTypeSymbol' this); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,EventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\EventSymbolAdapter.cs,Equals,The length of the statement  "            return this.ContainingType == other.ContainingType && ReferenceEquals(this.OriginalDefinition' other.OriginalDefinition); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,FieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\FieldSymbolAdapter.cs,AsMember,The length of the statement  "            return (newOwner == this.ContainingSymbol) ? this : new SubstitutedFieldSymbol(newOwner as SubstitutedNamedTypeSymbol' this); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\MethodSymbolAdapter.cs,GetReturnValueCustomAttributesToEmit,The length of the statement  "            return GetCustomAttributesToEmit(userDefined' synthesized' isReturnType: true' emittingAssemblyAttributesInNetModule: false); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\MethodSymbolAdapter.cs,ReduceExtensionMethod,The length of the statement  "            return (this.IsExtensionMethod && this.MethodKind != MethodKind.ReducedExtension) ? ReducedExtensionMethodSymbol.Create(this) : null; " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\MethodSymbolAdapter.cs,AsMember,The length of the statement  "            return (newOwner == this.ContainingSymbol) ? this : new SubstitutedMethodSymbol((SubstitutedNamedTypeSymbol)newOwner' this); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\MethodSymbolAdapter.cs,CalculateUseSiteDiagnostic,The length of the statement  "                    GetUnificationUseSiteDiagnosticRecursive(ref result' this.ReturnTypeCustomModifiers' this' ref unificationCheckedTypes) || " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\MethodSymbolAdapter.cs,GetTypeInferredDuringReduction,The length of the statement  "            return this.GetTypeInferredDuringReduction(reducedFromTypeParameter.EnsureCSharpSymbolOrNull<ITypeParameterSymbol' TypeParameterSymbol>("reducedFromTypeParameter")); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\NamedTypeSymbolAdapter.cs,GetExplicitImplementationOverrides,The length of the statement  "                            yield return new Microsoft.Cci.MethodImplementation(method' moduleBeingBuilt.TranslateOverriddenMethodReference(implemented' (CSharpSyntaxNode)context.SyntaxNodeOpt' context.Diagnostics)); " is 188.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\NamedTypeSymbolAdapter.cs,GetExplicitImplementationOverrides,The length of the statement  "                        yield return new Microsoft.Cci.MethodImplementation(method' moduleBeingBuilt.TranslateOverriddenMethodReference(method.OverriddenMethod' (CSharpSyntaxNode)context.SyntaxNodeOpt' context.Diagnostics)); " is 200.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\NamedTypeSymbolAdapter.cs,GetExplicitImplementationOverrides,The length of the statement  "                                yield return new Microsoft.Cci.MethodImplementation(method' moduleBeingBuilt.TranslateOverriddenMethodReference(objectMethod' (CSharpSyntaxNode)context.SyntaxNodeOpt' context.Diagnostics)); " is 189.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\NamedTypeSymbolAdapter.cs,GetExplicitImplementationOverrides,The length of the statement  "                            yield return new Microsoft.Cci.MethodImplementation(method' moduleBeingBuilt.TranslateOverriddenMethodReference(implemented' (CSharpSyntaxNode)context.SyntaxNodeOpt' context.Diagnostics)); " is 188.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\NamedTypeSymbolAdapter.cs,GetGenericArguments,The length of the statement  "                builder.Add(moduleBeingBuilt.Translate(type' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\NamedTypeSymbolAdapter.cs,EqualsComplicatedCases,The length of the statement  "            if ((object)this.ContainingType != null && !this.ContainingType.Equals(other.ContainingType' ignoreCustomModifiers' ignoreDynamic)) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\NamedTypeSymbolAdapter.cs,EqualsComplicatedCases,The length of the statement  "                if (!this.TypeArgumentsNoUseSiteDiagnostics[i].Equals(other.TypeArgumentsNoUseSiteDiagnostics[i]' ignoreCustomModifiers' ignoreDynamic)) return false; " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\NamedTypeSymbolAdapter.cs,GetUnificationUseSiteDiagnosticRecursive,The length of the statement  "            return GetUnificationUseSiteDiagnosticRecursive(ref result' this.InterfacesNoUseSiteDiagnostics()' owner' ref checkedTypes) || " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,PointerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PointerTypeSymbolAdapter.cs,GetTargetType,The length of the statement  "            var type = ((PEModuleBuilder)context.Module).Translate(this.PointedAtType' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,PropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PropertySymbolAdapter.cs,AsMember,The length of the statement  "            return (newOwner == this.ContainingSymbol) ? this : new SubstitutedPropertySymbol(newOwner as SubstitutedNamedTypeSymbol' this); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,PropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PropertySymbolAdapter.cs,Equals,The length of the statement  "            return this.ContainingType == other.ContainingType && ReferenceEquals(this.OriginalDefinition' other.OriginalDefinition); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\TypeParameterSymbolAdapter.cs,Equals,The length of the statement  "            return other.ContainingSymbol.ContainingType.Equals(this.ContainingSymbol.ContainingType' ignoreCustomModifiers' ignoreDynamic); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedMethodBaseSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\SynthesizedMethodBaseSymbol.cs,MakeParameters,The length of the statement  "                builder.Add(new SynthesizedParameterSymbol(this' this.TypeMap.SubstituteType(p.OriginalDefinition.Type)' ordinal++' p.RefKind' p.Name)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AbstractTypeMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AbstractTypeMap.cs,SubstituteNamedType,The length of the statement  "                return (oldFieldTypes == newFieldTypes) ? previous : AnonymousTypeManager.ConstructAnonymousTypeSymbol(previous' newFieldTypes); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AbstractTypeMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AbstractTypeMap.cs,SubstituteArrayType,The length of the statement  "                interfaces = ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)SubstituteType(interfaces[0])' (NamedTypeSymbol)SubstituteType(interfaces[1])); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AliasSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AliasSymbol.cs,CreateGlobalNamespaceAlias,The length of the statement  "            SyntaxToken aliasName = SyntaxFactory.Identifier(SyntaxFactory.TriviaList()' SyntaxKind.GlobalKeyword' "global"' "global"' SyntaxFactory.TriviaList()); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AliasSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AliasSymbol.cs,ResolveAliasTarget,The length of the statement  "            var declarationBinder = binder.WithAdditionalFlags(BinderFlags.SuppressConstraintChecks | BinderFlags.SuppressObsoleteChecks); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeDescriptor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\AnonymousTypeDescriptor.cs,Equals,The length of the statement  "            return obj is AnonymousTypeDescriptor && this.Equals((AnonymousTypeDescriptor)obj' ignoreCustomModifiers: false' ignoreDynamic: false); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\SynthesizedSymbols\AnonymousType.FieldSymbol.cs,AddSynthesizedAttributes,The length of the statement  "                        new TypedConstant(manager.System_Diagnostics_DebuggerBrowsableState' TypedConstantKind.Enum' DebuggerBrowsableState.Never)))); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeTemplateSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\SynthesizedSymbols\AnonymousType.TemplateSymbol.cs,AdjustLocation,The length of the statement  "                    if (currentSmallestLocation != null && this.Manager.Compilation.CompareSourceLocations(currentSmallestLocation' location) < 0) " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeTemplateSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\SynthesizedSymbols\AnonymousType.TemplateSymbol.cs,AdjustLocation,The length of the statement  "                    if (ReferenceEquals(Interlocked.CompareExchange(ref _smallestLocation' location' currentSmallestLocation)' currentSmallestLocation)) " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,LookupTopLevelMetadataType,The length of the statement  "            return LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName' visitedAssemblies: null' digThroughForwardedTypes: digThroughForwardedTypes); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,CreateCycleInTypeForwarderErrorTypeSymbol,The length of the statement  "            DiagnosticInfo diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_CycleInTypeForwarder' emittedName.FullName' this.Name); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,GetTypeByMetadataName,The length of the statement  "                    type = GetTopLevelTypeByMetadataName(ref mdName' assemblyOpt: null' includeReferences: includeReferences' isWellKnownType: isWellKnownType' warnings: warnings); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,GetTypeByMetadataName,The length of the statement  "                type = GetTopLevelTypeByMetadataName(ref mdName' assemblyOpt: null' includeReferences: includeReferences' isWellKnownType: isWellKnownType' warnings: warnings); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,GetTypeByReflectionType,The length of the statement  "                NamedTypeSymbol symbol = GetTopLevelTypeByMetadataName(ref mdName' assemblyId' includeReferences' isWellKnownType: false); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,GetTopLevelTypeByMetadataName,The length of the statement  "                Debug.Assert(!(this is SourceAssemblySymbol && reference.IsMissing)); // Non-source assemblies can have missing references " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,PerformIVTCheck,The length of the statement  "            // 3    YES YES NO  NO  NO MATCH         Smith has named a strong-named Jones as a friend' but this Jones is weak-named. " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,PerformIVTCheck,The length of the statement  "            // 4    YES NO  YES NO  SUCCESS          Smith has improperly (*) named any Jones as its friend. But we honor its offer of friendship. " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,PerformIVTCheck,The length of the statement  "            // 5    YES NO  NO  NO  SUCCESS          Smith has improperly (*) named any Jones as its friend. But we honor its offer of friendship. " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,PerformIVTCheck,The length of the statement  "            // 6    NO  YES YES YES SUCCESS' BAD REF Smith has named this strong-named Jones as a friend' but Jones should not be referring to a weak-named Smith. " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,PerformIVTCheck,The length of the statement  "            // 8    NO  YES NO  NO  NO MATCH         Smith has named a strong-named Jones as a friend' but this Jones is weak-named. " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,AssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AssemblySymbol.cs,PerformIVTCheck,The length of the statement  "            // 9    NO  NO  YES NO  SUCCESS' BAD REF Smith has named any Jones as a friend' but Jones should not be referring to a weak-named Smith. " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\SourceAttributeData.cs,WithOmittedCondition,The length of the statement  "                return new SourceAttributeData(this.ApplicationSyntaxReference' this.AttributeClass' this.AttributeConstructor' this.CommonConstructorArguments' " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,ResolveBounds,The length of the statement  "            var bounds = typeParameter.ResolveBounds(corLibrary' inProgress' constraintTypes' inherited' currentCompilation' diagnosticsBuilder' ref useSiteDiagnosticsBuilder); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,ResolveBounds,The length of the statement  "            NamedTypeSymbol effectiveBaseClass = corLibrary.GetSpecialType(typeParameter.HasValueTypeConstraint ? SpecialType.System_ValueType : SpecialType.System_Object); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,ResolveBounds,The length of the statement  "                                        diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(constraintTypeParameter' new CSDiagnosticInfo(ErrorCode.ERR_CircularConstraint' constraintTypeParameter' typeParameter))); " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,ResolveBounds,The length of the statement  "                                if (constraintTypeParameter.HasValueTypeConstraint && !inherited && currentCompilation != null && constraintTypeParameter.IsFromCompilation(currentCompilation)) " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,ResolveBounds,The length of the statement  "                                    diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter' new CSDiagnosticInfo(ErrorCode.ERR_ConWithValCon' typeParameter' constraintTypeParameter))); " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,ResolveBounds,The length of the statement  "                                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter' new CSDiagnosticInfo(ErrorCode.ERR_BaseConstraintConflict' typeParameter' constraintDeducedBase' deducedBaseType))); " is 186.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,ResolveBounds,The length of the statement  "            Debug.Assert((effectiveBaseClass.SpecialType == SpecialType.System_Object) || (deducedBaseType.SpecialType != SpecialType.System_Object)); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckOverrideConstraints,The length of the statement  "                diagnosticsBuilder.Add(GenerateConflictingConstraintsError(typeParameter' deducedBase' classConflict: deducedBase.IsValueType)); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckOverrideConstraints,The length of the statement  "            else if (deducedBase.IsNullableType() && (typeParameter.HasValueTypeConstraint || typeParameter.HasReferenceTypeConstraint)) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckOverrideConstraints,The length of the statement  "                diagnosticsBuilder.Add(GenerateConflictingConstraintsError(typeParameter' deducedBase' classConflict: typeParameter.HasReferenceTypeConstraint)); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckAllConstraints,The length of the statement  "            type.VisitType(s_checkConstraintsSingleTypeFunc' new CheckConstraintsArgs(type.DeclaringCompilation' conversions' location' diagnostics)); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "            var result = CheckTypeConstraints(type' conversions' currentCompilation' diagnosticsBuilder' ref useSiteDiagnosticsBuilder); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "            var result = CheckTypeConstraints(type' conversions' currentCompilation' diagnosticsBuilder' ref useSiteDiagnosticsBuilder); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,InterfacesAreDistinct,The length of the statement  "            return !type.InterfacesNoUseSiteDiagnostics(basesBeingResolved).HasDuplicates(TypeSymbol.EqualsIgnoringDynamicComparer); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "            var result = CheckMethodConstraints(method' conversions' currentCompilation' diagnosticsBuilder' ref useSiteDiagnosticsBuilder' skipParameters); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "            var result = CheckMethodConstraints(method' conversions' currentCompilation' diagnosticsBuilder' ref useSiteDiagnosticsBuilder); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "                if (!CheckConstraints(containingSymbol' conversions' substitution' typeParameter' typeArgument' currentCompilation' diagnosticsBuilder' ref useSiteDiagnosticsBuilder)) " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter' new CSDiagnosticInfo(ErrorCode.ERR_BadTypeArgument' typeArgument))); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter' new CSDiagnosticInfo(ErrorCode.ERR_RefConstraintNotSatisfied' containingSymbol.ConstructedFrom()' typeParameter' typeArgument))); " is 199.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "                // "The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'" " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter' new CSDiagnosticInfo(ErrorCode.ERR_ValConstraintNotSatisfied' containingSymbol.ConstructedFrom()' typeParameter' typeArgument))); " is 199.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "            substitution.SubstituteTypesDistinct(typeParameter.ConstraintTypesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)' constraintTypes); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "                    errorCode = constraintType.IsInterfaceType() ? ErrorCode.ERR_GenericConstraintNotSatisfiedNullableInterface : ErrorCode.ERR_GenericConstraintNotSatisfiedNullableEnum; " is 166.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter' new CSDiagnosticInfo(errorCode' containingSymbol.ConstructedFrom()' distinguisher.First' typeParameter' distinguisher.Second))); " is 198.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "                // "'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'" " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,CheckConstraints,The length of the statement  "                diagnosticsBuilder.Add(new TypeParameterDiagnosticInfo(typeParameter' new CSDiagnosticInfo(ErrorCode.ERR_NewConstraintNotSatisfied' containingSymbol.ConstructedFrom()' typeParameter' typeArgument))); " is 199.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,SatisfiesConstraintType,The length of the statement  "                conversions.HasBoxingConversion(typeArgument.IsNullableType() ? ((NamedTypeSymbol)typeArgument).ConstructedFrom : typeArgument' constraintType' ref useSiteDiagnostics)) " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,SatisfiesConstraintType,The length of the statement  "                foreach (var typeArgumentConstraint in typeParameter.ConstraintTypesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,IsReferenceType,The length of the statement  "            return typeParameter.HasReferenceTypeConstraint || TypeParameterSymbol.IsReferenceTypeFromConstraintTypes(constraintTypes); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,GenerateConflictingConstraintsError,The length of the statement  "            return new TypeParameterDiagnosticInfo(typeParameter' new CSDiagnosticInfo(ErrorCode.ERR_BaseConstraintConflict' typeParameter' deducedBase' classConflict ? "class" : "struct")); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,IsEncompassedBy,The length of the statement  "            return conversions.HasIdentityOrImplicitReferenceConversion(a' b' ref useSiteDiagnostics) || conversions.HasBoxingConversion(a' b' ref useSiteDiagnostics); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExtendedErrorTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ExtendedErrorTypeSymbol.cs,AsUnreported,The length of the statement  "                new ExtendedErrorTypeSymbol(_containingSymbol' _name' _arity' _errorInfo' true' VariableUsedBeforeDeclaration' _candidateSymbols' _resultKind); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExtendedErrorTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ExtendedErrorTypeSymbol.cs,UnwrapErrorCandidates,The length of the statement  "            return ((object)candidate != null && !candidate.CandidateSymbols.IsEmpty) ? candidate.CandidateSymbols : candidateSymbols; " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExtendedErrorTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ExtendedErrorTypeSymbol.cs,Equals,The length of the statement  "                ((object)this.ContainingType != null ? this.ContainingType.Equals(other.ContainingType' ignoreCustomModifiers' ignoreDynamic) : " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExtendedErrorTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ExtendedErrorTypeSymbol.cs,Equals,The length of the statement  "                 (object)this.ContainingSymbol == null ? (object)other.ContainingSymbol == null : this.ContainingSymbol.Equals(other.ContainingSymbol)) && " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,Equals,The length of the statement  "            if (member1.GetParameterCount() > 0 && !HaveSameParameterTypes(member1.GetParameters()' typeMap1' member2.GetParameters()' typeMap2' _considerRefOutDifference' _considerCustomModifiers)) " is 186.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,GetHashCode,The length of the statement  "                if (_considerReturnType && member.GetMemberArity() == 0 && !_considerCustomModifiers) // If it is generic' then type argument might be in return type. " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,HaveSameReturnTypes,The length of the statement  "                returnType1.Equals(returnType2' ignoreDynamic: true) && returnTypeCustomModifiers1.SequenceEqual(returnTypeCustomModifiers2) : " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,HaveSameParameterTypes,The length of the statement  "                        (!param1.CustomModifiers.IsEmpty && param1.RefKind != RefKind.None && param2.RefKind != RefKind.None && param1.HasByRefBeforeCustomModifiers != param2.HasByRefBeforeCustomModifiers)) " is 182.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSymbolExtensions.cs,IsAccessibleViaInheritance,The length of the statement  "                current = (current.Kind == SymbolKind.TypeParameter) ? ((TypeParameterSymbol)current).EffectiveBaseClass(ref useSiteDiagnostics) : current.BaseTypeWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics)) " is 204.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSymbolExtensions.cs,HasInvalidTypeParameter,The length of the statement  "                for (; ((object)containingSymbol != null) && (containingSymbol.Kind != SymbolKind.Namespace); containingSymbol = containingSymbol.ContainingSymbol) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MetadataOrSourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MetadataOrSourceAssemblySymbol.cs,GetDeclaredSpecialType,The length of the statement  "                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName()' useCLSCompliantNameArityEncoding: true); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MetadataOrSourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MetadataOrSourceAssemblySymbol.cs,GetDeclaredSpecialTypeMember,The length of the statement  "            if (_lazySpecialTypeMembers == null || ReferenceEquals(_lazySpecialTypeMembers[(int)member]' ErrorTypeSymbol.UnknownResultType)) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MetadataOrSourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MetadataOrSourceAssemblySymbol.cs,GetDeclaredSpecialTypeMember,The length of the statement  "                    result = CSharpCompilation.GetRuntimeMember(type' ref descriptor' CSharpCompilation.SpecialMembersSignatureComparer.Instance' accessWithinOpt: null); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MethodSymbolExtensions.cs,InferExtensionMethodTypeArguments,The length of the statement  "            var otherArgumentType = new ExtendedErrorTypeSymbol(errorNamespace' name: string.Empty' arity: 0' errorInfo: null' unreported: false); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MethodSymbolExtensions.cs,InferExtensionMethodTypeArguments,The length of the statement  "            var otherArgumentValue = new BoundLiteral(syntax' ConstantValue.Bad' otherArgumentType) { WasCompilerGenerated = true }; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MethodSymbolExtensions.cs,InferExtensionMethodTypeArguments,The length of the statement  "            var success = method.CheckConstraints(conversions' substitution' method.TypeParameters' typeArgs' compilation' diagnosticsBuilder' ref useSiteDiagnosticsBuilder); " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MethodSymbolExtensions.cs,IsRuntimeFinalizer,The length of the statement  "                method.ParameterCount != 0 || method.Arity != 0 || !method.IsMetadataVirtual(ignoreInterfaceImplementationChanges: true)) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MethodSymbolExtensions.cs,IsGenericTaskReturningAsync,The length of the statement  "                && ((NamedTypeSymbol)method.ReturnType).ConstructedFrom == compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MissingCorLibrarySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MissingCorLibrarySymbol.cs,GetDeclaredSpecialType,The length of the statement  "                MetadataTypeName emittedFullName = MetadataTypeName.FromFullName(SpecialTypes.GetMetadataName(type)' useCLSCompliantNameArityEncoding: true); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,MissingModuleSymbolWithName,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MissingModuleSymbol.cs,Equals,The length of the statement  "            return (object)other != null && assembly.Equals(other.assembly) && string.Equals(_name' other._name' StringComparison.OrdinalIgnoreCase); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NamespaceOrTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\NamespaceOrTypeSymbol.cs,LookupMetadataType,The length of the statement  "            Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NamespaceOrTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\NamespaceOrTypeSymbol.cs,LookupMetadataType,The length of the statement  "                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName' emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NonMissingModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\NonMissingModuleSymbol.cs,GetUnificationUseSiteDiagnostic,The length of the statement  "                    ErrorCode warning = (definitionId.Version.Major == referenceId.Version.Major && definitionId.Version.Minor == referenceId.Version.Minor) ? " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NonMissingModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\NonMissingModuleSymbol.cs,GetUnificationUseSiteDiagnostic,The length of the statement  "                    // warning: Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}'' you may need to supply runtime policy. " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,NonMissingModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\NonMissingModuleSymbol.cs,GetUnificationUseSiteDiagnostic,The length of the statement  "                    // error: Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}' " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ObsoleteAttributeHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ObsoleteAttributeHelpers.cs,CreateObsoleteDiagnostic,The length of the statement  "                return new CSDiagnosticInfo(isColInit ? ErrorCode.WRN_DeprecatedCollectionInitAdd : ErrorCode.WRN_DeprecatedSymbol' symbol); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakeOverriddenOrHiddenMembersWorker,The length of the statement  "            Debug.Assert(member.Kind == SymbolKind.Method || member.Kind == SymbolKind.Property || member.Kind == SymbolKind.Event); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakeOverriddenOrHiddenMembersWorker,The length of the statement  "            FindRelatedMembers(member.IsOverride' memberIsFromSomeCompilation' member.Kind' bestMatch' out overriddenMembers' out runtimeOverriddenMembers' ref hiddenBuilder); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakeOverriddenOrHiddenMembersWorker,The length of the statement  "            ImmutableArray<Symbol> hiddenMembers = hiddenBuilder == null ? ImmutableArray<Symbol>.Empty : hiddenBuilder.ToImmutableAndFree(); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakePropertyAccessorOverriddenOrHiddenMembers,The length of the statement  "                    MethodSymbol correspondingAccessor = accessorIsGetter ? propertyHiddenByProperty.GetMethod : propertyHiddenByProperty.SetMethod; " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakePropertyAccessorOverriddenOrHiddenMembers,The length of the statement  "            // There's a detailed comment in MakeOverriddenOrHiddenMembersWorker(Symbol) concerning why this predicate is appropriate. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakePropertyAccessorOverriddenOrHiddenMembers,The length of the statement  "                    accessor.IsOverride' accessorIsFromSomeCompilation' accessor.Kind' overriddenAccessor' out overriddenAccessors' out runtimeOverriddenAccessors' ref hiddenBuilder); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakePropertyAccessorOverriddenOrHiddenMembers,The length of the statement  "            ImmutableArray<Symbol> hiddenMembers = hiddenBuilder == null ? ImmutableArray<Symbol>.Empty : hiddenBuilder.ToImmutableAndFree(); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakeEventAccessorOverriddenOrHiddenMembers,The length of the statement  "            // There's a detailed comment in MakeOverriddenOrHiddenMembersWorker(Symbol) concerning why this predicate is appropriate. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakeEventAccessorOverriddenOrHiddenMembers,The length of the statement  "                    accessor.IsOverride' accessorIsFromSomeCompilation' accessor.Kind' overriddenAccessor' out overriddenAccessors' out runtimeOverriddenAccessors' ref hiddenBuilder); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakeEventAccessorOverriddenOrHiddenMembers,The length of the statement  "            ImmutableArray<Symbol> hiddenMembers = hiddenBuilder == null ? ImmutableArray<Symbol>.Empty : hiddenBuilder.ToImmutableAndFree(); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakeInterfaceOverriddenOrHiddenMembers,The length of the statement  "            PooledHashSet<NamedTypeSymbol> allMembersHidden = PooledHashSet<NamedTypeSymbol>.GetInstance(); // Implies membersOfOtherKindsHidden. " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakeInterfaceOverriddenOrHiddenMembers,The length of the statement  "                    FindRelatedMembers(member.IsOverride' memberIsFromSomeCompilation' member.Kind' hidden' out overriddenMembers' out runtimeOverriddenMembers' ref hiddenAndRelatedBuilder); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,MakeInterfaceOverriddenOrHiddenMembers,The length of the statement  "            ImmutableArray<Symbol> hiddenMembers = hiddenBuilder == null ? ImmutableArray<Symbol>.Empty : hiddenBuilder.ToImmutableAndFree(); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindOverriddenOrHiddenMembersInType,The length of the statement  "                            Debug.Assert(memberIsFromSomeCompilation || minCustomModifierCount == int.MaxValue' "Metadata members require exact custom modifier matches."); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindOverriddenOrHiddenMembersInType,The length of the statement  "            if (currTypeHasExactMatch && memberIsFromSomeCompilation && member.IsDefinition && TypeOrReturnTypeHasCustomModifiers(currTypeBestMatch)) " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindRelatedMembers,The length of the statement  "                        FindOtherOverriddenMethodsInContainingType(representativeMember' overridingMemberIsFromSomeCompilation' overriddenBuilder' runtimeOverriddenBuilder); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,CanOverrideOrHide,The length of the statement  "                    return MethodSymbol.CanOverrideOrHide(methodSymbol.MethodKind) && ReferenceEquals(methodSymbol' methodSymbol.ConstructedFrom); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,RequiresExplicitOverride,The length of the statement  "                // TODO: do we want to add more sophisticated handling for the case where there are multiple runtime-overridden methods? " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,RequiresExplicitOverride,The length of the statement  "                MethodSymbol runtimeOverriddenMethod = method.GetFirstRuntimeOverriddenMethodIgnoringNewSlot(ignoreInterfaceImplementationChanges: true); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,GetFirstRuntimeOverriddenMethodIgnoringNewSlot,The length of the statement  "            for (NamedTypeSymbol currType = containingType.BaseTypeNoUseSiteDiagnostics; !ReferenceEquals(currType' null); currType = currType.BaseTypeNoUseSiteDiagnostics) " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,IsOverriddenSymbolAccessible,The length of the statement  "            return AccessCheck.IsSymbolAccessible(overridden.OriginalDefinition' overridingContainingType.OriginalDefinition' ref useSiteDiagnostics); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ReducedExtensionMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ReducedExtensionMethodSymbol.cs,Create,The length of the statement  "            var conversion = conversions.ConvertExtensionMethodThisArg(method.Parameters[0].Type' receiverType' ref useSiteDiagnostics); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ConstantEvaluationHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ConstantEvaluationHelpers.cs,OrderAllDependencies,The length of the statement  "            var graph = PooledDictionary<SourceFieldSymbolWithSyntaxReference' Node<SourceFieldSymbolWithSyntaxReference>>.GetInstance(); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CustomModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\CustomModifierUtils.cs,CopyMethodCustomModifiers,The length of the statement  "            parameters = CopyParameterCustomModifiers(constructedSourceMethod.Parameters' destinationMethod.Parameters' alsoCopyParamsModifier); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CustomModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\CustomModifierUtils.cs,CopyMethodCustomModifiers,The length of the statement  "                returnType = CopyTypeCustomModifiers(returnTypeWithCustomModifiers' returnType' RefKind.None' destinationMethod.ContainingAssembly); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CustomModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\CustomModifierUtils.cs,CopyTypeCustomModifiers,The length of the statement  "            ImmutableArray<bool> flags = CSharpCompilation.DynamicTransformsEncoder.Encode(destinationType' customModifierCount' refKind); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CustomModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\CustomModifierUtils.cs,CopyTypeCustomModifiers,The length of the statement  "            TypeSymbol resultType = DynamicTypeDecoder.TransformTypeWithoutCustomModifierFlags(sourceType' containingAssembly' refKind' flags); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CustomModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\CustomModifierUtils.cs,CopyTypeCustomModifiers,The length of the statement  "            Debug.Assert(resultType.Equals(sourceType' ignoreCustomModifiers: false' ignoreDynamic: true)); // Same custom modifiers as source type. " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CustomModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\CustomModifierUtils.cs,CopyTypeCustomModifiers,The length of the statement  "            Debug.Assert(resultType.Equals(destinationType' ignoreCustomModifiers: true' ignoreDynamic: false)); // Same object/dynamic as destination type. " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CustomModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\CustomModifierUtils.cs,CopyParameterCustomModifiers,The length of the statement  "                    destinationParameter.CustomModifiers.Any() || destinationParameter.Type.HasCustomModifiers() || // Could happen if the associated property has custom modifiers. " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,CustomModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\CustomModifierUtils.cs,CopyParameterCustomModifiers,The length of the statement  "                    builder.Add(destinationParameter.WithCustomModifiersAndParams(sourceParameter.Type' sourceParameter.CustomModifiers' sourceParameter.HasByRefBeforeCustomModifiers' newParams)); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,GetMemberName,The length of the statement  "            string methodName = GetMemberNameAndInterfaceSymbol(binder' explicitInterfaceSpecifierOpt' name' discardedDiagnostics' out discardedExplicitInterfaceType' out discardedAliasOpt); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,GetMemberName,The length of the statement  "            string interfaceName = explicitInterfaceTypeOpt.ToDisplayString(SymbolDisplayFormat.ExplicitInterfaceImplementationFormat); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,SubstituteExplicitInterfaceImplementations,The length of the statement  "                Debug.Assert((object)substitutedMemberImplemented != null); //if it was an explicit implementation before the substitution' it should still be after " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedMethod,The length of the statement  "            return (MethodSymbol)FindExplicitlyImplementedMember(implementingMethod' explicitInterfaceType' interfaceMethodName' explicitInterfaceSpecifierSyntax' diagnostics); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedProperty,The length of the statement  "            return (PropertySymbol)FindExplicitlyImplementedMember(implementingProperty' explicitInterfaceType' interfacePropertyName' explicitInterfaceSpecifierSyntax' diagnostics); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitlyImplementedEvent,The length of the statement  "            return (EventSymbol)FindExplicitlyImplementedMember(implementingEvent' explicitInterfaceType' interfaceEventName' explicitInterfaceSpecifierSyntax' diagnostics); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitImplementationCollisions,The length of the statement  "            bool explicitInterfaceTypeIsDefinition = explicitInterfaceType.IsDefinition; //no runtime ref/out ambiguities if this is true " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitImplementationCollisions,The length of the statement  "                    if (!explicitInterfaceTypeIsDefinition && MemberSignatureComparer.RuntimeSignatureComparer.Equals(implementedMember' collisionCandidateMember)) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitInterfaceHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ExplicitInterfaceHelpers.cs,FindExplicitImplementationCollisions,The length of the statement  "                            diagnostics.Add(ErrorCode.ERR_ExplicitImplCollisionOnRefOut' explicitInterfaceType.Locations[0]' explicitInterfaceType' implementedMember); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ModifierUtils.cs,CheckModifiers,The length of the statement  "            bool isMethod = (allowedModifiers & (DeclarationModifiers.Partial | DeclarationModifiers.Virtual)) == (DeclarationModifiers.Partial | DeclarationModifiers.Virtual); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ModifierUtils.cs,CheckModifiers,The length of the statement  "            if (isMethod && ((result & (DeclarationModifiers.Partial | DeclarationModifiers.Private)) == (DeclarationModifiers.Partial | DeclarationModifiers.Private))) " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ModifierUtils.cs,ToDeclarationModifiers,The length of the statement  "            if ((result & DeclarationModifiers.AccessibilityMask) == (DeclarationModifiers.Protected | DeclarationModifiers.Internal)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,MakeParameters,The length of the statement  "                var refKind = GetModifiers(parameterSyntax.Modifiers' out outKeyword' out refKeyword' out paramsKeyword' out thisKeyword); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportParameterErrors,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_IllegalParams' parameterSyntax.Modifiers.First(t => t.Kind() == SyntaxKind.ParamsKeyword).GetLocation()); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportParameterErrors,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_ParamsMustBeArray' parameterSyntax.Modifiers.First(t => t.Kind() == SyntaxKind.ParamsKeyword).GetLocation()); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The length of the statement  "            Conversion conversion = binder.Conversions.ClassifyImplicitConversionFromExpression(defaultExpression' parameterType' ref useSiteDiagnostics); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_DefaultValueMustBeConstant' parameterSyntax.Default.Value.Location' parameterSyntax.Identifier.ValueText); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The length of the statement  "                // error CS1750: A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}' " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The length of the statement  "                // error CS1763: '{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The length of the statement  "            else if (conversion.IsNullable && defaultExpression.Kind == BoundKind.DefaultOperator && !defaultExpression.Type.IsNullableType() && " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The length of the statement  "                !(parameterType.GetNullableUnderlyingType().IsEnumType() || parameterType.GetNullableUnderlyingType().IsIntrinsicType())) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The length of the statement  "                // A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ComputeStrongNameKeys,The length of the statement  "            return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider' keyFile' keyContainer' MessageProvider.Instance); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForSynthesizedAttributes,The length of the statement  "                TypeSymbol compilationRelaxationsAttribute = compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_CompilationRelaxationsAttribute); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForSynthesizedAttributes,The length of the statement  "                    // As in Dev10 (see GlobalAttrBind::EmitCompilerGeneratedAttrs)' we only synthesize this attribute if CompilationRelaxationsAttribute is found. " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForSynthesizedAttributes,The length of the statement  "                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32' diagnostics' NoLocation.Singleton); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForSynthesizedAttributes,The length of the statement  "                TypeSymbol runtimeCompatibilityAttribute = compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForSynthesizedAttributes,The length of the statement  "                    // As in Dev10 (see GlobalAttrBind::EmitCompilerGeneratedAttrs)' we only synthesize this attribute if RuntimeCompatibilityAttribute is found. " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForSynthesizedAttributes,The length of the statement  "                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor' diagnostics' NoLocation.Singleton); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForSynthesizedAttributes,The length of the statement  "                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows' diagnostics' NoLocation.Singleton); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForUnsafeSynthesizedAttributes,The length of the statement  "            TypeSymbol unverifiableCodeAttribute = compilation.GetWellKnownType(WellKnownType.System_Security_UnverifiableCodeAttribute); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForUnsafeSynthesizedAttributes,The length of the statement  "            TypeSymbol securityPermissionAttribute = compilation.GetWellKnownType(WellKnownType.System_Security_Permissions_SecurityPermissionAttribute); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForUnsafeSynthesizedAttributes,The length of the statement  "                WellKnownMember.System_Security_Permissions_SecurityPermissionAttribute__SkipVerification' diagnostics' NoLocation.Singleton); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                diagnostics.Add(ErrorCode.WRN_CmdOptionConflictsSource' NoLocation.Singleton' "DelaySign"' AttributeDescription.AssemblyDelaySignAttribute.FullName); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                else if (String.Compare(_compilation.Options.CryptoKeyContainer' assemblyKeyContainerAttributeSetting' StringComparison.OrdinalIgnoreCase) != 0) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                    // but it doesn't drop the attribute during emit. That might be fine if we produce an assembly because we actually sign it with correct " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                    // If we are building a .NET module' things get more complicated. In particular' we don't sign the module' we emit an attribute with the key  " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                    // information' which will be used to sign an assembly once the module is linked into it. If there is already an attribute like that in source' " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                    // native compiler emits both of them' synthetic attribute is emitted after the one from source. Incidentally' ALink picks the last attribute " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                    // for signing and things seem to work out. However' relying on the order of attributes feels fragile' especially given that Roslyn emits " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                    // synthetic attributes before attributes from source. The behavior we settled on for .NET modules is that' if the attribute in source has the " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                    // same value as the one in compilation options' we won't emit the senthetic attribute. If the value doesn't match' we report an error' which  " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                    // is a breaking change. Bottom line' we will never produce a module or an assembly with two attributes' regardless whether values are the same " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_CmdOptionConflictsSource' NoLocation.Singleton' AttributeDescription.AssemblyKeyNameAttribute.FullName' "CryptoKeyContainer"); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                        diagnostics.Add(ErrorCode.WRN_CmdOptionConflictsSource' NoLocation.Singleton' "CryptoKeyContainer"' AttributeDescription.AssemblyKeyNameAttribute.FullName); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                else if (String.Compare(_compilation.Options.CryptoKeyFile' assemblyKeyFileAttributeSetting' StringComparison.OrdinalIgnoreCase) != 0) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_CmdOptionConflictsSource' NoLocation.Singleton' AttributeDescription.AssemblyKeyFileAttribute.FullName' "CryptoKeyFile"); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DetectAttributeAndOptionConflicts,The length of the statement  "                        diagnostics.Add(ErrorCode.WRN_CmdOptionConflictsSource' NoLocation.Singleton' "CryptoKeyFile"' AttributeDescription.AssemblyKeyFileAttribute.FullName); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportDiagnosticsForAddedModules,The length of the statement  "                bool isPlatformAgnostic = (assemblyMachine == System.Reflection.PortableExecutable.Machine.I386 && !this.Bit32Required); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportNameCollisionDiagnosticsForAddedModules,The length of the statement  "            if (constituent.Length > 2 || (constituent.Length == 2 && constituent[0].ContainingModule.Ordinal != 0 && constituent[1].ContainingModule.Ordinal != 0)) " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ValidateAttributeUsageForNetModuleAttribute,The length of the statement  "                // Duplicate attributes are allowed' but native compiler doesn't emit duplicate attributes' i.e. attributes with same constructor and arguments. " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ValidateAttributeUsageForNetModuleAttribute,The length of the statement  "                    // For (a)' native compiler picks the last of these duplicate well-known netmodule attributes' but these can vary based on the ordering of referenced netmodules. " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ValidateAttributeUsageForNetModuleAttribute,The length of the statement  "                            diagnostics.Add(ErrorCode.WRN_AssemblyAttributeFromModuleIsOverridden' NoLocation.Singleton' attribute.AttributeClass' netModuleName); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ValidateAttributeUsageForNetModuleAttribute,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_DuplicateAttributeInNetModule' NoLocation.Singleton' attribute.AttributeClass.Name' netModuleName); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ValidateAttributeUsageForNetModuleAttribute,The length of the statement  "            //    diagnostics.Add(ErrorCode.ERR_AttributeOnBadSymbolTypeInNetModule' NoLocation.Singleton' attribute.AttributeClass.Name' netModuleName' attributeUsageInfo.GetValidTargetsString()); " is 185.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ValidateAttributeUsageAndDecodeWellKnownAttributes,The length of the statement  "                if (!attribute.HasErrors && ValidateAttributeUsageForNetModuleAttribute(attribute' netModuleNames[i]' diagnostics' ref uniqueAttributes)) " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,LoadAndValidateNetModuleAttributes,The length of the statement  "                    wellKnownData = ValidateAttributeUsageAndDecodeWellKnownAttributes(attributesFromNetModules' netModuleNames' diagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,LoadAndValidateNetModuleAttributes,The length of the statement  "                    // Compute duplicate source assembly attributes' i.e. attributes with same constructor and arguments' that must not be emitted. " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,LoadAndValidateNetModuleAttributes,The length of the statement  "                // Similar to attributes' type forwarders from the second added module should override type forwarders from the first added module' etc.  " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,IsIndexOfOmittedAssemblyAttribute,The length of the statement  "            Debug.Assert(_lazyOmittedAttributeIndices == null || !_lazyOmittedAttributeIndices.Any(i => i < 0 || i >= this.GetAttributes().Length)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,GetSecurityAttributes,The length of the statement  "                if (!(_compilation.GetWellKnownType(WellKnownType.System_Security_UnverifiableCodeAttribute) is MissingMetadataTypeSymbol) && " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,GetSecurityAttributes,The length of the statement  "                    !(_compilation.GetWellKnownType(WellKnownType.System_Security_Permissions_SecurityPermissionAttribute) is MissingMetadataTypeSymbol)) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,GetSecurityAttributes,The length of the statement  "                        var fieldRequestMinimum = (FieldSymbol)_compilation.GetWellKnownTypeMember(WellKnownMember.System_Security_Permissions_SecurityAction__RequestMinimum); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,GetSecurityAttributes,The length of the statement  "                        object constantValue = (object)fieldRequestMinimum == null || fieldRequestMinimum.HasUseSiteError ? 0 : fieldRequestMinimum.ConstantValue; " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the statement  "            bool emitCompilationRelaxationsAttribute = !isBuildingNetModule && !this.Modules.Any(m => m.HasAssemblyCompilationRelaxationsAttribute); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the statement  "                if (!(_compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_CompilationRelaxationsAttribute) is MissingMetadataTypeSymbol)) " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the statement  "                    var typedConstantNoStringInterning = new TypedConstant(int32Type' TypedConstantKind.Primitive' Cci.Constants.CompilationRelaxations_NoStringInterning); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the statement  "            bool emitRuntimeCompatibilityAttribute = !isBuildingNetModule && !this.Modules.Any(m => m.HasAssemblyRuntimeCompatibilityAttribute); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the statement  "                if (!(_compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute) is MissingMetadataTypeSymbol)) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the statement  "            // CONSIDER: Native VB compiler and Roslyn VB compiler also have an additional requirement: There is no applied DebuggableAttribute *module* attribute in source. " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the statement  "                    var typedConstant = new TypedConstant(stringType' TypedConstantKind.Primitive' _compilation.Options.CryptoKeyContainer); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the statement  "                    AddSynthesizedAttribute(ref attributes' _compilation.TrySynthesizeAttribute(WellKnownMember.System_Reflection_AssemblyKeyNameAttribute__ctor' ImmutableArray.Create(typedConstant))); " is 181.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AddSynthesizedAttributes,The length of the statement  "                    AddSynthesizedAttribute(ref attributes' _compilation.TrySynthesizeAttribute(WellKnownMember.System_Reflection_AssemblyKeyFileAttribute__ctor' ImmutableArray.Create(typedConstant))); " is 181.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,AreInternalsVisibleToThisAssembly,The length of the statement  "                            Interlocked.CompareExchange(ref _optimisticallyGrantedInternalsAccess' new ConcurrentDictionary<AssemblySymbol' bool>()' null); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeTypeForwardedToAttribute,The length of the statement  "                arguments.Diagnostics.Add(ErrorCode.ERR_InvalidFwdType' GetAssemblyAttributeLocationForDiagnostic(arguments.AttributeSyntaxOpt)); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeTypeForwardedToAttribute,The length of the statement  "                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic' arguments.Diagnostics' GetAssemblyAttributeLocationForDiagnostic(arguments.AttributeSyntaxOpt))) " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeTypeForwardedToAttribute,The length of the statement  "                arguments.Diagnostics.Add(ErrorCode.ERR_ForwardedTypeInThisAssembly' GetAssemblyAttributeLocationForDiagnostic(arguments.AttributeSyntaxOpt)' forwardedType); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeTypeForwardedToAttribute,The length of the statement  "                arguments.Diagnostics.Add(ErrorCode.ERR_ForwardedTypeIsNested' GetAssemblyAttributeLocationForDiagnostic(arguments.AttributeSyntaxOpt)' forwardedType' forwardedType.ContainingType); " is 181.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeTypeForwardedToAttribute,The length of the statement  "                arguments.Diagnostics.Add(ErrorCode.ERR_InvalidFwdType' GetAssemblyAttributeLocationForDiagnostic(arguments.AttributeSyntaxOpt)); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeTypeForwardedToAttribute,The length of the statement  "                arguments.Diagnostics.Add(ErrorCode.ERR_DuplicateTypeForwarder' GetAssemblyAttributeLocationForDiagnostic(arguments.AttributeSyntaxOpt)' forwardedType); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeOneInternalsVisibleToAttribute,The length of the statement  "                                            new ConcurrentDictionary<string' ConcurrentDictionary<ImmutableArray<byte>' Tuple<Location' String>>>(StringComparer.OrdinalIgnoreCase)' null); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                DecodeOneInternalsVisibleToAttribute(arguments.AttributeSyntaxOpt' attribute' arguments.Diagnostics' index' ref _lazyInternalsVisibleToMap); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                    arguments.Diagnostics.Add(ErrorCode.ERR_InvalidSignaturePublicKey' attribute.GetAttributeArgumentSyntaxLocation(0' arguments.AttributeSyntaxOpt)); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<CommonAssemblyWellKnownAttributeData>().AssemblyKeyFileAttributeSetting = (string)attribute.CommonConstructorArguments[0].Value; " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<CommonAssemblyWellKnownAttributeData>().AssemblyKeyContainerAttributeSetting = (string)attribute.CommonConstructorArguments[0].Value; " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<CommonAssemblyWellKnownAttributeData>().AssemblyDelaySignAttributeSetting = (bool)attribute.CommonConstructorArguments[0].Value ? ThreeState.True : ThreeState.False; " is 191.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                    Location attributeArgumentSyntaxLocation = attribute.GetAttributeArgumentSyntaxLocation(0' arguments.AttributeSyntaxOpt); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                    Location attributeArgumentSyntaxLocation = attribute.GetAttributeArgumentSyntaxLocation(0' arguments.AttributeSyntaxOpt); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<CommonAssemblyWellKnownAttributeData>().AssemblyTitleAttributeSetting = (string)attribute.CommonConstructorArguments[0].Value; " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<CommonAssemblyWellKnownAttributeData>().AssemblyDescriptionAttributeSetting = (string)attribute.CommonConstructorArguments[0].Value; " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                        arguments.Diagnostics.Add(ErrorCode.ERR_InvalidAssemblyCultureForExe' attribute.GetAttributeArgumentSyntaxLocation(0' arguments.AttributeSyntaxOpt)); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                        arguments.Diagnostics.Add(ErrorCode.ERR_InvalidAssemblyCulture' attribute.GetAttributeArgumentSyntaxLocation(0' arguments.AttributeSyntaxOpt)); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<CommonAssemblyWellKnownAttributeData>().AssemblyCompanyAttributeSetting = (string)attribute.CommonConstructorArguments[0].Value; " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<CommonAssemblyWellKnownAttributeData>().AssemblyProductAttributeSetting = (string)attribute.CommonConstructorArguments[0].Value; " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<CommonAssemblyWellKnownAttributeData>().AssemblyInformationalVersionAttributeSetting = (string)attribute.CommonConstructorArguments[0].Value; " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                    Location attributeArgumentSyntaxLocation = attribute.GetAttributeArgumentSyntaxLocation(0' arguments.AttributeSyntaxOpt); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<CommonAssemblyWellKnownAttributeData>().AssemblyCopyrightAttributeSetting = (string)attribute.CommonConstructorArguments[0].Value; " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<CommonAssemblyWellKnownAttributeData>().AssemblyTrademarkAttributeSetting = (string)attribute.CommonConstructorArguments[0].Value; " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "            else if ((signature = attribute.GetTargetAttributeSignatureIndex(this' AttributeDescription.AssemblyFlagsAttribute)) != -1) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<CommonAssemblyWellKnownAttributeData>().RuntimeCompatibilityWrapNonExceptionThrows = wrapNonExceptionThrows; " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The length of the statement  "            else if ((signature = attribute.GetTargetAttributeSignatureIndex(this' AttributeDescription.AssemblyAlgorithmIdAttribute)) != -1) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ValidateIntegralAttributeNonNegativeArguments,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_InvalidAttributeArgument' attributeArgumentSyntaxLocation' (object)nodeOpt != null ? nodeOpt.GetErrorDisplayName() : ""); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,NoteFieldDefinition,The length of the statement  "            Debug.Assert(_unusedFieldWarnings.IsDefault' "We shouldn't have computed the diagnostics if we're still noting definitions."); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,TryLookupForwardedMetadataTypeWithCycleDetection,The length of the statement  "                CommonAssemblyWellKnownAttributeData<NamedTypeSymbol> wellKnownAttributeData = GetSourceDecodedWellKnownAttributeData(); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,TryLookupForwardedMetadataTypeWithCycleDetection,The length of the statement  "                        string fullEmittedName = MetadataHelpers.BuildQualifiedName(originalDefinition.ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat)' " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,TryLookupForwardedMetadataTypeWithCycleDetection,The length of the statement  "                // Similar to attributes' type forwarders from the second added module should override type forwarders from the first added module' etc.  " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,TryLookupForwardedMetadataTypeWithCycleDetection,The length of the statement  "                            return forwardedToAssembly.LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName' visitedAssemblies' digThroughForwardedTypes: true); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceClonedParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceClonedParameterSymbol.cs,WithCustomModifiersAndParams,The length of the statement  "                _originalParam.WithCustomModifiersAndParamsCore(newType' newCustomModifiers' hasByRefBeforeCustomModifiers' newIsParams)' " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,MakeDefaultExpression,The length of the statement  "            var convertedExpression = binder.CreateBinderForParameterDefaultValue(this' defaultSyntax).BindParameterDefaultValue(defaultSyntax' parameterType' diagnostics' out valueBeforeConversion); " is 187.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,MakeDefaultExpression,The length of the statement  "            bool hasErrors = ParameterHelpers.ReportDefaultParameterErrors(binder' ContainingSymbol' parameterSyntax' this' valueBeforeConversion' diagnostics); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "            if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.DefaultParameterValueAttribute)) " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "                return EarlyDecodeAttributeForDefaultParameterValue(AttributeDescription.DefaultParameterValueAttribute' ref arguments); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "            else if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.DecimalConstantAttribute)) " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "            else if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.DateTimeConstantAttribute)) " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "                if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.CallerLineNumberAttribute)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "                else if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.CallerFilePathAttribute)) " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "                else if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.CallerMemberNameAttribute)) " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,EarlyDecodeAttributeForDefaultParameterValue,The length of the statement  "            var attribute = arguments.Binder.GetAttribute(arguments.AttributeSyntax' arguments.AttributeType' out hasAnyDiagnostics); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,EarlyDecodeAttributeForDefaultParameterValue,The length of the statement  "                value = DecodeDefaultParameterValueAttribute(description' attribute' arguments.AttributeSyntax' diagnose: false' diagnosticsOpt: null); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                    // error CS1745: Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                MarshalAsAttributeDecoder<CommonParameterWellKnownAttributeData' AttributeSyntax' CSharpAttributeData' AttributeLocation>.Decode(ref arguments' AttributeTargets.Parameter' MessageProvider.Instance); " is 198.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,DecodeDefaultParameterValueAttribute,The length of the statement  "            var value = DecodeDefaultParameterValueAttribute(description' attribute' syntax' diagnose: true' diagnosticsOpt: diagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,DecodeDefaultParameterValueAttribute,The length of the statement  "                // error CS1745: Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,DecodeDefaultParameterValueAttribute,The length of the statement  "            else if (!compilation.Conversions.ClassifyConversion((TypeSymbol)arg.Type' this.Type' ref useSiteDiagnostics).Kind.IsImplicitConversion()) " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,IsValidCallerInfoContext,The length of the statement  "            return !ContainingSymbol.IsExplicitInterfaceImplementation() && !ContainingSymbol.IsOperator() && !IsOnPartialImplementation(node); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerLineNumberAttribute,The length of the statement  "                diagnostics.Add(ErrorCode.WRN_CallerLineNumberParamForUnconsumedLocation' node.Name.Location' CSharpSyntaxNode.Identifier.ValueText); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerLineNumberAttribute,The length of the statement  "                // CS4017: CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}' " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerLineNumberAttribute,The length of the statement  "            else if (!HasExplicitDefaultValue && !ContainingSymbol.IsPartialImplementation()) // attribute applied to parameter without default " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerFilePathAttribute,The length of the statement  "                diagnostics.Add(ErrorCode.WRN_CallerFilePathParamForUnconsumedLocation' node.Name.Location' CSharpSyntaxNode.Identifier.ValueText); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerFilePathAttribute,The length of the statement  "                // CS4018: CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}' " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerFilePathAttribute,The length of the statement  "            else if (!HasExplicitDefaultValue && !ContainingSymbol.IsPartialImplementation()) // attribute applied to parameter without default " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerFilePathAttribute,The length of the statement  "                // CS7082: The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute. " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerFilePathAttribute,The length of the statement  "                diagnostics.Add(ErrorCode.WRN_CallerLineNumberPreferredOverCallerFilePath' node.Name.Location' CSharpSyntaxNode.Identifier.ValueText); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerMemberNameAttribute,The length of the statement  "                diagnostics.Add(ErrorCode.WRN_CallerMemberNameParamForUnconsumedLocation' node.Name.Location' CSharpSyntaxNode.Identifier.ValueText); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerMemberNameAttribute,The length of the statement  "                // CS4019: CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}' " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerMemberNameAttribute,The length of the statement  "            else if (!HasExplicitDefaultValue && !ContainingSymbol.IsPartialImplementation()) // attribute applied to parameter without default " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerMemberNameAttribute,The length of the statement  "                // CS7081: The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute. " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerMemberNameAttribute,The length of the statement  "                diagnostics.Add(ErrorCode.WRN_CallerLineNumberPreferredOverCallerMemberName' node.Name.Location' CSharpSyntaxNode.Identifier.ValueText); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerMemberNameAttribute,The length of the statement  "                // CS7080: The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute. " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,ValidateCallerMemberNameAttribute,The length of the statement  "                diagnostics.Add(ErrorCode.WRN_CallerFilePathPreferredOverCallerMemberName' node.Name.Location' CSharpSyntaxNode.Identifier.ValueText); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceComplexParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceComplexParameterSymbol.cs,PostDecodeWellKnownAttributes,The length of the statement  "                    // error CS0662: '...' cannot specify only Out attribute on a ref parameter. Use both In and Out attributes' or neither. " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceConstructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceConstructorSymbol.cs,CreateConstructorSymbol,The length of the statement  "            var methodKind = syntax.Modifiers.Any(SyntaxKind.StaticKeyword) ? MethodKind.StaticConstructor : MethodKind.Constructor; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceConstructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceConstructorSymbol.cs,MethodChecks,The length of the statement  "            _lazyParameters = ParameterHelpers.MakeParameters(bodyBinder' this' parameterList' true' out arglistToken' diagnostics); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceConstructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceConstructorSymbol.cs,MethodChecks,The length of the statement  "            if (_lazyIsVararg && (IsGenericMethod || ContainingType.IsGenericType || _lazyParameters.Length > 0 && _lazyParameters[_lazyParameters.Length - 1].IsParams)) " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceConstructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceConstructorSymbol.cs,MakeModifiers,The length of the statement  "            var defaultAccess = (methodKind == MethodKind.StaticConstructor) ? DeclarationModifiers.None : DeclarationModifiers.Private; " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceConstructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceConstructorSymbol.cs,MakeModifiers,The length of the statement  "            var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers' defaultAccess' allowedModifiers' location' diagnostics' out modifierErrors); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceConstructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceConstructorSymbol.cs,CalculateLocalSyntaxOffset,The length of the statement  "            if (containingType.TryCalculateSyntaxOffsetOfPositionInInitializer(position' tree' this.IsStatic' ctorInitializerLength' out syntaxOffset)) " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceCustomEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceCustomEventSymbol.cs,AfterAddingTypeMembersChecks,The length of the statement  "                _explicitInterfaceType.CheckAllConstraints(conversions' new SourceLocation(explicitInterfaceSpecifier.Name)' diagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceCustomEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceCustomEventSymbol.cs,CreateAccessorSymbol,The length of the statement  "            return new SourceCustomEventAccessorSymbol(this' syntaxOpt' explicitlyImplementedEventOpt' aliasQualifierOpt' diagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceDestructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceDestructorSymbol.cs,MakeModifiers,The length of the statement  "            var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers' DeclarationModifiers.None' allowedModifiers' location' diagnostics' out modifierErrors); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceDestructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceDestructorSymbol.cs,MakeModifiers,The length of the statement  "            mods = (mods & ~DeclarationModifiers.AccessibilityMask) | DeclarationModifiers.Protected; // we mark destructors protected in the symbol table " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEnumConstantSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEnumConstantSymbol.cs,CreateImplicitValuedConstant,The length of the statement  "                return new ImplicitValuedEnumConstantSymbol(containingEnum' syntax' otherConstant' (uint)otherConstantOffset' diagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ExplicitValuedEnumConstantSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEnumConstantSymbol.cs,MakeConstantValue,The length of the statement  "                return ConstantValueUtils.EvaluateFieldConstant(this' (EqualsValueClauseSyntax)_equalsValueNodeRef.GetSyntax()' dependencies' earlyDecodingWellKnownAttributes' diagnostics); " is 173.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,ImplicitValuedEnumConstantSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEnumConstantSymbol.cs,MakeConstantValue,The length of the statement  "                var otherValue = _otherConstant.GetConstantValue(new ConstantFieldsInProgress(this' dependencies)' earlyDecodingWellKnownAttributes); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventAccessorSymbol.cs,MethodChecks,The length of the statement  "                    TypeSymbol eventTokenType = compilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationToken); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventAccessorSymbol.cs,MethodChecks,The length of the statement  "                        var parameter = new SynthesizedAccessorValueParameterSymbol(this' _event.Type' 0' ImmutableArray<CustomModifier>.Empty); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventAccessorSymbol.cs,MethodChecks,The length of the statement  "                        var parameter = new SynthesizedAccessorValueParameterSymbol(this' eventTokenType' 0' ImmutableArray<CustomModifier>.Empty); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventAccessorSymbol.cs,MethodChecks,The length of the statement  "                    var parameter = new SynthesizedAccessorValueParameterSymbol(this' _event.Type' 0' ImmutableArray<CustomModifier>.Empty); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventFieldSymbol.cs,AddSynthesizedAttributes,The length of the statement  "            AddSynthesizedAttribute(ref attributes' compilation.TrySynthesizeAttribute(WellKnownMember.System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,MakeModifiers,The length of the statement  "            var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers' defaultAccess' allowedModifiers' location' diagnostics' out modifierErrors); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,CheckModifiersAndType,The length of the statement  "                // Dev10 reports different errors for field-like events (ERR_BadVisFieldType) and custom events (ERR_BadVisPropertyType). " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,ComputeIsWindowsRuntimeEvent,The length of the statement  "                        this == this.containingType.FindImplementationForInterfaceMember(interfaceMember)) //slow check (necessary and sufficient) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,BindEventType,The length of the statement  "            binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks | BinderFlags.SuppressUnsafeDiagnostics' this); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                    arguments.Diagnostics.Add(ErrorCode.ERR_StructOffsetOnBadField' arguments.AttributeSyntaxOpt.Name.Location' arguments.AttributeSyntaxOpt.GetErrorDisplayName()); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                        arguments.Diagnostics.Add(ErrorCode.ERR_InvalidAttributeArgument' attributeArgumentSyntax.Location' arguments.AttributeSyntaxOpt.GetErrorDisplayName()); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                MarshalAsAttributeDecoder<CommonFieldWellKnownAttributeData' AttributeSyntax' CSharpAttributeData' AttributeLocation>.Decode(ref arguments' AttributeTargets.Field' MessageProvider.Instance); " is 190.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                // error CS1716: Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead. " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,PostDecodeWellKnownAttributes,The length of the statement  "                    // error CS0636: The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,PostDecodeWellKnownAttributes,The length of the statement  "                    // error CS0625: '<field>': instance field types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,AddSynthesizedAttributes,The length of the statement  "                AddSynthesizedAttribute(ref attributes' compilation.SynthesizeDynamicAttribute(this.Type' this.CustomModifiers.Length)); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbolWithSyntaxReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,SetLazyConstantValue,The length of the statement  "                if (Interlocked.CompareExchange(ref _lazyConstantValue' value' Microsoft.CodeAnalysis.ConstantValue.Unset) == Microsoft.CodeAnalysis.ConstantValue.Unset) " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,FixedFieldImplementationType,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFixedFieldSymbol.cs,AddSynthesizedAttributes,The length of the statement  "            AddSynthesizedAttribute(ref attributes' compilation.TrySynthesizeAttribute(WellKnownMember.System_Runtime_CompilerServices_UnsafeValueTypeAttribute__ctor)); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceLocalSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceLocalSymbol.cs,MakeForeachLocal,The length of the statement  "            return new ForEachLocal(containingMethod' binder' typeSyntax' identifierToken' collection' LocalDeclarationKind.ForEachIterationVariable); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MakeModifiers,The length of the statement  "                    allowedModifiers |= DeclarationModifiers.Static | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract | DeclarationModifiers.Unsafe; " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MakeModifiers,The length of the statement  "                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MakeAndCheckTypeModifiers,The length of the statement  "                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS' declaration.Declarations[i].NameLocation' self.Name' self.ContainingSymbol); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MakeAndCheckTypeModifiers,The length of the statement  "                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass' declaration.Declarations[i].NameLocation' self.ContainingSymbol' self.Name); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,NoteFieldDefinitions,The length of the statement  "                            else if (fieldDeclaredAccessibility == Accessibility.Internal || containerEffectiveAccessibility == Accessibility.Internal) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CalculateSyntaxOffsetInSynthesizedConstructor,The length of the statement  "            if (TryCalculateSyntaxOffsetOfPositionInInitializer(position' tree' isStatic' ctorInitializerLength: 0' syntaxOffset: out syntaxOffset)) " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,TryCalculateSyntaxOffsetOfPositionInInitializer,The length of the statement  "            var allInitializers = isStatic ? membersAndInitializers.StaticInitializers : membersAndInitializers.InstanceInitializers; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,TryCalculateSyntaxOffsetOfPositionInInitializer,The length of the statement  "            int initializersLength = isStatic ? membersAndInitializers.StaticInitializersSyntaxLength : membersAndInitializers.InstanceInitializersSyntaxLength; " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,GetEarlyAttributeDecodingMembers,The length of the statement  "            return GetEarlyAttributeDecodingMembersDictionary().TryGetValue(name' out result) ? result : ImmutableArray<Symbol>.Empty; " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMemberNameConflicts,The length of the statement  "            var methodsBySignature = new Dictionary<SourceMethodSymbol' SourceMethodSymbol>(MemberSignatureComparer.DuplicateSourceComparer); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMemberNameConflicts,The length of the statement  "            var conversionsAsMethods = new Dictionary<SourceMethodSymbol' SourceMethodSymbol>(MemberSignatureComparer.DuplicateSourceComparer); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMemberNameConflicts,The length of the statement  "            var conversionsAsConversions = new Dictionary<SourceUserDefinedConversionSymbol' SourceUserDefinedConversionSymbol>(ConversionSignatureComparer.Comparer); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMemberNameConflicts,The length of the statement  "                            if (symbol.Kind != SymbolKind.Field || !symbol.IsImplicitlyDeclared || !(symbol is SynthesizedBackingFieldSymbol)) // don't report duplicate errors on backing fields " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckIndexerNameConflicts,The length of the statement  "            var indexersBySignature = new Dictionary<PropertySymbol' PropertySymbol>(MemberSignatureComparer.DuplicateSourceComparer); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckIndexerSignatureCollisions,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_MemberAlreadyExists' indexer.Locations[0]' SyntaxFacts.GetText(SyntaxKind.ThisKeyword)' this); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckForProtectedInStaticClass,The length of the statement  "                    if (member.DeclaredAccessibility == Accessibility.Protected || member.DeclaredAccessibility == Accessibility.ProtectedOrInternal) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckForUnmatchedOperators,The length of the statement  "            CheckForUnmatchedOperator(diagnostics' WellKnownMemberNames.EqualityOperatorName' WellKnownMemberNames.InequalityOperatorName); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckForUnmatchedOperators,The length of the statement  "            CheckForUnmatchedOperator(diagnostics' WellKnownMemberNames.LessThanOperatorName' WellKnownMemberNames.GreaterThanOperatorName); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckForUnmatchedOperators,The length of the statement  "            CheckForUnmatchedOperator(diagnostics' WellKnownMemberNames.LessThanOrEqualOperatorName' WellKnownMemberNames.GreaterThanOrEqualOperatorName); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,TypeOverridesObjectMethod,The length of the statement  "                if (method.IsOverride && method.GetConstructedLeastOverriddenMethod(this).ContainingType.SpecialType == Microsoft.CodeAnalysis.SpecialType.System_Object) " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,AddDeclaredNontypeMembers,The length of the statement  "                        SourceDelegateMethodSymbol.AddDelegateMembers(this' builder.NonTypeNonIndexerMembers' (DelegateDeclarationSyntax)syntax' diagnostics); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MergePartialMethods,The length of the statement  "            var methodsBySignature = new Dictionary<MethodSymbol' SourceMethodSymbol>(MemberSignatureComparer.DuplicateSourceComparer); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckForMemberConflictWithPropertyAccessor,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass' GetAccessorOrPropertyLocation(propertySymbol' getNotSet)' this' accessorName); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckForMemberConflictWithPropertyAccessor,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_MemberReserved' GetAccessorOrPropertyLocation(propertySymbol' getNotSet)' accessorName' this); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckForMemberConflictWithEventAccessor,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass' GetAccessorOrEventLocation(eventSymbol' isAdder)' this' accessorName); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,AddEnumMembers,The length of the statement  "                    symbol = SourceEnumConstantSymbol.CreateImplicitValuedConstant(this' member' otherSymbol' otherSymbolOffset' diagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckForStructBadInitializers,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_FieldInitializerInStruct' (initializer.FieldOpt.AssociatedSymbol ?? initializer.FieldOpt).Locations[0]' this); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,AddNonTypeMembers,The length of the statement  "                            var modifiers = SourceMemberFieldSymbol.MakeModifiers(this' fieldSyntax.Declaration.Variables[0].Identifier' fieldSyntax.Modifiers' diagnostics' out modifierErrors); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,AddNonTypeMembers,The length of the statement  "                                SourceFieldLikeEventSymbol @event = new SourceFieldLikeEventSymbol(this' bodyBinder' eventFieldSyntax.Modifiers' declarator' diagnostics); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,The length of the statement  "                    var synthesizedImplementation = this.SynthesizeInterfaceMemberImplementation(implementingMemberAndDiagnostics' interfaceMember); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,The length of the statement  "                            // At this point (and not before)' we know that maybeWinRTEvent is definitely a WinRT event and maybeRegularEvent is definitely a regular event. " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,The length of the statement  "                            var info = new CSDiagnosticInfo(ErrorCode.ERR_MixingWinRTEventWithRegular' args' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<Location>(this.Locations[0])); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,The length of the statement  "                    var associatedPropertyOrEvent = interfaceMemberKind == SymbolKind.Method ? ((MethodSymbol)interfaceMember).AssociatedSymbol : null; " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,The length of the statement  "                        //(b) the interface member is an accessor of an interesting (see ReportAccessorOfInterfacePropertyOrEvent) property or event' or " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,The length of the statement  "                            hasImportedBaseTypeDeclaringInterface = hasImportedBaseTypeDeclaringInterface ?? HasImportedBaseTypeDeclaringInterface(@interface); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,The length of the statement  "                                        diagnostics.Add(ErrorCode.ERR_UnimplementedInterfaceMember' GetImplementsLocation(@interface) ?? this.Locations[0]' this' interfaceMember); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ReportAccessorOfInterfacePropertyOrEvent,The length of the statement  "            Symbol implementingPropertyOrEvent = this.FindImplementationForInterfaceMemberWithDiagnostics(interfacePropertyOrEvent).Symbol; " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ReportAccessorOfInterfacePropertyOrEvent,The length of the statement  "                ((EventSymbol)interfacePropertyOrEvent).IsWindowsRuntimeEvent != ((EventSymbol)implementingPropertyOrEvent).IsWindowsRuntimeEvent) " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,HasImportedBaseTypeDeclaringInterface,The length of the statement  "                if (!currType.OriginalDefinition.IsFromCompilation(compilation) && currType.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains(@interface)) " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMembersAgainstBaseType,The length of the statement  "                            MethodSymbol overridden = method.GetFirstRuntimeOverriddenMethodIgnoringNewSlot(ignoreInterfaceImplementationChanges: true); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMembersAgainstBaseType,The length of the statement  "                            CheckNonOverrideMember(property' isNewProperty' property.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMembersAgainstBaseType,The length of the statement  "                                    CheckNonOverrideMember(getMethod' isNewProperty' getMethod.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMembersAgainstBaseType,The length of the statement  "                                    CheckNonOverrideMember(setMethod' isNewProperty' setMethod.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMembersAgainstBaseType,The length of the statement  "                                    CheckNonOverrideMember(removeMethod' isNewEvent' removeMethod.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The length of the statement  "                        !(overridingMemberIsMethod && ((MethodSymbol)overriddenMember).MethodKind == MethodKind.Destructor)) //destructors are metadata virtual " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_CantChangeAccessOnOverride' overridingMemberLocation' overridingMember' accessibility' overriddenMember); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The length of the statement  "                                diagnostics.Add(ErrorCode.ERR_CantChangeTypeOnOverride' overridingMemberLocation' overridingMember' overriddenMember' overriddenMemberType); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The length of the statement  "                                if (overridingProperty.GetMethod != ownOrInheritedGetMethod && !AccessCheck.IsSymbolAccessible(ownOrInheritedGetMethod' overridingType' ref useSiteDiagnostics)) " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The length of the statement  "                                if (overridingProperty.SetMethod != ownOrInheritedSetMethod && !AccessCheck.IsSymbolAccessible(ownOrInheritedSetMethod' overridingType' ref useSiteDiagnostics)) " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The length of the statement  "                                diagnostics.Add(ErrorCode.ERR_CantChangeTypeOnOverride' overridingMemberLocation' overridingMember' overriddenMember' overriddenMemberType); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The length of the statement  "                                diagnostics.Add(ErrorCode.ERR_CantChangeReturnTypeOnOverride' overridingMemberLocation' overridingMember' overriddenMember' returnType); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The length of the statement  "            if (runtimeOverriddenMembers.Length > 1 && overridingMember.Kind == SymbolKind.Method) // The runtime doesn't define overriding for properties or events. " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The length of the statement  "                diagnostics.Add(ErrorCode.WRN_MultipleRuntimeOverrideMatches' ambiguousMethod.Locations[0]' ambiguousMethod' overridingMember); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckNonOverrideMember,The length of the statement  "                        diagnosticAdded |= AddHidingAbstractDiagnostic(hidingMember' hidingMemberLocation' hiddenMember' diagnostics' ref suppressAccessors); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,AddHidingAbstractDiagnostic,The length of the statement  "                                    diagnostics.Add(ErrorCode.ERR_HidingAbstractMethod' associatedPropertyOrEvent.Locations[0]' associatedPropertyOrEvent' hiddenMember); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,SynthesizeInterfaceMemberImplementation,The length of the statement  "                    SourceMethodSymbol sourceImplementMethodOriginalDefinition = implementingMethodOriginalDefinition as SourceMethodSymbol; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,Flags,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ModifiersRequireMetadataVirtual,The length of the statement  "                return (modifiers & (DeclarationModifiers.Abstract | DeclarationModifiers.Virtual | DeclarationModifiers.Override)) != 0; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberFieldSymbol.cs,GetFieldType,The length of the statement  "                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberFieldSymbol.cs,GetFieldType,The length of the statement  "                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T> " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberFieldSymbol.cs,GetFieldType,The length of the statement  "                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics' declarator.Initializer' declarator); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberFieldSymbol.cs,MakeConstantValue,The length of the statement  "                : ConstantValueUtils.EvaluateFieldConstant(this' initializer' dependencies' earlyDecodingWellKnownAttributes' diagnostics); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberFieldSymbol.cs,IsDefinedInSourceTree,The length of the statement  "                return fieldDeclaration.SyntaxTree.HasCompilationUnitRoot && fieldDeclaration.Span.IntersectsWith(definedWithinSpan.Value); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,CreateMethodSymbol,The length of the statement  "            var name = ExplicitInterfaceHelpers.GetMemberNameAndInterfaceSymbol(bodyBinder' interfaceSpecifier' nameToken.ValueText' diagnostics' out explicitInterfaceType' out discardedAliasQualifier); " is 190.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,CreateMethodSymbol,The length of the statement  "            return new SourceMemberMethodSymbol(containingType' explicitInterfaceType' name' location' bodyBinder' syntax' methodKind' diagnostics); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The length of the statement  "            var signatureBinder = withTypeParamsBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks' this); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The length of the statement  "            _lazyParameters = ParameterHelpers.MakeParameters(signatureBinder' this' syntax.ParameterList' true' out arglistToken' diagnostics); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The length of the statement  "                    (this.ContainingType.SpecialType == SpecialType.System_TypedReference || this.ContainingType.SpecialType == SpecialType.System_ArgIterator)) " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The length of the statement  "            if (this.Name == WellKnownMemberNames.DestructorName && this.ParameterCount == 0 && this.Arity == 0 && this.ReturnsVoid) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The length of the statement  "                    var attributeConstructor = withTypeParamsBinder.Compilation.GetWellKnownTypeMember(WellKnownMember.System_Runtime_CompilerServices_ExtensionAttribute__ctor); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The length of the statement  "                        var memberDescriptor = WellKnownMembers.GetDescriptor(WellKnownMember.System_Runtime_CompilerServices_ExtensionAttribute__ctor); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The length of the statement  "                        // do not use Binder.ReportUseSiteErrorForAttributeCtor in this case' because we'll need to report a special error id' not a generic use site error. " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The length of the statement  "                        CustomModifierUtils.CopyMethodCustomModifiers(overriddenMethod' this' out _lazyReturnType' out _lazyReturnTypeCustomModifiers' out _lazyParameters' alsoCopyParamsModifier: true); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The length of the statement  "                MethodSymbol implementedMethod = this.FindExplicitlyImplementedMethod(_explicitInterfaceType' syntax.Identifier.ValueText' syntax.ExplicitInterfaceSpecifier' diagnostics); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The length of the statement  "                    CustomModifierUtils.CopyMethodCustomModifiers(implementedMethod' this' out _lazyReturnType' out _lazyReturnTypeCustomModifiers' out _lazyParameters' alsoCopyParamsModifier: false); " is 180.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,LazyAsyncMethodChecks,The length of the statement  "            if (!this.IsGenericTaskReturningAsync(this.DeclaringCompilation) && !this.IsTaskReturningAsync(this.DeclaringCompilation) && !this.IsVoidReturningAsync()) " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,GetTypeParameterConstraintClause,The length of the statement  "                if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameterConstraints' MakeTypeParameterConstraints(diagnostics))) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,GetDocumentationCommentXml,The length of the statement  "            return SourceDocumentationCommentUtils.GetAndCacheDocumentationComment(this.SourcePartialImplementation ?? this' expandIncludes' ref lazyDocComment); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,GetAttributeDeclarations,The length of the statement  "                return OneOrMany.Create(ImmutableArray.Create(AttributeDeclarationSyntaxList' this.SourcePartialImplementation.AttributeDeclarationSyntaxList)); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MakeModifiers,The length of the statement  "            var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers' defaultAccess' allowedModifiers' location' diagnostics' out modifierErrors); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,AddImpliedModifiers,The length of the statement  "            // Let's overwrite modifiers for interface and explicit interface implementation methods with what they are supposed to be.  " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,CheckModifiers,The length of the statement  "            const DeclarationModifiers partialMethodInvalidModifierMask = (DeclarationModifiers.AccessibilityMask & ~DeclarationModifiers.Private) | " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,CheckModifiers,The length of the statement  "            else if (_lazyIsVararg && (IsGenericMethod || ContainingType.IsGenericType || _lazyParameters.Length > 0 && _lazyParameters[_lazyParameters.Length - 1].IsParams)) " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,AfterAddingTypeMembersChecks,The length of the statement  "                _explicitInterfaceType.CheckAllConstraints(conversions' new SourceLocation(syntax.ExplicitInterfaceSpecifier.Name)' diagnostics); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,MakeFlags,The length of the statement  "            this.flags = new Flags(methodKind' declarationModifiers' returnsVoid' isExtensionMethod' isMetadataVirtualIgnoringModifiers); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,GetAttributesBag,The length of the statement  "                bagCreatedOnThisThread = LoadAndValidateAttributes(this.GetReturnTypeAttributeDeclarations()' ref lazyCustomAttributesBag' symbolPart: AttributeLocation.Return); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,AddSynthesizedReturnTypeAttributes,The length of the statement  "                AddSynthesizedAttribute(ref attributes' compilation.SynthesizeDynamicAttribute(this.ReturnType' this.ReturnTypeCustomModifiers.Length)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "                if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.ConditionalAttribute)) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "                    var boundAttribute = arguments.Binder.GetAttribute(arguments.AttributeSyntax' arguments.AttributeType' out hasAnyDiagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,DecodeWellKnownAttributeAppliedToMethod,The length of the statement  "                AttributeData.DecodeMethodImplAttribute<CommonMethodWellKnownAttributeData' AttributeSyntax' CSharpAttributeData' AttributeLocation>(ref arguments' MessageProvider.Instance); " is 174.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,DecodeWellKnownAttributeAppliedToMethod,The length of the statement  "                    arguments.Diagnostics.Add(ErrorCode.ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync' arguments.AttributeSyntaxOpt.Location' arguments.AttributeSyntaxOpt.GetErrorDisplayName()); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,VerifyObsoleteAttributeAppliedToMethod,The length of the statement  "                    arguments.Diagnostics.Add(ErrorCode.ERR_AttributeNotOnAccessor' arguments.AttributeSyntaxOpt.Name.Location' description.FullName' attributeUsage.GetValidTargetsErrorArgument()); " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,ValidateConditionalAttribute,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_AttributeNotOnAccessor' node.Name.Location' node.GetErrorDisplayName()' attributeUsage.GetValidTargetsErrorArgument()); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,ValidateConditionalAttribute,The length of the statement  "                // CS0577: The Conditional attribute is not valid on '{0}' because it is a constructor' destructor' operator' or explicit interface implementation " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,DecodeWellKnownAttributeAppliedToReturnValue,The length of the statement  "                MarshalAsAttributeDecoder<CommonReturnTypeWellKnownAttributeData' AttributeSyntax' CSharpAttributeData' AttributeLocation>.Decode(ref arguments' AttributeTargets.ReturnValue' MessageProvider.Instance); " is 201.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,DecodeDllImportAttribute,The length of the statement  "                arguments.Diagnostics.Add(ErrorCode.ERR_InvalidAttributeArgument' attributeArgumentSyntax.Location' arguments.AttributeSyntaxOpt.GetErrorDisplayName()); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,DecodeDllImportAttribute,The length of the statement  "                            arguments.Diagnostics.Add(ErrorCode.ERR_InvalidNamedArgument' arguments.AttributeSyntaxOpt.ArgumentList.Arguments[position].Location' namedArg.Key); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,AddSynthesizedAttributes,The length of the statement  "                    var arg = new TypedConstant(compilation.GetWellKnownType(WellKnownType.System_Type)' TypedConstantKind.Type' stateMachineType.GetUnboundGenericTypeOrSelf()); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceModuleSymbol.cs,ValidateLinkedAssemblies,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_NoPIAAssemblyMissingAttribute' NoLocation.Singleton' a' AttributeDescription.GuidAttribute.FullName); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceModuleSymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                    arguments.Diagnostics.Add(ErrorCode.ERR_InvalidAttributeArgument' attributeArgumentSyntax.Location' arguments.AttributeSyntaxOpt.GetErrorDisplayName()); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceModuleSymbol.cs,AddSynthesizedAttributes,The length of the statement  "                if (!(compilation.GetWellKnownType(WellKnownType.System_Security_UnverifiableCodeAttribute) is MissingMetadataTypeSymbol)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,GetTypeParameterConstraintClause,The length of the statement  "                if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameterConstraints' MakeTypeParameterConstraints(diagnostics))) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "            if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.ComImportAttribute)) " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "                boundAttribute = arguments.Binder.GetAttribute(arguments.AttributeSyntax' arguments.AttributeType' out hasAnyDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "            if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.ConditionalAttribute)) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "                boundAttribute = arguments.Binder.GetAttribute(arguments.AttributeSyntax' arguments.AttributeType' out hasAnyDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "            if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.AttributeUsageAttribute)) " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "                boundAttribute = arguments.Binder.GetAttribute(arguments.AttributeSyntax' arguments.AttributeType' out hasAnyDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "                    AttributeUsageInfo info = this.DecodeAttributeUsageAttribute(boundAttribute' arguments.AttributeSyntax' diagnose: false); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,GetAttributeUsageInfo,The length of the statement  "            return ((object)this.BaseTypeNoUseSiteDiagnostics != null) ? this.BaseTypeNoUseSiteDiagnostics.GetAttributeUsageInfo() : AttributeUsageInfo.Default; " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                DecodeAttributeUsageAttribute(attribute' arguments.AttributeSyntaxOpt' diagnose: true' diagnosticsOpt: arguments.Diagnostics); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                arguments.GetOrCreateData<TypeWellKnownAttributeData>().GuidString = attribute.DecodeGuidAttribute(arguments.AttributeSyntaxOpt' arguments.Diagnostics); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,DecodeWellKnownAttribute,The length of the statement  "                AttributeData.DecodeStructLayoutAttribute<TypeWellKnownAttributeData' AttributeSyntax' CSharpAttributeData' AttributeLocation>( " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,DecodeWellKnownAttribute,The length of the statement  "            else if (_lazyIsExplicitDefinitionOfNoPiaLocalType == ThreeState.Unknown && attribute.IsTargetAttribute(this' AttributeDescription.TypeIdentifierAttribute)) " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,DecodeAttributeUsageAttribute,The length of the statement  "                        diagnosticsOpt.Add(ErrorCode.ERR_InvalidAttributeArgument' attributeArgumentSyntax.Location' node.GetErrorDisplayName()); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,DecodeCoClassAttribute,The length of the statement  "            if (this.IsInterfaceType() && (!arguments.HasDecodedData || (object)((TypeWellKnownAttributeData)arguments.DecodedData).ComImportCoClass == null)) " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,AddSynthesizedAttributes,The length of the statement  "                AddSynthesizedAttribute(ref attributes' compilation.TrySynthesizeAttribute(WellKnownMember.System_Runtime_CompilerServices_ExtensionAttribute__ctor)); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,AddSynthesizedAttributes,The length of the statement  "                var defaultMemberNameConstant = new TypedConstant(compilation.GetSpecialType(SpecialType.System_String)' TypedConstantKind.Primitive' defaultMemberName); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,InterfacesNoUseSiteDiagnostics,The length of the statement  "                if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces' acyclicInterfaces' default(ImmutableArray<NamedTypeSymbol>)).IsDefault) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,GetDeclaredBases,The length of the statement  "                if (Interlocked.CompareExchange(ref _lazyDeclaredBases' MakeDeclaredBases(basesBeingResolved' diagnostics)' null) == null) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,MakeDeclaredBases,The length of the statement  "                Tuple<NamedTypeSymbol' ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved' decl' diagnostics); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,MakeDeclaredBases,The length of the statement  "                foreach (var t in partInterfaces) // this could probably be done more efficiently with a side hash table if it proves necessary " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamespaceSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol.cs,ForceComplete,The length of the statement  "            CompletionPart allParts = (locationOpt == null) ? CompletionPart.NamespaceSymbolAll : CompletionPart.NamespaceSymbolAll & ~CompletionPart.MembersCompleted; " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceParameterSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceParameterSymbolBase.cs,AddSynthesizedAttributes,The length of the statement  "                AddSynthesizedAttribute(ref attributes' compilation.TrySynthesizeAttribute(WellKnownMember.System_ParamArrayAttribute__ctor)); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceParameterSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceParameterSymbolBase.cs,AddSynthesizedAttributes,The length of the statement  "                AddSynthesizedAttribute(ref attributes' compilation.SynthesizeDynamicAttribute(this.Type' this.CustomModifiers.Length' this.RefKind)); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,GetNameAndExplicitInterfaceImplementations,The length of the statement  "                name = ExplicitInterfaceHelpers.GetMemberName(accessorName' explicitlyImplementedPropertyOpt.ContainingType' aliasQualifierOpt); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,MethodChecks,The length of the statement  "                CustomModifierUtils.CopyMethodCustomModifiers(implementedMethod' this' out _lazyReturnType' out _lazyReturnTypeCustomModifiers' out _lazyParameters' alsoCopyParamsModifier: false); " is 180.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,MethodChecks,The length of the statement  "                    CustomModifierUtils.CopyMethodCustomModifiers(overriddenMethod' this' out _lazyReturnType' out _lazyReturnTypeCustomModifiers' out _lazyParameters' alsoCopyParamsModifier: true); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,MethodChecks,The length of the statement  "                _lazyReturnType = CustomModifierUtils.CopyTypeCustomModifiers(associatedProperty.Type' _lazyReturnType' RefKind.None' this.ContainingAssembly); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,MakeModifiers,The length of the statement  "            var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(syntax.Modifiers' defaultAccess' allowedModifiers' location' diagnostics' out modifierErrors); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,ComputeParameters,The length of the statement  "                parameters.Add(new SynthesizedAccessorValueParameterSymbol(this' propertyType' parameters.Count' _property.TypeCustomModifiers)); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,AddSynthesizedAttributes,The length of the statement  "                AddSynthesizedAttribute(ref attributes' compilation.TrySynthesizeAttribute(WellKnownMember.System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,AfterAddingTypeMembersChecks,The length of the statement  "                _explicitInterfaceType.CheckAllConstraints(conversions' new SourceLocation(explicitInterfaceSpecifier.Name)' diagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,MakeModifiers,The length of the statement  "            var mods = ModifierUtils.MakeAndCheckNontypeMemberModifiers(modifiers' defaultAccess' allowedModifiers' location' diagnostics' out modifierErrors); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,MakeParameters,The length of the statement  "            var parameters = ParameterHelpers.MakeParameters(binder' owner' parameterSyntaxOpt' false' out arglistToken' diagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,MakeParameters,The length of the statement  "                    diagnostics.Add(ErrorCode.WRN_DefaultValueForUnconsumedLocation' paramNameToken.GetLocation()' paramNameToken.ValueText); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,CheckExplicitImplementationAccessor,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_ExplicitPropertyAddingAccessor' thisAccessor.Locations[0]' thisAccessor' explicitlyImplementedProperty); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,AddSynthesizedAttributes,The length of the statement  "                AddSynthesizedAttribute(ref attributes' compilation.SynthesizeDynamicAttribute(this.Type' this.TypeCustomModifiers.Length)); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "            if (CSharpAttributeData.IsTargetEarlyAttribute(arguments.AttributeType' arguments.AttributeSyntax' AttributeDescription.IndexerNameAttribute)) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,EarlyDecodeWellKnownAttribute,The length of the statement  "                boundAttribute = arguments.Binder.GetAttribute(arguments.AttributeSyntax' arguments.AttributeType' out hasAnyDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,PostDecodeWellKnownAttributes,The length of the statement  "                // error CS0842: '<property>': Automatically implemented properties cannot be used inside a type marked with StructLayout(LayoutKind.Explicit) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,ValidateIndexerNameAttribute,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_BadArgumentToAttribute' node.ArgumentList.Arguments[0].Location' node.GetErrorDisplayName()); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,ComputeType,The length of the statement  "                diagnostics.Add((this.IsIndexer ? ErrorCode.ERR_BadVisIndexerReturn : ErrorCode.ERR_BadVisPropertyType)' _location' this' type); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceTypeParameterSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceTypeParameterSymbol.cs,GetAttributesBag,The length of the statement  "                    lazyAttributesStored = LoadAndValidateAttributes(OneOrMany.Create(this.MergedAttributeDeclarationSyntaxLists)' ref _lazyCustomAttributesBag); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceTypeParameterSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceTypeParameterSymbol.cs,GetBounds,The length of the statement  "                if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBounds' bounds' TypeParameterBounds.Unset)' TypeParameterBounds.Unset)) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceTypeParameterSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceTypeParameterSymbol.cs,ForceComplete,The length of the statement  "                        //Debug.Assert(this.ContainingSymbol.IsContainingSymbolOfAllTypeParameters(ImmutableArray<TypeSymbol>.CreateFrom(this.Interfaces))); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceTypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceTypeParameterSymbol.cs,ResolveBounds,The length of the statement  "            return this.ResolveBounds(this.ContainingAssembly.CorLibrary' inProgress.Prepend(this)' constraintTypes' false' this.DeclaringCompilation' diagnostics); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodTypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceTypeParameterSymbol.cs,ResolveBounds,The length of the statement  "            return this.ResolveBounds(this.ContainingAssembly.CorLibrary' inProgress.Prepend(this)' constraintTypes' false' this.DeclaringCompilation' diagnostics); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceOverridingMethodTypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceTypeParameterSymbol.cs,ResolveBounds,The length of the statement  "            return this.ResolveBounds(this.ContainingAssembly.CorLibrary' inProgress.Prepend(this)' constraintTypes' true' this.DeclaringCompilation' diagnostics); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceUserDefinedOperatorSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceUserDefinedOperatorSymbolBase.cs,CheckUserDefinedConversionSignature,The length of the statement  "                if (same.IsDerivedFrom(different' ignoreDynamic: false' useSiteDiagnostics: ref useSiteDiagnostics)) // tomat: ignoreDynamic should be true' but we don't want to introduce breaking change. See bug 605326. " is 204.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceUserDefinedOperatorSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceUserDefinedOperatorSymbolBase.cs,CheckUserDefinedConversionSignature,The length of the statement  "                else if (different.IsDerivedFrom(same' ignoreDynamic: false' useSiteDiagnostics: ref useSiteDiagnostics)) // tomat: ignoreDynamic should be true' but we don't want to introduce breaking change. See bug 605326. " is 209.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SourceUserDefinedOperatorSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceUserDefinedOperatorSymbolBase.cs,CheckIncrementDecrementSignature,The length of the statement  "            else if (!this.ReturnType.EffectiveTypeNoUseSiteDiagnostics.IsEqualToOrDerivedFrom(parameterType' ignoreDynamic: false' useSiteDiagnostics: ref useSiteDiagnostics)) " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedFieldSymbol.cs,GetFieldType,The length of the statement  "                Interlocked.CompareExchange(ref _lazyType' _containingType.TypeSubstitution.SubstituteType(_originalDefinition.GetFieldType(fieldsBeingBound))' null); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedFieldSymbol.cs,FixedImplementationType,The length of the statement  "            return (NamedTypeSymbol)_containingType.TypeSubstitution.SubstituteType(_originalDefinition.FixedImplementationType(emitModule)); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedFieldSymbol.cs,Equals,The length of the statement  "            return (object)other != null && _containingType == other._containingType && _originalDefinition == other._originalDefinition; " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedMethodSymbol.cs,EnsureMapAndTypeParameters,The length of the statement  "            ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeParameters' typeParameters' default(ImmutableArray<TypeParameterSymbol>)); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedNamedTypeSymbol.cs,EnsureMapAndTypeParameters,The length of the statement  "            ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeParameters' typeParameters' default(ImmutableArray<TypeParameterSymbol>)); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedNamedTypeSymbol.cs,GetDeclaredInterfaces,The length of the statement  "            return _unbound ? ImmutableArray<NamedTypeSymbol>.Empty : Map.SubstituteNamedTypes(OriginalDefinition.GetDeclaredInterfaces(basesBeingResolved)); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedNamedTypeSymbol.cs,InterfacesNoUseSiteDiagnostics,The length of the statement  "            return _unbound ? ImmutableArray<NamedTypeSymbol>.Empty : Map.SubstituteNamedTypes(OriginalDefinition.InterfacesNoUseSiteDiagnostics(basesBeingResolved)); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedNamedTypeSymbol.cs,MakeAllInterfaces,The length of the statement  "            return _unbound ? ImmutableArray<NamedTypeSymbol>.Empty : Map.SubstituteNamedTypes(OriginalDefinition.AllInterfacesNoUseSiteDiagnostics); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedTypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedTypeParameterSymbol.cs,GetConstraintTypes,The length of the statement  "            return _map.SubstituteTypes(_substitutedFrom.GetConstraintTypes(inProgress)).WhereAsArray(s_isNotObjectFunc).Distinct(); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,MakeLambdaDisplayClassName,The length of the statement  "            return MakeMethodScopedSynthesizedName(GeneratedNameKind.LambdaDisplayClass' methodOrdinal' generation' suffix: "DisplayClass"' uniqueId: scopeOrdinal' isTypeName: true); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,TryParseAnonymousTypeTemplateName,The length of the statement  "                if (int.TryParse(name.Substring(AnonymousNamePrefix.Length)' NumberStyles.None' CultureInfo.InvariantCulture' out index)) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,MakeStateMachineTypeName,The length of the statement  "            return MakeMethodScopedSynthesizedName(GeneratedNameKind.StateMachineType' methodOrdinal' generation' methodName' isTypeName: true); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,MakeLambdaMethodName,The length of the statement  "            return MakeMethodScopedSynthesizedName(GeneratedNameKind.LambdaMethod' methodOrdinal' generation' methodName' uniqueId: lambdaOrdinal); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,MakeLambdaCacheFieldName,The length of the statement  "            return MakeMethodScopedSynthesizedName(GeneratedNameKind.LambdaCacheField' methodOrdinal' generation' uniqueId: lambdaOrdinal); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,GetKind,The length of the statement  "            return TryParseGeneratedName(name' out kind' out openBracketOffset' out closeBracketOffset) ? kind : GeneratedNameKind.None; " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,MakeDynamicCallSiteContainerName,The length of the statement  "            return MakeMethodScopedSynthesizedName(GeneratedNameKind.DynamicCallSiteContainerType' methodOrdinal' generation' isTypeName: true); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedContainer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedContainer.cs,GetMembers,The length of the statement  "            return ((object)ctor != null && name == ctor.Name) ? ImmutableArray.Create<Symbol>(ctor) : ImmutableArray<Symbol>.Empty; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedEntryPointSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedEntryPointSymbol.cs,CreateSubmissionFactoryBody,The length of the statement  "                submissionResult = new BoundConversion(syntax' submissionResult' Conversion.Boxing' false' true' ConstantValue.NotAvailable' _returnType) " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedFieldLikeEventAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedFieldLikeEventAccessorSymbol.cs,AddSynthesizedAttributes,The length of the statement  "            AddSynthesizedAttribute(ref attributes' compilation.TrySynthesizeAttribute(WellKnownMember.System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedFieldSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedFieldSymbolBase.cs,AddSynthesizedAttributes,The length of the statement  "            AddSynthesizedAttribute(ref attributes' compilation.TrySynthesizeAttribute(WellKnownMember.System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedInstanceConstructor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedInstanceConstructor.cs,GetLexicalSortKey,The length of the statement  "            //For the sake of matching the metadata output of the native compiler' make synthesized constructors appear last in the metadata. " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedImplementationMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedImplementationMethod.cs,AddSynthesizedAttributes,The length of the statement  "                AddSynthesizedAttribute(ref attributes' compilation.TrySynthesizeAttribute(WellKnownMember.System_Diagnostics_DebuggerHiddenAttribute__ctor)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedImplementationMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedImplementationMethod.cs,AddSynthesizedAttributes,The length of the statement  "                AddSynthesizedAttribute(ref attributes' compilation.SynthesizeDynamicAttribute(this.ReturnType' this.ReturnTypeCustomModifiers.Length)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedStaticConstructor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedStaticConstructor.cs,GetLexicalSortKey,The length of the statement  "            //For the sake of matching the metadata output of the native compiler' make synthesized constructors appear last in the metadata. " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeMap.cs,ForType,The length of the statement  "                new SmallDictionary<TypeParameterSymbol' TypeSymbol>(substituted.TypeSubstitution.Mapping' ReferenceEqualityComparer.Instance) : " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeMap.cs,WithAlphaRename,The length of the statement  "            bool synthesized = !ReferenceEquals(oldTypeParameters[0].ContainingSymbol.OriginalDefinition' newOwner.OriginalDefinition); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeMap.cs,ConstructMapping,The length of the statement  "            SmallDictionary<TypeParameterSymbol' TypeSymbol> mapping = new SmallDictionary<TypeParameterSymbol' TypeSymbol>(ReferenceEqualityComparer.Instance); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeParameterSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeParameterSymbolExtensions.cs,DependsOn,The length of the statement  "            Func<TypeParameterSymbol' IEnumerable<TypeParameterSymbol>> dependencies = x => x.ConstraintTypesNoUseSiteDiagnostics.OfType<TypeParameterSymbol>(); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,GetInterfaceInfo,The length of the statement  "                var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics(); " is 181.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,IsEqualToOrDerivedFrom,The length of the statement  "            return this.Equals(type' ignoreDynamic: ignoreDynamic) || this.IsDerivedFrom(type' ignoreDynamic' ref useSiteDiagnostics); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,MakeAllInterfaces,The length of the statement  "                var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics(); " is 181.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,FindImplementationForInterfaceMemberWithDiagnostics,The length of the statement  "                        Interlocked.CompareExchange(ref info.implementationForInterfaceMemberMap' new ConcurrentDictionary<Symbol' SymbolAndDiagnostics>()' null); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,FindImplementationForInterfaceMemberWithDiagnostics,The length of the statement  "                    return info.implementationForInterfaceMemberMap.GetOrAdd(interfaceMember' this.ComputeImplementationAndDiagnosticsForInterfaceMember); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ComputeImplementationForInterfaceMember,The length of the statement  "            Debug.Assert(interfaceMember.Kind == SymbolKind.Method || interfaceMember.Kind == SymbolKind.Property || interfaceMember.Kind == SymbolKind.Event); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ComputeImplementationForInterfaceMember,The length of the statement  "            for (TypeSymbol currType = implementingType; (object)currType != null; currType = currType.BaseTypeNoUseSiteDiagnostics) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ComputeImplementationForInterfaceMember,The length of the statement  "                seenTypeDeclaringInterface = seenTypeDeclaringInterface || currType.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics.Contains(interfaceType); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ComputeImplementationForInterfaceMember,The length of the statement  "                CheckForImplementationOfCorrespondingPropertyOrEvent((MethodSymbol)interfaceMember' implementingType' implementingTypeIsFromSomeCompilation' ref implicitImpl); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,IsExplicitlyImplementedViaAccessors,The length of the statement  "            if (TryGetExplicitImplementationAssociatedPropertyOrEvent(interfaceAccessor1' currType' out associated1) |  // NB: not || " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,CheckForImplementationOfCorrespondingPropertyOrEvent,The length of the statement  "            Symbol implementingPropertyOrEvent = implementingType.FindImplementationForInterfaceMember(associatedInterfacePropertyOrEvent); // NB: uses cache " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,CheckForImplementationOfCorrespondingPropertyOrEvent,The length of the statement  "            else if ((object)correspondingImplementingAccessor == null && (object)implicitImpl != null && implicitImpl.IsAccessor()) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,CheckForImplementationOfCorrespondingPropertyOrEvent,The length of the statement  "            else if ((object)correspondingImplementingAccessor != null && ((object)implicitImpl == null || correspondingImplementingAccessor.ContainingType == implicitImpl.ContainingType)) " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,CheckForImplementationOfCorrespondingPropertyOrEvent,The length of the statement  "                if (IsInterfaceMemberImplementation(correspondingImplementingAccessor' interfaceAccessorWithImplementationName' implementingTypeIsFromSomeCompilation)) " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ReportImplicitImplementationMatchDiagnostics,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_MethodImplementingAccessor' implicitImpl.Locations[0]' implicitImpl' interfaceMethod' implementingType); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ReportImplicitImplementationMatchDiagnostics,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_AccessorImplementingMethod' implicitImpl.Locations[0]' implicitImpl' interfaceMethod' implementingType); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ReportImplicitImplementationMatchDiagnostics,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_InterfaceImplementedByConditional' implicitImpl.Locations[0]' implicitImpl' interfaceMethod' implementingType); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ReportImplicitImplementationMatchDiagnostics,The length of the statement  "                    else if (MemberSignatureComparer.RuntimeImplicitImplementationComparer.Equals(interfaceMember' member) && !member.IsAccessor()) " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ReportImplicitImplementationMatchDiagnostics,The length of the statement  "                        diagnostics.Add(ErrorCode.WRN_MultipleRuntimeImplementationMatches' member.Locations[0]' member' interfaceMember' implementingType); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ReportImplicitImplementationMismatchDiagnostics,The length of the statement  "                diagnostics.Add(ErrorCode.ERR_CloseUnimplementedInterfaceMemberStatic' interfacelocation' implementingType' interfaceMember' closestMismatch); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ReportImplicitImplementationMismatchDiagnostics,The length of the statement  "                ErrorCode errorCode = interfaceMember.IsAccessor() ? ErrorCode.ERR_UnimplementedInterfaceAccessor : ErrorCode.ERR_CloseUnimplementedInterfaceMemberNotPublic; " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ReportImplicitImplementationMismatchDiagnostics,The length of the statement  "                    diagnostics.Add(ErrorCode.ERR_CloseUnimplementedInterfaceMemberWrongReturnType' interfacelocation' implementingType' interfaceMember' closestMismatch' interfaceMemberReturnType); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ReportAnyMismatchedConstraints,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_ImplBadConstraints' location' typeParameter2.Name' implicitImpl' typeParameter1.Name' interfaceMethod); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,GetExplicitImplementationForInterfaceMember,The length of the statement  "                Interlocked.CompareExchange(ref info.explicitInterfaceImplementationMap' MakeExplicitInterfaceImplementationMap()' null); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,GetExplicitImplementationForInterfaceMember,The length of the statement  "            info.explicitInterfaceImplementationMap.TryGetValue(interfaceMember' out implementingMethod); //no exception - just return null " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,GetAttributeParameterTypedConstantKind,The length of the statement  "            // The types of positional and named parameters for an attribute class are limited to the attribute parameter types' which are: " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,GetAttributeParameterTypedConstantKind,The length of the statement  "            // 	1) One of the following types: bool' byte' char' double' float' int' long' sbyte' short' string' uint' ulong' ushort. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,GetAttributeParameterTypedConstantKind,The length of the statement  "            //     4) An enum type' provided it has public accessibility and the types in which it is nested (if any) also have public accessibility. " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,GetAttributeParameterTypedConstantKind,The length of the statement  "                // SPEC VIOLATION: Dev11 doesn't enforce either the Enum type or its enclosing types (if any) to have public accessibility. " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,GetDefaultValue,The length of the statement  "            // SPEC:    sbyte' byte' short' ushort' int' uint' long' ulong' char' float' double' decimal' bool' or any enumeration type. " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,IsAtLeastAsVisibleAs,The length of the statement  "            var result = type.VisitType((type1' symbol' unused) => IsTypeLessVisibleThan(type1' symbol' ref localUseSiteDiagnostics)' sym); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,IsAsRestrictive,The length of the statement  "                            if ((acc2 == Accessibility.Private || acc2 == Accessibility.Internal) && s2.ContainingAssembly.HasInternalAccessTo(s1.ContainingAssembly)) " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,IsAsRestrictive,The length of the statement  "                                if (ReferenceEquals(parent2.OriginalDefinition' parent1OriginalDefinition) || parent1OriginalDefinition.TypeKind == TypeKind.Submission && parent2.TypeKind == TypeKind.Submission) " is 179.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,HasNameQualifier,The length of the statement  "                return string.Equals(container.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat)' qualifiedName' comparison); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,AsUnboundGenericType,The length of the statement  "                original.AsMember(originalContainingType.IsGenericType ? originalContainingType.AsUnboundGenericType() : originalContainingType); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,UnboundArgumentErrorTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\UnboundGenericType.cs,Equals,The length of the statement  "            return (object)other != null && string.Equals(other._name' _name' StringComparison.Ordinal) && object.Equals(other._errorInfo' _errorInfo); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,VarianceSafety,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\VarianceSafety.cs,IsVarianceUnsafe,The length of the statement  "                    return IsVarianceUnsafe(((ArrayTypeSymbol)type).ElementType' requireOutputSafety' requireInputSafety' context' locationProvider' locationArg' diagnostics); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,VarianceSafety,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\VarianceSafety.cs,IsVarianceUnsafe,The length of the statement  "                    return IsVarianceUnsafe((NamedTypeSymbol)type' requireOutputSafety' requireInputSafety' context' locationProvider' locationArg' diagnostics); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,VarianceSafety,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\VarianceSafety.cs,AddVarianceError,The length of the statement  "            // CONSIDER: instead of using the same error code for all variance errors' we could use different codes for "requires input-safe"'  " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,VarianceSafety,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\VarianceSafety.cs,AddVarianceError,The length of the statement  "            // "requires output-safe"' and "requires input-safe and output-safe".  This would make the error codes much easier to document and " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols,VarianceSafety,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\VarianceSafety.cs,AddVarianceError,The length of the statement  "            diagnostics.Add(ErrorCode.ERR_UnexpectedVariance' location' context' unsafeTypeParameter' actualVariance.Localize()' expectedVariance.Localize()); " is 146.
Long Statement,Microsoft.CodeAnalysis,CSharpExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpExtensions.cs,ReplaceTrivia,The length of the statement  "            return Syntax.SyntaxReplacer.Replace(token' trivia: new[] { oldTrivia }' computeReplacementTrivia: (o' r) => newTrivia); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,CSharpDefinitionMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\CSharpDefinitionMap.cs,TryGetStateMachineType,The length of the statement  "            if (_metadataDecoder.Module.HasStringValuedAttribute(methodHandle' AttributeDescription.AsyncStateMachineAttribute' out typeName) || " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,CSharpDefinitionMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\CSharpDefinitionMap.cs,TryGetStateMachineType,The length of the statement  "                _metadataDecoder.Module.HasStringValuedAttribute(methodHandle' AttributeDescription.IteratorStateMachineAttribute' out typeName)) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,EmitHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\EmitHelpers.cs,EmitDifference,The length of the statement  "            var serializationProperties = compilation.ConstructModuleSerializationProperties(emitOptions' runtimeMDVersion' moduleVersionId); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,EmitHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\EmitHelpers.cs,EmitDifference,The length of the statement  "                        diagnostics.Add(ErrorCode.ERR_PermissionSetAttributeFileReadError' Location.None' e.FileName' e.PropertyName' e.Message); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,EmitHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\EmitHelpers.cs,MapToCompilation,The length of the statement  "            var mappedSynthesizedMembers = matcher.MapSynthesizedMembers(previousGeneration.SynthesizedMembers' currentSynthesizedMembers); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,MatchDefs,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\CSharpSymbolMatcher.cs,VisitDefInternal,The length of the statement  "                    return this.VisitTypeMembers(otherContainer' nestedType' GetNestedTypes' (a' b) => s_nameComparer.Equals(a.Name' b.Name)); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,ExpandedVarargsMethodReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\ExpandedVarargsMethodReference.cs,GetGenericMethod,The length of the statement  "            return new ExpandedVarargsMethodReference(_underlyingMethod.AsGenericMethodInstanceReference.GetGenericMethod(context)' _argListParams); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,GenericMethodInstanceReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\GenericMethodInstanceReference.cs,GetGenericArguments,The length of the statement  "                yield return moduleBeingBuilt.Translate(arg' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,GenericNestedTypeInstanceReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\GenericNestedTypeInstanceReference.cs,GetContainingType,The length of the statement  "            return ((PEModuleBuilder)context.Module).Translate(UnderlyingNamedType.ContainingType' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics); " is 177.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,GenericTypeInstanceReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\GenericTypeInstanceReference.cs,GetGenericArguments,The length of the statement  "                builder.Add(moduleBeingBuilt.Translate(type' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,MethodReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\MethodReference.cs,GetType,The length of the statement  "            return ((PEModuleBuilder)context.Module).Translate(UnderlyingMethod.ReturnType' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,ParameterTypeInformation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\ParameterTypeInformation.cs,GetType,The length of the statement  "            return ((PEModuleBuilder)context.Module).Translate(_underlyingParameter.Type' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,PEAssemblyBuilderBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEAssemblyBuilder.cs,AddEmbeddedResourcesFromAddedModules,The length of the statement  "                    foreach (EmbeddedResource resource in ((Symbols.Metadata.PE.PEModuleSymbol)modules[i]).Module.GetEmbeddedResourcesOrThrow()) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,GetSourceAssemblyAttributes,The length of the statement  "            return SourceModule.ContainingSourceAssembly.GetCustomAttributesToEmit(this.CompilationState' emittingAssemblyAttributesInNetModule: OutputKind.IsNetModule()); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,ValidateReferencedAssembly,The length of the statement  "                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName' assembly)' NoLocation.Singleton); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,ValidateReferencedAssembly,The length of the statement  "                diagnostics.Add(new CSDiagnosticInfo(ErrorCode.WRN_RefCultureMismatch' assembly' refIdentity.CultureName)' NoLocation.Singleton); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,GetInitArrayHelper,The length of the statement  "            return (MethodSymbol)Compilation.GetWellKnownTypeMember(WellKnownMember.System_Runtime_CompilerServices_RuntimeHelpers__InitializeArrayArrayRuntimeFieldHandle); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,Translate,The length of the statement  "                    diagnostics.Add(new CSDiagnostic(diagInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType' string.Empty)' syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location)); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,MemberVisibility,The length of the statement  "            // We need to relax visibility of members in interactive submissions since they might be emitted into multiple assemblies. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,GetMethodKey,The length of the statement  "            string result = methodSymbol.ToDisplayString(methodSymbol.IsOperator() ? _testDataOperatorKeyFormat : _testDataKeyFormat); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,SpecializedFieldReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\SpecializedFieldReference.cs,GetType,The length of the statement  "            var type = ((PEModuleBuilder)context.Module).Translate(_underlyingField.Type' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,SpecializedGenericMethodInstanceReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\SpecializedGenericMethodInstanceReference.cs,GetGenericArguments,The length of the statement  "                yield return moduleBeingBuilt.Translate(arg' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,SpecializedGenericNestedTypeInstanceReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\SpecializedGenericNestedTypeInstanceReference.cs,GetGenericArguments,The length of the statement  "                builder.Add(moduleBeingBuilt.Translate(type' syntaxNodeOpt: (CSharpSyntaxNode)context.SyntaxNodeOpt' diagnostics: context.Diagnostics)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,SpecializedNestedTypeReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\SpecializedNestedTypeReference.cs,GetContainingType,The length of the statement  "            return ((PEModuleBuilder)context.Module).Translate(UnderlyingNamedType.ContainingType' (CSharpSyntaxNode)context.SyntaxNodeOpt' context.Diagnostics); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit,TypeMemberReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\TypeMemberReference.cs,GetContainingType,The length of the statement  "            return moduleBeingBuilt.Translate(UnderlyingSymbol.ContainingType' (CSharpSyntaxNode)context.SyntaxNodeOpt' context.Diagnostics); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedEvent,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedEvent.cs,EmbedCorrespondingComEventInterfaceMethodInternal,The length of the statement  "                            EmbeddedTypesManager.Error(diagnostics' ErrorCode.ERR_MissingSourceInterface' syntaxNodeOpt' underlyingContainingType' UnderlyingEvent); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedEvent,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedEvent.cs,EmbedCorrespondingComEventInterfaceMethodInternal,The length of the statement  "                            EmbeddedTypesManager.Error(diagnostics' ErrorCode.ERR_MissingMethodOnSourceInterface' syntaxNodeOpt' sourceInterface' UnderlyingEvent.MetadataName' UnderlyingEvent); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedType,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedType.cs,CreateCompilerGeneratedAttribute,The length of the statement  "            Debug.Assert(WellKnownMembers.IsSynthesizedAttributeOptional(WellKnownMember.System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor)); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedType,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedType.cs,CreateCompilerGeneratedAttribute,The length of the statement  "            return compilation.TrySynthesizeAttribute(WellKnownMember.System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedType,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedType.cs,CreateTypeIdentifierAttribute,The length of the statement  "                return new SynthesizedAttributeData(ctor' ImmutableArray<TypedConstant>.Empty' ImmutableArray<KeyValuePair<string' TypedConstant>>.Empty); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedType,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedType.cs,ReportMissingAttribute,The length of the statement  "            EmbeddedTypesManager.Error(diagnostics' ErrorCode.ERR_InteropTypeMissingAttribute' syntaxNodeOpt' UnderlyingNamedType' description.FullName); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,GetSystemStringType,The length of the statement  "                if (Interlocked.CompareExchange(ref _lazySystemStringType' typeSymbol' ErrorTypeSymbol.UnknownResultType) == ErrorTypeSymbol.UnknownResultType) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,LazyGetWellKnownTypeMethod,The length of the statement  "                if (Interlocked.CompareExchange(ref lazyMethod' symbol' ErrorMethodSymbol.UnknownMethod) == ErrorMethodSymbol.UnknownMethod) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,CreateSynthesizedAttribute,The length of the statement  "                        ImmutableArray.Create(new TypedConstant(ctor.Parameters[0].Type' TypedConstantKind.Type' ctor.ContainingAssembly.GetSpecialType(SpecialType.System_Object)))' " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,GetAssemblyGuidString,The length of the statement  "            Debug.Assert(!IsFrozen); // After we freeze the set of types' we might add additional assemblies into this map without actual guid values. " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,EmbedType,The length of the statement  "                Debug.Assert(namedType.TypeKind == TypeKind.Struct || namedType.TypeKind == TypeKind.Enum || namedType.TypeKind == TypeKind.Delegate); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,EmbedField,The length of the statement  "                ReportNotEmbeddableSymbol(ErrorCode.ERR_InteropStructContainsMethods' field.ContainingType' syntaxNodeOpt' diagnostics' this); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,EmbedMethod,The length of the statement  "                    ReportNotEmbeddableSymbol(ErrorCode.ERR_InteropStructContainsMethods' type.UnderlyingNamedType' syntaxNodeOpt' diagnostics' this); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,EmbedMethod,The length of the statement  "                        Error(diagnostics' ErrorCode.ERR_InteropMethodWithBody' syntaxNodeOpt' method.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,EmbedProperty,The length of the statement  "            EmbeddedMethod embeddedGet = (object)getMethod != null ? EmbedMethod(type' getMethod' syntaxNodeOpt' diagnostics) : null; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,EmbedProperty,The length of the statement  "            EmbeddedMethod embeddedSet = (object)setMethod != null ? EmbedMethod(type' setMethod' syntaxNodeOpt' diagnostics) : null; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,EmbedEvent,The length of the statement  "            EmbeddedMethod embeddedAdd = (object)addMethod != null ? EmbedMethod(type' addMethod' syntaxNodeOpt' diagnostics) : null; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,EmbedEvent,The length of the statement  "            EmbeddedMethod embeddedRemove = (object)removeMethod != null ? EmbedMethod(type' removeMethod' syntaxNodeOpt' diagnostics) : null; " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Cursor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Blender.Cursor.cs,MoveToFirstToken,The length of the statement  "                    for (var node = cursor.CurrentNodeOrToken; node.Kind() != SyntaxKind.None && !SyntaxFacts.IsAnyToken(node.Kind()); node = cursor.CurrentNodeOrToken) " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Reader,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Blender.Reader.cs,CanReuse,The length of the statement  "                    (nodeOrToken.IsToken && ((CSharpSyntaxNode)nodeOrToken.AsToken().Node).ContainsSkippedText && nodeOrToken.Parent.ContainsDiagnostics)) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Reader,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Blender.Reader.cs,CreateBlendedNode,The length of the statement  "                    new Blender(_lexer' _oldTreeCursor' _changes' _newPosition' _changeDelta' _newDirectives' _oldDirectives' _newLexerDrivenMode)); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseDirective,The length of the statement  "                    result = this.ParseDefineOrUndefDirective(hash' this.EatContextualToken(contextualKind)' isActive' isAfterFirstTokenInFile && !isAfterNonWhitespaceOnLine); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseDirective,The length of the statement  "                    result = this.ParseReferenceDirective(hash' this.EatContextualToken(contextualKind)' isActive' isAfterFirstTokenInFile && !isAfterNonWhitespaceOnLine); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseElifDirective,The length of the statement  "                eod = eod.WithLeadingTrivia(SyntaxList.Concat(SyntaxFactory.DisabledText(expr.ToFullString())' eod.GetLeadingTrivia())); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseElifDirective,The length of the statement  "                    return this.AddError(SyntaxFactory.BadDirectiveTrivia(hash' keyword' eod' isActive)' ErrorCode.ERR_EndRegionDirectiveExpected); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseElifDirective,The length of the statement  "                    return this.AddError(SyntaxFactory.BadDirectiveTrivia(hash' keyword' eod' isActive)' ErrorCode.ERR_EndifDirectiveExpected); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseElifDirective,The length of the statement  "                    return this.AddError(SyntaxFactory.BadDirectiveTrivia(hash' keyword' eod' isActive)' ErrorCode.ERR_UnexpectedDirective); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseElseDirective,The length of the statement  "                return this.AddError(SyntaxFactory.BadDirectiveTrivia(hash' keyword' eod' isActive)' ErrorCode.ERR_EndRegionDirectiveExpected); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseElseDirective,The length of the statement  "                return this.AddError(SyntaxFactory.BadDirectiveTrivia(hash' keyword' eod' isActive)' ErrorCode.ERR_EndifDirectiveExpected); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseElseDirective,The length of the statement  "                return this.AddError(SyntaxFactory.BadDirectiveTrivia(hash' keyword' eod' isActive)' ErrorCode.ERR_UnexpectedDirective); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseEndIfDirective,The length of the statement  "                return this.AddError(SyntaxFactory.BadDirectiveTrivia(hash' keyword' eod' isActive)' ErrorCode.ERR_EndRegionDirectiveExpected); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseEndIfDirective,The length of the statement  "                return this.AddError(SyntaxFactory.BadDirectiveTrivia(hash' keyword' eod' isActive)' ErrorCode.ERR_UnexpectedDirective); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseRegionDirective,The length of the statement  "            return SyntaxFactory.RegionDirectiveTrivia(hash' keyword' this.ParseEndOfDirectiveWithOptionalPreprocessingMessage()' isActive); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseEndRegionDirective,The length of the statement  "                return this.AddError(SyntaxFactory.BadDirectiveTrivia(hash' keyword' eod' isActive)' ErrorCode.ERR_EndifDirectiveExpected); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseEndRegionDirective,The length of the statement  "                return this.AddError(SyntaxFactory.BadDirectiveTrivia(hash' keyword' eod' isActive)' ErrorCode.ERR_UnexpectedDirective); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseErrorOrWarningDirective,The length of the statement  "                eod = this.AddError(eod' triviaOffset' triviaWidth' isError ? ErrorCode.ERR_ErrorDirective : ErrorCode.WRN_WarningDirective' triviaBuilder.ToString()); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseLineDirective,The length of the statement  "                        (line.IsMissing || line.GetTrailingTriviaWidth() > 0 || this.CurrentToken.GetLeadingTriviaWidth() > 0)) //require separation between line number and file name " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseReferenceDirective,The length of the statement  "            var end = this.ParseEndOfDirective(ignoreErrors: file.IsMissing || !isActive' afterPragma: false' afterLineNumber: false' afterReference: true); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParsePragmaDirective,The length of the statement  "                            id = this.EatToken(SyntaxKind.NumericLiteralToken' ErrorCode.WRN_IdentifierOrNumericLiteralExpected' reportError: isActive); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParsePragmaDirective,The length of the statement  "                    return SyntaxFactory.PragmaWarningDirectiveTrivia(hash' pragma' warning' style' default(SeparatedSyntaxList<ExpressionSyntax>)' end' isActive); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParsePragmaDirective,The length of the statement  "                var guid = this.EatToken(SyntaxKind.StringLiteralToken' ErrorCode.WRN_IllegalPPChecksum' reportError: isActive && !file.IsMissing); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParsePragmaDirective,The length of the statement  "                var bytes = this.EatToken(SyntaxKind.StringLiteralToken' ErrorCode.WRN_IllegalPPChecksum' reportError: isActive && !guid.IsMissing); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParsePragmaDirective,The length of the statement  "                return SyntaxFactory.PragmaWarningDirectiveTrivia(hash' pragma' warning' style' default(SeparatedSyntaxList<ExpressionSyntax>)' eod' isActive); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseEquality,The length of the statement  "            while (this.CurrentToken.Kind == SyntaxKind.EqualsEqualsToken || this.CurrentToken.Kind == SyntaxKind.ExclamationEqualsToken) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveStack,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Directives.cs,HasPreviousIfOrElif,The length of the statement  "            return prev != null && prev.Any() && (prev.Head.Kind == SyntaxKind.IfDirectiveTrivia || prev.Head.Kind == SyntaxKind.ElifDirectiveTrivia); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveStack,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Directives.cs,Add,The length of the statement  "                    return new DirectiveStack(CompleteRegion(_directives)); // remove region directives from stack but leave everything else " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveStack,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Directives.cs,Add,The length of the statement  "                    return new DirectiveStack(new ConsList<Directive>(directive' _directives != null ? _directives : ConsList<Directive>.Empty)); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseDocumentationComment,The length of the statement  "                isTerminated = !_isDelimited || (eoc.LeadingTrivia.Count > 0 && eoc.LeadingTrivia[eoc.LeadingTrivia.Count - 1].ToString() == "*/"); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseDocumentationComment,The length of the statement  "                SyntaxKind kind = _isDelimited ? SyntaxKind.MultiLineDocumentationCommentTrivia : SyntaxKind.SingleLineDocumentationCommentTrivia; " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseXmlAttribute,The length of the statement  "            if (hasNoPrefix && DocumentationCommentXmlNames.AttributeEquals(attrNameText' DocumentationCommentXmlNames.CrefAttributeName) && " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseXmlAttribute,The length of the statement  "            else if (hasNoPrefix && DocumentationCommentXmlNames.AttributeEquals(attrNameText' DocumentationCommentXmlNames.NameAttributeName) && " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseXmlName,The length of the statement  "                    colon = WithAdditionalDiagnostics(colon' new XmlSyntaxDiagnosticInfo(offset' width' XmlParseErrorCode.XML_InvalidWhitespace)); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseXmlName,The length of the statement  "                    id = WithAdditionalDiagnostics(id' new XmlSyntaxDiagnosticInfo(offset' width' XmlParseErrorCode.XML_InvalidWhitespace)); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseXmlName,The length of the statement  "                    // CONSIDER: Another interpretation would be that the local part of this name is a missing identifier and the identifier " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseXmlProcessingInstruction,The length of the statement  "            return SyntaxFactory.XmlProcessingInstruction(startProcessingInstructionToken' name' textTokens' endProcessingInstructionToken); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,GetExpectedTokenError,The length of the statement  "            // NOTE: There are no errors in crefs - only warnings.  We accomplish this by wrapping every diagnostic in ErrorCode.WRN_ErrorOverride. " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,GetExpectedTokenError,The length of the statement  "                SyntaxDiagnosticInfo crefInfo = new SyntaxDiagnosticInfo(rawInfo.Offset' rawInfo.Width' ErrorCode.WRN_ErrorOverride' rawInfo' rawInfo.Code); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,GetExpectedTokenError,The length of the statement  "            // NOTE: There are no errors in crefs - only warnings.  We accomplish this by wrapping every diagnostic in ErrorCode.WRN_ErrorOverride. " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseOperatorMemberCref,The length of the statement  "                if (SyntaxFacts.IsUnaryOperatorDeclarationToken(CurrentToken.Kind) || SyntaxFacts.IsBinaryExpressionOperatorToken(CurrentToken.Kind)) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseOperatorMemberCref,The length of the statement  "                SyntaxDiagnosticInfo crefInfo = new SyntaxDiagnosticInfo(offset' width' ErrorCode.WRN_ErrorOverride' rawInfo' rawInfo.Code); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseOperatorMemberCref,The length of the statement  "            if (operatorToken.Kind == SyntaxKind.GreaterThanToken && operatorToken.GetTrailingTriviaWidth() == 0 && CurrentToken.GetLeadingTriviaWidth() == 0) " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseOperatorMemberCref,The length of the statement  "                    SyntaxDiagnosticInfo crefInfo = new SyntaxDiagnosticInfo(offset' width' ErrorCode.WRN_ErrorOverride' rawInfo' rawInfo.Code); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseCrefName,The length of the statement  "                            new SyntaxDiagnosticInfo(ErrorCode.ERR_TypeParamMustBeIdentifier)' $"{(int)ErrorCode.ERR_TypeParamMustBeIdentifier:d4}"); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseCrefTypeSuffix,The length of the statement  "                var omittedArraySizeExpressionInstance = SyntaxFactory.OmittedArraySizeExpression(SyntaxFactory.Token(SyntaxKind.OmittedArraySizeExpressionToken)); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseNamespaceDeclaration,The length of the statement  "                return _syntaxFactory.NamespaceDeclaration(namespaceToken' name' openBrace' body.Externs' body.Usings' body.Members' closeBrace' semicolon); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,AddSkippedNamespaceText,The length of the statement  "                body.Attributes[body.Attributes.Count - 1] = AddTrailingSkippedSyntax(body.Attributes[body.Attributes.Count - 1]' skippedSyntax); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseUsingDirective,The length of the statement  "                name = WithAdditionalDiagnostics(CreateMissingIdentifierName()' GetExpectedTokenError(SyntaxKind.IdentifierToken' this.CurrentToken.Kind)); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAttributeArgumentList,The length of the statement  "                        else if (this.SkipBadAttributeArgumentTokens(ref openParen' argNodes' SyntaxKind.IdentifierToken) == PostSkipAction.Continue) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseModifiers,The length of the statement  "                                    ((currToken.Kind == SyntaxKind.ExplicitKeyword || currToken.Kind == SyntaxKind.ImplicitKeyword) && PeekToken(1).Kind == SyntaxKind.OperatorKeyword) || " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseModifiers,The length of the statement  "                                    (ScanType() != ScanTypeFlags.NotType && (this.CurrentToken.Kind == SyntaxKind.OperatorKeyword || IsPossibleMemberName()))) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseClassOrStructOrInterfaceDeclaration,The length of the statement  "            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ClassKeyword || this.CurrentToken.Kind == SyntaxKind.StructKeyword || this.CurrentToken.Kind == SyntaxKind.InterfaceKeyword); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseClassOrStructOrInterfaceDeclaration,The length of the statement  "            var typeParameters = this.ParseTypeParameterList(allowVariance: classOrStructOrInterface.Kind == SyntaxKind.InterfaceKeyword); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseClassOrStructOrInterfaceDeclaration,The length of the statement  "                    closeBrace = WithAdditionalDiagnostics(closeBrace' this.GetExpectedTokenError(SyntaxKind.CloseBraceToken' this.CurrentToken.Kind)); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadMemberListTokens,The length of the statement  "                        !(kind == SyntaxKind.DelegateKeyword && (this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken || this.PeekToken(1).Kind == SyntaxKind.OpenParenToken))) " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadBaseListTokens,The length of the statement  "                p => p.CurrentToken.Kind == SyntaxKind.OpenBraceToken || p.IsPossibleTypeParameterConstraintClauseStart() || p.IsTerminator()' " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseTypeParameterConstraintClause,The length of the statement  "                    bounds.Add(_syntaxFactory.TypeConstraint(this.AddError(this.CreateMissingIdentifierName()' ErrorCode.ERR_TypeExpected))); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseTypeParameterConstraintClause,The length of the statement  "                                bounds.Add(_syntaxFactory.TypeConstraint(this.AddError(this.CreateMissingIdentifierName()' ErrorCode.ERR_TypeExpected))); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseTypeParameterConstraint,The length of the statement  "                    return _syntaxFactory.ClassOrStructConstraint(isStruct ? SyntaxKind.StructConstraint : SyntaxKind.ClassConstraint' token); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadTypeParameterConstraintTokens,The length of the statement  "                p => this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || this.IsPossibleTypeParameterConstraintClauseStart() || this.IsTerminator()' " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The length of the statement  "                // Doing this before parsing modifiers simplifies further analysis since some of these keywords can act as modifiers as well. " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The length of the statement  "                        return this.ParseMethodDeclaration(attributes' modifiers' voidType' explicitInterfaceOpt: null' identifier: identifier' typeParameterList: null); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The length of the statement  "                        (this.CurrentToken.Kind == SyntaxKind.OperatorKeyword && !SyntaxFacts.IsAnyOverloadableOperator(this.PeekToken(1).Kind))) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The length of the statement  "                    var incompleteMember = _syntaxFactory.IncompleteMember(attributes' modifiers.ToTokenList()' type.IsMissing ? null : type); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The length of the statement  "                    ReconsiderTypeAsAsyncModifier(ref modifiers' ref type' ref explicitInterfaceOpt' identifierOrThisOpt' typeParameterListOpt)) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The length of the statement  "                    return this.ParseIndexerDeclaration(attributes' modifiers' type' explicitInterfaceOpt' identifierOrThisOpt' typeParameterListOpt); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The length of the statement  "                            return this.ParsePropertyDeclaration(attributes' modifiers' type' explicitInterfaceOpt' identifierOrThisOpt' typeParameterListOpt); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The length of the statement  "                            return this.ParseMethodDeclaration(attributes' modifiers' type' explicitInterfaceOpt' identifierOrThisOpt' typeParameterListOpt); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,TypeArgumentFromTypeParameters,The length of the statement  "            var result = _syntaxFactory.TypeArgumentList(typeParameterList.LessThanToken' types.ToList()' typeParameterList.GreaterThanToken); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseConstructorDeclaration,The length of the statement  "                var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false' allowDefaults: true' allowAttributes: true); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseConstructorDeclaration,The length of the statement  "                return _syntaxFactory.ConstructorDeclaration(attributes' modifiers.ToTokenList()' name' paramList' initializer' body' semicolon); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseDestructorDeclaration,The length of the statement  "            return _syntaxFactory.DestructorDeclaration(attributes' modifiers.ToTokenList()' tilde' name' parameterList' body' semicolon); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMethodDeclaration,The length of the statement  "            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: true' allowDefaults: true' allowAttributes: true); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMethodDeclaration,The length of the statement  "                    // Use else if' rather than if' because if we see both a constructor initializer and a constraint clause' we're too lost to recover. " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseConversionOperatorDeclaration,The length of the statement  "            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false' allowDefaults: true' allowAttributes: true); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseOperatorDeclaration,The length of the statement  "                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset' opTokenErrorWidth' ErrorCode.ERR_BadOperatorSyntax' SyntaxFacts.GetText(SyntaxKind.PlusToken)); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseOperatorDeclaration,The length of the statement  "                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia()' SyntaxKind.GreaterThanGreaterThanToken' opToken2.GetTrailingTrivia()); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseOperatorDeclaration,The length of the statement  "            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: false' allowDefaults: true' allowAttributes: true); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseOperatorDeclaration,The length of the statement  "                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset' opTokenErrorWidth' ErrorCode.ERR_OvlUnaryOperatorExpected); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseOperatorDeclaration,The length of the statement  "                        SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset' opTokenErrorWidth' ErrorCode.ERR_OvlBinaryOperatorExpected); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadSeparatedListTokensWithExpectedKind,The length of the statement  "            var action = this.SkipBadListTokensWithExpectedKindHelper(list.UnderlyingBuilder' isNotExpectedFunction' abortFunction' expected' out trailingTrivia); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadListTokensWithErrorCode,The length of the statement  "            var action = this.SkipBadListTokensWithErrorCodeHelper(list' isNotExpectedFunction' abortFunction' error' out trailingTrivia); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadTokensWithErrorCode,The length of the statement  "                    var token = (first && !this.CurrentToken.ContainsDiagnostics) ? this.EatTokenWithPrejudice(errorCode) : this.EatToken(); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAccessorDeclaration,The length of the statement  "                    accessorName = this.AddError(accessorName' isEvent ? ErrorCode.ERR_AddOrRemoveExpected : ErrorCode.ERR_GetOrSetExpected); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAccessorDeclaration,The length of the statement  "                if (this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || (validAccName && !currentTokenIsSemicolon && !IsTerminator())) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAccessorDeclaration,The length of the statement  "                return _syntaxFactory.AccessorDeclaration(accessorKind' accAttrs' accMods.ToTokenList()' accessorName' body' semicolon); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseParenthesizedParameterList,The length of the statement  "            if (this.IsIncrementalAndFactoryContextMatches && CanReuseParameterList(this.CurrentNode as CSharp.Syntax.ParameterListSyntax)) " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseParenthesizedParameterList,The length of the statement  "                this.ParseParameterList(out open' parameters' out close' openKind' closeKind' allowThisKeyword' allowDefaults' allowAttributes); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseBracketedParameterList,The length of the statement  "            if (this.IsIncrementalAndFactoryContextMatches && CanReuseBracketedParameterList(this.CurrentNode as CSharp.Syntax.BracketedParameterListSyntax)) " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseBracketedParameterList,The length of the statement  "                this.ParseParameterList(out open' parameters' out close' openKind' closeKind' allowThisKeyword: false' allowDefaults: allowDefaults' allowAttributes: true); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseParameterList,The length of the statement  "                            else if (this.SkipBadParameterListTokens(ref open' nodes' SyntaxKind.CommaToken' closeKind' allowThisKeyword) == PostSkipAction.Abort) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseParameterList,The length of the statement  "                    else if (this.SkipBadParameterListTokens(ref open' nodes' SyntaxKind.IdentifierToken' closeKind' allowThisKeyword) == PostSkipAction.Continue) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseParameterList,The length of the statement  "                        nodes[mustBeLastIndex] = this.AddError(nodes[mustBeLastIndex]' mustBeLastHadParams ? ErrorCode.ERR_ParamsLast : ErrorCode.ERR_VarargsLast); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseParameter,The length of the statement  "            if (this.IsIncrementalAndFactoryContextMatches && CanReuseParameter(this.CurrentNode as CSharp.Syntax.ParameterSyntax' attributes' modifiers)) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseParameter,The length of the statement  "                type = WithAdditionalDiagnostics(type' this.GetExpectedTokenError(SyntaxKind.CloseParenToken' SyntaxKind.IdentifierToken' 0' type.Width)); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseEventFieldDeclaration,The length of the statement  "                    eventToken = this.AddError(eventToken' ErrorCode.ERR_ExplicitEventFieldImpl);  // Better error message for confusing event situation. " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseVariableDeclarators,The length of the statement  "            // Although we try parse variable declarations in contexts where they are not allowed (non-interactive top-level or a namespace)  " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseVariableDeclarators,The length of the statement  "                else if (!variableDeclarationsExpected || this.SkipBadVariableListTokens(variables' SyntaxKind.CommaToken) == PostSkipAction.Abort) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetOriginalVariableFlags,The length of the statement  "            if (parent != null && (parent.Kind() == SyntaxKind.VariableDeclaration || parent.Kind() == SyntaxKind.LocalDeclarationStatement)) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseVariableDeclarator,The length of the statement  "            if (this.IsIncrementalAndFactoryContextMatches && CanReuseVariableDeclarator(this.CurrentNode as CSharp.Syntax.VariableDeclaratorSyntax' flags' isFirst)) " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseVariableDeclarator,The length of the statement  "                    var specifier = this.ParseArrayRankSpecifier(isArrayCreation: false' expectSizes: flags == VariableFlags.Fixed' sawNonOmittedSize: out sawNonOmittedSize); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseVariableInitializer,The length of the statement  "                        stackAllocExpr = this.AddErrorToFirstToken(stackAllocExpr' ErrorCode.ERR_InvalidExprTerm' SyntaxFacts.GetText(SyntaxKind.StackAllocKeyword)); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseDelegateDeclaration,The length of the statement  "            var parameterList = this.ParseParenthesizedParameterList(allowThisKeyword: false' allowDefaults: true' allowAttributes: true); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseDelegateDeclaration,The length of the statement  "                return _syntaxFactory.DelegateDeclaration(attributes' modifiers.ToTokenList()' delegateToken' type' name' typeParameters' parameterList' constraints' semicolon); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseEnumMemberDeclarations,The length of the statement  "                if (this.IsPossibleEnumMemberDeclaration() || this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken) " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseEnumMemberDeclarations,The length of the statement  "                        else if (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.SemicolonToken || this.IsPossibleEnumMemberDeclaration()) " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseEnumMemberDeclarations,The length of the statement  "                else if (this.SkipBadEnumMemberListTokens(ref openBrace' members' SyntaxKind.IdentifierToken) == PostSkipAction.Continue) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadEnumMemberListTokens,The length of the statement  "                p => p.CurrentToken.Kind != SyntaxKind.CommaToken && p.CurrentToken.Kind != SyntaxKind.SemicolonToken && !p.IsPossibleEnumMemberDeclaration()' " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseSimpleName,The length of the statement  "                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0)) " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanPossibleTypeArgumentList,The length of the statement  "                    // We currently do not have the ability to scan attributes' so if this is an open square' we early out and assume it is an attribute " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseTypeArgumentList,The length of the statement  "                var omittedTypeArgumentInstance = _syntaxFactory.OmittedTypeArgument(SyntaxFactory.Token(SyntaxKind.OmittedTypeArgumentToken)); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberName,The length of the statement  "                            Debug.Assert(!ReferenceEquals(tmp' explicitInterfaceName)' "We should have consumed something and updated explicitInterfaceName"); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberName,The length of the statement  "                        separator = WithAdditionalDiagnostics(separator' GetExpectedTokenError(SyntaxKind.DotToken' separator.Kind' separator.GetLeadingTriviaWidth()' separator.Width)); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseQualifiedNameRight,The length of the statement  "                    return WithAdditionalDiagnostics(_syntaxFactory.AliasQualifiedName(identifierLeft' separator' right)' left.GetDiagnostics()); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseTypeCore,The length of the statement  "                    if (isOrAs && (IsTerm() || IsPredefinedType(this.CurrentToken.Kind) || SyntaxFacts.IsAnyUnaryExpression(this.CurrentToken.Kind))) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseArrayRankSpecifier,The length of the statement  "                var omittedArraySizeExpressionInstance = _syntaxFactory.OmittedArraySizeExpression(SyntaxFactory.Token(SyntaxKind.OmittedArraySizeExpressionToken)); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleYieldStatement,The length of the statement  "            return this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword && (this.PeekToken(1).Kind == SyntaxKind.ReturnKeyword || this.PeekToken(1).Kind == SyntaxKind.BreakKeyword); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleLocalDeclarationStatement,The length of the statement  "                // We could always return true for st == AliasQualName in addition to MustBeType on the first line' however' we want it to return false in the case where " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleLocalDeclarationStatement,The length of the statement  "                // CurrentToken.Kind != SyntaxKind.Identifier so that error cases' like: A::N()' are not parsed as variable declarations and instead are parsed as A.N() where we can give " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleMethodDeclarationFollowingNullableType,The length of the statement  "            var paramList = this.ParseParenthesizedParameterList(allowThisKeyword: true' allowDefaults: true' allowAttributes: true); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseEmbeddedStatement,The length of the statement  "            if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken && (!complexCheck || this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)) " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseEmbeddedStatement,The length of the statement  "            if (statement != null && (statement.Kind == SyntaxKind.LabeledStatement || statement.Kind == SyntaxKind.LocalDeclarationStatement)) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseTryStatement,The length of the statement  "                block = _syntaxFactory.Block(this.EatToken(SyntaxKind.OpenBraceToken)' default(SyntaxList<StatementSyntax>)' this.EatToken(SyntaxKind.CloseBraceToken)); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseCheckedStatement,The length of the statement  "            Debug.Assert(this.CurrentToken.Kind == SyntaxKind.CheckedKeyword || this.CurrentToken.Kind == SyntaxKind.UncheckedKeyword); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseForStatement,The length of the statement  "                return _syntaxFactory.ForStatement(@for' openParen' decl' initializers' semi' condition' semi2' incrementors' closeParen' statement); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseForStatementExpressionList,The length of the statement  "                        else if (this.SkipBadForStatementExpressionListTokens(ref startToken' list' SyntaxKind.CommaToken) == PostSkipAction.Abort) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseForStatementExpressionList,The length of the statement  "                else if (this.SkipBadForStatementExpressionListTokens(ref startToken' list' SyntaxKind.IdentifierToken) == PostSkipAction.Continue) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadForStatementExpressionListTokens,The length of the statement  "                p => p.CurrentToken.Kind == SyntaxKind.CloseParenToken || p.CurrentToken.Kind == SyntaxKind.SemicolonToken || p.IsTerminator()' " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseForEachStatement,The length of the statement  "                skippedForToken = this.AddError(skippedForToken' ErrorCode.ERR_SyntaxError' SyntaxFacts.GetText(SyntaxKind.ForEachKeyword)' SyntaxFacts.GetText(SyntaxKind.ForKeyword)); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseSubExpressionCore,The length of the statement  "                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseSubExpressionCore,The length of the statement  "                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken; " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseTerm,The length of the statement  "                        if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword && this.PeekToken(1).Kind == SyntaxKind.DelegateKeyword) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParsePostFixExpression,The length of the statement  "                            expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' expr' dotToken' this.ParseSimpleName(NameOptions.InExpression)); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParsePostFixExpression,The length of the statement  "                        expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.PointerMemberAccessExpression' expr' this.EatToken()' this.ParseSimpleName(NameOptions.InExpression)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParsePostFixExpression,The length of the statement  "                        expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' expr' this.EatToken()' this.ParseSimpleName(NameOptions.InExpression)); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseConsequenceSyntax,The length of the statement  "                        expr = _syntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' expr' this.EatToken()' this.ParseSimpleName(NameOptions.InExpression)); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseBracketedArgumentList,The length of the statement  "            ParseArgumentList(out openToken' out arguments' out closeToken' SyntaxKind.OpenBracketToken' SyntaxKind.CloseBracketToken); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseArgumentList,The length of the statement  "                    else if (this.SkipBadArgumentListTokens(ref open' list' SyntaxKind.IdentifierToken' closeKind) == PostSkipAction.Continue) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseArgumentExpression,The length of the statement  "            if (isIndexer && (this.CurrentToken.Kind == SyntaxKind.CommaToken || this.CurrentToken.Kind == SyntaxKind.CloseBracketToken)) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseCheckedOrUncheckedExpression,The length of the statement  "            Debug.Assert(checkedOrUnchecked.Kind == SyntaxKind.CheckedKeyword || checkedOrUnchecked.Kind == SyntaxKind.UncheckedKeyword); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseCheckedOrUncheckedExpression,The length of the statement  "            var kind = (checkedOrUnchecked.Kind == SyntaxKind.CheckedKeyword) ? SyntaxKind.CheckedExpression : SyntaxKind.UncheckedExpression; " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanCast,The length of the statement  "            return (type == ScanTypeFlags.GenericTypeOrMethod || type == ScanTypeFlags.GenericTypeOrExpression || type == ScanTypeFlags.NonGenericTypeOrExpression) && CanFollowCast(this.CurrentToken.Kind); " is 193.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanAsyncLambda,The length of the statement  "            if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseArrayOrObjectCreationExpression,The length of the statement  "            var type = this.ParseTypeCore(parentIsParameter: false' isOrAs: false' expectSizes: isPossibleArrayCreation' isArrayCreation: isPossibleArrayCreation); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseObjectOrCollectionInitializer,The length of the statement  "                openBrace = CheckFeatureAvailability(openBrace' isObjectInitializer ? MessageID.IDS_FeatureObjectInitializer : MessageID.IDS_FeatureCollectionInitializer); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseObjectOrCollectionInitializerMembers,The length of the statement  "                else if (this.SkipBadInitializerListTokens(ref startToken' list' SyntaxKind.IdentifierToken) == PostSkipAction.Continue) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseComplexElementInitializer,The length of the statement  "                return _syntaxFactory.InitializerExpression(SyntaxKind.ComplexElementInitializerExpression' openBrace' initializers' closeBrace); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseImplicitlyTypedArrayCreation,The length of the statement  "                return _syntaxFactory.ImplicitArrayCreationExpression(@new' openBracket' commas.ToTokenList()' closeBracket' initializer); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseStackAllocExpression,The length of the statement  "            var elementType = this.ParseTypeCore(parentIsParameter: false' isOrAs: false' expectSizes: true' isArrayCreation: false); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAnonymousMethodExpression,The length of the statement  "                parameterList = this.ParseParenthesizedParameterList(allowThisKeyword: false' allowDefaults: false' allowAttributes: false); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseLambdaExpression,The length of the statement  "            if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword && PeekToken(1).Kind != SyntaxKind.EqualsGreaterThanToken) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseLambdaExpression,The length of the statement  "                    _syntaxFactory.Parameter(default(SyntaxList<AttributeListSyntax>)' default(SyntaxList<SyntaxToken>)' type: null' identifier: name' @default: null)' " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseLambdaParameterList,The length of the statement  "                            else if (this.SkipBadLambdaParameterListTokens(ref openParen' nodes' SyntaxKind.CommaToken' SyntaxKind.CloseParenToken) == PostSkipAction.Abort) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseLambdaParameterList,The length of the statement  "                    else if (this.SkipBadLambdaParameterListTokens(ref openParen' nodes' SyntaxKind.IdentifierToken' SyntaxKind.CloseParenToken) == PostSkipAction.Continue) " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseLambdaParameter,The length of the statement  "            bool isRefOrOutOrParams = this.CurrentToken.Kind == SyntaxKind.RefKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword || this.CurrentToken.Kind == SyntaxKind.ParamsKeyword; " is 179.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseLambdaParameter,The length of the statement  "            return _syntaxFactory.Parameter(default(SyntaxList<AttributeListSyntax>)' refOrOutOrParams' paramType' paramName' null); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsQueryExpressionAfterFrom,The length of the statement  "                if (isType != ScanTypeFlags.NotType && (this.CurrentToken.Kind == SyntaxKind.IdentifierToken || this.CurrentToken.Kind == SyntaxKind.InKeyword)) " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseQueryBody,The length of the statement  "                        selectOrGroupBy = this.AddError(_syntaxFactory.SelectClause(SyntaxFactory.MissingToken(SyntaxKind.SelectKeyword)' this.CreateMissingIdentifierName())' ErrorCode.ERR_ExpectedSelectOrGroup); " is 188.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseFromClause,The length of the statement  "                (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || SyntaxFacts.IsQueryContextualKeyword(this.CurrentToken.ContextualKind))) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseFromClause,The length of the statement  "                name = WithAdditionalDiagnostics(name' this.GetExpectedTokenError(SyntaxKind.IdentifierToken' name.ContextualKind' name.GetLeadingTriviaWidth()' name.Width)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseJoinClause,The length of the statement  "            return _syntaxFactory.JoinClause(@join' type' name' @in' inExpression' @on' leftExpression' @equals' rightExpression' joinInto); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetResetPoint,The length of the statement  "            return new ResetPoint(base.GetResetPoint()' _termState' _isInTry' _syntaxFactoryContext.IsInAsync' _syntaxFactoryContext.QueryDepth); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseInterpolatedStringToken,The length of the statement  "                originalToken.GetLeadingTrivia()' isVerbatim ? SyntaxKind.InterpolatedVerbatimStringStartToken : SyntaxKind.InterpolatedStringStartToken' null); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseInterpolatedStringToken,The length of the statement  "                ? SyntaxFactory.MissingToken(SyntaxKind.InterpolatedStringEndToken).WithTrailingTrivia(originalToken.GetTrailingTrivia()) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseInterpolatedStringToken,The length of the statement  "                    var text = Substring(originalText' (i == 0) ? (openQuoteIndex + 1) : (interpolations[i - 1].CloseBracePosition + 1)' interpolation.OpenBracePosition - 1); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseInterpolatedStringToken,The length of the statement  "                var lastText = Substring(originalText' interpolations[interpolations.Count - 1].CloseBracePosition + 1' closeQuoteIndex - 1); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseInterpolation,The length of the statement  "            var parsedText = Substring(text' interpolation.OpenBracePosition' interpolation.HasColon ? interpolation.ColonPosition - 1 : interpolation.CloseBracePosition - 1); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseInterpolation,The length of the statement  "            Debug.Assert(Substring(text' interpolation.OpenBracePosition' interpolation.LastPosition) == result.ToFullString()); // yield from text equals yield from node " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanNumericLiteral,The length of the statement  "                    // * If the literal has no suffix' it has the first of these types in which its value can be represented: int' uint' long' ulong. " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanNumericLiteral,The length of the statement  "                        // * If the literal is suffixed by U or u' it has the first of these types in which its value can be represented: uint' ulong. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanNumericLiteral,The length of the statement  "                    // * If the literal is suffixed by L or l' it has the first of these types in which its value can be represented: long' ulong. " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,GetValueInt32,The length of the statement  "            if (!Int32.TryParse(text' isHex ? NumberStyles.AllowHexSpecifier : NumberStyles.None' CultureInfo.InvariantCulture' out result)) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,GetValueUInt64,The length of the statement  "            if (!UInt64.TryParse(text' isHex ? NumberStyles.AllowHexSpecifier : NumberStyles.None' CultureInfo.InvariantCulture' out result)) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,GetValueDouble,The length of the statement  "            if (!Double.TryParse(text' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture' out result)) " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,GetValueSingle,The length of the statement  "            if (!Single.TryParse(text' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture' out result)) " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,GetValueDecimal,The length of the statement  "            if (!decimal.TryParse(text' NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent' CultureInfo.InvariantCulture' out result)) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_SlowPath,The length of the statement  "                    Debug.Assert(string.Equals(info.Text.Substring(0' objectAddressOffset + 1)' "@0x"' StringComparison.OrdinalIgnoreCase)); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocComment,The length of the statement  "            Debug.Assert(this.LocationIs(XmlDocCommentLocation.End) || TextWindow.PeekChar() == SlidingTextWindow.InvalidCharacter); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,MatchesProductionForXmlChar,The length of the statement  "            // Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF] /* any Unicode character' excluding the surrogate blocks' FFFE' and FFFF. */ " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlCrefToken,The length of the statement  "                    // GreaterThanGreaterThanToken is synthesized in the parser since it is ambiguous (with closing nested type parameter lists) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlCrefToken,The length of the statement  "                    if (!InXmlNameAttributeValue && !info.IsVerbatim && !info.HasIdentifierEscapeSequence && _cache.TryGetKeywordKind(info.StringValue' out keywordKind)) " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The length of the statement  "                            if (this.StyleIs(XmlDocCommentStyle.SingleLine) && TextWindow.PeekChar(1) == '/' && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/') " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,NextCharOrUnicodeEscape,The length of the statement  "            Debug.Assert(ch != InvalidCharacter' "Precondition established by all callers; required for correctness of AdvanceChar() call."); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxParser.cs,CheckFeatureAvailability,The length of the statement  "                SyntaxDiagnosticInfo rawInfo = new SyntaxDiagnosticInfo(availableVersion.GetErrorCode()' featureName' requiredVersion.Localize()); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\Syntax.cs,Token,The length of the statement  "            return kind >= SyntaxToken.FirstTokenWithWellKnownText && kind <= SyntaxToken.LastTokenWithWellKnownText && text == defaultText && valueText == defaultText " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,CSharpSyntaxRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxRewriter.cs,VisitList,The length of the statement  "                    Debug.Assert(visited != null && visited.Kind != SyntaxKind.None' "Cannot remove node using Syntax.InternalSyntax.SyntaxRewriter."); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,MissingTokenWithTrivia,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.MissingTokenWithTrivia.cs,SetDiagnostics,The length of the statement  "                return new MissingTokenWithTrivia(this.Kind' this.LeadingField' this.TrailingField' diagnostics' this.GetAnnotations()); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,MissingTokenWithTrivia,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.MissingTokenWithTrivia.cs,SetAnnotations,The length of the statement  "                return new MissingTokenWithTrivia(this.Kind' this.LeadingField' this.TrailingField' this.GetDiagnostics()' annotations); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifier,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifier.cs,WithLeadingTrivia,The length of the statement  "                return new SyntaxIdentifierWithTrivia(this.Kind' this.TextField' this.TextField' trivia' null' this.GetDiagnostics()' this.GetAnnotations()); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifier,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifier.cs,WithTrailingTrivia,The length of the statement  "                return new SyntaxIdentifierWithTrivia(this.Kind' this.TextField' this.TextField' null' trivia' this.GetDiagnostics()' this.GetAnnotations()); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierExtended,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierExtended.cs,WithLeadingTrivia,The length of the statement  "                return new SyntaxIdentifierWithTrivia(this.contextualKind' this.TextField' this.valueText' trivia' null' this.GetDiagnostics()' this.GetAnnotations()); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierExtended,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierExtended.cs,WithTrailingTrivia,The length of the statement  "                return new SyntaxIdentifierWithTrivia(this.contextualKind' this.TextField' this.valueText' null' trivia' this.GetDiagnostics()' this.GetAnnotations()); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierExtended,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierExtended.cs,SetDiagnostics,The length of the statement  "                return new SyntaxIdentifierExtended(this.contextualKind' this.TextField' this.valueText' diagnostics' this.GetAnnotations()); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierExtended,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierExtended.cs,SetAnnotations,The length of the statement  "                return new SyntaxIdentifierExtended(this.contextualKind' this.TextField' this.valueText' this.GetDiagnostics()' annotations); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierWithTrailingTrivia,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierWithTrailingTrivia.cs,WithLeadingTrivia,The length of the statement  "                return new SyntaxIdentifierWithTrivia(this.Kind' this.TextField' this.TextField' trivia' _trailing' this.GetDiagnostics()' this.GetAnnotations()); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierWithTrivia,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierWithTrivia.cs,WithLeadingTrivia,The length of the statement  "                return new SyntaxIdentifierWithTrivia(this.contextualKind' this.TextField' this.valueText' trivia' _trailing' this.GetDiagnostics()' this.GetAnnotations()); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierWithTrivia,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierWithTrivia.cs,WithTrailingTrivia,The length of the statement  "                return new SyntaxIdentifierWithTrivia(this.contextualKind' this.TextField' this.valueText' _leading' trivia' this.GetDiagnostics()' this.GetAnnotations()); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierWithTrivia,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierWithTrivia.cs,SetDiagnostics,The length of the statement  "                return new SyntaxIdentifierWithTrivia(this.contextualKind' this.TextField' this.valueText' _leading' _trailing' diagnostics' this.GetAnnotations()); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxIdentifierWithTrivia,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxIdentifierWithTrivia.cs,SetAnnotations,The length of the statement  "                return new SyntaxIdentifierWithTrivia(this.contextualKind' this.TextField' this.valueText' _leading' _trailing' this.GetDiagnostics()' annotations); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxTokenWithValue<T>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxLiteral.cs,WithLeadingTrivia,The length of the statement  "                return new SyntaxTokenWithValueAndTrivia<T>(this.Kind' this.TextField' this.ValueField' trivia' null' this.GetDiagnostics()' this.GetAnnotations()); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxTokenWithValue<T>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxLiteral.cs,WithTrailingTrivia,The length of the statement  "                return new SyntaxTokenWithValueAndTrivia<T>(this.Kind' this.TextField' this.ValueField' null' trivia' this.GetDiagnostics()' this.GetAnnotations()); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxTokenWithValueAndTrivia<T>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxLiteralWithTrivia.cs,WithLeadingTrivia,The length of the statement  "                return new SyntaxTokenWithValueAndTrivia<T>(this.Kind' this.TextField' this.ValueField' trivia' _trailing' this.GetDiagnostics()' this.GetAnnotations()); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxTokenWithValueAndTrivia<T>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxLiteralWithTrivia.cs,WithTrailingTrivia,The length of the statement  "                return new SyntaxTokenWithValueAndTrivia<T>(this.Kind' this.TextField' this.ValueField' _leading' trivia' this.GetDiagnostics()' this.GetAnnotations()); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxTokenWithValueAndTrivia<T>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxLiteralWithTrivia.cs,SetDiagnostics,The length of the statement  "                return new SyntaxTokenWithValueAndTrivia<T>(this.Kind' this.TextField' this.ValueField' _leading' _trailing' diagnostics' this.GetAnnotations()); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxTokenWithValueAndTrivia<T>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxToken.SyntaxLiteralWithTrivia.cs,SetAnnotations,The length of the statement  "                return new SyntaxTokenWithValueAndTrivia<T>(this.Kind' this.TextField' this.ValueField' _leading' _trailing' this.GetDiagnostics()' annotations); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\PEAttributeData.cs,EnsureClassAndConstructorSymbolsAreLoaded,The length of the statement  "                Interlocked.CompareExchange(ref _lazyAttributeClass' (NamedTypeSymbol)attributeClass' ErrorTypeSymbol.UnknownResultType); // Serves as a flag' so do it last. " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,DynamicTypeDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\DynamicTypeDecoder.cs,TransformTypeWithoutCustomModifierFlags,The length of the statement  "            return TransformTypeInternal(type' containingAssembly' 0' targetSymbolRefKind' dynamicTransformFlags' haveCustomModifierFlags: false); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,DynamicTypeDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\DynamicTypeDecoder.cs,TransformTypeInternal,The length of the statement  "            // Native compiler encodes bools (always false) for custom modifiers and parameter ref-kinds' if ref-kind is ref or out. " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,DynamicTypeDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\DynamicTypeDecoder.cs,TransformTypeInternal,The length of the statement  "            if (decoder.HandleCustomModifiers(targetSymbolCustomModifierCount) && decoder.HandleParameterRefKind(targetSymbolRefKind)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,DynamicTypeDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\DynamicTypeDecoder.cs,TransformNamedType,The length of the statement  "            // Native compiler encodes bools for each type argument' starting from type arguments for the outermost containing type to those for the given namedType. " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,MemberRefMetadataDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\MemberRefMetadataDecoder.cs,FindMember,The length of the statement  "                        ParamInfo<TypeSymbol>[] targetParamInfo = this.DecodeSignatureParametersOrThrow(ref signaturePointer' signatureHeader' out typeParamCount); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,MemberRefMetadataDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\MemberRefMetadataDecoder.cs,MethodSymbolMatchesParamInfo,The length of the statement  "                if (!ParametersMatch(candidateMethod.Parameters[i]' candidateMethodTypeMap' ref targetParamInfo[i + 1 /*for return type*/])) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,MetadataDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\MetadataDecoder.cs,LookupTopLevelTypeDefSymbol,The length of the statement  "            return new MissingMetadataTypeSymbol.TopLevel(new MissingModuleSymbolWithName(moduleSymbol.ContainingAssembly' moduleName)' ref emittedName' SpecialType.None); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,MetadataDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\MetadataDecoder.cs,SubstituteNoPiaLocalType,The length of the statement  "                Debug.Assert(!(assembly is SourceAssemblySymbol) || !((SourceAssemblySymbol)assembly).SourceModule.MightContainNoPiaLocalTypes()); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEAssemblySymbol.cs,TryLookupForwardedMetadataTypeWithCycleDetection,The length of the statement  "                    return forwardedToAssembly.LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName' visitedAssemblies' digThroughForwardedTypes: true); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEEventSymbol.cs,GetAssociatedField,The length of the statement  "                    NamedTypeSymbol eventRegistrationTokenTable_T = ((PEModuleSymbol)(this.ContainingModule)).EventRegistrationTokenTable_T; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEEventSymbol.cs,DoModifiersMatch,The length of the statement  "                // (addMethod.IsAbstract == removeMethod.IsAbstract) && // NOTE: Dev10 accepts one abstract accessor (same as for events) " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEEventSymbol.cs,DoModifiersMatch,The length of the statement  "                // (addMethod.IsSealed == removeMethod.IsSealed) && // NOTE: Dev10 accepts one sealed accessor (for events' not for properties) " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEEventSymbol.cs,DoModifiersMatch,The length of the statement  "                // (addMethod.IsOverride == removeMethod.IsOverride) && // NOTE: Dev10 accepts one override accessor (for events' not for properties) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEEventSymbol.cs,DoesSignatureMatch,The length of the statement  "            var methodParams = metadataDecoder.GetSignatureForMethod(method.Handle' out signatureHeader' out mrEx' setParamHandles: false); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEEventSymbol.cs,GetDocumentationCommentXml,The length of the statement  "            return PEDocumentationCommentUtils.GetDocumentationComment(this' _containingType.ContainingPEModule' preferredCulture' cancellationToken' ref _lazyDocComment); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEFieldSymbol.cs,EnsureSignatureIsLoaded,The length of the statement  "                TypeSymbol type = (new MetadataDecoder(moduleSymbol' _containingType)).DecodeFieldSignature(_handle' out isVolatile' out customModifiers); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEFieldSymbol.cs,EnsureSignatureIsLoaded,The length of the statement  "                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyCustomModifiers' customModifiersArray' default(ImmutableArray<CustomModifier>)); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEFieldSymbol.cs,GetCustomAttributesToEmit,The length of the statement  "                                          containingPEModuleSymbol.Module.FindLastTargetAttribute(_handle' AttributeDescription.DecimalConstantAttribute).Handle); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEFieldSymbol.cs,GetDocumentationCommentXml,The length of the statement  "            return PEDocumentationCommentUtils.GetDocumentationComment(this' _containingType.ContainingPEModule' preferredCulture' cancellationToken' ref _lazyDocComment); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,LoadSignature,The length of the statement  "            ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol' this).GetSignatureForMethod(_handle' out signatureHeader' out mrEx); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,LoadSignature,The length of the statement  "                var old = Interlocked.CompareExchange(ref _lazyUseSiteDiagnostic' new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus' this)' CSDiagnosticInfo.EmptyErrorInfo); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,LoadSignature,The length of the statement  "                             ((object)old != null && old.Code == (int)ErrorCode.ERR_BindToBogus && old.Arguments.Length == 1 && old.Arguments[0] == (object)this)); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,EnsureTypeParametersAreLoaded,The length of the statement  "                    var old = Interlocked.CompareExchange(ref _lazyUseSiteDiagnostic' new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus' this)' CSDiagnosticInfo.EmptyErrorInfo); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,EnsureTypeParametersAreLoaded,The length of the statement  "                                    ((object)old != null && old.Code == (int)ErrorCode.ERR_BindToBogus && old.Arguments.Length == 1 && old.Arguments[0] == (object)this)); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,EnsureTypeParametersAreLoaded,The length of the statement  "                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeParameters' typeParams' default(ImmutableArray<TypeParameterSymbol>)); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,ComputeMethodKind,The length of the statement  "                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) && " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,GetDocumentationCommentXml,The length of the statement  "            return PEDocumentationCommentUtils.GetDocumentationComment(this' _containingType.ContainingPEModule' preferredCulture' cancellationToken' ref _lazyDocComment); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,GetAppliedConditionalSymbols,The length of the statement  "                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyConditionalAttributeSymbols' conditionalSymbols' default(ImmutableArray<string>)); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,GetAssemblyAttributes,The length of the statement  "                    (moduleAssemblyAttributesBuilder != null) ? moduleAssemblyAttributesBuilder.ToImmutableAndFree() : ImmutableArray<CSharpAttributeData>.Empty' " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,GetTypeSymbolForWellKnownType,The length of the statement  "            MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName()' useCLSCompliantNameArityEncoding: true); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,GetAssemblyForForwardedType,The length of the statement  "                AssemblyReferenceHandle assemblyRef = Module.GetAssemblyForForwardedType(fullName.FullName' ignoreCase: false' matchedName: out matchedName); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,GetAssemblyForForwardedType,The length of the statement  "                return assemblyRef.IsNil ? null : this.GetReferencedAssemblySymbols()[Module.GetAssemblyReferenceIndexOrThrow(assemblyRef)]; " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,Create,The length of the statement  "                result = new PENamedTypeSymbolNonGeneric(moduleSymbol' containingNamespace' handle' emittedNamespaceName' out mangleName); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,InterfacesNoUseSiteDiagnostics,The length of the statement  "                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces' MakeAcyclicInterfaces()' default(ImmutableArray<NamedTypeSymbol>)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,GetDeclaredInterfaces,The length of the statement  "                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyDeclaredInterfaces' MakeDeclaredInterfaces()' default(ImmutableArray<NamedTypeSymbol>)); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,MakeDeclaredInterfaces,The length of the statement  "                        symbols[i++] = (object)namedTypeSymbol != null ? namedTypeSymbol : new UnsupportedMetadataTypeSymbol(); // interface tmpList contains a bad type " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,GetEnumFieldsToEmit,The length of the statement  "                        if ((fieldFlags & FieldAttributes.Static) == 0 && ModuleExtensions.ShouldImportField(fieldFlags' moduleSymbol.ImportOptions)) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,GetEnumFieldsToEmit,The length of the statement  "                if (instanceIndex < uncommon.lazyInstanceEnumFields.Length && uncommon.lazyInstanceEnumFields[instanceIndex].Handle == fieldDef) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,GetDocumentationCommentXml,The length of the statement  "            return PEDocumentationCommentUtils.GetDocumentationComment(this' ContainingPEModule' preferredCulture' cancellationToken' ref _lazyDocComment); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateFields,The length of the statement  "            // for ordinary embeddable struct types we import private members so that we can report appropriate errors if the structure is used  " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateMethods,The length of the statement  "            // for ordinary embeddable struct types we import private members so that we can report appropriate errors if the structure is used  " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateMethods,The length of the statement  "            var isOrdinaryEmbeddableStruct = (this.TypeKind == TypeKind.Struct) && (this.SpecialType == Microsoft.CodeAnalysis.SpecialType.None) && this.ContainingAssembly.IsLinked; " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,GetAppliedConditionalSymbols,The length of the statement  "                ImmutableInterlocked.InterlockedCompareExchange(ref uncommon.lazyConditionalAttributeSymbols' conditionalSymbols' default(ImmutableArray<string>)); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,GetAttributeUsageInfo,The length of the statement  "                return ((object)this.BaseTypeNoUseSiteDiagnostics != null) ? this.BaseTypeNoUseSiteDiagnostics.GetAttributeUsageInfo() : AttributeUsageInfo.Default; " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,DecodeAttributeUsageInfo,The length of the statement  "                    AttributeUsageInfo info = AttributeData.DecodeAttributeUsageAttribute(positionalArgs[0]' namedArgs.AsImmutableOrNull()); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,DecodeAttributeUsageInfo,The length of the statement  "            return ((object)this.BaseTypeNoUseSiteDiagnostics != null) ? this.BaseTypeNoUseSiteDiagnostics.GetAttributeUsageInfo() : AttributeUsageInfo.Default; " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbolGeneric,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,MatchesContainingTypeParameters,The length of the statement  "                var nestedTypeMap = new TypeMap(nestedTypeParameters' IndexedTypeParameterSymbol.Take(nestedTypeParameters.Length)' allowAlpha: false); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbolGeneric,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,MatchesContainingTypeParameters,The length of the statement  "                    if (!MemberSignatureComparer.HaveSameConstraints(containingTypeParameter' containingTypeMap' nestedTypeParameter' nestedTypeMap)) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEPropertySymbol.cs,DoSignaturesMatch,The length of the statement  "            if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams' getMethodParams' comparingToSetter: false' compareParamByRef: true' compareReturnType: true)) " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEPropertySymbol.cs,DoSignaturesMatch,The length of the statement  "            if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams' setMethodParams' comparingToSetter: true' compareParamByRef: true' compareReturnType: true)) " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEPropertySymbol.cs,GetDocumentationCommentXml,The length of the statement  "            return PEDocumentationCommentUtils.GetDocumentationComment(this' _containingType.ContainingPEModule' preferredCulture' cancellationToken' ref _lazyDocComment); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PETypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PETypeParameterSymbol.cs,GetDeclaredConstraintTypes,The length of the statement  "                Interlocked.CompareExchange(ref _lazyBoundsErrorInfo' new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus' this)' CSDiagnosticInfo.EmptyErrorInfo); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PETypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PETypeParameterSymbol.cs,GetBounds,The length of the statement  "                var bounds = this.ResolveBounds(this.ContainingAssembly.CorLibrary' inProgress.Prepend(this)' constraintTypes' inherited' currentCompilation: null' " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,SymbolFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\SymbolFactory.cs,GetSZArrayTypeSymbol,The length of the statement  "            return new ArrayTypeSymbol(moduleSymbol.ContainingAssembly' elementType' CSharpCustomModifier.Convert(customModifiers)); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\RetargetingAttributeData.cs,GetSystemType,The length of the statement  "            var retargetingAssembly = (RetargetingAssemblySymbol)(targetSymbol.Kind == SymbolKind.Assembly ? targetSymbol : targetSymbol.ContainingAssembly); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingFieldSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingFieldSymbol.cs,GetFieldType,The length of the statement  "            return this.RetargetingTranslator.Retarget(_underlyingField.GetFieldType(fieldsBeingBound)' RetargetOptions.RetargetPrimitiveTypesByTypeCode); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingMethodSymbol.cs,GetAttributes,The length of the statement  "            return this.RetargetingTranslator.GetRetargetedAttributes(_underlyingMethod.GetAttributes()' ref _lazyCustomAttributes); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingMethodSymbol.cs,GetReturnTypeAttributes,The length of the statement  "            return this.RetargetingTranslator.GetRetargetedAttributes(_underlyingMethod.GetReturnTypeAttributes()' ref _lazyReturnTypeCustomAttributes); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingMethodSymbol.cs,RetargetExplicitInterfaceImplementations,The length of the statement  "                var retargeted = this.RetargetingTranslator.Retarget(impls[i]' MemberSignatureComparer.RetargetedExplicitImplementationComparer); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingModuleSymbol.cs,SetReferences,The length of the statement  "            Debug.Assert(referencedAssemblySymbols.Length <= underlyingBoundReferences.Length); // Linked references are filtered out. " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingModuleSymbol.cs,SetReferences,The length of the statement  "                Debug.Assert(identityComparer.Compare(moduleReferences.Names[i]' definitionIdentity) != AssemblyIdentityComparer.ComparisonResult.NotEquivalent); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingModuleSymbol.cs,SetReferences,The length of the statement  "                Debug.Assert(identityComparer.Compare(moduleReferences.Names[i]' underlyingBoundReferences[j].Identity) != AssemblyIdentityComparer.ComparisonResult.NotEquivalent); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingNamedTypeSymbol.cs,LookupMetadataType,The length of the statement  "            return this.RetargetingTranslator.Retarget(_underlyingType.LookupMetadataType(ref typeName)' RetargetOptions.RetargetPrimitiveTypesByName); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingNamedTypeSymbol.cs,GetDeclaredBaseType,The length of the statement  "                var declaredBase = (object)underlyingBase != null ? this.RetargetingTranslator.Retarget(underlyingBase' RetargetOptions.RetargetPrimitiveTypesByName) : null; " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingNamedTypeSymbol.cs,GetDeclaredInterfaces,The length of the statement  "                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyDeclaredInterfaces' result' default(ImmutableArray<NamedTypeSymbol>)); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingParameterSymbol.cs,GetAttributes,The length of the statement  "            return this.RetargetingModule.RetargetingTranslator.GetRetargetedAttributes(_underlyingParameter.GetAttributes()' ref _lazyCustomAttributes); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingParameterSymbol.cs,GetCustomAttributesToEmit,The length of the statement  "            return this.RetargetingModule.RetargetingTranslator.RetargetAttributes(_underlyingParameter.GetCustomAttributesToEmit(compilationState)); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingPropertySymbol.cs,RetargetExplicitInterfaceImplementations,The length of the statement  "                var retargeted = this.RetargetingTranslator.Retarget(impls[i]' MemberSignatureComparer.RetargetedExplicitImplementationComparer); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingPropertySymbol.cs,GetAttributes,The length of the statement  "            return this.RetargetingTranslator.GetRetargetedAttributes(_underlyingProperty.GetAttributes()' ref _lazyCustomAttributes); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,Retarget,The length of the statement  "                Debug.Assert(symbol.Kind != SymbolKind.NamedType || ((NamedTypeSymbol)symbol).PrimitiveTypeCode == Cci.PrimitiveTypeCode.NotPrimitive); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,RetargetNoPiaLocalType,The length of the statement  "                    MetadataTypeName name = MetadataTypeName.FromFullName(type.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat)' forcedArity: type.Arity); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,Retarget,The length of the statement  "                    newArguments.Add((TypeSymbol)arg.Accept(this' RetargetOptions.RetargetPrimitiveTypesByTypeCode)); // generic instantiation is a signature " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,Retarget,The length of the statement  "                bool noPiaIllegalGenericInstantiation = IsNoPiaIllegalGenericInstantiation(oldArguments' newArguments' startOfNonInterfaceArguments); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,RetargetModifiers,The length of the statement  "                        NamedTypeSymbol newModifier = Retarget((NamedTypeSymbol)oldModifier.Modifier' RetargetOptions.RetargetPrimitiveTypesByName); // should be retargeted by name " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,Retarget,The length of the statement  "                        type.ErrorInfo ?? new CSDiagnosticInfo(ErrorCode.ERR_ErrorInReferencedAssembly' type.ContainingAssembly?.Identity.GetDisplayName() ?? string.Empty)' true); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,Retarget,The length of the statement  "                if (ReferenceEquals(method.ContainingModule' this.UnderlyingModule) && ReferenceEquals(method' method.OriginalDefinition)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,Retarget,The length of the statement  "                if (ReferenceEquals(property.ContainingModule' this.UnderlyingModule) && ReferenceEquals(property' property.OriginalDefinition)) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,Retarget,The length of the statement  "                if (ReferenceEquals(@event.ContainingModule' this.UnderlyingModule) && ReferenceEquals(@event' @event.OriginalDefinition)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,RetargetModifiers,The length of the statement  "                    ImmutableInterlocked.InterlockedCompareExchange(ref lazyCustomModifiers' newModifiers' default(ImmutableArray<CustomModifier>)); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,RetargetAttributes,The length of the statement  "                SourceAttributeData y = x; // Code below relies on the fact that SynthesizedAttributeData derives from SourceAttributeData. " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,RetargetAttributeData,The length of the statement  "                ImmutableArray<TypedConstant> newAttributeCtorArguments = RetargetAttributeConstructorArguments(oldAttributeCtorArguments); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,RetargetAttributeData,The length of the statement  "                ImmutableArray<KeyValuePair<string' TypedConstant>> newAttributeNamedArguments = RetargetAttributeNamedArguments(oldAttributeNamedArguments); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,GetRetargetedAttributes,The length of the statement  "                    ImmutableInterlocked.InterlockedCompareExchange(ref lazyCustomAttributes' retargetedAttributes' default(ImmutableArray<CSharpAttributeData>)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingTypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingTypeParameterSymbol.cs,GetAttributes,The length of the statement  "            return this.RetargetingTranslator.GetRetargetedAttributes(_underlyingTypeParameter.GetAttributes()' ref _lazyCustomAttributes); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingTypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingTypeParameterSymbol.cs,GetEffectiveBaseClass,The length of the statement  "            return this.RetargetingTranslator.Retarget(_underlyingTypeParameter.GetEffectiveBaseClass(inProgress)' RetargetOptions.RetargetPrimitiveTypesByTypeCode); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingTypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingTypeParameterSymbol.cs,GetDeducedBaseType,The length of the statement  "            return this.RetargetingTranslator.Retarget(_underlyingTypeParameter.GetDeducedBaseType(inProgress)' RetargetOptions.RetargetPrimitiveTypesByTypeCode); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,CSharpPragmaWarningStateMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpPragmaWarningStateMap.cs,CreatePragmaWarningStateEntries,The length of the statement  "            // Captures the mapping of a warning number to the reporting option' accumulated of all #pragma up to the current directive. " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,CSharpPragmaWarningStateMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpPragmaWarningStateMap.cs,CreatePragmaWarningStateEntries,The length of the statement  "                var directiveState = currentDirective.DisableOrRestoreKeyword.Kind() == SyntaxKind.DisableKeyword ? ReportDiagnostic.Suppress : ReportDiagnostic.Default; " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,CSharpPragmaWarningStateMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpPragmaWarningStateMap.cs,CreatePragmaWarningStateEntries,The length of the statement  "                current = new WarningStateMapEntry(currentDirective.Location.SourceSpan.End' accumulatedGeneralWarningState' accumulatedSpecificWarningState); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,AnonymousMethodExpression,The length of the statement  "            return SyntaxFactory.AnonymousMethodExpression(default(SyntaxToken)' SyntaxFactory.Token(SyntaxKind.DelegateKeyword)' default(ParameterListSyntax)' SyntaxFactory.Block()); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,TypeDeclaration,The length of the statement  "                    return SyntaxFactory.ClassDeclaration(attributes' modifiers' keyword' identifier' typeParameterList' baseList' constraintClauses' openBraceToken' members' closeBraceToken' semicolonToken); " is 188.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,TypeDeclaration,The length of the statement  "                    return SyntaxFactory.StructDeclaration(attributes' modifiers' keyword' identifier' typeParameterList' baseList' constraintClauses' openBraceToken' members' closeBraceToken' semicolonToken); " is 189.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,TypeDeclaration,The length of the statement  "                    return SyntaxFactory.InterfaceDeclaration(attributes' modifiers' keyword' identifier' typeParameterList' baseList' constraintClauses' openBraceToken' members' closeBraceToken' semicolonToken); " is 192.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,LookupPosition,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\LookupPosition.cs,IsInTypeParameterList,The length of the statement  "            return typeParameterListOpt != null && IsBeforeToken(position' typeParameterListOpt' typeParameterListOpt.GreaterThanToken); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,LookupPosition,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\LookupPosition.cs,IsInMethodTypeParameterScope,The length of the statement  "            var firstNameToken = explicitInterfaceSpecifier == null ? methodDecl.Identifier : explicitInterfaceSpecifier.GetFirstToken(); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,VisitToken,The length of the statement  "                var nextToken = token.GetNextToken(t => SyntaxToken.NonZeroWidth(t) || t.Kind() == SyntaxKind.EndOfDirectiveToken' t => t.Kind() == SyntaxKind.SkippedTokensTrivia); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,RewriteTrivia,The length of the statement  "                    var needsLineBreak = NeedsLineBreakBefore(trivia) || (currentTriviaList.Count > 0 && NeedsLineBreakBetween(currentTriviaList.Last()' trivia' isTrailing)); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxListBuilder.cs,ToListNode,The length of the statement  "                    return Syntax.InternalSyntax.SyntaxList.List((Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].Value); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxListBuilder.cs,ToListNode,The length of the statement  "                    return Syntax.InternalSyntax.SyntaxList.List((Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[2].Value); " is 216.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxReplacer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxReplacer.cs,InsertNodeInList,The length of the statement  "            return new NodeListEditor(nodeInList' nodesToInsert' insertBefore ? ListEditKind.InsertBefore : ListEditKind.InsertAfter).Visit(root); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxReplacer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxReplacer.cs,InsertTokenInList,The length of the statement  "            return new TokenListEditor(tokenInList' newTokens' insertBefore ? ListEditKind.InsertBefore : ListEditKind.InsertAfter).Visit(root); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxReplacer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxReplacer.cs,InsertTriviaInList,The length of the statement  "            return new TriviaListEditor(triviaInList' newTrivia' insertBefore ? ListEditKind.InsertBefore : ListEditKind.InsertAfter).Visit(root); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxReplacer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxReplacer.cs,InsertTriviaInList,The length of the statement  "            return new TriviaListEditor(triviaInList' newTrivia' insertBefore ? ListEditKind.InsertBefore : ListEditKind.InsertAfter).VisitToken(root); " is 139.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,MemberGroupFinalValidationAccessibilityChecks,The conditional expression  "InFieldInitializer && !ContainingType.IsScriptClass || InConstructorInitializer || InAttributeArgument"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ComputeSortedCrefMembers,The conditional expression  "containerType.Name == memberName && (hasParameterList || containerType.Arity == 0 || this.ContainingType != containerType.OriginalDefinition)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCast,The conditional expression  "targetType.IsNullableType() &&                  !operand.HasAnyErrors &&                  operand.Type != null &&                  !operand.Type.IsNullableType() &&                  targetType.GetNullableUnderlyingType() != operand.Type"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCastCore,The conditional expression  "operand.HasAnyErrors || targetType.IsErrorType() || !conversion.IsValid || targetTypeIsStatic"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindMemberAccessReportError,The conditional expression  "boundLeft.Kind == BoundKind.TypeExpression ||                      boundLeft.Kind == BoundKind.BaseReference ||                      node.Kind() == SyntaxKind.AwaitExpression && plainName == WellKnownMemberNames.GetResult"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIndexerOrIndexedPropertyAccess,The conditional expression  "!gotError && receiver != null && receiver.Kind == BoundKind.ThisReference && receiver.WasCompilerGenerated"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindGlobalStatement,The conditional expression  "binder.Compilation.IsSubmission && isLast && boundStatement.Kind == BoundKind.ExpressionStatement && !boundStatement.HasAnyErrors"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckRestrictedTypeReceiver,The conditional expression  "!call.HasAnyErrors &&                              call.ReceiverOpt != null &&                              (object)call.ReceiverOpt.Type != null &&                              call.ReceiverOpt.Type.IsRestrictedType() &&                              call.Method.ContainingType != call.ReceiverOpt.Type"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpressionContinued,The conditional expression  "invokedAsExtensionMethod || (method.IsStatic && receiver != null && receiver.WasCompilerGenerated)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInvocationExpressionContinued,The conditional expression  "!gotError && !method.IsStatic && receiver != null && receiver.Kind == BoundKind.ThisReference && receiver.WasCompilerGenerated"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindSimpleBinaryOperator,The conditional expression  "(object)leftType != null && leftType.IsDynamic() || (object)rightType != null && rightType.IsDynamic()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportAssignmentOperatorError,The conditional expression  "((SyntaxKind)node.OperatorToken.RawKind == SyntaxKind.PlusEqualsToken || (SyntaxKind)node.OperatorToken.RawKind == SyntaxKind.MinusEqualsToken) &&                  (object)left.Type != null && left.Type.TypeKind == TypeKind.Delegate"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConditionalLogicalOperator,The conditional expression  "(object)left.Type != null && left.Type.SpecialType == SpecialType.System_Boolean &&                  (object)right.Type != null && right.Type.SpecialType == SpecialType.System_Boolean"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIntegralMinValConstants,The conditional expression  "token.Text.Contains("u") || token.Text.Contains("U") || token.Text.Contains("l") || token.Text.Contains("L")"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckForUnobservedAwaitable,The conditional expression  "expression == null                  || expression.Kind != BoundKind.Call                  || (object)expression.Type == null                  || expression.Type.IsDynamic()                  || expression.Type.SpecialType == SpecialType.System_Void"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckIsVariable,The conditional expression  "(expr.Kind == BoundKind.Lambda) ||                  (expr.Kind == BoundKind.UnboundLambda) ||                  (expr.ConstantValue != null) ||                  (expr.Type.GetSpecialTypeSafe() == SpecialType.System_Void)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckIsVariable,The conditional expression  "(object)containing != null &&                          fieldIsStatic == containing.IsStatic &&                          (fieldIsStatic || fieldAccess.ReceiverOpt.Kind == BoundKind.ThisReference) &&                          fieldSymbol.ContainingType == containing.ContainingType"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckValue,The conditional expression  "!hasResolutionErrors && CheckValueKind(expr' valueKind' diagnostics) ||                  expr.HasAnyErrors && valueKind == BindValueKind.RValueOrMethodGroup"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The conditional expression  "sourceType.SpecialType == SpecialType.System_Double && syntax.Kind() == SyntaxKind.NumericLiteralExpression &&                          (targetType.SpecialType == SpecialType.System_Single || targetType.SpecialType == SpecialType.System_Decimal)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GenerateImplicitConversionError,The conditional expression  "conversion.Kind == ConversionKind.ExplicitNumeric && sourceConstantValueOpt != null && sourceConstantValueOpt != ConstantValue.Bad &&                          ConversionsBase.HasImplicitConstantExpressionConversion(new BoundLiteral(syntax' ConstantValue.Bad' sourceType)' targetType)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindNonGenericSimpleName,The conditional expression  "(object)qualifierOpt == null &&                  node.Parent != null &&                  node.Parent.Kind() != SyntaxKind.Attribute && // dynamic not allowed as an attribute type                  SyntaxFacts.IsInTypeOnlyContext(node) &&                  node.Identifier.ToString() == "dynamic" &&                  !IsViableType(result) &&                  ((CSharpParseOptions)node.SyntaxTree.Options).LanguageVersion >= MessageID.IDS_FeatureDynamic.RequiredVersion()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The conditional expression  "options.IsAttributeTypeLookup() &&                                  first.Kind == SymbolKind.NamedType &&                                  second.Kind == SymbolKind.NamedType &&                                  originalSymbols[best.Index].Name != originalSymbols[secondBest.Index].Name && // Use alias names' if available.                                  Compilation.IsAttributeType((NamedTypeSymbol)first) &&                                  Compilation.IsAttributeType((NamedTypeSymbol)second)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResultSymbol,The conditional expression  "(symbols.Count > 1) || (symbols[0] is NamespaceOrTypeSymbol || symbols[0] is AliasSymbol) ||                  result.Kind == LookupResultKind.NotATypeOrNamespace || result.Kind == LookupResultKind.NotAnAttributeType"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitConversion,The conditional expression  "type.SpecialType == SpecialType.System_Object ||                          operandType.IsArray() && type.IsArray() &&                          ((ArrayTypeSymbol)type).ElementType.SpecialType == SpecialType.System_Object"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ForEachLoopBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ForEachLoopBinder.cs,SatisfiesForEachPattern,The conditional expression  "(object)moveNextMethodCandidate == null ||                      moveNextMethodCandidate.IsStatic || moveNextMethodCandidate.DeclaredAccessibility != Accessibility.Public ||                      ((MethodSymbol)moveNextMethodCandidate.OriginalDefinition).ReturnType.SpecialType != SpecialType.System_Boolean"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasImplicitConstantExpressionConversion,The conditional expression  "specialSource == SpecialType.System_Int64 && destination.GetSpecialTypeSafe() == SpecialType.System_UInt64 && (constantValue.IsBad || 0 <= constantValue.Int64Value)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasSpecialIntPtrConversion,The conditional expression  "s0.SpecialType != SpecialType.System_UIntPtr &&                  s0.SpecialType != SpecialType.System_IntPtr &&                  t0.SpecialType != SpecialType.System_UIntPtr &&                  t0.SpecialType != SpecialType.System_IntPtr"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceConversion,The conditional expression  "source.IsClassType() && destination.IsInterfaceType() && !source.IsSealed && !HasAnyBaseInterfaceConversion(source' destination' ref useSiteDiagnostics)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceConversion,The conditional expression  "source.IsInterfaceType() && destination.IsClassType() && (!destination.IsSealed || HasAnyBaseInterfaceConversion(destination' source' ref useSiteDiagnostics))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceTypeParameterConversion,The conditional expression  "(object)s != null && s.IsReferenceType && destination.IsInterfaceType() && !HasImplicitReferenceTypeParameterConversion(s' destination' ref useSiteDiagnostics)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitReferenceTypeParameterConversion,The conditional expression  "(object)s != null && (object)t != null && t.IsReferenceType && t.DependsOn(s)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasUnboxingTypeParameterConversion,The conditional expression  "(object)s != null && !s.IsReferenceType && destination.IsInterfaceType() && !HasImplicitReferenceTypeParameterConversion(s' destination' ref useSiteDiagnostics)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasUnboxingTypeParameterConversion,The conditional expression  "(object)s != null && (object)t != null && !t.IsReferenceType && t.DependsOn(s)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitArrayConversion,The conditional expression  "specialDefinition == SpecialType.System_Collections_Generic_IList_T ||                      specialDefinition == SpecialType.System_Collections_Generic_ICollection_T ||                      specialDefinition == SpecialType.System_Collections_Generic_IEnumerable_T ||                      specialDefinition == SpecialType.System_Collections_Generic_IReadOnlyList_T ||                      specialDefinition == SpecialType.System_Collections_Generic_IReadOnlyCollection_T"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasUnboxingConversion,The conditional expression  "source.IsInterfaceType() &&                  destination.IsValueType &&                  !destination.IsNullableType() &&                  HasBoxingConversion(destination' source' ref useSiteDiagnostics)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AddUserDefinedConversionsToExplicitCandidateSet,The conditional expression  "!fromConversion.Exists &&                      (object)source != null &&                      source.IsNullableType() &&                      EncompassingExplicitConversion(null' source.GetNullableUnderlyingType()' convertsFrom' ref useSiteDiagnostics).Exists"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AddUserDefinedConversionsToExplicitCandidateSet,The conditional expression  "!toConversion.Exists &&                      (object)target != null &&                      target.IsNullableType() &&                      EncompassingExplicitConversion(null' convertsTo' target.GetNullableUnderlyingType()' ref useSiteDiagnostics).Exists"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,AddUserDefinedConversionsToExplicitCandidateSet,The conditional expression  "(object)source != null && source.IsNullableType() && convertsFrom.IsNonNullableValueType() && target.CanBeAssignedNull()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeApplicableUserDefinedImplicitConversionSet,The conditional expression  "(object)source != null && source.IsInterfaceType() || (object)target != null && target.IsInterfaceType()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ComputeApplicableUserDefinedImplicitConversionSet,The conditional expression  "(object)source != null && (object)target != null && source.IsNullableType() && convertsFrom.IsNonNullableValueType() && target.CanBeAssignedNull()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddDistinctOperators,The conditional expression  "op.Signature.Kind == existingSignature.Kind && // Easy out                          op.Signature.ReturnType.Equals(existingSignature.ReturnType' ignoreDynamic: false) &&                          op.Signature.LeftType.Equals(existingSignature.LeftType' ignoreDynamic: true) &&                          op.Signature.RightType.Equals(existingSignature.RightType' ignoreDynamic: true) &&                          op.Signature.Method.ContainingType.Equals(existingSignature.Method.ContainingType' ignoreDynamic: true)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,UserDefinedBinaryOperatorCanBeLifted,The conditional expression  "!left.IsValueType ||                  left.IsNullableType() ||                  !right.IsValueType ||                  right.IsNullableType()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterOperator,The conditional expression  "leftBetter == BetterResult.Left && rightBetter != BetterResult.Right ||                  leftBetter != BetterResult.Right && rightBetter == BetterResult.Left"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,BetterOperator,The conditional expression  "leftBetter == BetterResult.Right && rightBetter != BetterResult.Left ||                  leftBetter != BetterResult.Left && rightBetter == BetterResult.Right"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetUserDefinedUnaryOperatorsFromType,The conditional expression  "operandType.IsValueType && !operandType.IsNullableType() &&                              resultType.IsValueType && !resultType.IsNullableType()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,ExpressionMatchExactly,The conditional expression  "node.Kind == BoundKind.UnboundLambda &&                  (object)(d = t.GetDelegateType()) != null &&                  (object)(invoke = d.DelegateInvokeMethod) != null &&                  (y = invoke.ReturnType).SpecialType != SpecialType.System_Void"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEffectiveParameterRefKind,The conditional expression  "allowRefOmittedArguments && paramRefKind == RefKind.Ref && argRefKind == RefKind.None && !_binder.InAttributeArgument"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,BoundQueryClause,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundQueryClause.cs,Update,The conditional expression  "value != this.Value || definedSymbol != this.DefinedSymbol || queryInvocation != this.Operation || castInvocation != this.Cast || binder != this.Binder || unoptimizedForm != this.UnoptimizedForm || type != this.Type"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,UnboundLambdaState,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs,ReallyBind,The conditional expression  "(object)returnType != null && // Can be null if "delegateType" is not actually a delegate type.                      returnType.SpecialType != SpecialType.System_Void &&                      returnType != binder.Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task) &&                      returnType.OriginalDefinition != binder.Compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task_T)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,FindEntryPoint,The conditional expression  "(object)mainType == null || mainType.IsGenericType || (mainType.TypeKind != TypeKind.Class && mainType.TypeKind != TypeKind.Struct)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetRuntimeMember,The conditional expression  "member.Kind != targetSymbolKind || member.IsStatic != isStatic ||                      !(member.DeclaredAccessibility == Accessibility.Public || ((object)accessWithinOpt != null && Symbol.IsSymbolAccessible(member' accessWithinOpt)))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,GetRuntimeMember,The conditional expression  "method.Arity != descriptor.Arity || methodKind != targetMethodKind ||                                  ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,SymbolSearcher,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,AppendMemberSymbolsWithName,The conditional expression  "!member.IsTypeOrTypeAlias() &&                          (member.CanBeReferencedByName || member.IsExplicitInterfaceImplementation() || member.IsIndexer()) &&                          predicate(member.Name)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,CanGetSemanticInfo,The conditional expression  "!isSpeculative && node.Parent != null && node.Parent.Kind() == SyntaxKind.NameEquals && node.Parent.Parent.Kind() == SyntaxKind.UsingDirective"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetCollectionInitializerSymbolInfo,The conditional expression  "initializer.Parent != null &&                             initializer.Parent.Kind() == SyntaxKind.SimpleAssignmentExpression &&                             ((AssignmentExpressionSyntax)initializer.Parent).Right == initializer &&                             initializer.Parent.Parent != null &&                             initializer.Parent.Parent.Kind() == SyntaxKind.ObjectInitializerExpression"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetCollectionInitializerSymbolInfo,The conditional expression  "initializer.Parent != null && initializer.Parent.Kind() == SyntaxKind.ObjectCreationExpression &&                          ((ObjectCreationExpressionSyntax)initializer.Parent).Initializer == initializer &&                          CanGetSemanticInfo(initializer.Parent' allowNamedArgumentName: false)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetAdjustedNodePosition,The conditional expression  "node.IsMissing || node.HasErrors || node.Width == 0 || node.IsPartOfStructuredTrivia()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetTypeInfoForNode,The conditional expression  "boundExpr != null &&                  !(boundNodeForSyntacticParent != null &&                    boundNodeForSyntacticParent.Syntax.Kind() == SyntaxKind.ObjectCreationExpression &&                    ((ObjectCreationExpressionSyntax)boundNodeForSyntacticParent.Syntax).Type == boundExpr.Syntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSemanticSymbols,The conditional expression  "boundNodeForSyntacticParent != null &&                             boundNodeForSyntacticParent.Syntax.Kind() == SyntaxKind.ObjectCreationExpression &&                             ((ObjectCreationExpressionSyntax)boundNodeForSyntacticParent.Syntax).Type == boundType.Syntax &&                             boundNodeForSyntacticParent.Kind == BoundKind.BadExpression &&                             ((BoundBadExpression)boundNodeForSyntacticParent).ResultKind == LookupResultKind.NotCreatable"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The conditional expression  "operandType == 0 || operandType == BinaryOperatorKind.UserDefined || binaryOperator.ResultKind != LookupResultKind.Viable || binaryOperator.OperatorKind.IsLogical()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetSymbolsAndResultKind,The conditional expression  "!isDynamic &&                      (op == BinaryOperatorKind.Equal || op == BinaryOperatorKind.NotEqual) &&                      ((binaryOperator.Left.IsLiteralNull() && binaryOperator.Right.Type.IsNullableType()) ||                       (binaryOperator.Right.IsLiteralNull() && binaryOperator.Left.Type.IsNullableType())) &&                      binaryOperator.Type.SpecialType == SpecialType.System_Boolean"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,AdjustSymbolsForObjectCreation,The conditional expression  "parentSyntax != null &&                  parentSyntax == boundNode.Syntax.Parent &&                  parentSyntax.Kind() == SyntaxKind.Attribute && ((AttributeSyntax)parentSyntax).Name == boundNode.Syntax"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetBindableSyntaxNode,The conditional expression  "node is QueryExpressionSyntax && parent is QueryContinuationSyntax ||                              !(node is ExpressionSyntax) &&                              !(node is StatementSyntax) &&                              !(node is SelectOrGroupClauseSyntax) &&                              !(node is QueryClauseSyntax) &&                              !(node is OrderingSyntax) &&                              !(node is JoinIntoClauseSyntax) &&                              !(node is QueryContinuationSyntax) &&                              !(node is ArrowExpressionClauseSyntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetSymbolInfoWorker,The conditional expression  "(object)result.Symbol == null && result.CandidateReason == CandidateReason.None && node is ExpressionSyntax && SyntaxFacts.IsInNamespaceOrTypeContext((ExpressionSyntax)node)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetBasesBeingResolved,The conditional expression  "parent is BaseTypeSyntax && parent.Parent != null && parent.Parent.Kind() == SyntaxKind.BaseList && ((BaseTypeSyntax)parent).Type == expression"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckMemberDistinctness,The conditional expression  "IsAccessibleIfContainerIsAccessible(member) &&                              (!member.IsOverride || !(member.Kind == SymbolKind.Method || member.Kind == SymbolKind.Property))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckMemberDistinctness,The conditional expression  "IsAccessibleOutsideAssembly(member) &&                              IsTrue(GetDeclaredOrInheritedCompliance(member)) &&                              (!member.IsOverride || !(member.Kind == SymbolKind.Method || member.Kind == SymbolKind.Property))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckMemberDistinctness,The conditional expression  "DoNotVisit(member) ||                      !IsAccessibleIfContainerIsAccessible(member) || // We already know that the container is accessible.                      !IsTrue(GetDeclaredOrInheritedCompliance(member)) ||                      member.IsOverride"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,CheckSymbolDistinctness,The conditional expression  "symbol.Kind == other.Kind &&                      !symbol.IsAccessor() &&                      !other.IsAccessor() &&                      TryGetCollisionErrorCode(symbol' other' out code)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethodBodies,The conditional expression  "moduleBeingBuiltOpt != null && methodCompiler._globalHasErrors && !diagnostics.HasAnyErrors() && !hasDeclarationErrors"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,The conditional expression  "(object)eventSymbol != null && eventSymbol.HasAssociatedField && !eventSymbol.IsAbstract && compilationState.Emitting"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileMethod,The conditional expression  "(methodSymbol.MethodKind == MethodKind.Constructor || methodSymbol.MethodKind == MethodKind.StaticConstructor) &&                           methodSymbol.IsImplicitlyDeclared && body == null"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,GetBaseTypeFinalizeMethod,The conditional expression  "(accessibility == Accessibility.ProtectedOrInternal || accessibility == Accessibility.Protected) &&                              baseTypeMethod.ParameterCount == 0 &&                              baseTypeMethod.Arity == 0 && // NOTE: the native compiler doesn't check this' so it broken IL.                              baseTypeMethod.ReturnsVoid"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,UnprocessedDocumentationCommentFinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\UnprocessedDocumentationCommentFinder.cs,DefaultVisit,The conditional expression  "node is BaseTypeDeclarationSyntax ||                  node is DelegateDeclarationSyntax ||                  node is EnumMemberDeclarationSyntax ||                  node is BaseMethodDeclarationSyntax ||                  node is BasePropertyDeclarationSyntax || //includes EventDeclarationSyntax                  node is BaseFieldDeclarationSyntax"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,ValidateOptions,The conditional expression  "Platform == Platform.AnyCpu32BitPreferred && OutputKind.IsValid() && !(OutputKind == OutputKind.ConsoleApplication || OutputKind == OutputKind.WindowsApplication || OutputKind == OutputKind.WindowsRuntimeApplication)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ControlFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ControlFlowPass.cs,CheckReachable,The conditional expression  "!this.State.Alive && !this.State.Reported && !statement.WasCompilerGenerated && statement.Syntax.Span.Length != 0"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,DataFlowsInWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowsInWalker.cs,NoteBranch,The conditional expression  "!gotoStmt.WasCompilerGenerated && !targetStmt.WasCompilerGenerated && !RegionContains(gotoStmt.Syntax.Span) && RegionContains(targetStmt.Syntax.Span)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,EntryPointsWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\EntryPointsWalker.cs,NoteBranch,The conditional expression  "!gotoStmt.WasCompilerGenerated && !targetStmt.WasCompilerGenerated && RegionContains(targetStmt.Syntax.Span) && !RegionContains(gotoStmt.Syntax.Span)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,FlowAnalysisPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\FlowAnalysisPass.cs,Rewrite,The conditional expression  "method.ReturnsVoid || method.IsIterator ||                  (method.IsAsync && compilation.GetWellKnownType(WellKnownType.System_Threading_Tasks_Task) == method.ReturnType)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,PreciseAbstractFlowPass<LocalState>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\PreciseAbstractFlowPass.AbstractLocalState.cs,VisitReceiverAfterCall,The conditional expression  "receiverOpt != null && ((object)method == null || method.MethodKind == MethodKind.Constructor || (object)(containingType = method.ContainingType) != null && !method.IsStatic && !containingType.IsReferenceType && !TypeIsImmutable(containingType))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,AsyncMethodBuilderMemberCollection,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodBuilderMemberCollection.cs,TryCreate,The conditional expression  "TryGetWellKnownMethodAsMember(F' setException' builderType' out setExceptionMethod) &&                  TryGetWellKnownMethodAsMember(F' setResult' builderType' out setResultMethod) &&                  TryGetWellKnownMethodAsMember(F' awaitOnCompleted' builderType' out awaitOnCompletedMethod) &&                  TryGetWellKnownMethodAsMember(F' awaitUnsafeOnCompleted' builderType' out awaitUnsafeOnCompletedMethod) &&                  TryGetWellKnownMethodAsMember(F' start' builderType' out startMethod) &&                  TryGetWellKnownMethodAsMember(F' setStateMachine' builderType' out setStateMachineMethod)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,VisitAssignmentOperator,The conditional expression  "!CheckForAssignmentToSelf(node) && _inExpressionLambda && node.Left.Kind != BoundKind.ObjectInitializerMember && node.Left.Kind != BoundKind.DynamicObjectInitializerMember"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckRelationals,The conditional expression  "node.Left.Type.SpecialType == SpecialType.System_Object && !IsExplicitCast(node.Left) && !(node.Left.ConstantValue != null && node.Left.ConstantValue.IsNull) && ConvertedHasEqual(node.OperatorKind' node.Right' out t)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckRelationals,The conditional expression  "node.Right.Type.SpecialType == SpecialType.System_Object && !IsExplicitCast(node.Right) && !(node.Right.ConstantValue != null && node.Right.ConstantValue.IsNull) && ConvertedHasEqual(node.OperatorKind' node.Left' out t)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckLiftedBinOp,The conditional expression  "(node.Left.NullableNeverHasValue() && node.Right.IsNullableNonBoolean()) ||                          (node.Left.IsNullableNonBoolean() && node.Right.NullableNeverHasValue())"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,ExpressionLambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs,VisitObjectCreationExpressionInternal,The conditional expression  "(object)node.Constructor == null ||                  (node.Arguments.Length == 0 && !node.Type.IsStructType()) ||                  node.Constructor.IsDefaultValueTypeConstructor()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeDynamicLogicalBinaryOperator,The conditional expression  "testOperator == UnaryOperatorKind.DynamicFalse && constantLeft == ConstantValue.False ||                  testOperator == UnaryOperatorKind.DynamicTrue && constantLeft == ConstantValue.True"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,TrivialLiftedComparisonOperatorOptimizations,The conditional expression  "leftAlwaysNull && rightNonNull != null || rightAlwaysNull && leftNonNull != null"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCall,The conditional expression  "method.IsStatic &&                  method.ContainingType.IsObjectType() &&                  !_inExpressionLambda &&                  (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_Object__ReferenceEquals)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeArguments,The conditional expression  "rewrittenArguments.Length == methodOrIndexer.GetParameterCount() &&                  argsToParamsOpt.IsDefault &&                  !expanded &&                  !isComReceiver"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteConditionalAccess,The conditional expression  "!isAsync && !node.AccessExpression.Type.IsDynamic() && rewrittenWhenNull == null &&                  (receiverType.IsReferenceType || receiverType.IsTypeParameter() && needTemp)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeConversion,The conditional expression  "!rewrittenType.IsNullableType() &&                          rewrittenOperand.IsDefaultValue() &&                          (!_inExpressionLambda || !explicitCastInCode)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,AddLocalDeclarationSequencePointIfNecessary,The conditional expression  "this.GenerateDebugInfo && !wasCompilerGenerated && !localSymbol.IsConst && syntax.Kind() == SyntaxKind.VariableDeclarator"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitReturnStatement,The conditional expression  "this.GenerateDebugInfo &&                  (!rewritten.WasCompilerGenerated ||                   (node.ExpressionOpt != null && IsLambdaOrExpressionBodiedMember))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,FlattenConcatArg,The conditional expression  "(object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatStringString) ||                              (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatStringStringString) ||                              (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatStringStringStringString) ||                              (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatObject) ||                              (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatObjectObject) ||                              (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatObjectObjectObject)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitInterpolatedString,The conditional expression  "(c == '{' || c == '}') && (i + 1) < formatLength && formatText[i + 1] == c"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitUnaryOperator,The conditional expression  "node.OperatorKind == UnaryOperatorKind.DynamicTrue && binaryOperator.OperatorKind == BinaryOperatorKind.DynamicLogicalOr ||                      node.OperatorKind == UnaryOperatorKind.DynamicFalse && binaryOperator.OperatorKind == BinaryOperatorKind.DynamicLogicalAnd"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,MakeDynamicOperation,The conditional expression  "binderConstruction == null ||                  (object)delegateTypeOverMethodTypeParameters == null ||                  delegateTypeOverMethodTypeParameters.IsErrorType() ||                  (object)(delegateInvoke = delegateTypeOverMethodTypeParameters.DelegateInvokeMethod) == null ||                  callSiteTypeGeneric.IsErrorType() ||                  (object)callSiteFactoryGeneric == null ||                  (object)callSiteTargetFieldGeneric == null"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitLocal,The conditional expression  "symbol.IsConst &&                  symbol.HasConstantValue &&                  format.LocalOptions.IncludesOption(SymbolDisplayLocalOptions.IncludeConstantValue) &&                  CanAddConstant(symbol.Type' symbol.ConstantValue)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddAccessibilityIfRequired,The conditional expression  "format.MemberOptions.IncludesOption(SymbolDisplayMemberOptions.IncludeAccessibility) &&                  (containingType == null ||                   (containingType.TypeKind != TypeKind.Interface && !IsEnumMember(symbol)))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitField,The conditional expression  "this.isFirstSymbolVisited &&                  format.MemberOptions.IncludesOption(SymbolDisplayMemberOptions.IncludeConstantValue) &&                  symbol.IsConst &&                  symbol.HasConstantValue &&                  CanAddConstant(symbol.Type' symbol.ConstantValue)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddMemberModifiersIfRequired,The conditional expression  "format.MemberOptions.IncludesOption(SymbolDisplayMemberOptions.IncludeModifiers) &&                  (containingType == null ||                   (containingType.TypeKind != TypeKind.Interface && !IsEnumMember(symbol)))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitFieldLoad,The conditional expression  "!used && !field.IsVolatile && !field.IsStatic && fieldAccess.ReceiverOpt.Type.IsVerifierValue()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,ReuseOrVisit,The conditional expression  "_counter == _lastExpressionCnt + 1 &&                  _lastExprContext != ExprContext.Box &&                  (_lastExprContext == context || _lastExprContext != ExprContext.Value) &&                  CanDup(_lastExpression' node)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitAssignmentOperator,The conditional expression  "CanScheduleToStack(localSymbol) &&                      assignmentLocal.Type.IsPointerType() && right.Kind == BoundKind.Conversion &&                      ((BoundConversion)right).ConversionKind.IsPointerConversion()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitFieldAccess,The conditional expression  "receiver.Type.IsValueType && (                              _context == ExprContext.AssignmentTarget ||                              _context == ExprContext.Address ||                              CodeGenerator.FieldLoadMustUseRef(receiver))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,PermissionSetAttributeTypeHasRequiredProperty,The conditional expression  "(object)property.Type != null && property.Type.SpecialType == SpecialType.System_String &&                      property.DeclaredAccessibility == Accessibility.Public && property.GetMemberArity() == 0 &&                      (object)property.SetMethod != null && property.SetMethod.DeclaredAccessibility == Accessibility.Public"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,ShouldEmitAttribute,The conditional expression  "(!emittingAssemblyAttributesInNetModule &&                              (IsTargetAttribute(target' AttributeDescription.AssemblyCultureAttribute) ||                               IsTargetAttribute(target' AttributeDescription.AssemblyVersionAttribute) ||                               IsTargetAttribute(target' AttributeDescription.AssemblyFlagsAttribute) ||                               IsTargetAttribute(target' AttributeDescription.AssemblyAlgorithmIdAttribute))) ||                          IsTargetAttribute(target' AttributeDescription.TypeForwardedToAttribute) ||                          IsSecurityAttribute(target.DeclaringCompilation)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,ShouldEmitAttribute,The conditional expression  "IsTargetAttribute(target' AttributeDescription.SpecialNameAttribute) ||                          IsTargetAttribute(target' AttributeDescription.NonSerializedAttribute) ||                          IsTargetAttribute(target' AttributeDescription.FieldOffsetAttribute) ||                          IsTargetAttribute(target' AttributeDescription.MarshalAsAttribute)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,ShouldEmitAttribute,The conditional expression  "IsTargetAttribute(target' AttributeDescription.SpecialNameAttribute) ||                              IsTargetAttribute(target' AttributeDescription.MethodImplAttribute) ||                              IsTargetAttribute(target' AttributeDescription.DllImportAttribute) ||                              IsTargetAttribute(target' AttributeDescription.PreserveSigAttribute) ||                              IsTargetAttribute(target' AttributeDescription.DynamicSecurityMethodAttribute) ||                              IsSecurityAttribute(target.DeclaringCompilation)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,ShouldEmitAttribute,The conditional expression  "IsTargetAttribute(target' AttributeDescription.SpecialNameAttribute) ||                          IsTargetAttribute(target' AttributeDescription.ComImportAttribute) ||                          IsTargetAttribute(target' AttributeDescription.SerializableAttribute) ||                          IsTargetAttribute(target' AttributeDescription.StructLayoutAttribute) ||                          IsTargetAttribute(target' AttributeDescription.WindowsRuntimeImportAttribute) ||                          IsSecurityAttribute(target.DeclaringCompilation)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,ShouldEmitAttribute,The conditional expression  "IsTargetAttribute(target' AttributeDescription.OptionalAttribute) ||                          IsTargetAttribute(target' AttributeDescription.DefaultParameterValueAttribute) ||                          IsTargetAttribute(target' AttributeDescription.InAttribute) ||                          IsTargetAttribute(target' AttributeDescription.OutAttribute) ||                          IsTargetAttribute(target' AttributeDescription.MarshalAsAttribute)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\MethodSymbolAdapter.cs,CalculateUseSiteDiagnostic,The conditional expression  "this.ReturnType.GetUnificationUseSiteDiagnosticRecursive(ref result' this' ref unificationCheckedTypes) ||                      GetUnificationUseSiteDiagnosticRecursive(ref result' this.ReturnTypeCustomModifiers' this' ref unificationCheckedTypes) ||                      GetUnificationUseSiteDiagnosticRecursive(ref result' this.Parameters' this' ref unificationCheckedTypes) ||                      GetUnificationUseSiteDiagnosticRecursive(ref result' this.TypeParameters' this' ref unificationCheckedTypes)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,ConstantValueUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstantValueUtils.cs,GetAndValidateConstantValue,The conditional expression  "unconvertedConstantValue != null &&                          !unconvertedConstantValue.IsNull &&                          typeSymbol.IsReferenceType &&                          typeSymbol.SpecialType != SpecialType.System_String"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,ConstraintsHelper,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstraintsHelper.cs,ResolveBounds,The conditional expression  "constraintTypeParameter.HasValueTypeConstraint && !inherited && currentCompilation != null && constraintTypeParameter.IsFromCompilation(currentCompilation)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,HaveSameConstraints,The conditional expression  "(typeParameter1.HasConstructorConstraint != typeParameter2.HasConstructorConstraint) ||                  (typeParameter1.HasReferenceTypeConstraint != typeParameter2.HasReferenceTypeConstraint) ||                  (typeParameter1.HasValueTypeConstraint != typeParameter2.HasValueTypeConstraint) ||                  (typeParameter1.Variance != typeParameter2.Variance)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,MemberSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSignatureComparer.cs,HaveSameParameterTypes,The conditional expression  "!type1.Equals(type2' ignoreDynamic: true) ||                          !param1.CustomModifiers.SequenceEqual(param2.CustomModifiers) ||                          (!param1.CustomModifiers.IsEmpty && param1.RefKind != RefKind.None && param2.RefKind != RefKind.None && param1.HasByRefBeforeCustomModifiers != param2.HasByRefBeforeCustomModifiers)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,MethodSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MethodSymbolExtensions.cs,IsRuntimeFinalizer,The conditional expression  "(object)method == null || method.Name != WellKnownMemberNames.DestructorName ||                  method.ParameterCount != 0 || method.Arity != 0 || !method.IsMetadataVirtual(ignoreInterfaceImplementationChanges: true)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,TopLevel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MissingMetadataTypeSymbol.cs,Equals,The conditional expression  "ignoreDynamic &&                      (object)t2 != null &&                      t2.TypeKind == TypeKind.Dynamic &&                      this.SpecialType == Microsoft.CodeAnalysis.SpecialType.System_Object"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,OverriddenOrHiddenMembersHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\OverriddenOrHiddenMembersHelpers.cs,FindOverriddenOrHiddenMembersInType,The conditional expression  "currTypeHasExactMatch && memberIsFromSomeCompilation && member.IsDefinition && TypeOrReturnTypeHasCustomModifiers(currTypeBestMatch)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,CustomModifierUtils,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\CustomModifierUtils.cs,CopyParameterCustomModifiers,The conditional expression  "sourceParameter.CustomModifiers.Any() || sourceParameter.Type.HasCustomModifiers() ||                      destinationParameter.CustomModifiers.Any() || destinationParameter.Type.HasCustomModifiers() || // Could happen if the associated property has custom modifiers.                      (alsoCopyParamsModifier && (sourceParameter.IsParams != destinationParameter.IsParams))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,MakeParameters,The conditional expression  "paramsKeyword.Kind() != SyntaxKind.None || outKeyword.Kind() != SyntaxKind.None ||                          refKeyword.Kind() != SyntaxKind.None || thisKeyword.Kind() != SyntaxKind.None"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportParameterErrors,The conditional expression  "firstDefault != -1 && parameterIndex > firstDefault && !isDefault && !parameter.IsParams"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The conditional expression  "!conversion.Exists ||                  conversion.IsUserDefined ||                  conversion.IsIdentity && parameterType.SpecialType == SpecialType.System_Object && defaultExpression.Type.IsDynamic()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The conditional expression  "conversion.IsReference &&                  (parameterType.SpecialType == SpecialType.System_Object || parameterType.Kind == SymbolKind.DynamicType) &&                  (object)defaultExpression.Type != null &&                  defaultExpression.Type.SpecialType == SpecialType.System_String ||                  conversion.IsBoxing"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,ReportDefaultParameterErrors,The conditional expression  "conversion.IsNullable && defaultExpression.Kind == BoundKind.DefaultOperator && !defaultExpression.Type.IsNullableType() &&                  !(parameterType.GetNullableUnderlyingType().IsEnumType() || parameterType.GetNullableUnderlyingType().IsIntrinsicType())"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ValidateAttributeSemantics,The conditional expression  "DeclaringCompilation.Options.OutputKind != OutputKind.NetModule &&                  Identity.HasPublicKey &&                  !IsDelaySign &&                  !StrongNameKeys.CanSign &&                  StrongNameKeys.DiagnosticOpt == null"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportNameCollisionDiagnosticsForAddedModules,The conditional expression  "constituent.Length > 2 || (constituent.Length == 2 && constituent[0].ContainingModule.Ordinal != 0 && constituent[1].ContainingModule.Ordinal != 0)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,IsKnownAssemblyAttribute,The conditional expression  "attribute.IsTargetAttribute(this' AttributeDescription.AssemblyTitleAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyDescriptionAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyConfigurationAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyCultureAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyVersionAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyCompanyAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyProductAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyInformationalVersionAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyCopyrightAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyTrademarkAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyKeyFileAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyKeyNameAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyAlgorithmIdAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyFlagsAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyDelaySignAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblyFileVersionAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.SatelliteContractVersionAttribute) ||                  attribute.IsTargetAttribute(this' AttributeDescription.AssemblySignatureKeyAttribute)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,TryLookupForwardedMetadataTypeWithCycleDetection,The conditional expression  "(forcedArity == -1 || result.Arity == forcedArity) &&                      (!emittedName.UseCLSCompliantNameArityEncoding || result.Arity == 0 || result.MangleName)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceConstructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceConstructorSymbol.cs,MethodChecks,The conditional expression  "_lazyIsVararg && (IsGenericMethod || ContainingType.IsGenericType || _lazyParameters.Length > 0 && _lazyParameters[_lazyParameters.Length - 1].IsParams)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,CheckModifiersAndType,The conditional expression  "this.DeclaredAccessibility == Accessibility.Private && (IsVirtual || IsAbstract || IsOverride)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceEventSymbol.cs,CheckModifiersAndType,The conditional expression  "IsStatic && (IsOverride || IsVirtual || IsAbstract)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldLikeEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldLikeEventSymbol.cs,SourceFieldLikeEventSymbol,The conditional expression  "hasInitializer || !(inInterfaceType || this.IsExtern || this.IsAbstract)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceFieldSymbolWithSyntaxReference,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceFieldSymbol.cs,GetConstantValueDependencies,The conditional expression  "(builder.Count == 0) &&                  (value != null) &&                  !value.IsBad &&                  (value != Microsoft.CodeAnalysis.ConstantValue.Unset) &&                  diagnostics.IsEmptyWithoutResolution"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,HasStructCircularity,The conditional expression  "((object)type != null) &&                          (type.TypeKind == TypeKind.Struct) &&                          BaseTypeAnalysis.StructDependsOn(type' this) &&                          !type.IsPrimitiveRecursiveStruct()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,AddSynthesizedConstructorsIfNecessary,The conditional expression  "(!hasParameterlessInstanceConstructor && this.IsStructType()) || (!hasInstanceConstructor && !this.IsStatic)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,ComputeInterfaceImplementations,The conditional expression  "(object)associatedPropertyOrEvent == null ||                          ReportAccessorOfInterfacePropertyOrEvent(associatedPropertyOrEvent) ||                          (wasImplementingMemberFound && !implementingMember.IsAccessor())"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckOverrideMember,The conditional expression  "!overriddenMember.IsVirtual && !overriddenMember.IsAbstract && !overriddenMember.IsOverride &&                          !(overridingMemberIsMethod && ((MethodSymbol)overriddenMember).MethodKind == MethodKind.Destructor)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckNonOverrideMember,The conditional expression  "!hidingMemberIsNew && hiddenMember.Kind == hidingMember.Kind &&                              !hidingMember.IsAccessor() &&                              (hiddenMember.IsAbstract || hiddenMember.IsVirtual || hiddenMember.IsOverride)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckNonOverrideMember,The conditional expression  "!hidingMemberIsNew && !diagnosticAdded && !hidingMember.IsAccessor() && !hidingMember.IsOperator()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckInterfaceUnification,The conditional expression  "interface1.IsGenericType && interface2.IsGenericType &&                          interface1.OriginalDefinition == interface2.OriginalDefinition &&                          interface1.CanUnifyWith(interface2)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,MethodChecks,The conditional expression  "this.Name == WellKnownMemberNames.DestructorName && this.ParameterCount == 0 && this.Arity == 0 && this.ReturnsVoid"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,CheckModifiers,The conditional expression  "this.DeclaredAccessibility == Accessibility.Private && (IsVirtual || IsAbstract || IsOverride)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,CheckModifiers,The conditional expression  "IsStatic && (IsOverride || IsVirtual || IsAbstract)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,CheckModifiers,The conditional expression  "bodySyntaxReferenceOpt == null && !IsExtern && !IsAbstract && !IsPartial && !IsExpressionBodied"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberMethodSymbol.cs,CheckModifiers,The conditional expression  "_lazyIsVararg && (IsGenericMethod || ContainingType.IsGenericType || _lazyParameters.Length > 0 && _lazyParameters[_lazyParameters.Length - 1].IsParams)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,MakeOneDeclaredBases,The conditional expression  "this.SpecialType == SpecialType.System_Enum && baseSpecialType == SpecialType.System_ValueType ||                              this.SpecialType == SpecialType.System_MulticastDelegate && baseSpecialType == SpecialType.System_Delegate"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,MakeOneDeclaredBases,The conditional expression  "(baseType.TypeKind == TypeKind.Class ||                           baseType.TypeKind == TypeKind.Delegate ||                           baseType.TypeKind == TypeKind.Struct ||                           baseTypeIsErrorWithoutInterfaceGuess) &&                          ((object)localBase == null)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamespaceSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol.cs,MakeNameToMembersMap,The conditional expression  "nts is SourceNamedTypeSymbol && other is SourceNamedTypeSymbol &&                              (nts as SourceNamedTypeSymbol).IsPartial && (other as SourceNamedTypeSymbol).IsPartial"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceParameterSymbol.cs,Create,The conditional expression  "!isParams &&                  !isExtensionMethodThis &&                  (syntax.Default == null) &&                  (syntax.AttributeLists.Count == 0) &&                  !owner.IsPartialMethod()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,CheckModifiers,The conditional expression  "bodySyntaxReferenceOpt == null && !IsExtern && !IsAbstract && !isAutoPropertyOrExpressionBodied"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,CheckModifiers,The conditional expression  "this.DeclaredAccessibility == Accessibility.Private && (IsVirtual || IsAbstract || IsOverride)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,CheckModifiers,The conditional expression  "IsStatic && (IsOverride || IsVirtual || IsAbstract)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceUserDefinedOperatorSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceUserDefinedOperatorSymbolBase.cs,SourceUserDefinedOperatorSymbolBase,The conditional expression  "bodySyntaxReference == null && !IsExtern && !IsAbstract && !IsPartial"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SourceUserDefinedOperatorSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceUserDefinedOperatorSymbolBase.cs,CheckUserDefinedConversionSignature,The conditional expression  "source0 != this.ContainingType && target0 != this.ContainingType &&                  // allow conversion between T and Nullable<T> in declaration of Nullable<T>                  source != this.ContainingType && target != this.ContainingType"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,TryParseGeneratedName,The conditional expression  "(c >= '1' && c <= '9') || (c >= 'a' && c <= 'z')"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedIntrinsicOperatorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedIntrinsicOperatorSymbol.cs,Equals,The conditional expression  "_isCheckedBuiltin == other._isCheckedBuiltin &&                  _parameters.Length == other._parameters.Length &&                  string.Equals(_name' other._name' StringComparison.Ordinal) &&                  _containingType == other._containingType &&                  _returnType == other._returnType"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,IsPossibleArrayGenericInterface,The conditional expression  "st == SpecialType.System_Collections_Generic_IList_T ||                  st == SpecialType.System_Collections_Generic_ICollection_T ||                  st == SpecialType.System_Collections_Generic_IEnumerable_T ||                  st == SpecialType.System_Collections_Generic_IReadOnlyList_T ||                  st == SpecialType.System_Collections_Generic_IReadOnlyCollection_T"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedTypesManager,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedTypesManager.cs,EmbedField,The conditional expression  "containerKind == TypeKind.Interface || containerKind == TypeKind.Delegate ||                  (containerKind == TypeKind.Struct && (field.IsStatic || field.DeclaredAccessibility != Accessibility.Public))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Reader,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Blender.Reader.cs,CanReuse,The conditional expression  "nodeOrToken.ContainsDiagnostics ||                      (nodeOrToken.IsToken && ((CSharpSyntaxNode)nodeOrToken.AsToken().Node).ContainsSkippedText && nodeOrToken.Parent.ContainsDiagnostics)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Reader,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Blender.Reader.cs,CanReuse,The conditional expression  "(nodeOrToken.IsToken && nodeOrToken.AsToken().IsMissing) ||                      (nodeOrToken.IsNode && IsIncomplete((CSharp.CSharpSyntaxNode)nodeOrToken.AsNode()))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseLineDirective,The conditional expression  "this.CurrentToken.Kind == SyntaxKind.StringLiteralToken &&                          (line.IsMissing || line.GetTrailingTriviaWidth() > 0 || this.CurrentToken.GetLeadingTriviaWidth() > 0)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,IsVerbatimCref,The conditional expression  "(current.Kind == SyntaxKind.XmlTextLiteralToken || current.Kind == SyntaxKind.XmlEntityLiteralToken) &&                  current.ValueText != SyntaxFacts.GetText(openQuote.Kind) &&                  current.ValueText != ":""  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseXmlAttributeText,The conditional expression  "this.CurrentToken.Kind == SyntaxKind.XmlTextLiteralToken                      || this.CurrentToken.Kind == SyntaxKind.XmlTextLiteralNewLineToken                      || this.CurrentToken.Kind == SyntaxKind.XmlEntityLiteralToken                      || this.CurrentToken.Kind == SyntaxKind.LessThanToken"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseModifiers,The conditional expression  "IsPossibleStartOfTypeDeclaration(currToken.Kind) ||                                      currToken.Kind == SyntaxKind.EventKeyword ||                                      ((currToken.Kind == SyntaxKind.ExplicitKeyword || currToken.Kind == SyntaxKind.ImplicitKeyword) && PeekToken(1).Kind == SyntaxKind.OperatorKeyword) ||                                      (ScanType() != ScanTypeFlags.NotType && (this.CurrentToken.Kind == SyntaxKind.OperatorKeyword || IsPossibleMemberName()))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ReportDuplicateModifiers,The conditional expression  "!(((newMod == SyntaxModifier.Protected) && (mods & SyntaxModifier.Internal) != 0) ||                              ((newMod == SyntaxModifier.Internal) && (mods & SyntaxModifier.Protected) != 0))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,SkipBadMemberListTokens,The conditional expression  "CanStartMember(kind) &&                          !(kind == SyntaxKind.DelegateKeyword && (this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken || this.PeekToken(1).Kind == SyntaxKind.OpenParenToken))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The conditional expression  "this.CurrentToken.Kind == SyntaxKind.ExplicitKeyword ||                      this.CurrentToken.Kind == SyntaxKind.ImplicitKeyword ||                          (this.CurrentToken.Kind == SyntaxKind.OperatorKeyword && !SyntaxFacts.IsAnyOverloadableOperator(this.PeekToken(1).Kind))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The conditional expression  "acceptStatement &&                      this.CurrentToken.Kind != SyntaxKind.CloseBraceToken &&                      this.CurrentToken.Kind != SyntaxKind.EndOfFileToken &&                      this.IsPossibleStatement()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The conditional expression  "GetModifier(this.CurrentToken) != SyntaxModifier.None &&                      this.CurrentToken.ContextualKind != SyntaxKind.PartialKeyword &&                      this.CurrentToken.ContextualKind != SyntaxKind.AsyncKeyword &&                      IsComplete(type)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The conditional expression  "identifierOrThisOpt != null &&                      (typeParameterListOpt != null && typeParameterListOpt.ContainsDiagnostics                        || this.CurrentToken.Kind != SyntaxKind.OpenParenToken && this.CurrentToken.Kind != SyntaxKind.OpenBraceToken) &&                      ReconsiderTypeAsAsyncModifier(ref modifiers' ref type' ref explicitInterfaceOpt' identifierOrThisOpt' typeParameterListOpt)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMethodDeclaration,The conditional expression  "!constraints.IsNull && constraints.Count > 0 &&                      ((explicitInterfaceOpt != null) || (modifiers != null && modifiers.Any(SyntaxKind.OverrideKeyword)))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAccessorDeclaration,The conditional expression  "(isAdd && hasGetOrAdd) || (isRemove && hasSetOrRemove)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAccessorDeclaration,The conditional expression  "(isGet && hasGetOrAdd) || (isSet && hasSetOrRemove)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAccessorDeclaration,The conditional expression  "this.CurrentToken.Kind == SyntaxKind.OpenBraceToken || (validAccName && !currentTokenIsSemicolon && !IsTerminator())"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseParameterModifiers,The conditional expression  "mod.Kind == SyntaxKind.ThisKeyword ||                      mod.Kind == SyntaxKind.RefKeyword ||                      mod.Kind == SyntaxKind.OutKeyword ||                      mod.Kind == SyntaxKind.ParamsKeyword"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanTypeArgumentList,The conditional expression  "tokenID != SyntaxKind.OpenParenToken &&                              tokenID != SyntaxKind.CloseParenToken &&                              tokenID != SyntaxKind.CloseBracketToken &&                              tokenID != SyntaxKind.ColonToken &&                              tokenID != SyntaxKind.SemicolonToken &&                              tokenID != SyntaxKind.CommaToken &&                              tokenID != SyntaxKind.DotToken &&                              tokenID != SyntaxKind.QuestionToken &&                              tokenID != SyntaxKind.EqualsEqualsToken &&                              tokenID != SyntaxKind.ExclamationEqualsToken &&                                // The preceding tokens are from 7.5.4.2 Grammar Ambiguities;                              // the following tokens are not.                              tokenID != SyntaxKind.AmpersandAmpersandToken &&                              tokenID != SyntaxKind.BarBarToken &&                              tokenID != SyntaxKind.CaretToken &&                              tokenID != SyntaxKind.BarToken &&                              tokenID != SyntaxKind.CloseBraceToken &&                              tokenID != SyntaxKind.EndOfFileToken"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseTypeCore,The conditional expression  "isOrAs && (IsTerm() || IsPredefinedType(this.CurrentToken.Kind) || SyntaxFacts.IsAnyUnaryExpression(this.CurrentToken.Kind))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleMethodDeclarationFollowingNullableType,The conditional expression  "!parameter.Identifier.IsMissing &&                      (separatedParameters.Count >= 2 && !separatedParameters[1].IsMissing ||                       separatedParameters.Count == 1 && !paramList.CloseParenToken.IsMissing)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseStatements,The conditional expression  "this.CurrentToken.Kind != SyntaxKind.CloseBraceToken                  && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken                  && !(stopOnSwitchSections && this.IsPossibleSwitchSection())"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseForOrForEachStatement,The conditional expression  "this.EatToken().Kind == SyntaxKind.OpenParenToken &&                          this.ScanType() != ScanTypeFlags.NotType &&                          this.EatToken().Kind == SyntaxKind.IdentifierToken &&                          this.EatToken().Kind == SyntaxKind.InKeyword"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseUsingExpression,The conditional expression  "this.CurrentToken.Kind == SyntaxKind.ColonToken &&                                  type.Kind == SyntaxKind.NullableType &&                                  SyntaxFacts.IsName(((NullableTypeSyntax)type).ElementType.Kind) &&                                  variables.Count == 1"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanParenthesizedImplicitlyTypedLambda,The conditional expression  "this.PeekToken(1).Kind == SyntaxKind.IdentifierToken                  && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))                  && this.PeekToken(2).Kind == SyntaxKind.CommaToken"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanParenthesizedImplicitlyTypedLambda,The conditional expression  "this.PeekToken(1).Kind == SyntaxKind.IdentifierToken                  && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))                  && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken                  && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanCast,The conditional expression  "type == ScanTypeFlags.PointerOrMultiplication ||                  type == ScanTypeFlags.NullableType ||                  type == ScanTypeFlags.MustBeType ||                  type == ScanTypeFlags.AliasQualifiedName"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseLambdaParameter,The conditional expression  "isRefOrOutOrParams                  || (pk != SyntaxKind.CommaToken && pk != SyntaxKind.CloseParenToken && (hasTypes || isFirst))                  || IsPredefinedType(this.CurrentToken.Kind)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_CrefSlowPath,The conditional expression  "!isEscaped && (TextWindow.Position == beforeConsumed + 1) &&                              (TextWindow.PeekChar() == 'u' || TextWindow.PeekChar() == 'U')"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexSyntaxTrivia,The conditional expression  "!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&                                  TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/'"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The conditional expression  "TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '['"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlCrefToken,The conditional expression  "!InXmlNameAttributeValue && !info.IsVerbatim && !info.HasIdentifierEscapeSequence && _cache.TryGetKeywordKind(info.StringValue' out keywordKind)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,AdvanceIfMatches,The conditional expression  "(peekCh == ch) ||                  (peekCh == '{' && ch == '<') ||                  (peekCh == '}' && ch == '>')"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The conditional expression  "TextWindow.PeekChar() == '/'                      && TextWindow.PeekChar(1) == '*'                      && TextWindow.PeekChar(2) == '*'                      && TextWindow.PeekChar(3) != '*'"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The conditional expression  "this.StyleIs(XmlDocCommentStyle.SingleLine) && TextWindow.PeekChar(1) == '/' && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/'"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\Syntax.cs,XmlTextNewLine,The conditional expression  "leading == null && trailing == null && text == CrLf && value == CrLf"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,MemberRefMetadataDecoder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\MemberRefMetadataDecoder.cs,FindMethodBySignature,The conditional expression  "(object)method != null &&                      ((byte)method.CallingConvention == targetMemberSignatureHeader.RawValue) &&                      (targetMemberTypeParamCount == method.Arity) &&                      MethodSymbolMatchesParamInfo(method' targetParamInfo)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,ComputeMethodKind,The conditional expression  "(_flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&                          _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&                          this.ReturnsVoid && this.Arity == 0"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateFields,The conditional expression  "!(isOrdinaryEmbeddableStruct ||                              (isOrdinaryStruct && (module.GetFieldDefFlagsOrThrow(fieldRid) & FieldAttributes.Static) == 0) ||                              module.ShouldImportField(fieldRid' moduleSymbol.ImportOptions))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEPropertySymbol.cs,PEPropertySymbol,The conditional expression  "propEx != null || getEx != null || setEx != null || mrEx != null || isBad"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEPropertySymbol.cs,DoSignaturesMatch,The conditional expression  "(getMethod.IsExtern != setMethod.IsExtern) ||                      // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor                      (getMethod.IsSealed != setMethod.IsSealed) ||                      (getMethod.IsOverride != setMethod.IsOverride) ||                      (getMethod.IsStatic != setMethod.IsStatic)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,LineBreaksAfter,The conditional expression  "(nextToken.IsKind(SyntaxKind.FromKeyword) && nextToken.Parent.IsKind(SyntaxKind.FromClause)) ||                  (nextToken.IsKind(SyntaxKind.LetKeyword) && nextToken.Parent.IsKind(SyntaxKind.LetClause)) ||                  (nextToken.IsKind(SyntaxKind.WhereKeyword) && nextToken.Parent.IsKind(SyntaxKind.WhereClause)) ||                  (nextToken.IsKind(SyntaxKind.JoinKeyword) && nextToken.Parent.IsKind(SyntaxKind.JoinClause)) ||                  (nextToken.IsKind(SyntaxKind.JoinKeyword) && nextToken.Parent.Kind() == SyntaxKind.JoinIntoClause) ||                  (nextToken.Kind() == SyntaxKind.OrderByKeyword && nextToken.Parent.Kind() == SyntaxKind.OrderByClause) ||                  (nextToken.Kind() == SyntaxKind.SelectKeyword && nextToken.Parent.Kind() == SyntaxKind.SelectClause) ||                  (nextToken.Kind() == SyntaxKind.GroupKeyword && nextToken.Parent.Kind() == SyntaxKind.GroupClause)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,NeedsSeparator,The conditional expression  "(token.Parent is AssignmentExpressionSyntax && AssignmentTokenNeedsSeparator(token.Kind())) ||                  (next.Parent is AssignmentExpressionSyntax && AssignmentTokenNeedsSeparator(next.Kind())) ||                  (token.Parent is BinaryExpressionSyntax && BinaryTokenNeedsSeparator(token.Kind())) ||                  (next.Parent is BinaryExpressionSyntax && BinaryTokenNeedsSeparator(next.Kind()))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,NeedsSeparator,The conditional expression  "!next.IsKind(SyntaxKind.ColonToken) &&                      !next.IsKind(SyntaxKind.DotToken) &&                      !next.IsKind(SyntaxKind.SemicolonToken) &&                      !next.IsKind(SyntaxKind.OpenBracketToken) &&                      !next.IsKind(SyntaxKind.CloseParenToken) &&                      !next.IsKind(SyntaxKind.CloseBraceToken) &&                      !next.IsKind(SyntaxKind.ColonColonToken) &&                      !next.IsKind(SyntaxKind.GreaterThanToken) &&                      !next.IsKind(SyntaxKind.CommaToken)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,GetDeclarationDepth,The conditional expression  "node is MemberDeclarationSyntax ||                          node is AccessorDeclarationSyntax ||                          node is TypeParameterConstraintClauseSyntax ||                          node is SwitchSectionSyntax ||                          node is UsingDirectiveSyntax ||                          node is ExternAliasDirectiveSyntax ||                          node is QueryExpressionSyntax ||                          node is QueryContinuationSyntax"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxRemover,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxNodeRemover.cs,AddTrivia,The conditional expression  "(_options & SyntaxRemoveOptions.KeepEndOfLine) != 0                      && (HasEndOfLine(token.LeadingTrivia) ||                          HasEndOfLine(token.TrailingTrivia) ||                          HasEndOfLine(node.GetLeadingTrivia()))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxRemover,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxNodeRemover.cs,AddTrivia,The conditional expression  "(_options & SyntaxRemoveOptions.KeepEndOfLine) != 0                      && (HasEndOfLine(node.GetTrailingTrivia()) ||                          HasEndOfLine(token.LeadingTrivia) ||                          HasEndOfLine(token.TrailingTrivia))"  is complex.
Virtual Method Call from Constructor,Microsoft.CodeAnalysis.CSharp.Symbols,BaseMethodWrapperSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,BaseMethodWrapperSymbol,The constructor "BaseMethodWrapperSymbol" calls a virtual method "GetReference".
Virtual Method Call from Constructor,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertySymbol.cs,SourcePropertySymbol,The constructor "SourcePropertySymbol" calls a virtual method "Equals".
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,GetAssemblyAttributes,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,GetCustomAttributesForToken,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEModuleSymbol.cs,HasAnyCustomAttributes,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,EnsureNonTypeMemberNamesAreLoaded,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,EnsureNonTypeMemberNamesAreLoaded,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,EnsureNonTypeMemberNamesAreLoaded,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,EnsureNonTypeMemberNamesAreLoaded,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,EnsureNonTypeMemberNamesAreLoaded,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,EnsureNonTypeMemberNamesAreLoaded,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,EnsureNonTypeMemberNamesAreLoaded,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,EnsureNonTypeMemberNamesAreLoaded,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,GetEnumFieldsToEmit,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,GetEnumFieldsToEmit,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,GetMethodsToEmit,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,LoadMembers,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateFields,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateFields,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateMethods,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateProperties,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateProperties,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateEvents,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateEvents,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamespaceSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamespaceSymbol.cs,LazyInitializeTypes,The method has an empty catch block.
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindInterpolatedString,The following statement contains a magic number: foreach (var content in node.Contents)              {                  switch (content.Kind())                  {                      case SyntaxKind.Interpolation:                          {                              var interpolation = (InterpolationSyntax)content;                              var value = BindValue(interpolation.Expression' diagnostics' Binder.BindValueKind.RValue);                              // We need to ensure the argument is not a lambda' method group' etc. It isn't nice to wait until lowering'                              // when we perform overload resolution' to report a problem. So we do that check by calling                              // GenerateConversionForAssignment with objectType. However we want to preserve the original expression's                              // natural type so that overload resolution may select a specialized implementation of string.Format'                              // so we discard the result of that call and only preserve its diagnostics.                              var discarded = GenerateConversionForAssignment(objectType' value' diagnostics);                              BoundExpression alignment = null' format = null;                              if (interpolation.AlignmentClause != null)                              {                                  alignment = GenerateConversionForAssignment(intType' BindValue(interpolation.AlignmentClause.Value' diagnostics' Binder.BindValueKind.RValue)' diagnostics);                                  var alignmentConstant = alignment.ConstantValue;                                  if (alignmentConstant != null && !alignmentConstant.IsBad)                                  {                                      const int magnitudeLimit = 32767;                                      // check that the magnitude of the alignment is "in range".                                      int alignmentValue = alignmentConstant.Int32Value;                                      //  We do the arithmetic using negative numbers because the largest negative int has no corresponding positive (absolute) value.                                      alignmentValue = (alignmentValue > 0) ? -alignmentValue : alignmentValue;                                      if (alignmentValue < -magnitudeLimit)                                      {                                          diagnostics.Add(ErrorCode.WRN_AlignmentMagnitude' alignment.Syntax.Location' alignmentConstant.Int32Value' magnitudeLimit);                                      }                                  }                                  else if (!alignment.HasErrors)                                  {                                      diagnostics.Add(ErrorCode.ERR_ConstantExpected' interpolation.AlignmentClause.Value.Location);                                  }                              }                                if (interpolation.FormatClause != null)                              {                                  var text = interpolation.FormatClause.FormatStringToken.ValueText;                                  char lastChar;                                  bool hasErrors = false;                                  if (text.Length == 0)                                  {                                      diagnostics.Add(ErrorCode.ERR_EmptyFormatSpecifier' interpolation.FormatClause.Location);                                      hasErrors = true;                                  }                                  else if (SyntaxFacts.IsWhitespace(lastChar = text[text.Length - 1]) || SyntaxFacts.IsNewLine(lastChar))                                  {                                      diagnostics.Add(ErrorCode.ERR_TrailingWhitespaceInFormatSpecifier' interpolation.FormatClause.Location);                                      hasErrors = true;                                  }                                    format = new BoundLiteral(interpolation.FormatClause' ConstantValue.Create(text)' stringType' hasErrors);                              }                                builder.Add(new BoundStringInsert(interpolation' value' alignment' format' null));                              continue;                          }                      case SyntaxKind.InterpolatedStringText:                          {                              var text = ((InterpolatedStringTextSyntax)content).TextToken.ValueText;                              builder.Add(new BoundLiteral(node' ConstantValue.Create(text' SpecialType.System_String)' stringType));                              continue;                          }                      default:                          throw ExceptionUtilities.Unreachable;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ResolveMultipleSymbolsInAttributeTypeLookup,The following statement contains a magic number: Debug.Assert(symbols.Count >= 2);
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIntegralMinValConstants,The following statement contains a magic number: if (token.Value is uint)              {                  uint value = (uint)token.Value;                  if (value != 2147483648U)                  {                      return null;                  }                    if (token.Text.Contains("u") || token.Text.Contains("U") || token.Text.Contains("l") || token.Text.Contains("L"))                  {                      return null;                  }                    return new BoundLiteral(node' ConstantValue.Create((int)-2147483648)' GetSpecialType(SpecialType.System_Int32' diagnostics' node));              }              else if (token.Value is ulong)              {                  var value = (ulong)token.Value;                  if (value != 9223372036854775808UL)                  {                      return null;                  }                    if (token.Text.Contains("u") || token.Text.Contains("U"))                  {                      return null;                  }                    return new BoundLiteral(node' ConstantValue.Create(-9223372036854775808)' GetSpecialType(SpecialType.System_Int64' diagnostics' node));              }
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIntegralMinValConstants,The following statement contains a magic number: if (token.Value is uint)              {                  uint value = (uint)token.Value;                  if (value != 2147483648U)                  {                      return null;                  }                    if (token.Text.Contains("u") || token.Text.Contains("U") || token.Text.Contains("l") || token.Text.Contains("L"))                  {                      return null;                  }                    return new BoundLiteral(node' ConstantValue.Create((int)-2147483648)' GetSpecialType(SpecialType.System_Int32' diagnostics' node));              }              else if (token.Value is ulong)              {                  var value = (ulong)token.Value;                  if (value != 9223372036854775808UL)                  {                      return null;                  }                    if (token.Text.Contains("u") || token.Text.Contains("U"))                  {                      return null;                  }                    return new BoundLiteral(node' ConstantValue.Create(-9223372036854775808)' GetSpecialType(SpecialType.System_Int64' diagnostics' node));              }
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReverseLastTwoParameterOrder,The following statement contains a magic number: arguments[n - 1] = arguments[n - 2];
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReverseLastTwoParameterOrder,The following statement contains a magic number: arguments[n - 2] = lastArgument;
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReverseLastTwoParameterOrder,The following statement contains a magic number: argsToParams[n - 1] = n - 2;
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReverseLastTwoParameterOrder,The following statement contains a magic number: argsToParams[n - 2] = n - 1;
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceFrom,The following statement contains a magic number: if (state.clauses.IsEmpty() && state.selectOrGroup.IsKind(SyntaxKind.SelectClause))              {                  var select = (SelectClauseSyntax)state.selectOrGroup;                    // A query expression with a second from clause followed by a select clause                  //     from x1 in e1                  //     from x2 in e2                  //     select v                  // is translated into                  //     ( e1 ) . SelectMany( x1 => e2 ' ( x1 ' x2 ) => v )                  var resultSelectorLambda = MakeQueryUnboundLambda(state.RangeVariableMap()' ImmutableArray.Create(x1' x2)' select.Expression);                    var invocation = MakeQueryInvocation(                      from'                      state.fromExpression'                      "SelectMany"'                      ImmutableArray.Create(collectionSelectorLambda' resultSelectorLambda)'                      diagnostics);                    // Adjust the second-to-last parameter to be a query clause (if it was an extension method' an extra parameter was added)                  BoundExpression castInvocation = (from.Type != null) ? ExtractCastInvocation(invocation) : null;                    var arguments = invocation.Arguments;                  invocation = invocation.Update(                      invocation.ReceiverOpt'                      invocation.Method'                      arguments.SetItem(arguments.Length - 2' MakeQueryClause(from' arguments[arguments.Length - 2]' x2' invocation' castInvocation)));                    state.Clear();                  state.fromExpression = MakeQueryClause(from' invocation' definedSymbol: x2' queryInvocation: invocation);                  state.fromExpression = MakeQueryClause(select' state.fromExpression);              }              else              {                  // A query expression with a second from clause followed by something other than a select clause:                  //     from x1 in e1                  //     from x2 in e2                  //     ...                  // is translated into                  //     from * in ( e1 ) . SelectMany( x1 => e2 ' ( x1 ' x2 ) => new { x1 ' x2 } )                  //     ...                    // We use a slightly different translation strategy.  We produce                  //     from * in ( e ) . SelectMany ( x1 => e2' ( x1 ' x2 ) => new Pair<X1'X2>(x1' x2) )                  // Where X1 is the type of x1' and X2 is the type of x2.                  // Subsequently' x1 (or members of x1' if it is a transparent identifier)                  // are accessed as TRID.Item1 (or members of that)' and x2 is accessed                  // as TRID.Item2' where TRID is the compiler-generated identifier used                  // to represent the transparent identifier in the result.                  var resultSelectorLambda = MakePairLambda(from' state' x1' x2);                    var invocation = MakeQueryInvocation(                      from'                      state.fromExpression'                      "SelectMany"'                      ImmutableArray.Create(collectionSelectorLambda' resultSelectorLambda)'                      diagnostics);                    BoundExpression castInvocation = (from.Type != null) ? ExtractCastInvocation(invocation) : null;                  state.fromExpression = MakeQueryClause(from' invocation' x2' invocation' castInvocation);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReduceFrom,The following statement contains a magic number: if (state.clauses.IsEmpty() && state.selectOrGroup.IsKind(SyntaxKind.SelectClause))              {                  var select = (SelectClauseSyntax)state.selectOrGroup;                    // A query expression with a second from clause followed by a select clause                  //     from x1 in e1                  //     from x2 in e2                  //     select v                  // is translated into                  //     ( e1 ) . SelectMany( x1 => e2 ' ( x1 ' x2 ) => v )                  var resultSelectorLambda = MakeQueryUnboundLambda(state.RangeVariableMap()' ImmutableArray.Create(x1' x2)' select.Expression);                    var invocation = MakeQueryInvocation(                      from'                      state.fromExpression'                      "SelectMany"'                      ImmutableArray.Create(collectionSelectorLambda' resultSelectorLambda)'                      diagnostics);                    // Adjust the second-to-last parameter to be a query clause (if it was an extension method' an extra parameter was added)                  BoundExpression castInvocation = (from.Type != null) ? ExtractCastInvocation(invocation) : null;                    var arguments = invocation.Arguments;                  invocation = invocation.Update(                      invocation.ReceiverOpt'                      invocation.Method'                      arguments.SetItem(arguments.Length - 2' MakeQueryClause(from' arguments[arguments.Length - 2]' x2' invocation' castInvocation)));                    state.Clear();                  state.fromExpression = MakeQueryClause(from' invocation' definedSymbol: x2' queryInvocation: invocation);                  state.fromExpression = MakeQueryClause(select' state.fromExpression);              }              else              {                  // A query expression with a second from clause followed by something other than a select clause:                  //     from x1 in e1                  //     from x2 in e2                  //     ...                  // is translated into                  //     from * in ( e1 ) . SelectMany( x1 => e2 ' ( x1 ' x2 ) => new { x1 ' x2 } )                  //     ...                    // We use a slightly different translation strategy.  We produce                  //     from * in ( e ) . SelectMany ( x1 => e2' ( x1 ' x2 ) => new Pair<X1'X2>(x1' x2) )                  // Where X1 is the type of x1' and X2 is the type of x2.                  // Subsequently' x1 (or members of x1' if it is a transparent identifier)                  // are accessed as TRID.Item1 (or members of that)' and x2 is accessed                  // as TRID.Item2' where TRID is the compiler-generated identifier used                  // to represent the transparent identifier in the result.                  var resultSelectorLambda = MakePairLambda(from' state' x1' x2);                    var invocation = MakeQueryInvocation(                      from'                      state.fromExpression'                      "SelectMany"'                      ImmutableArray.Create(collectionSelectorLambda' resultSelectorLambda)'                      diagnostics);                    BoundExpression castInvocation = (from.Type != null) ? ExtractCastInvocation(invocation) : null;                  state.fromExpression = MakeQueryClause(from' invocation' x2' invocation' castInvocation);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckLocalVariable,The following statement contains a magic number: int index = (cause != 0 ? 4 : 0) + (checkingReceiver ? 2 : 0) + (kind == BindValueKind.OutParameter ? 0 : 1);
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckLocalVariable,The following statement contains a magic number: int index = (cause != 0 ? 4 : 0) + (checkingReceiver ? 2 : 0) + (kind == BindValueKind.OutParameter ? 0 : 1);
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckLocalVariable,The following statement contains a magic number: Debug.Assert(index != 2 && index != 3);
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckLocalVariable,The following statement contains a magic number: Debug.Assert(index != 2 && index != 3);
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportReadOnlyError,The following statement contains a magic number: int index = (checkingReceiver ? 4 : 0) + (field.IsStatic ? 2 : 0) + (kind == BindValueKind.OutParameter ? 0 : 1);
Magic Number,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportReadOnlyError,The following statement contains a magic number: int index = (checkingReceiver ? 4 : 0) + (field.IsStatic ? 2 : 0) + (kind == BindValueKind.OutParameter ? 0 : 1);
Magic Number,Microsoft.CodeAnalysis.CSharp,BinderFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,BinderFactory,The following statement contains a magic number: _binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this)' 64);
Magic Number,Microsoft.CodeAnalysis.CSharp,BinderFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,BinderFactory,The following statement contains a magic number: _binderCache = new ConcurrentCache<BinderCacheKey' Binder>(50);
Magic Number,Microsoft.CodeAnalysis.CSharp,LookupResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\LookupResult.cs,CreatePool,The following statement contains a magic number: pool = new ObjectPool<LookupResult>(() => new LookupResult(pool)' 128);
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetNumericTypeIndex,The following statement contains a magic number: switch (specialType)              {                  case SpecialType.System_SByte: return 0;                  case SpecialType.System_Byte: return 1;                  case SpecialType.System_Int16: return 2;                  case SpecialType.System_UInt16: return 3;                  case SpecialType.System_Int32: return 4;                  case SpecialType.System_UInt32: return 5;                  case SpecialType.System_Int64: return 6;                  case SpecialType.System_UInt64: return 7;                  case SpecialType.System_Char: return 8;                  case SpecialType.System_Single: return 9;                  case SpecialType.System_Double: return 10;                  case SpecialType.System_Decimal: return 11;                  default: return -1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetNumericTypeIndex,The following statement contains a magic number: switch (specialType)              {                  case SpecialType.System_SByte: return 0;                  case SpecialType.System_Byte: return 1;                  case SpecialType.System_Int16: return 2;                  case SpecialType.System_UInt16: return 3;                  case SpecialType.System_Int32: return 4;                  case SpecialType.System_UInt32: return 5;                  case SpecialType.System_Int64: return 6;                  case SpecialType.System_UInt64: return 7;                  case SpecialType.System_Char: return 8;                  case SpecialType.System_Single: return 9;                  case SpecialType.System_Double: return 10;                  case SpecialType.System_Decimal: return 11;                  default: return -1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetNumericTypeIndex,The following statement contains a magic number: switch (specialType)              {                  case SpecialType.System_SByte: return 0;                  case SpecialType.System_Byte: return 1;                  case SpecialType.System_Int16: return 2;                  case SpecialType.System_UInt16: return 3;                  case SpecialType.System_Int32: return 4;                  case SpecialType.System_UInt32: return 5;                  case SpecialType.System_Int64: return 6;                  case SpecialType.System_UInt64: return 7;                  case SpecialType.System_Char: return 8;                  case SpecialType.System_Single: return 9;                  case SpecialType.System_Double: return 10;                  case SpecialType.System_Decimal: return 11;                  default: return -1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetNumericTypeIndex,The following statement contains a magic number: switch (specialType)              {                  case SpecialType.System_SByte: return 0;                  case SpecialType.System_Byte: return 1;                  case SpecialType.System_Int16: return 2;                  case SpecialType.System_UInt16: return 3;                  case SpecialType.System_Int32: return 4;                  case SpecialType.System_UInt32: return 5;                  case SpecialType.System_Int64: return 6;                  case SpecialType.System_UInt64: return 7;                  case SpecialType.System_Char: return 8;                  case SpecialType.System_Single: return 9;                  case SpecialType.System_Double: return 10;                  case SpecialType.System_Decimal: return 11;                  default: return -1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetNumericTypeIndex,The following statement contains a magic number: switch (specialType)              {                  case SpecialType.System_SByte: return 0;                  case SpecialType.System_Byte: return 1;                  case SpecialType.System_Int16: return 2;                  case SpecialType.System_UInt16: return 3;                  case SpecialType.System_Int32: return 4;                  case SpecialType.System_UInt32: return 5;                  case SpecialType.System_Int64: return 6;                  case SpecialType.System_UInt64: return 7;                  case SpecialType.System_Char: return 8;                  case SpecialType.System_Single: return 9;                  case SpecialType.System_Double: return 10;                  case SpecialType.System_Decimal: return 11;                  default: return -1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetNumericTypeIndex,The following statement contains a magic number: switch (specialType)              {                  case SpecialType.System_SByte: return 0;                  case SpecialType.System_Byte: return 1;                  case SpecialType.System_Int16: return 2;                  case SpecialType.System_UInt16: return 3;                  case SpecialType.System_Int32: return 4;                  case SpecialType.System_UInt32: return 5;                  case SpecialType.System_Int64: return 6;                  case SpecialType.System_UInt64: return 7;                  case SpecialType.System_Char: return 8;                  case SpecialType.System_Single: return 9;                  case SpecialType.System_Double: return 10;                  case SpecialType.System_Decimal: return 11;                  default: return -1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetNumericTypeIndex,The following statement contains a magic number: switch (specialType)              {                  case SpecialType.System_SByte: return 0;                  case SpecialType.System_Byte: return 1;                  case SpecialType.System_Int16: return 2;                  case SpecialType.System_UInt16: return 3;                  case SpecialType.System_Int32: return 4;                  case SpecialType.System_UInt32: return 5;                  case SpecialType.System_Int64: return 6;                  case SpecialType.System_UInt64: return 7;                  case SpecialType.System_Char: return 8;                  case SpecialType.System_Single: return 9;                  case SpecialType.System_Double: return 10;                  case SpecialType.System_Decimal: return 11;                  default: return -1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetNumericTypeIndex,The following statement contains a magic number: switch (specialType)              {                  case SpecialType.System_SByte: return 0;                  case SpecialType.System_Byte: return 1;                  case SpecialType.System_Int16: return 2;                  case SpecialType.System_UInt16: return 3;                  case SpecialType.System_Int32: return 4;                  case SpecialType.System_UInt32: return 5;                  case SpecialType.System_Int64: return 6;                  case SpecialType.System_UInt64: return 7;                  case SpecialType.System_Char: return 8;                  case SpecialType.System_Single: return 9;                  case SpecialType.System_Double: return 10;                  case SpecialType.System_Decimal: return 11;                  default: return -1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetNumericTypeIndex,The following statement contains a magic number: switch (specialType)              {                  case SpecialType.System_SByte: return 0;                  case SpecialType.System_Byte: return 1;                  case SpecialType.System_Int16: return 2;                  case SpecialType.System_UInt16: return 3;                  case SpecialType.System_Int32: return 4;                  case SpecialType.System_UInt32: return 5;                  case SpecialType.System_Int64: return 6;                  case SpecialType.System_UInt64: return 7;                  case SpecialType.System_Char: return 8;                  case SpecialType.System_Single: return 9;                  case SpecialType.System_Double: return 10;                  case SpecialType.System_Decimal: return 11;                  default: return -1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,GetNumericTypeIndex,The following statement contains a magic number: switch (specialType)              {                  case SpecialType.System_SByte: return 0;                  case SpecialType.System_Byte: return 1;                  case SpecialType.System_Int16: return 2;                  case SpecialType.System_UInt16: return 3;                  case SpecialType.System_Int32: return 4;                  case SpecialType.System_UInt32: return 5;                  case SpecialType.System_Int64: return 6;                  case SpecialType.System_UInt64: return 7;                  case SpecialType.System_Char: return 8;                  case SpecialType.System_Single: return 9;                  case SpecialType.System_Double: return 10;                  case SpecialType.System_Decimal: return 11;                  default: return -1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,MostSpecificConversionOperator,The following statement contains a magic number: BestIndex bestFullyLifted = UniqueIndex(u'                  conv =>                  conv.FromType == sx &&                  conv.ToType == tx &&                  LiftingCount(conv) == 2);
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default:                          return -1;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The following statement contains a magic number: switch (kind)              {                  case BinaryOperatorKind.Addition:                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingAddition' enumType' underlying' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumAddition' underlying' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingAddition' nullableEnum' nullableUnderlying' nullableEnum));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumAddition' nullableUnderlying' nullableEnum' nullableEnum));                      break;                  case BinaryOperatorKind.Subtraction:                      if (Strict)                      {                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum));                      }                      else                      {                          // SPEC VIOLATION:                          // The native compiler has bugs in overload resolution involving binary operator- for enums'                          // which we duplicate by hardcoding Priority values among the operators. When present on both                          // methods being compared during overload resolution' Priority values are used to decide between                          // two candidates (instead of the usual language-specified rules).                          bool isExactSubtraction = right.Type?.StrippedType() == underlying;                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying)                          { Priority = 2 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType)                          { Priority = isExactSubtraction ? 1 : 3 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying)                          { Priority = 12 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum)                          { Priority = isExactSubtraction ? 11 : 13 });                            // Due to a bug' the native compiler allows "underlying - enum"' so Roslyn does as well.                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumSubtraction' underlying' enumType' enumType)                          { Priority = 4 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumSubtraction' nullableUnderlying' nullableEnum' nullableEnum)                          { Priority = 14 });                      }                      break;                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                  case BinaryOperatorKind.LessThanOrEqual:                      var boolean = Compilation.GetSpecialType(SpecialType.System_Boolean);                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' boolean));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' boolean));                      break;                  case BinaryOperatorKind.And:                  case BinaryOperatorKind.Or:                  case BinaryOperatorKind.Xor:                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' nullableEnum));                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The following statement contains a magic number: switch (kind)              {                  case BinaryOperatorKind.Addition:                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingAddition' enumType' underlying' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumAddition' underlying' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingAddition' nullableEnum' nullableUnderlying' nullableEnum));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumAddition' nullableUnderlying' nullableEnum' nullableEnum));                      break;                  case BinaryOperatorKind.Subtraction:                      if (Strict)                      {                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum));                      }                      else                      {                          // SPEC VIOLATION:                          // The native compiler has bugs in overload resolution involving binary operator- for enums'                          // which we duplicate by hardcoding Priority values among the operators. When present on both                          // methods being compared during overload resolution' Priority values are used to decide between                          // two candidates (instead of the usual language-specified rules).                          bool isExactSubtraction = right.Type?.StrippedType() == underlying;                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying)                          { Priority = 2 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType)                          { Priority = isExactSubtraction ? 1 : 3 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying)                          { Priority = 12 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum)                          { Priority = isExactSubtraction ? 11 : 13 });                            // Due to a bug' the native compiler allows "underlying - enum"' so Roslyn does as well.                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumSubtraction' underlying' enumType' enumType)                          { Priority = 4 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumSubtraction' nullableUnderlying' nullableEnum' nullableEnum)                          { Priority = 14 });                      }                      break;                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                  case BinaryOperatorKind.LessThanOrEqual:                      var boolean = Compilation.GetSpecialType(SpecialType.System_Boolean);                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' boolean));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' boolean));                      break;                  case BinaryOperatorKind.And:                  case BinaryOperatorKind.Or:                  case BinaryOperatorKind.Xor:                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' nullableEnum));                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The following statement contains a magic number: switch (kind)              {                  case BinaryOperatorKind.Addition:                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingAddition' enumType' underlying' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumAddition' underlying' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingAddition' nullableEnum' nullableUnderlying' nullableEnum));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumAddition' nullableUnderlying' nullableEnum' nullableEnum));                      break;                  case BinaryOperatorKind.Subtraction:                      if (Strict)                      {                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum));                      }                      else                      {                          // SPEC VIOLATION:                          // The native compiler has bugs in overload resolution involving binary operator- for enums'                          // which we duplicate by hardcoding Priority values among the operators. When present on both                          // methods being compared during overload resolution' Priority values are used to decide between                          // two candidates (instead of the usual language-specified rules).                          bool isExactSubtraction = right.Type?.StrippedType() == underlying;                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying)                          { Priority = 2 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType)                          { Priority = isExactSubtraction ? 1 : 3 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying)                          { Priority = 12 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum)                          { Priority = isExactSubtraction ? 11 : 13 });                            // Due to a bug' the native compiler allows "underlying - enum"' so Roslyn does as well.                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumSubtraction' underlying' enumType' enumType)                          { Priority = 4 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumSubtraction' nullableUnderlying' nullableEnum' nullableEnum)                          { Priority = 14 });                      }                      break;                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                  case BinaryOperatorKind.LessThanOrEqual:                      var boolean = Compilation.GetSpecialType(SpecialType.System_Boolean);                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' boolean));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' boolean));                      break;                  case BinaryOperatorKind.And:                  case BinaryOperatorKind.Or:                  case BinaryOperatorKind.Xor:                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' nullableEnum));                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The following statement contains a magic number: switch (kind)              {                  case BinaryOperatorKind.Addition:                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingAddition' enumType' underlying' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumAddition' underlying' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingAddition' nullableEnum' nullableUnderlying' nullableEnum));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumAddition' nullableUnderlying' nullableEnum' nullableEnum));                      break;                  case BinaryOperatorKind.Subtraction:                      if (Strict)                      {                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum));                      }                      else                      {                          // SPEC VIOLATION:                          // The native compiler has bugs in overload resolution involving binary operator- for enums'                          // which we duplicate by hardcoding Priority values among the operators. When present on both                          // methods being compared during overload resolution' Priority values are used to decide between                          // two candidates (instead of the usual language-specified rules).                          bool isExactSubtraction = right.Type?.StrippedType() == underlying;                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying)                          { Priority = 2 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType)                          { Priority = isExactSubtraction ? 1 : 3 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying)                          { Priority = 12 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum)                          { Priority = isExactSubtraction ? 11 : 13 });                            // Due to a bug' the native compiler allows "underlying - enum"' so Roslyn does as well.                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumSubtraction' underlying' enumType' enumType)                          { Priority = 4 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumSubtraction' nullableUnderlying' nullableEnum' nullableEnum)                          { Priority = 14 });                      }                      break;                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                  case BinaryOperatorKind.LessThanOrEqual:                      var boolean = Compilation.GetSpecialType(SpecialType.System_Boolean);                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' boolean));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' boolean));                      break;                  case BinaryOperatorKind.And:                  case BinaryOperatorKind.Or:                  case BinaryOperatorKind.Xor:                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' nullableEnum));                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The following statement contains a magic number: switch (kind)              {                  case BinaryOperatorKind.Addition:                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingAddition' enumType' underlying' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumAddition' underlying' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingAddition' nullableEnum' nullableUnderlying' nullableEnum));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumAddition' nullableUnderlying' nullableEnum' nullableEnum));                      break;                  case BinaryOperatorKind.Subtraction:                      if (Strict)                      {                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum));                      }                      else                      {                          // SPEC VIOLATION:                          // The native compiler has bugs in overload resolution involving binary operator- for enums'                          // which we duplicate by hardcoding Priority values among the operators. When present on both                          // methods being compared during overload resolution' Priority values are used to decide between                          // two candidates (instead of the usual language-specified rules).                          bool isExactSubtraction = right.Type?.StrippedType() == underlying;                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying)                          { Priority = 2 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType)                          { Priority = isExactSubtraction ? 1 : 3 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying)                          { Priority = 12 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum)                          { Priority = isExactSubtraction ? 11 : 13 });                            // Due to a bug' the native compiler allows "underlying - enum"' so Roslyn does as well.                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumSubtraction' underlying' enumType' enumType)                          { Priority = 4 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumSubtraction' nullableUnderlying' nullableEnum' nullableEnum)                          { Priority = 14 });                      }                      break;                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                  case BinaryOperatorKind.LessThanOrEqual:                      var boolean = Compilation.GetSpecialType(SpecialType.System_Boolean);                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' boolean));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' boolean));                      break;                  case BinaryOperatorKind.And:                  case BinaryOperatorKind.Or:                  case BinaryOperatorKind.Xor:                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' nullableEnum));                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The following statement contains a magic number: switch (kind)              {                  case BinaryOperatorKind.Addition:                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingAddition' enumType' underlying' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumAddition' underlying' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingAddition' nullableEnum' nullableUnderlying' nullableEnum));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumAddition' nullableUnderlying' nullableEnum' nullableEnum));                      break;                  case BinaryOperatorKind.Subtraction:                      if (Strict)                      {                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum));                      }                      else                      {                          // SPEC VIOLATION:                          // The native compiler has bugs in overload resolution involving binary operator- for enums'                          // which we duplicate by hardcoding Priority values among the operators. When present on both                          // methods being compared during overload resolution' Priority values are used to decide between                          // two candidates (instead of the usual language-specified rules).                          bool isExactSubtraction = right.Type?.StrippedType() == underlying;                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying)                          { Priority = 2 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType)                          { Priority = isExactSubtraction ? 1 : 3 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying)                          { Priority = 12 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum)                          { Priority = isExactSubtraction ? 11 : 13 });                            // Due to a bug' the native compiler allows "underlying - enum"' so Roslyn does as well.                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumSubtraction' underlying' enumType' enumType)                          { Priority = 4 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumSubtraction' nullableUnderlying' nullableEnum' nullableEnum)                          { Priority = 14 });                      }                      break;                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                  case BinaryOperatorKind.LessThanOrEqual:                      var boolean = Compilation.GetSpecialType(SpecialType.System_Boolean);                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' boolean));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' boolean));                      break;                  case BinaryOperatorKind.And:                  case BinaryOperatorKind.Or:                  case BinaryOperatorKind.Xor:                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' nullableEnum));                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The following statement contains a magic number: switch (kind)              {                  case BinaryOperatorKind.Addition:                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingAddition' enumType' underlying' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumAddition' underlying' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingAddition' nullableEnum' nullableUnderlying' nullableEnum));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumAddition' nullableUnderlying' nullableEnum' nullableEnum));                      break;                  case BinaryOperatorKind.Subtraction:                      if (Strict)                      {                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum));                      }                      else                      {                          // SPEC VIOLATION:                          // The native compiler has bugs in overload resolution involving binary operator- for enums'                          // which we duplicate by hardcoding Priority values among the operators. When present on both                          // methods being compared during overload resolution' Priority values are used to decide between                          // two candidates (instead of the usual language-specified rules).                          bool isExactSubtraction = right.Type?.StrippedType() == underlying;                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying)                          { Priority = 2 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType)                          { Priority = isExactSubtraction ? 1 : 3 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying)                          { Priority = 12 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum)                          { Priority = isExactSubtraction ? 11 : 13 });                            // Due to a bug' the native compiler allows "underlying - enum"' so Roslyn does as well.                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumSubtraction' underlying' enumType' enumType)                          { Priority = 4 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumSubtraction' nullableUnderlying' nullableEnum' nullableEnum)                          { Priority = 14 });                      }                      break;                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                  case BinaryOperatorKind.LessThanOrEqual:                      var boolean = Compilation.GetSpecialType(SpecialType.System_Boolean);                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' boolean));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' boolean));                      break;                  case BinaryOperatorKind.And:                  case BinaryOperatorKind.Or:                  case BinaryOperatorKind.Xor:                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' nullableEnum));                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetUserDefinedBinaryOperatorsFromType,The following statement contains a magic number: foreach (MethodSymbol op in type.GetOperators(name))              {                  // If we're in error recovery' we might have bad operators. Just ignore it.                  if (op.ParameterCount != 2 || op.ReturnsVoid)                  {                      continue;                  }                    TypeSymbol leftOperandType = op.ParameterTypes[0];                  TypeSymbol rightOperandType = op.ParameterTypes[1];                  TypeSymbol resultType = op.ReturnType;                    operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UserDefined | kind' leftOperandType' rightOperandType' resultType' op));                    LiftingResult lifting = UserDefinedBinaryOperatorCanBeLifted(leftOperandType' rightOperandType' resultType' kind);                    if (lifting == LiftingResult.LiftOperandsAndResult)                  {                      operators.Add(new BinaryOperatorSignature(                          BinaryOperatorKind.Lifted | BinaryOperatorKind.UserDefined | kind'                          MakeNullable(leftOperandType)' MakeNullable(rightOperandType)' MakeNullable(resultType)' op));                  }                  else if (lifting == LiftingResult.LiftOperandsButNotResult)                  {                      operators.Add(new BinaryOperatorSignature(                          BinaryOperatorKind.Lifted | BinaryOperatorKind.UserDefined | kind'                          MakeNullable(leftOperandType)' MakeNullable(rightOperandType)' resultType' op));                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,PerformMemberOverloadResolution,The following statement contains a magic number: if (members.Count > 50) // TODO: fine-tune this value              {                  containingTypeMapOpt = PartitionMembersByContainingType(members);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,AddMemberToCandidateSet,The following statement contains a magic number: if (members.Count < 2)              {                  // No hiding or overriding possible.              }              else if (containingTypeMapOpt == null)              {                  if (MemberGroupContainsOverride(members' member))                  {                      // Don't even add it to the result set.  We'll add only the most-overriding members.                      return;                  }                    if (MemberGroupHidesByName(members' member' ref useSiteDiagnostics))                  {                      return;                  }              }              else if (containingTypeMapOpt.Count == 1)              {                  // No hiding or overriding since all members are in the same type.              }              else              {                  // NOTE: only check for overriding/hiding in subtypes of f.ContainingType.                  NamedTypeSymbol memberContainingType = member.ContainingType;                  foreach (var pair in containingTypeMapOpt)                  {                      NamedTypeSymbol otherType = pair.Key;                      if (otherType.IsDerivedFrom(memberContainingType' ignoreDynamic: false' useSiteDiagnostics: ref useSiteDiagnostics))                      {                          ArrayBuilder<TMember> others = pair.Value;                            if (MemberGroupContainsOverride(others' member))                          {                              // Don't even add it to the result set.  We'll add only the most-overriding members.                              return;                          }                            if (MemberGroupHidesByName(others' member' ref useSiteDiagnostics))                          {                              return;                          }                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,RemoveWorseMembers,The following statement contains a magic number: const int notBetterThanEverything = 2;
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,RemoveWorseMembers,The following statement contains a magic number: const int betterThanEverything = 3;
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,BinaryOperatorOverloadResolutionResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorOverloadResolutionResult.cs,BinaryOperatorOverloadResolutionResult,The following statement contains a magic number: this.Results = new ArrayBuilder<BinaryOperatorAnalysisResult>(10);
Magic Number,Microsoft.CodeAnalysis.CSharp,BinaryOperatorOverloadResolutionResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorOverloadResolutionResult.cs,CreatePool,The following statement contains a magic number: pool = new ObjectPool<BinaryOperatorOverloadResolutionResult>(() => new BinaryOperatorOverloadResolutionResult()' 10);
Magic Number,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,OperatorIndex,The following statement contains a magic number: return ((int)kind.Operator() >> 8) - 16;
Magic Number,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,OperatorIndex,The following statement contains a magic number: return ((int)kind.Operator() >> 8) - 16;
Magic Number,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,OperatorIndex,The following statement contains a magic number: return ((int)kind.Operator() >> 8) - 16;
Magic Number,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,OperatorIndex,The following statement contains a magic number: return ((int)kind.Operator() >> 8) - 16;
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following statement contains a magic number: switch (type.GetSpecialTypeSafe())                  {                      case SpecialType.System_Object: return 0;                      case SpecialType.System_String: return 1;                      case SpecialType.System_Boolean: return 2;                      case SpecialType.System_Char: return 3;                      case SpecialType.System_SByte: return 4;                      case SpecialType.System_Int16: return 5;                      case SpecialType.System_Int32: return 6;                      case SpecialType.System_Int64: return 7;                      case SpecialType.System_Byte: return 8;                      case SpecialType.System_UInt16: return 9;                      case SpecialType.System_UInt32: return 10;                      case SpecialType.System_UInt64: return 11;                      case SpecialType.System_Single: return 12;                      case SpecialType.System_Double: return 13;                      case SpecialType.System_Decimal: return 14;                        case SpecialType.None:                          if ((object)type != null && type.IsNullableType())                          {                              TypeSymbol underlyingType = type.GetNullableUnderlyingType();                                switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }                          }                            // fall through                          goto default;                        default: return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,UnaryOperatorOverloadResolutionResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorOverloadResolutionResult.cs,UnaryOperatorOverloadResolutionResult,The following statement contains a magic number: this.Results = new ArrayBuilder<UnaryOperatorAnalysisResult>(10);
Magic Number,Microsoft.CodeAnalysis.CSharp,UnaryOperatorOverloadResolutionResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorOverloadResolutionResult.cs,CreatePool,The following statement contains a magic number: pool = new ObjectPool<UnaryOperatorOverloadResolutionResult>(() => new UnaryOperatorOverloadResolutionResult()' 10);
Magic Number,Microsoft.CodeAnalysis.CSharp,AnalyzedArguments,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\AnalyzedArguments.cs,AnalyzedArguments,The following statement contains a magic number: this.Arguments = new ArrayBuilder<BoundExpression>(32);
Magic Number,Microsoft.CodeAnalysis.CSharp,AnalyzedArguments,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\AnalyzedArguments.cs,AnalyzedArguments,The following statement contains a magic number: this.Names = new ArrayBuilder<IdentifierNameSyntax>(32);
Magic Number,Microsoft.CodeAnalysis.CSharp,AnalyzedArguments,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\AnalyzedArguments.cs,AnalyzedArguments,The following statement contains a magic number: this.RefKinds = new ArrayBuilder<RefKind>(32);
Magic Number,Microsoft.CodeAnalysis.CSharp,AnalyzedArguments,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\AnalyzedArguments.cs,CreatePool,The following statement contains a magic number: pool = new ObjectPool<AnalyzedArguments>(() => new AnalyzedArguments()' 10);
Magic Number,Microsoft.CodeAnalysis.CSharp,MethodGroup,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodGroup.cs,CreatePool,The following statement contains a magic number: pool = new ObjectPool<MethodGroup>(() => new MethodGroup()' 10);
Magic Number,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,Fix,The following statement contains a magic number: if (exact != null && exact.Count >= 2)              {                  return false;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,CreatePool,The following statement contains a magic number: pool = new ObjectPool<OverloadResolutionResult<TMember>>(() => new OverloadResolutionResult<TMember>()' 10);
Magic Number,Microsoft.CodeAnalysis.CSharp,BoundLambda,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs,InferReturnType,The following statement contains a magic number: inferredFromSingleType = numberOfDistinctReturns < 2;
Magic Number,Microsoft.CodeAnalysis.CSharp,BoundTreeWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundTreeWalker.cs,VisitUnoptimizedForm,The following statement contains a magic number: if (call != null && (object)call.Method != null)              {                  var arguments = call.Arguments;                  if (call.Method.Name == "Select")                  {                      this.Visit(arguments[arguments.Length - 1]);                  }                  else if (call.Method.Name == "GroupBy")                  {                      this.Visit(arguments[arguments.Length - 2]);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,ChecksumMatches,The following statement contains a magic number: if (bytesText.Length != bytes.Length * 2)              {                  return false;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,ChecksumMatches,The following statement contains a magic number: for (int i = 0' len = bytesText.Length / 2; i < len; i++)              {                  // 1A  in text becomes   0x1A                  var b = SyntaxFacts.HexValue(bytesText[i * 2]) * 16 +                          SyntaxFacts.HexValue(bytesText[i * 2 + 1]);                    if (b != bytes[i])                  {                      return false;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,ChecksumMatches,The following statement contains a magic number: for (int i = 0' len = bytesText.Length / 2; i < len; i++)              {                  // 1A  in text becomes   0x1A                  var b = SyntaxFacts.HexValue(bytesText[i * 2]) * 16 +                          SyntaxFacts.HexValue(bytesText[i * 2 + 1]);                    if (b != bytes[i])                  {                      return false;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,ChecksumMatches,The following statement contains a magic number: for (int i = 0' len = bytesText.Length / 2; i < len; i++)              {                  // 1A  in text becomes   0x1A                  var b = SyntaxFacts.HexValue(bytesText[i * 2]) * 16 +                          SyntaxFacts.HexValue(bytesText[i * 2 + 1]);                    if (b != bytes[i])                  {                      return false;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,ChecksumMatches,The following statement contains a magic number: for (int i = 0' len = bytesText.Length / 2; i < len; i++)              {                  // 1A  in text becomes   0x1A                  var b = SyntaxFacts.HexValue(bytesText[i * 2]) * 16 +                          SyntaxFacts.HexValue(bytesText[i * 2 + 1]);                    if (b != bytes[i])                  {                      return false;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,MakeChecksumBytes,The following statement contains a magic number: int length = bytesText.Length / 2;
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,MakeChecksumBytes,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  // 1A  in text becomes   0x1A                  var b = SyntaxFacts.HexValue(bytesText[i * 2]) * 16 +                          SyntaxFacts.HexValue(bytesText[i * 2 + 1]);                    builder.Add((byte)b);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,MakeChecksumBytes,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  // 1A  in text becomes   0x1A                  var b = SyntaxFacts.HexValue(bytesText[i * 2]) * 16 +                          SyntaxFacts.HexValue(bytesText[i * 2 + 1]);                    builder.Add((byte)b);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,MakeChecksumBytes,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  // 1A  in text becomes   0x1A                  var b = SyntaxFacts.HexValue(bytesText[i * 2]) * 16 +                          SyntaxFacts.HexValue(bytesText[i * 2 + 1]);                    builder.Add((byte)b);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCompilation,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs,SynthesizeDecimalConstantAttribute,The following statement contains a magic number: return TrySynthesizeAttribute(                  WellKnownMember.System_Runtime_CompilerServices_DecimalConstantAttribute__ctor'                  ImmutableArray.Create(                      new TypedConstant(systemByte' TypedConstantKind.Primitive' decimalBits.Scale)'                      new TypedConstant(systemByte' TypedConstantKind.Primitive' decimalBits.IsNegative ? (byte)128 : (byte)0)'                      new TypedConstant(systemUnit32' TypedConstantKind.Primitive' decimalBits.High)'                      new TypedConstant(systemUnit32' TypedConstantKind.Primitive' decimalBits.Mid)'                      new TypedConstant(systemUnit32' TypedConstantKind.Primitive' decimalBits.Low)                  ));
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,IndexOfNewLine,The following statement contains a magic number: for (; start < str.Length; start++)              {                  switch (str[start])                  {                      case '\r':                          if ((start + 1) < str.Length && str[start + 1] == '\n')                          {                              newLineLength = 2;                          }                          else                          {                              newLineLength = 1;                          }                          return start;                        case '\n':                          newLineLength = 1;                          return start;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteFormattedSingleLineComment,The following statement contains a magic number: for (int start = 0; start < text.Length;)              {                  int newLineLength;                  int end = IndexOfNewLine(text' start' out newLineLength);                  int trimStart = GetIndexOfFirstNonWhitespaceChar(text' start' end);                  int trimmedLength = end - trimStart;                  if (trimmedLength < 4 || !SyntaxFacts.IsWhitespace(text[trimStart + 3]))                  {                      skipSpace = false;                      break;                  }                    start = end + newLineLength;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteFormattedSingleLineComment,The following statement contains a magic number: for (int start = 0; start < text.Length;)              {                  int newLineLength;                  int end = IndexOfNewLine(text' start' out newLineLength);                  int trimStart = GetIndexOfFirstNonWhitespaceChar(text' start' end);                  int trimmedLength = end - trimStart;                  if (trimmedLength < 4 || !SyntaxFacts.IsWhitespace(text[trimStart + 3]))                  {                      skipSpace = false;                      break;                  }                    start = end + newLineLength;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteFormattedSingleLineComment,The following statement contains a magic number: int substringStart = skipSpace ? 4 : 3;
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteFormattedSingleLineComment,The following statement contains a magic number: int substringStart = skipSpace ? 4 : 3;
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteFormattedMultiLineComment,The following statement contains a magic number: if (numLines > 1)              {                  string pattern = FindMultiLineCommentPattern(lines[1]);                    if (pattern != null)                  {                      bool allMatch = true;                        for (int i = 2; i < numLines; i++)                      {                          string currentLinePattern = LongestCommonPrefix(pattern' lines[i]);                          if (string.IsNullOrWhiteSpace(currentLinePattern))                          {                              allMatch = false;                              break;                          }                          Debug.Assert(pattern.StartsWith(currentLinePattern));                          pattern = currentLinePattern;                      }                        if (allMatch)                      {                          skipLength = pattern.Length;                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteFormattedMultiLineComment,The following statement contains a magic number: if (!skipFirstLine)              {                  string trimmed = lines[0].TrimStart(null);                  if (!skipLastLine && numLines == 1)                  {                      trimmed = TrimEndOfMultiLineComment(trimmed);                  }                  WriteLine(trimmed.Substring(SyntaxFacts.IsWhitespace(trimmed[3]) ? 4 : 3));              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteFormattedMultiLineComment,The following statement contains a magic number: if (!skipFirstLine)              {                  string trimmed = lines[0].TrimStart(null);                  if (!skipLastLine && numLines == 1)                  {                      trimmed = TrimEndOfMultiLineComment(trimmed);                  }                  WriteLine(trimmed.Substring(SyntaxFacts.IsWhitespace(trimmed[3]) ? 4 : 3));              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,WriteFormattedMultiLineComment,The following statement contains a magic number: if (!skipFirstLine)              {                  string trimmed = lines[0].TrimStart(null);                  if (!skipLastLine && numLines == 1)                  {                      trimmed = TrimEndOfMultiLineComment(trimmed);                  }                  WriteLine(trimmed.Substring(SyntaxFacts.IsWhitespace(trimmed[3]) ? 4 : 3));              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,MakeIndent,The following statement contains a magic number: switch (depth)              {                  case 0:                      return "";                  case 1:                      return "    ";                  case 2:                      return "        ";                  case 3:                      return "            ";                  default:                      Debug.Assert(false' "Didn't expect nesting to reach depth " + depth);                      return new string(' '' depth * 4);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,MakeIndent,The following statement contains a magic number: switch (depth)              {                  case 0:                      return "";                  case 1:                      return "    ";                  case 2:                      return "        ";                  case 3:                      return "            ";                  default:                      Debug.Assert(false' "Didn't expect nesting to reach depth " + depth);                      return new string(' '' depth * 4);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,MakeIndent,The following statement contains a magic number: switch (depth)              {                  case 0:                      return "";                  case 1:                      return "    ";                  case 2:                      return "        ";                  case 3:                      return "            ";                  default:                      Debug.Assert(false' "Didn't expect nesting to reach depth " + depth);                      return new string(' '' depth * 4);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,ParseNameAttribute,The following statement contains a magic number: Debug.Assert(structure.Content.Count == 2);
Magic Number,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,MakeSubmissionInitialization,The following statement contains a magic number: Debug.Assert(submissionConstructor.ParameterCount == 2);
Magic Number,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,MakeSubmissionInitialization,The following statement contains a magic number: var statements = new List<BoundStatement>(2 + synthesizedFields.Count);
Magic Number,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructFieldLikeEventAccessorBody_Regular,The following statement contains a magic number: const int numTemps = 3;
Magic Number,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructFieldLikeEventAccessorBody_Regular,The following statement contains a magic number: BoundStatement tmp2Update = new BoundExpressionStatement(syntax'                  expression: new BoundAssignmentOperator(syntax'                      left: boundTmps[2]'                      right: delegateUpdate'                      type: delegateType)                  { WasCompilerGenerated = true })              { WasCompilerGenerated = true };
Magic Number,Microsoft.CodeAnalysis.CSharp,MethodBodySynthesizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.cs,ConstructFieldLikeEventAccessorBody_Regular,The following statement contains a magic number: BoundExpression compareExchange = BoundCall.Synthesized(syntax'                  receiverOpt: null'                  method: compareExchangeMethod'                  arguments: ImmutableArray.Create<BoundExpression>(boundBackingField' boundTmps[2]' boundTmps[1]));
Magic Number,Microsoft.CodeAnalysis.CSharp,CSharpCompilationOptions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CSharpCompilationOptions.cs,ValidateOptions,The following statement contains a magic number: if (WarningLevel < 0 || WarningLevel > 4)              {                  builder.Add(Diagnostic.Create(MessageProvider.Instance' (int)ErrorCode.ERR_BadCompilationOptionValue' "WarningLevel"' WarningLevel));              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DeclarationTreeBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTreeBuilder.cs,CreateScriptClass,The following statement contains a magic number: for (int i = fullName.Length - 2; i >= 0; i--)              {                  decl = SingleNamespaceDeclaration.Create(                      name: fullName[i]'                      hasUsings: false'                      hasExternAliases: false'                      syntaxReference: parentReference'                      nameLocation: new SourceLocation(parentReference)'                      children: ImmutableArray.Create<SingleNamespaceOrTypeDeclaration>(decl));              }
Magic Number,Microsoft.CodeAnalysis.CSharp,PartVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\DocumentationComments\DocumentationCommentIDVisitor.PartVisitor.cs,GetEscapedMetadataName,The following statement contains a magic number: int startIndex = colonColonIndex < 0 ? 0 : colonColonIndex + 2;
Magic Number,Microsoft.CodeAnalysis.CSharp,ErrorFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\ErrorFacts.cs,GetWarningLevel,The following statement contains a magic number: switch (code)              {                  case ErrorCode.WRN_InvalidMainSig:                  case ErrorCode.WRN_LowercaseEllSuffix:                  case ErrorCode.WRN_NewNotRequired:                  case ErrorCode.WRN_MainCantBeGeneric:                  case ErrorCode.WRN_ProtectedInSealed:                  case ErrorCode.WRN_UnassignedInternalField:                  case ErrorCode.WRN_MissingParamTag:                  case ErrorCode.WRN_MissingXMLComment:                  case ErrorCode.WRN_MissingTypeParamTag:                  case ErrorCode.WRN_InvalidVersionFormat:                      return 4;                  case ErrorCode.WRN_UnreferencedEvent:                  case ErrorCode.WRN_DuplicateUsing:                  case ErrorCode.WRN_UnreferencedVar:                  case ErrorCode.WRN_UnreferencedField:                  case ErrorCode.WRN_UnreferencedVarAssg:                  case ErrorCode.WRN_SequentialOnPartialClass:                  case ErrorCode.WRN_UnreferencedFieldAssg:                  case ErrorCode.WRN_AmbiguousXMLReference:                  case ErrorCode.WRN_PossibleMistakenNullStatement:                  case ErrorCode.WRN_EqualsWithoutGetHashCode:                  case ErrorCode.WRN_EqualityOpWithoutEquals:                  case ErrorCode.WRN_EqualityOpWithoutGetHashCode:                  case ErrorCode.WRN_IncorrectBooleanAssg:                  case ErrorCode.WRN_BitwiseOrSignExtend:                  case ErrorCode.WRN_TypeParameterSameAsOuterTypeParameter:                  case ErrorCode.WRN_InvalidAssemblyName:                  case ErrorCode.WRN_UnifyReferenceBldRev:                  case ErrorCode.WRN_AssignmentToSelf:                  case ErrorCode.WRN_ComparisonToSelf:                  case ErrorCode.WRN_IsDynamicIsConfusing:                  case ErrorCode.WRN_DebugFullNameTooLong:                  case ErrorCode.WRN_PdbLocalNameTooLong:                      return 3;                  case ErrorCode.WRN_NewRequired:                  case ErrorCode.WRN_NewOrOverrideExpected:                  case ErrorCode.WRN_UnreachableCode:                  case ErrorCode.WRN_UnreferencedLabel:                  case ErrorCode.WRN_NegativeArrayIndex:                  case ErrorCode.WRN_BadRefCompareLeft:                  case ErrorCode.WRN_BadRefCompareRight:                  case ErrorCode.WRN_PatternIsAmbiguous:                  case ErrorCode.WRN_PatternStaticOrInaccessible:                  case ErrorCode.WRN_PatternBadSignature:                  case ErrorCode.WRN_SameFullNameThisNsAgg:                  case ErrorCode.WRN_SameFullNameThisAggAgg:                  case ErrorCode.WRN_SameFullNameThisAggNs:                  case ErrorCode.WRN_GlobalAliasDefn:                  case ErrorCode.WRN_AlwaysNull:                  case ErrorCode.WRN_CmpAlwaysFalse:                  case ErrorCode.WRN_GotoCaseShouldConvert:                  case ErrorCode.WRN_NubExprIsConstBool:                  case ErrorCode.WRN_NubExprIsConstBool2:                  case ErrorCode.WRN_ExplicitImplCollision:                  case ErrorCode.WRN_DeprecatedSymbolStr:                  case ErrorCode.WRN_VacuousIntegralComp:                  case ErrorCode.WRN_AssignmentToLockOrDispose:                  case ErrorCode.WRN_DeprecatedCollectionInitAddStr:                  case ErrorCode.WRN_DeprecatedCollectionInitAdd:                  case ErrorCode.WRN_DuplicateParamTag:                  case ErrorCode.WRN_UnmatchedParamTag:                  case ErrorCode.WRN_UnprocessedXMLComment:                  case ErrorCode.WRN_InvalidSearchPathDir:                  case ErrorCode.WRN_UnifyReferenceMajMin:                  case ErrorCode.WRN_DuplicateTypeParamTag:                  case ErrorCode.WRN_UnmatchedTypeParamTag:                  case ErrorCode.WRN_UnmatchedParamRefTag:                  case ErrorCode.WRN_UnmatchedTypeParamRefTag:                  case ErrorCode.WRN_CantHaveManifestForModule:                  case ErrorCode.WRN_DynamicDispatchToConditionalMethod:                  case ErrorCode.WRN_NoSources:                  case ErrorCode.WRN_CLS_MeaninglessOnPrivateType:                  case ErrorCode.WRN_CLS_AssemblyNotCLS2:                  case ErrorCode.WRN_MainIgnored:                  case ErrorCode.WRN_UnqualifiedNestedTypeInCref:                  case ErrorCode.WRN_NoRuntimeMetadataVersion:                      return 2;                  case ErrorCode.WRN_IsAlwaysTrue:                  case ErrorCode.WRN_IsAlwaysFalse:                  case ErrorCode.WRN_ByRefNonAgileField:                  case ErrorCode.WRN_VolatileByRef:                  case ErrorCode.WRN_FinalizeMethod:                  case ErrorCode.WRN_DeprecatedSymbol:                  case ErrorCode.WRN_ExternMethodNoImplementation:                  case ErrorCode.WRN_AttributeLocationOnBadDeclaration:                  case ErrorCode.WRN_InvalidAttributeLocation:                  case ErrorCode.WRN_NonObsoleteOverridingObsolete:                  case ErrorCode.WRN_CoClassWithoutComImport:                  case ErrorCode.WRN_ObsoleteOverridingNonObsolete:                  case ErrorCode.WRN_ExternCtorNoImplementation:                  case ErrorCode.WRN_WarningDirective:                  case ErrorCode.WRN_UnreachableGeneralCatch:                  case ErrorCode.WRN_DefaultValueForUnconsumedLocation:                  case ErrorCode.WRN_EmptySwitch:                  case ErrorCode.WRN_XMLParseError:                  case ErrorCode.WRN_BadXMLRef:                  case ErrorCode.WRN_BadXMLRefParamType:                  case ErrorCode.WRN_BadXMLRefReturnType:                  case ErrorCode.WRN_BadXMLRefSyntax:                  case ErrorCode.WRN_FailedInclude:                  case ErrorCode.WRN_InvalidInclude:                  case ErrorCode.WRN_XMLParseIncludeError:                  case ErrorCode.WRN_ALinkWarn:                  case ErrorCode.WRN_AssemblyAttributeFromModuleIsOverridden:                  case ErrorCode.WRN_CmdOptionConflictsSource:                  case ErrorCode.WRN_IllegalPragma:                  case ErrorCode.WRN_IllegalPPWarning:                  case ErrorCode.WRN_BadRestoreNumber:                  case ErrorCode.WRN_NonECMAFeature:                  case ErrorCode.WRN_ErrorOverride:                  case ErrorCode.WRN_MultiplePredefTypes:                  case ErrorCode.WRN_TooManyLinesForDebugger:                  case ErrorCode.WRN_CallOnNonAgileField:                  case ErrorCode.WRN_InvalidNumber:                  case ErrorCode.WRN_IllegalPPChecksum:                  case ErrorCode.WRN_EndOfPPLineExpected:                  case ErrorCode.WRN_ConflictingChecksum:                  case ErrorCode.WRN_DotOnDefault:                  case ErrorCode.WRN_BadXMLRefTypeVar:                  case ErrorCode.WRN_ReferencedAssemblyReferencesLinkedPIA:                  case ErrorCode.WRN_MultipleRuntimeImplementationMatches:                  case ErrorCode.WRN_MultipleRuntimeOverrideMatches:                  case ErrorCode.WRN_FileAlreadyIncluded:                  case ErrorCode.WRN_NoConfigNotOnCommandLine:                  case ErrorCode.WRN_AnalyzerCannotBeCreated:                  case ErrorCode.WRN_NoAnalyzerInAssembly:                  case ErrorCode.WRN_UnableToLoadAnalyzer:                  case ErrorCode.WRN_DefineIdentifierRequired:                  case ErrorCode.WRN_CLS_NoVarArgs:                  case ErrorCode.WRN_CLS_BadArgType:                  case ErrorCode.WRN_CLS_BadReturnType:                  case ErrorCode.WRN_CLS_BadFieldPropType:                  case ErrorCode.WRN_CLS_BadIdentifierCase:                  case ErrorCode.WRN_CLS_OverloadRefOut:                  case ErrorCode.WRN_CLS_OverloadUnnamed:                  case ErrorCode.WRN_CLS_BadIdentifier:                  case ErrorCode.WRN_CLS_BadBase:                  case ErrorCode.WRN_CLS_BadInterfaceMember:                  case ErrorCode.WRN_CLS_NoAbstractMembers:                  case ErrorCode.WRN_CLS_NotOnModules:                  case ErrorCode.WRN_CLS_ModuleMissingCLS:                  case ErrorCode.WRN_CLS_AssemblyNotCLS:                  case ErrorCode.WRN_CLS_BadAttributeType:                  case ErrorCode.WRN_CLS_ArrayArgumentToAttribute:                  case ErrorCode.WRN_CLS_NotOnModules2:                  case ErrorCode.WRN_CLS_IllegalTrueInFalse:                  case ErrorCode.WRN_CLS_MeaninglessOnParam:                  case ErrorCode.WRN_CLS_MeaninglessOnReturn:                  case ErrorCode.WRN_CLS_BadTypeVar:                  case ErrorCode.WRN_CLS_VolatileField:                  case ErrorCode.WRN_CLS_BadInterface:                  case ErrorCode.WRN_UnobservedAwaitableExpression:                  case ErrorCode.WRN_CallerLineNumberParamForUnconsumedLocation:                  case ErrorCode.WRN_CallerFilePathParamForUnconsumedLocation:                  case ErrorCode.WRN_CallerMemberNameParamForUnconsumedLocation:                  case ErrorCode.WRN_CallerFilePathPreferredOverCallerMemberName:                  case ErrorCode.WRN_CallerLineNumberPreferredOverCallerMemberName:                  case ErrorCode.WRN_CallerLineNumberPreferredOverCallerFilePath:                  case ErrorCode.WRN_DelaySignButNoKey:                  case ErrorCode.WRN_UnimplementedCommandLineSwitch:                  case ErrorCode.WRN_AsyncLacksAwaits:                  case ErrorCode.WRN_BadUILang:                  case ErrorCode.WRN_RefCultureMismatch:                  case ErrorCode.WRN_ConflictingMachineAssembly:                  case ErrorCode.WRN_FilterIsConstant:                  case ErrorCode.WRN_IdentifierOrNumericLiteralExpected:                  case ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName:                  case ErrorCode.WRN_AlignmentMagnitude:                      return 1;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ErrorFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\ErrorFacts.cs,GetWarningLevel,The following statement contains a magic number: switch (code)              {                  case ErrorCode.WRN_InvalidMainSig:                  case ErrorCode.WRN_LowercaseEllSuffix:                  case ErrorCode.WRN_NewNotRequired:                  case ErrorCode.WRN_MainCantBeGeneric:                  case ErrorCode.WRN_ProtectedInSealed:                  case ErrorCode.WRN_UnassignedInternalField:                  case ErrorCode.WRN_MissingParamTag:                  case ErrorCode.WRN_MissingXMLComment:                  case ErrorCode.WRN_MissingTypeParamTag:                  case ErrorCode.WRN_InvalidVersionFormat:                      return 4;                  case ErrorCode.WRN_UnreferencedEvent:                  case ErrorCode.WRN_DuplicateUsing:                  case ErrorCode.WRN_UnreferencedVar:                  case ErrorCode.WRN_UnreferencedField:                  case ErrorCode.WRN_UnreferencedVarAssg:                  case ErrorCode.WRN_SequentialOnPartialClass:                  case ErrorCode.WRN_UnreferencedFieldAssg:                  case ErrorCode.WRN_AmbiguousXMLReference:                  case ErrorCode.WRN_PossibleMistakenNullStatement:                  case ErrorCode.WRN_EqualsWithoutGetHashCode:                  case ErrorCode.WRN_EqualityOpWithoutEquals:                  case ErrorCode.WRN_EqualityOpWithoutGetHashCode:                  case ErrorCode.WRN_IncorrectBooleanAssg:                  case ErrorCode.WRN_BitwiseOrSignExtend:                  case ErrorCode.WRN_TypeParameterSameAsOuterTypeParameter:                  case ErrorCode.WRN_InvalidAssemblyName:                  case ErrorCode.WRN_UnifyReferenceBldRev:                  case ErrorCode.WRN_AssignmentToSelf:                  case ErrorCode.WRN_ComparisonToSelf:                  case ErrorCode.WRN_IsDynamicIsConfusing:                  case ErrorCode.WRN_DebugFullNameTooLong:                  case ErrorCode.WRN_PdbLocalNameTooLong:                      return 3;                  case ErrorCode.WRN_NewRequired:                  case ErrorCode.WRN_NewOrOverrideExpected:                  case ErrorCode.WRN_UnreachableCode:                  case ErrorCode.WRN_UnreferencedLabel:                  case ErrorCode.WRN_NegativeArrayIndex:                  case ErrorCode.WRN_BadRefCompareLeft:                  case ErrorCode.WRN_BadRefCompareRight:                  case ErrorCode.WRN_PatternIsAmbiguous:                  case ErrorCode.WRN_PatternStaticOrInaccessible:                  case ErrorCode.WRN_PatternBadSignature:                  case ErrorCode.WRN_SameFullNameThisNsAgg:                  case ErrorCode.WRN_SameFullNameThisAggAgg:                  case ErrorCode.WRN_SameFullNameThisAggNs:                  case ErrorCode.WRN_GlobalAliasDefn:                  case ErrorCode.WRN_AlwaysNull:                  case ErrorCode.WRN_CmpAlwaysFalse:                  case ErrorCode.WRN_GotoCaseShouldConvert:                  case ErrorCode.WRN_NubExprIsConstBool:                  case ErrorCode.WRN_NubExprIsConstBool2:                  case ErrorCode.WRN_ExplicitImplCollision:                  case ErrorCode.WRN_DeprecatedSymbolStr:                  case ErrorCode.WRN_VacuousIntegralComp:                  case ErrorCode.WRN_AssignmentToLockOrDispose:                  case ErrorCode.WRN_DeprecatedCollectionInitAddStr:                  case ErrorCode.WRN_DeprecatedCollectionInitAdd:                  case ErrorCode.WRN_DuplicateParamTag:                  case ErrorCode.WRN_UnmatchedParamTag:                  case ErrorCode.WRN_UnprocessedXMLComment:                  case ErrorCode.WRN_InvalidSearchPathDir:                  case ErrorCode.WRN_UnifyReferenceMajMin:                  case ErrorCode.WRN_DuplicateTypeParamTag:                  case ErrorCode.WRN_UnmatchedTypeParamTag:                  case ErrorCode.WRN_UnmatchedParamRefTag:                  case ErrorCode.WRN_UnmatchedTypeParamRefTag:                  case ErrorCode.WRN_CantHaveManifestForModule:                  case ErrorCode.WRN_DynamicDispatchToConditionalMethod:                  case ErrorCode.WRN_NoSources:                  case ErrorCode.WRN_CLS_MeaninglessOnPrivateType:                  case ErrorCode.WRN_CLS_AssemblyNotCLS2:                  case ErrorCode.WRN_MainIgnored:                  case ErrorCode.WRN_UnqualifiedNestedTypeInCref:                  case ErrorCode.WRN_NoRuntimeMetadataVersion:                      return 2;                  case ErrorCode.WRN_IsAlwaysTrue:                  case ErrorCode.WRN_IsAlwaysFalse:                  case ErrorCode.WRN_ByRefNonAgileField:                  case ErrorCode.WRN_VolatileByRef:                  case ErrorCode.WRN_FinalizeMethod:                  case ErrorCode.WRN_DeprecatedSymbol:                  case ErrorCode.WRN_ExternMethodNoImplementation:                  case ErrorCode.WRN_AttributeLocationOnBadDeclaration:                  case ErrorCode.WRN_InvalidAttributeLocation:                  case ErrorCode.WRN_NonObsoleteOverridingObsolete:                  case ErrorCode.WRN_CoClassWithoutComImport:                  case ErrorCode.WRN_ObsoleteOverridingNonObsolete:                  case ErrorCode.WRN_ExternCtorNoImplementation:                  case ErrorCode.WRN_WarningDirective:                  case ErrorCode.WRN_UnreachableGeneralCatch:                  case ErrorCode.WRN_DefaultValueForUnconsumedLocation:                  case ErrorCode.WRN_EmptySwitch:                  case ErrorCode.WRN_XMLParseError:                  case ErrorCode.WRN_BadXMLRef:                  case ErrorCode.WRN_BadXMLRefParamType:                  case ErrorCode.WRN_BadXMLRefReturnType:                  case ErrorCode.WRN_BadXMLRefSyntax:                  case ErrorCode.WRN_FailedInclude:                  case ErrorCode.WRN_InvalidInclude:                  case ErrorCode.WRN_XMLParseIncludeError:                  case ErrorCode.WRN_ALinkWarn:                  case ErrorCode.WRN_AssemblyAttributeFromModuleIsOverridden:                  case ErrorCode.WRN_CmdOptionConflictsSource:                  case ErrorCode.WRN_IllegalPragma:                  case ErrorCode.WRN_IllegalPPWarning:                  case ErrorCode.WRN_BadRestoreNumber:                  case ErrorCode.WRN_NonECMAFeature:                  case ErrorCode.WRN_ErrorOverride:                  case ErrorCode.WRN_MultiplePredefTypes:                  case ErrorCode.WRN_TooManyLinesForDebugger:                  case ErrorCode.WRN_CallOnNonAgileField:                  case ErrorCode.WRN_InvalidNumber:                  case ErrorCode.WRN_IllegalPPChecksum:                  case ErrorCode.WRN_EndOfPPLineExpected:                  case ErrorCode.WRN_ConflictingChecksum:                  case ErrorCode.WRN_DotOnDefault:                  case ErrorCode.WRN_BadXMLRefTypeVar:                  case ErrorCode.WRN_ReferencedAssemblyReferencesLinkedPIA:                  case ErrorCode.WRN_MultipleRuntimeImplementationMatches:                  case ErrorCode.WRN_MultipleRuntimeOverrideMatches:                  case ErrorCode.WRN_FileAlreadyIncluded:                  case ErrorCode.WRN_NoConfigNotOnCommandLine:                  case ErrorCode.WRN_AnalyzerCannotBeCreated:                  case ErrorCode.WRN_NoAnalyzerInAssembly:                  case ErrorCode.WRN_UnableToLoadAnalyzer:                  case ErrorCode.WRN_DefineIdentifierRequired:                  case ErrorCode.WRN_CLS_NoVarArgs:                  case ErrorCode.WRN_CLS_BadArgType:                  case ErrorCode.WRN_CLS_BadReturnType:                  case ErrorCode.WRN_CLS_BadFieldPropType:                  case ErrorCode.WRN_CLS_BadIdentifierCase:                  case ErrorCode.WRN_CLS_OverloadRefOut:                  case ErrorCode.WRN_CLS_OverloadUnnamed:                  case ErrorCode.WRN_CLS_BadIdentifier:                  case ErrorCode.WRN_CLS_BadBase:                  case ErrorCode.WRN_CLS_BadInterfaceMember:                  case ErrorCode.WRN_CLS_NoAbstractMembers:                  case ErrorCode.WRN_CLS_NotOnModules:                  case ErrorCode.WRN_CLS_ModuleMissingCLS:                  case ErrorCode.WRN_CLS_AssemblyNotCLS:                  case ErrorCode.WRN_CLS_BadAttributeType:                  case ErrorCode.WRN_CLS_ArrayArgumentToAttribute:                  case ErrorCode.WRN_CLS_NotOnModules2:                  case ErrorCode.WRN_CLS_IllegalTrueInFalse:                  case ErrorCode.WRN_CLS_MeaninglessOnParam:                  case ErrorCode.WRN_CLS_MeaninglessOnReturn:                  case ErrorCode.WRN_CLS_BadTypeVar:                  case ErrorCode.WRN_CLS_VolatileField:                  case ErrorCode.WRN_CLS_BadInterface:                  case ErrorCode.WRN_UnobservedAwaitableExpression:                  case ErrorCode.WRN_CallerLineNumberParamForUnconsumedLocation:                  case ErrorCode.WRN_CallerFilePathParamForUnconsumedLocation:                  case ErrorCode.WRN_CallerMemberNameParamForUnconsumedLocation:                  case ErrorCode.WRN_CallerFilePathPreferredOverCallerMemberName:                  case ErrorCode.WRN_CallerLineNumberPreferredOverCallerMemberName:                  case ErrorCode.WRN_CallerLineNumberPreferredOverCallerFilePath:                  case ErrorCode.WRN_DelaySignButNoKey:                  case ErrorCode.WRN_UnimplementedCommandLineSwitch:                  case ErrorCode.WRN_AsyncLacksAwaits:                  case ErrorCode.WRN_BadUILang:                  case ErrorCode.WRN_RefCultureMismatch:                  case ErrorCode.WRN_ConflictingMachineAssembly:                  case ErrorCode.WRN_FilterIsConstant:                  case ErrorCode.WRN_IdentifierOrNumericLiteralExpected:                  case ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName:                  case ErrorCode.WRN_AlignmentMagnitude:                      return 1;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,ErrorFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Errors\ErrorFacts.cs,GetWarningLevel,The following statement contains a magic number: switch (code)              {                  case ErrorCode.WRN_InvalidMainSig:                  case ErrorCode.WRN_LowercaseEllSuffix:                  case ErrorCode.WRN_NewNotRequired:                  case ErrorCode.WRN_MainCantBeGeneric:                  case ErrorCode.WRN_ProtectedInSealed:                  case ErrorCode.WRN_UnassignedInternalField:                  case ErrorCode.WRN_MissingParamTag:                  case ErrorCode.WRN_MissingXMLComment:                  case ErrorCode.WRN_MissingTypeParamTag:                  case ErrorCode.WRN_InvalidVersionFormat:                      return 4;                  case ErrorCode.WRN_UnreferencedEvent:                  case ErrorCode.WRN_DuplicateUsing:                  case ErrorCode.WRN_UnreferencedVar:                  case ErrorCode.WRN_UnreferencedField:                  case ErrorCode.WRN_UnreferencedVarAssg:                  case ErrorCode.WRN_SequentialOnPartialClass:                  case ErrorCode.WRN_UnreferencedFieldAssg:                  case ErrorCode.WRN_AmbiguousXMLReference:                  case ErrorCode.WRN_PossibleMistakenNullStatement:                  case ErrorCode.WRN_EqualsWithoutGetHashCode:                  case ErrorCode.WRN_EqualityOpWithoutEquals:                  case ErrorCode.WRN_EqualityOpWithoutGetHashCode:                  case ErrorCode.WRN_IncorrectBooleanAssg:                  case ErrorCode.WRN_BitwiseOrSignExtend:                  case ErrorCode.WRN_TypeParameterSameAsOuterTypeParameter:                  case ErrorCode.WRN_InvalidAssemblyName:                  case ErrorCode.WRN_UnifyReferenceBldRev:                  case ErrorCode.WRN_AssignmentToSelf:                  case ErrorCode.WRN_ComparisonToSelf:                  case ErrorCode.WRN_IsDynamicIsConfusing:                  case ErrorCode.WRN_DebugFullNameTooLong:                  case ErrorCode.WRN_PdbLocalNameTooLong:                      return 3;                  case ErrorCode.WRN_NewRequired:                  case ErrorCode.WRN_NewOrOverrideExpected:                  case ErrorCode.WRN_UnreachableCode:                  case ErrorCode.WRN_UnreferencedLabel:                  case ErrorCode.WRN_NegativeArrayIndex:                  case ErrorCode.WRN_BadRefCompareLeft:                  case ErrorCode.WRN_BadRefCompareRight:                  case ErrorCode.WRN_PatternIsAmbiguous:                  case ErrorCode.WRN_PatternStaticOrInaccessible:                  case ErrorCode.WRN_PatternBadSignature:                  case ErrorCode.WRN_SameFullNameThisNsAgg:                  case ErrorCode.WRN_SameFullNameThisAggAgg:                  case ErrorCode.WRN_SameFullNameThisAggNs:                  case ErrorCode.WRN_GlobalAliasDefn:                  case ErrorCode.WRN_AlwaysNull:                  case ErrorCode.WRN_CmpAlwaysFalse:                  case ErrorCode.WRN_GotoCaseShouldConvert:                  case ErrorCode.WRN_NubExprIsConstBool:                  case ErrorCode.WRN_NubExprIsConstBool2:                  case ErrorCode.WRN_ExplicitImplCollision:                  case ErrorCode.WRN_DeprecatedSymbolStr:                  case ErrorCode.WRN_VacuousIntegralComp:                  case ErrorCode.WRN_AssignmentToLockOrDispose:                  case ErrorCode.WRN_DeprecatedCollectionInitAddStr:                  case ErrorCode.WRN_DeprecatedCollectionInitAdd:                  case ErrorCode.WRN_DuplicateParamTag:                  case ErrorCode.WRN_UnmatchedParamTag:                  case ErrorCode.WRN_UnprocessedXMLComment:                  case ErrorCode.WRN_InvalidSearchPathDir:                  case ErrorCode.WRN_UnifyReferenceMajMin:                  case ErrorCode.WRN_DuplicateTypeParamTag:                  case ErrorCode.WRN_UnmatchedTypeParamTag:                  case ErrorCode.WRN_UnmatchedParamRefTag:                  case ErrorCode.WRN_UnmatchedTypeParamRefTag:                  case ErrorCode.WRN_CantHaveManifestForModule:                  case ErrorCode.WRN_DynamicDispatchToConditionalMethod:                  case ErrorCode.WRN_NoSources:                  case ErrorCode.WRN_CLS_MeaninglessOnPrivateType:                  case ErrorCode.WRN_CLS_AssemblyNotCLS2:                  case ErrorCode.WRN_MainIgnored:                  case ErrorCode.WRN_UnqualifiedNestedTypeInCref:                  case ErrorCode.WRN_NoRuntimeMetadataVersion:                      return 2;                  case ErrorCode.WRN_IsAlwaysTrue:                  case ErrorCode.WRN_IsAlwaysFalse:                  case ErrorCode.WRN_ByRefNonAgileField:                  case ErrorCode.WRN_VolatileByRef:                  case ErrorCode.WRN_FinalizeMethod:                  case ErrorCode.WRN_DeprecatedSymbol:                  case ErrorCode.WRN_ExternMethodNoImplementation:                  case ErrorCode.WRN_AttributeLocationOnBadDeclaration:                  case ErrorCode.WRN_InvalidAttributeLocation:                  case ErrorCode.WRN_NonObsoleteOverridingObsolete:                  case ErrorCode.WRN_CoClassWithoutComImport:                  case ErrorCode.WRN_ObsoleteOverridingNonObsolete:                  case ErrorCode.WRN_ExternCtorNoImplementation:                  case ErrorCode.WRN_WarningDirective:                  case ErrorCode.WRN_UnreachableGeneralCatch:                  case ErrorCode.WRN_DefaultValueForUnconsumedLocation:                  case ErrorCode.WRN_EmptySwitch:                  case ErrorCode.WRN_XMLParseError:                  case ErrorCode.WRN_BadXMLRef:                  case ErrorCode.WRN_BadXMLRefParamType:                  case ErrorCode.WRN_BadXMLRefReturnType:                  case ErrorCode.WRN_BadXMLRefSyntax:                  case ErrorCode.WRN_FailedInclude:                  case ErrorCode.WRN_InvalidInclude:                  case ErrorCode.WRN_XMLParseIncludeError:                  case ErrorCode.WRN_ALinkWarn:                  case ErrorCode.WRN_AssemblyAttributeFromModuleIsOverridden:                  case ErrorCode.WRN_CmdOptionConflictsSource:                  case ErrorCode.WRN_IllegalPragma:                  case ErrorCode.WRN_IllegalPPWarning:                  case ErrorCode.WRN_BadRestoreNumber:                  case ErrorCode.WRN_NonECMAFeature:                  case ErrorCode.WRN_ErrorOverride:                  case ErrorCode.WRN_MultiplePredefTypes:                  case ErrorCode.WRN_TooManyLinesForDebugger:                  case ErrorCode.WRN_CallOnNonAgileField:                  case ErrorCode.WRN_InvalidNumber:                  case ErrorCode.WRN_IllegalPPChecksum:                  case ErrorCode.WRN_EndOfPPLineExpected:                  case ErrorCode.WRN_ConflictingChecksum:                  case ErrorCode.WRN_DotOnDefault:                  case ErrorCode.WRN_BadXMLRefTypeVar:                  case ErrorCode.WRN_ReferencedAssemblyReferencesLinkedPIA:                  case ErrorCode.WRN_MultipleRuntimeImplementationMatches:                  case ErrorCode.WRN_MultipleRuntimeOverrideMatches:                  case ErrorCode.WRN_FileAlreadyIncluded:                  case ErrorCode.WRN_NoConfigNotOnCommandLine:                  case ErrorCode.WRN_AnalyzerCannotBeCreated:                  case ErrorCode.WRN_NoAnalyzerInAssembly:                  case ErrorCode.WRN_UnableToLoadAnalyzer:                  case ErrorCode.WRN_DefineIdentifierRequired:                  case ErrorCode.WRN_CLS_NoVarArgs:                  case ErrorCode.WRN_CLS_BadArgType:                  case ErrorCode.WRN_CLS_BadReturnType:                  case ErrorCode.WRN_CLS_BadFieldPropType:                  case ErrorCode.WRN_CLS_BadIdentifierCase:                  case ErrorCode.WRN_CLS_OverloadRefOut:                  case ErrorCode.WRN_CLS_OverloadUnnamed:                  case ErrorCode.WRN_CLS_BadIdentifier:                  case ErrorCode.WRN_CLS_BadBase:                  case ErrorCode.WRN_CLS_BadInterfaceMember:                  case ErrorCode.WRN_CLS_NoAbstractMembers:                  case ErrorCode.WRN_CLS_NotOnModules:                  case ErrorCode.WRN_CLS_ModuleMissingCLS:                  case ErrorCode.WRN_CLS_AssemblyNotCLS:                  case ErrorCode.WRN_CLS_BadAttributeType:                  case ErrorCode.WRN_CLS_ArrayArgumentToAttribute:                  case ErrorCode.WRN_CLS_NotOnModules2:                  case ErrorCode.WRN_CLS_IllegalTrueInFalse:                  case ErrorCode.WRN_CLS_MeaninglessOnParam:                  case ErrorCode.WRN_CLS_MeaninglessOnReturn:                  case ErrorCode.WRN_CLS_BadTypeVar:                  case ErrorCode.WRN_CLS_VolatileField:                  case ErrorCode.WRN_CLS_BadInterface:                  case ErrorCode.WRN_UnobservedAwaitableExpression:                  case ErrorCode.WRN_CallerLineNumberParamForUnconsumedLocation:                  case ErrorCode.WRN_CallerFilePathParamForUnconsumedLocation:                  case ErrorCode.WRN_CallerMemberNameParamForUnconsumedLocation:                  case ErrorCode.WRN_CallerFilePathPreferredOverCallerMemberName:                  case ErrorCode.WRN_CallerLineNumberPreferredOverCallerMemberName:                  case ErrorCode.WRN_CallerLineNumberPreferredOverCallerFilePath:                  case ErrorCode.WRN_DelaySignButNoKey:                  case ErrorCode.WRN_UnimplementedCommandLineSwitch:                  case ErrorCode.WRN_AsyncLacksAwaits:                  case ErrorCode.WRN_BadUILang:                  case ErrorCode.WRN_RefCultureMismatch:                  case ErrorCode.WRN_ConflictingMachineAssembly:                  case ErrorCode.WRN_FilterIsConstant:                  case ErrorCode.WRN_IdentifierOrNumericLiteralExpected:                  case ErrorCode.WRN_ReferencedAssemblyDoesNotHaveStrongName:                  case ErrorCode.WRN_AlignmentMagnitude:                      return 1;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,GetOrCreateSlot,The following statement contains a magic number: if (!_variableSlot.TryGetValue(identifier' out slot))              {                  TypeSymbol variableType = VariableType(symbol);                  if (_emptyStructTypeCache.IsEmptyStructType(variableType))                  {                      return -1;                  }                    slot = nextVariableSlot++;                  _variableSlot.Add(identifier' slot);                  if (slot >= variableBySlot.Length)                  {                      Array.Resize(ref this.variableBySlot' slot * 2);                  }                    variableBySlot[slot] = identifier;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,ConvertedHasEqual,The following statement contains a magic number: for (var t = nt; (object)t != null; t = t.BaseTypeNoUseSiteDiagnostics)              {                  foreach (var sym in t.GetMembers(opName))                  {                      MethodSymbol op = sym as MethodSymbol;                      if ((object)op == null || op.MethodKind != MethodKind.UserDefinedOperator) continue;                      var parameters = op.GetParameters();                      if (parameters.Length == 2 && parameters[0].Type == t && parameters[1].Type == t)                      {                          type = t;                          return true;                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,FindSurprisingSignExtensionBits,The following statement contains a magic number: if (toSize < fromSize)              {                  // We are casting from a larger type to a smaller type' and are therefore                  // losing surprising bits.                   switch (toSize)                  {                      case 1: return unchecked((ulong)(byte)recursive);                      case 2: return unchecked((ulong)(ushort)recursive);                      case 4: return unchecked((ulong)(uint)recursive);                  }                  Debug.Assert(false' "How did we get here?");                  return recursive;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,FindSurprisingSignExtensionBits,The following statement contains a magic number: if (toSize < fromSize)              {                  // We are casting from a larger type to a smaller type' and are therefore                  // losing surprising bits.                   switch (toSize)                  {                      case 1: return unchecked((ulong)(byte)recursive);                      case 2: return unchecked((ulong)(ushort)recursive);                      case 4: return unchecked((ulong)(uint)recursive);                  }                  Debug.Assert(false' "How did we get here?");                  return recursive;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,FindSurprisingSignExtensionBits,The following statement contains a magic number: for (int i = fromSize; i < toSize; ++i)              {                  result |= (0xFFUL) << (i * 8);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeCall,The following statement contains a magic number: if (method.IsStatic &&                  method.ContainingType.IsObjectType() &&                  !_inExpressionLambda &&                  (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_Object__ReferenceEquals))              {                  Debug.Assert(rewrittenArguments.Length == 2);                    // ECMA - 335                  // I.8.2.5.1 Identity                  //           ...                  //           Identity is implemented on System.Object via the ReferenceEquals method.                  rewrittenBoundCall = new BoundBinaryOperator(                      syntax'                      BinaryOperatorKind.ObjectEqual'                      rewrittenArguments[0]'                      rewrittenArguments[1]'                      null'                      null'                      resultKind'                      type);              }              else if (node == null)              {                  rewrittenBoundCall = new BoundCall(                      syntax'                      rewrittenReceiver'                      method'                      rewrittenArguments'                      default(ImmutableArray<string>)'                      argumentRefKinds'                      isDelegateCall: false'                      expanded: false'                      invokedAsExtensionMethod: invokedAsExtensionMethod'                      argsToParamsOpt: default(ImmutableArray<int>)'                      resultKind: resultKind'                      type: type);              }              else              {                  rewrittenBoundCall = node.Update(                      rewrittenReceiver'                      method'                      rewrittenArguments'                      default(ImmutableArray<string>)'                      argumentRefKinds'                      node.IsDelegateCall'                      false'                      node.InvokedAsExtensionMethod'                      default(ImmutableArray<int>)'                      node.ResultKind'                      node.Type);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitEventAssignmentOperator,The following statement contains a magic number: if (rewrittenReceiverOpt != null && node.Event.ContainingAssembly.IsLinked && node.Event.ContainingType.IsInterfaceType())              {                  var @interface = node.Event.ContainingType;                    foreach (var attrData in @interface.GetAttributes())                  {                      if (attrData.IsTargetAttribute(@interface' AttributeDescription.ComEventInterfaceAttribute) &&                          attrData.CommonConstructorArguments.Length == 2)                      {                          return RewriteNoPiaEventAssignmentOperator(node' rewrittenReceiverOpt' rewrittenArgument);                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteWindowsRuntimeEventAssignmentOperator,The following statement contains a magic number: ArrayBuilder<BoundExpression> sideEffects = ArrayBuilder<BoundExpression>.GetInstance(2);
Magic Number,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitLockStatement,The following statement contains a magic number: if ((TryGetWellKnownTypeMember(lockSyntax' WellKnownMember.System_Threading_Monitor__Enter2' out enterMethod' isOptional: true) ||                   TryGetWellKnownTypeMember(lockSyntax' WellKnownMember.System_Threading_Monitor__Enter' out enterMethod)) && // If we didn't find the overload introduced in .NET 4.0' then use the older one.                   enterMethod.ParameterCount == 2)              {                  // C# 4.0+ version                  // L $lock = `argument`;                      // sequence point                  // bool $lockTaken = false;                                     // try                  // {                  //     Monitor.Enter($lock' ref $lockTaken);                  //     `body`                                 // sequence point                    // }                  // finally                  // {                                          // hidden sequence point                     //     if ($lockTaken) Monitor.Exit($lock);                     // }                    TypeSymbol boolType = _compilation.GetSpecialType(SpecialType.System_Boolean);                  BoundAssignmentOperator assignmentToLockTakenTemp;                    BoundLocal boundLockTakenTemp = _factory.StoreToTemp(                      MakeLiteral(rewrittenArgument.Syntax' ConstantValue.False' boolType)'                      store: out assignmentToLockTakenTemp'                      syntaxOpt: lockSyntax'                      kind: SynthesizedLocalKind.LockTaken);                    BoundStatement boundLockTakenTempInit = new BoundExpressionStatement(lockSyntax' assignmentToLockTakenTemp);                    BoundStatement enterCall = new BoundExpressionStatement(                      lockSyntax'                      BoundCall.Synthesized(                          lockSyntax'                          null'                          enterMethod'                          boundLockTemp'                          boundLockTakenTemp));                    exitCall = RewriteIfStatement(                      lockSyntax'                      boundLockTakenTemp'                      exitCall'                      null'                      node.HasErrors);                    return new BoundBlock(                      lockSyntax'                      ImmutableArray.Create(boundLockTemp.LocalSymbol' boundLockTakenTemp.LocalSymbol)'                      ImmutableArray.Create(                          MakeInitialLockSequencePoint(boundLockTempInit' lockSyntax)'                          boundLockTakenTempInit'                          new BoundTryStatement(                              lockSyntax'                              BoundBlock.SynthesizedNoLocals(lockSyntax' ImmutableArray.Create(                                  enterCall'                                  rewrittenBody))'                              ImmutableArray<BoundCatchBlock>.Empty'                              BoundBlock.SynthesizedNoLocals(lockSyntax'                                  exitCall))));              }              else              {                  // Pre-4.0 version                  // L $lock = `argument`;           // sequence point                  // Monitor.Enter($lock);           // NB: before try-finally so we don't Exit if an exception prevents us from acquiring the lock.                  // try                   // {                  //     `body`                      // sequence point                  // }                   // finally                   // {                  //     Monitor.Exit($lock);        // hidden sequence point                  // }                    BoundExpression enterCallExpr;                    if ((object)enterMethod != null)                  {                      Debug.Assert(enterMethod.ParameterCount == 1);                        enterCallExpr = BoundCall.Synthesized(                          lockSyntax'                          null'                          enterMethod'                          boundLockTemp);                  }                  else                  {                      enterCallExpr = new BoundBadExpression(lockSyntax' LookupResultKind.NotInvocable' ImmutableArray<Symbol>.Empty' ImmutableArray.Create<BoundNode>(boundLockTemp)' ErrorTypeSymbol.UnknownResultType);                  }                    BoundStatement enterCall = new BoundExpressionStatement(                      lockSyntax'                      enterCallExpr);                    return new BoundBlock(                      lockSyntax'                      ImmutableArray.Create(boundLockTemp.LocalSymbol)'                      ImmutableArray.Create(                          MakeInitialLockSequencePoint(boundLockTempInit' lockSyntax)'                          enterCall'                          new BoundTryStatement(                              lockSyntax'                              BoundBlock.SynthesizedNoLocals(lockSyntax' rewrittenBody)'                              ImmutableArray<BoundCatchBlock>.Empty'                              BoundBlock.SynthesizedNoLocals(lockSyntax' exitCall))));              }
Magic Number,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringConcatenation,The following statement contains a magic number: switch (leftFlattened.Count)              {                  case 0:                      result = _factory.StringLiteral(string.Empty);                      break;                    case 1:                      result = leftFlattened[0];                      break;                    case 2:                      var left = leftFlattened[0];                      var right = leftFlattened[1];                      result = RewriteStringConcatenationTwoExprs(syntax' left' right);                      break;                    case 3:                      var first = leftFlattened[0];                      var second = leftFlattened[1];                      var third = leftFlattened[2];                      result = RewriteStringConcatenationThreeExprs(syntax' first' second' third);                      break;                    default:                      result = RewriteStringConcatenationManyExprs(syntax' leftFlattened.ToImmutable());                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringConcatenation,The following statement contains a magic number: switch (leftFlattened.Count)              {                  case 0:                      result = _factory.StringLiteral(string.Empty);                      break;                    case 1:                      result = leftFlattened[0];                      break;                    case 2:                      var left = leftFlattened[0];                      var right = leftFlattened[1];                      result = RewriteStringConcatenationTwoExprs(syntax' left' right);                      break;                    case 3:                      var first = leftFlattened[0];                      var second = leftFlattened[1];                      var third = leftFlattened[2];                      result = RewriteStringConcatenationThreeExprs(syntax' first' second' third);                      break;                    default:                      result = RewriteStringConcatenationManyExprs(syntax' leftFlattened.ToImmutable());                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringConcatenation,The following statement contains a magic number: switch (leftFlattened.Count)              {                  case 0:                      result = _factory.StringLiteral(string.Empty);                      break;                    case 1:                      result = leftFlattened[0];                      break;                    case 2:                      var left = leftFlattened[0];                      var right = leftFlattened[1];                      result = RewriteStringConcatenationTwoExprs(syntax' left' right);                      break;                    case 3:                      var first = leftFlattened[0];                      var second = leftFlattened[1];                      var third = leftFlattened[2];                      result = RewriteStringConcatenationThreeExprs(syntax' first' second' third);                      break;                    default:                      result = RewriteStringConcatenationManyExprs(syntax' leftFlattened.ToImmutable());                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringConcatenationManyExprs,The following statement contains a magic number: Debug.Assert(loweredArgs.Length > 3);
Magic Number,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,RewriteStringConcatenationManyExprs,The following statement contains a magic number: if (!isObject && loweredArgs.Length == 4)              {                  SpecialMember member = SpecialMember.System_String__ConcatStringStringStringString;                  var method = GetSpecialTypeMethod(syntax' member);                  Debug.Assert((object)method != null);                    return (BoundExpression)BoundCall.Synthesized(syntax' null' method' loweredArgs);              }              else              {                  SpecialMember member = isObject ?                      SpecialMember.System_String__ConcatObjectArray :                      SpecialMember.System_String__ConcatStringArray;                    var method = GetSpecialTypeMethod(syntax' member);                  Debug.Assert((object)method != null);                    var array = _factory.Array(elementType' loweredArgs);                    return (BoundExpression)BoundCall.Synthesized(syntax' null' method' array);              }
Magic Number,Microsoft.CodeAnalysis.CSharp,SyntaxFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\CharacterInfo.cs,HexValue,The following statement contains a magic number: return (c >= '0' && c <= '9') ? c - '0' : (c & 0xdf) - 'A' + 10;
Magic Number,Microsoft.CodeAnalysis.CSharp,SyntaxFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\CharacterInfo.cs,IsWhitespace,The following statement contains a magic number: return ch == ' '                  || ch == '\t'                  || ch == '\v'                  || ch == '\f'                  || ch == '\u00A0' // NO-BREAK SPACE                                    // The native compiler' in ScanToken' recognized both the byte-order                                    // marker '\uFEFF' as well as ^Z '\u001A' as whitespace' although                                    // this is not to spec since neither of these are in Zs. For the                                    // sake of compatibility' we recognize them both here. Note: '\uFEFF'                                    // also happens to be a formatting character (class Cf)' which means                                    // that it is a legal non-initial identifier character. So it's                                    // especially funny' because it will be whitespace UNLESS we happen                                    // to be scanning an identifier or keyword' in which case it winds                                    // up in the identifier or keyword.                  || ch == '\uFEFF'                  || ch == '\u001A'                  || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator);
Magic Number,Microsoft.CodeAnalysis.CSharp,SyntaxFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\CharacterInfo.cs,IsFormattingChar,The following statement contains a magic number: return ch > 127 && IsFormattingChar(CharUnicodeInfo.GetUnicodeCategory(ch));
Magic Number,Microsoft.CodeAnalysis.CSharp,SpecialMembersSignatureComparer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Compilation_WellKnownMembers.cs,GetArrayElementType,The following statement contains a magic number: if (array.Rank < 2)                  {                      return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,SeparatedList,The following statement contains a magic number: using (var enumerator = nodes.GetEnumerator())              {                  if (!enumerator.MoveNext())                  {                      return default(SeparatedSyntaxList<TNode>);                  }                    var firstNode = enumerator.Current;                    if (!enumerator.MoveNext())                  {                      return SingletonSeparatedList<TNode>(firstNode);                  }                    var builder = new SeparatedSyntaxListBuilder<TNode>(collection != null ? collection.Count : 3);                    builder.Add(firstNode);                    var commaToken = Token(SyntaxKind.CommaToken);                    do                  {                      builder.AddSeparator(commaToken);                      builder.Add(enumerator.Current);                  }                  while (enumerator.MoveNext());                    return builder.ToList();              }
Magic Number,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,NodeOrTokenList,The following statement contains a magic number: var builder = new SyntaxNodeOrTokenListBuilder(8);
Magic Number,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,ParseCref,The following statement contains a magic number: Debug.Assert(structure.Content.Count == 2);
Magic Number,Microsoft.CodeAnalysis.CSharp,NodeIterationStack,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxTreeDiagnosticEnumerator.cs,Push,The following statement contains a magic number: if (_count >= _stack.Length)                  {                      var tmp = new NodeIteration[_stack.Length * 2];                      Array.Copy(_stack' tmp' _stack.Length);                      _stack = tmp;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,ShouldEmitBlockInitializer,The following statement contains a magic number: if (elementType.SpecialType.IsBlittable())              {                  if (_module.GetInitArrayHelper() == null)                  {                      return ArrayInitializerStyle.Element;                  }                    int initCount = 0;                  int constCount = 0;                  InitializerCountRecursive(inits' ref initCount' ref constCount);                    if (initCount > 2)                  {                      if (initCount == constCount)                      {                          return ArrayInitializerStyle.Block;                      }                        int thresholdCnt = Math.Max(3' (initCount / 3));                        if (constCount >= thresholdCnt)                      {                          return ArrayInitializerStyle.Mixed;                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,ShouldEmitBlockInitializer,The following statement contains a magic number: if (elementType.SpecialType.IsBlittable())              {                  if (_module.GetInitArrayHelper() == null)                  {                      return ArrayInitializerStyle.Element;                  }                    int initCount = 0;                  int constCount = 0;                  InitializerCountRecursive(inits' ref initCount' ref constCount);                    if (initCount > 2)                  {                      if (initCount == constCount)                      {                          return ArrayInitializerStyle.Block;                      }                        int thresholdCnt = Math.Max(3' (initCount / 3));                        if (constCount >= thresholdCnt)                      {                          return ArrayInitializerStyle.Mixed;                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,ShouldEmitBlockInitializer,The following statement contains a magic number: if (elementType.SpecialType.IsBlittable())              {                  if (_module.GetInitArrayHelper() == null)                  {                      return ArrayInitializerStyle.Element;                  }                    int initCount = 0;                  int constCount = 0;                  InitializerCountRecursive(inits' ref initCount' ref constCount);                    if (initCount > 2)                  {                      if (initCount == constCount)                      {                          return ArrayInitializerStyle.Block;                      }                        int thresholdCnt = Math.Max(3' (initCount / 3));                        if (constCount >= thresholdCnt)                      {                          return ArrayInitializerStyle.Mixed;                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,GetRawData,The following statement contains a magic number: var stream = new Cci.MemoryStream((uint)(initializers.Length * 4));
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,DelegateConstructor,The following statement contains a magic number: foreach (var possibleCtor in delegateType.GetMembers(WellKnownMemberNames.InstanceConstructorName))              {                  var m = possibleCtor as MethodSymbol;                  if ((object)m == null) continue;                  var parameters = m.Parameters;                  if (parameters.Length != 2) continue;                  if (parameters[0].Type.SpecialType != SpecialType.System_Object) continue;                  var p1t = parameters[1].Type.SpecialType;                  if (p1t == SpecialType.System_IntPtr || p1t == SpecialType.System_UIntPtr)                  {                      return m;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,InPlaceCtorCall,The following statement contains a magic number: var stackAdjustment = GetObjCreationStackBehavior(objCreation) - 2;
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitMethodInfoExpression,The following statement contains a magic number: if (getMethod.ParameterCount == 1)              {                  _builder.EmitOpCode(ILOpCode.Call' stackAdjustment: 0); //argument off' return value on              }              else              {                  Debug.Assert(getMethod.ParameterCount == 2);                  _builder.EmitOpCode(ILOpCode.Ldtoken);                  EmitSymbolToken(node.Method.ContainingType' node.Syntax);                  _builder.EmitOpCode(ILOpCode.Call' stackAdjustment: -1); //2 arguments off' return value on              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitFieldInfoExpression,The following statement contains a magic number: if (getField.ParameterCount == 1)              {                  _builder.EmitOpCode(ILOpCode.Call' stackAdjustment: 0); //argument off' return value on              }              else              {                  Debug.Assert(getField.ParameterCount == 2);                  _builder.EmitOpCode(ILOpCode.Ldtoken);                  EmitSymbolToken(node.Field.ContainingType' node.Syntax);                  _builder.EmitOpCode(ILOpCode.Call' stackAdjustment: -1); //2 arguments off' return value on              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitBinaryCondOperator,The following statement contains a magic number: switch (binOp.OperatorKind.OperatorWithLogical())              {                  case BinaryOperatorKind.LogicalOr:                      Debug.Assert(binOp.Left.Type.SpecialType == SpecialType.System_Boolean);                      Debug.Assert(binOp.Right.Type.SpecialType == SpecialType.System_Boolean);                        // Rewrite (a || b) as ~(~a && ~b)                      andOrSense = !andOrSense;                      // Fall through                      goto case BinaryOperatorKind.LogicalAnd;                    case BinaryOperatorKind.LogicalAnd:                      Debug.Assert(binOp.Left.Type.SpecialType == SpecialType.System_Boolean);                      Debug.Assert(binOp.Right.Type.SpecialType == SpecialType.System_Boolean);                        // ~(a && b) is equivalent to (~a || ~b)                      if (!andOrSense)                      {                          // generate (~a || ~b)                          EmitShortCircuitingOperator(binOp' sense' sense' true);                      }                      else                      {                          // generate (a && b)                          EmitShortCircuitingOperator(binOp' sense' !sense' false);                      }                      return;                    case BinaryOperatorKind.And:                      Debug.Assert(binOp.Left.Type.SpecialType == SpecialType.System_Boolean);                      Debug.Assert(binOp.Right.Type.SpecialType == SpecialType.System_Boolean);                      EmitBinaryCondOperatorHelper(ILOpCode.And' binOp.Left' binOp.Right' sense);                      return;                    case BinaryOperatorKind.Or:                      Debug.Assert(binOp.Left.Type.SpecialType == SpecialType.System_Boolean);                      Debug.Assert(binOp.Right.Type.SpecialType == SpecialType.System_Boolean);                      EmitBinaryCondOperatorHelper(ILOpCode.Or' binOp.Left' binOp.Right' sense);                      return;                    case BinaryOperatorKind.Xor:                      Debug.Assert(binOp.Left.Type.SpecialType == SpecialType.System_Boolean);                      Debug.Assert(binOp.Right.Type.SpecialType == SpecialType.System_Boolean);                        // Xor is equivalent to not equal.                      if (sense)                          EmitBinaryCondOperatorHelper(ILOpCode.Xor' binOp.Left' binOp.Right' true);                      else                          EmitBinaryCondOperatorHelper(ILOpCode.Ceq' binOp.Left' binOp.Right' true);                      return;                    case BinaryOperatorKind.NotEqual:                      // neq  is emitted as  !eq                      sense = !sense;                      goto case BinaryOperatorKind.Equal;                    case BinaryOperatorKind.Equal:                        var constant = binOp.Left.ConstantValue;                      var comparand = binOp.Right;                        if (constant == null)                      {                          constant = comparand.ConstantValue;                          comparand = binOp.Left;                      }                        if (constant != null)                      {                          if (constant.IsDefaultValue)                          {                              if (!constant.IsFloating)                              {                                  if (sense)                                  {                                      EmitIsNullOrZero(comparand' constant);                                  }                                  else                                  {                                      //  obj != null/0   for pointers and integral numerics is emitted as cgt.un                                      EmitIsNotNullOrZero(comparand' constant);                                  }                                  return;                              }                          }                          else if (constant.IsBoolean)                          {                              // treat  "x = True" ==> "x"                              EmitExpression(comparand' true);                              EmitIsSense(sense);                              return;                          }                      }                        EmitBinaryCondOperatorHelper(ILOpCode.Ceq' binOp.Left' binOp.Right' sense);                      return;                    case BinaryOperatorKind.LessThan:                      opIdx = 0;                      break;                    case BinaryOperatorKind.LessThanOrEqual:                      opIdx = 1;                      sense = !sense; // lte is emitted as !gt                       break;                    case BinaryOperatorKind.GreaterThan:                      opIdx = 2;                      break;                    case BinaryOperatorKind.GreaterThanOrEqual:                      opIdx = 3;                      sense = !sense; // gte is emitted as !lt                       break;                    default:                      throw ExceptionUtilities.UnexpectedValue(binOp.OperatorKind.OperatorWithLogical());              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitBinaryCondOperator,The following statement contains a magic number: switch (binOp.OperatorKind.OperatorWithLogical())              {                  case BinaryOperatorKind.LogicalOr:                      Debug.Assert(binOp.Left.Type.SpecialType == SpecialType.System_Boolean);                      Debug.Assert(binOp.Right.Type.SpecialType == SpecialType.System_Boolean);                        // Rewrite (a || b) as ~(~a && ~b)                      andOrSense = !andOrSense;                      // Fall through                      goto case BinaryOperatorKind.LogicalAnd;                    case BinaryOperatorKind.LogicalAnd:                      Debug.Assert(binOp.Left.Type.SpecialType == SpecialType.System_Boolean);                      Debug.Assert(binOp.Right.Type.SpecialType == SpecialType.System_Boolean);                        // ~(a && b) is equivalent to (~a || ~b)                      if (!andOrSense)                      {                          // generate (~a || ~b)                          EmitShortCircuitingOperator(binOp' sense' sense' true);                      }                      else                      {                          // generate (a && b)                          EmitShortCircuitingOperator(binOp' sense' !sense' false);                      }                      return;                    case BinaryOperatorKind.And:                      Debug.Assert(binOp.Left.Type.SpecialType == SpecialType.System_Boolean);                      Debug.Assert(binOp.Right.Type.SpecialType == SpecialType.System_Boolean);                      EmitBinaryCondOperatorHelper(ILOpCode.And' binOp.Left' binOp.Right' sense);                      return;                    case BinaryOperatorKind.Or:                      Debug.Assert(binOp.Left.Type.SpecialType == SpecialType.System_Boolean);                      Debug.Assert(binOp.Right.Type.SpecialType == SpecialType.System_Boolean);                      EmitBinaryCondOperatorHelper(ILOpCode.Or' binOp.Left' binOp.Right' sense);                      return;                    case BinaryOperatorKind.Xor:                      Debug.Assert(binOp.Left.Type.SpecialType == SpecialType.System_Boolean);                      Debug.Assert(binOp.Right.Type.SpecialType == SpecialType.System_Boolean);                        // Xor is equivalent to not equal.                      if (sense)                          EmitBinaryCondOperatorHelper(ILOpCode.Xor' binOp.Left' binOp.Right' true);                      else                          EmitBinaryCondOperatorHelper(ILOpCode.Ceq' binOp.Left' binOp.Right' true);                      return;                    case BinaryOperatorKind.NotEqual:                      // neq  is emitted as  !eq                      sense = !sense;                      goto case BinaryOperatorKind.Equal;                    case BinaryOperatorKind.Equal:                        var constant = binOp.Left.ConstantValue;                      var comparand = binOp.Right;                        if (constant == null)                      {                          constant = comparand.ConstantValue;                          comparand = binOp.Left;                      }                        if (constant != null)                      {                          if (constant.IsDefaultValue)                          {                              if (!constant.IsFloating)                              {                                  if (sense)                                  {                                      EmitIsNullOrZero(comparand' constant);                                  }                                  else                                  {                                      //  obj != null/0   for pointers and integral numerics is emitted as cgt.un                                      EmitIsNotNullOrZero(comparand' constant);                                  }                                  return;                              }                          }                          else if (constant.IsBoolean)                          {                              // treat  "x = True" ==> "x"                              EmitExpression(comparand' true);                              EmitIsSense(sense);                              return;                          }                      }                        EmitBinaryCondOperatorHelper(ILOpCode.Ceq' binOp.Left' binOp.Right' sense);                      return;                    case BinaryOperatorKind.LessThan:                      opIdx = 0;                      break;                    case BinaryOperatorKind.LessThanOrEqual:                      opIdx = 1;                      sense = !sense; // lte is emitted as !gt                       break;                    case BinaryOperatorKind.GreaterThan:                      opIdx = 2;                      break;                    case BinaryOperatorKind.GreaterThanOrEqual:                      opIdx = 3;                      sense = !sense; // gte is emitted as !lt                       break;                    default:                      throw ExceptionUtilities.UnexpectedValue(binOp.OperatorKind.OperatorWithLogical());              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitBinaryCondOperator,The following statement contains a magic number: if (IsUnsignedBinaryOperator(binOp))              {                  opIdx += 4;              }              else if (IsFloat(binOp.OperatorKind))              {                  opIdx += 8;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitBinaryCondOperator,The following statement contains a magic number: if (IsUnsignedBinaryOperator(binOp))              {                  opIdx += 4;              }              else if (IsFloat(binOp.OperatorKind))              {                  opIdx += 8;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,CodeForJump,The following statement contains a magic number: switch (op.OperatorKind.Operator())              {                  case BinaryOperatorKind.Equal:                      revOpCode = !sense ? ILOpCode.Beq : ILOpCode.Bne_un;                      return sense ? ILOpCode.Beq : ILOpCode.Bne_un;                    case BinaryOperatorKind.NotEqual:                      revOpCode = !sense ? ILOpCode.Bne_un : ILOpCode.Beq;                      return sense ? ILOpCode.Bne_un : ILOpCode.Beq;                    case BinaryOperatorKind.LessThan:                      opIdx = 0;                      break;                    case BinaryOperatorKind.LessThanOrEqual:                      opIdx = 1;                      break;                    case BinaryOperatorKind.GreaterThan:                      opIdx = 2;                      break;                    case BinaryOperatorKind.GreaterThanOrEqual:                      opIdx = 3;                      break;                    default:                      throw ExceptionUtilities.UnexpectedValue(op.OperatorKind.Operator());              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,CodeForJump,The following statement contains a magic number: switch (op.OperatorKind.Operator())              {                  case BinaryOperatorKind.Equal:                      revOpCode = !sense ? ILOpCode.Beq : ILOpCode.Bne_un;                      return sense ? ILOpCode.Beq : ILOpCode.Bne_un;                    case BinaryOperatorKind.NotEqual:                      revOpCode = !sense ? ILOpCode.Bne_un : ILOpCode.Beq;                      return sense ? ILOpCode.Bne_un : ILOpCode.Beq;                    case BinaryOperatorKind.LessThan:                      opIdx = 0;                      break;                    case BinaryOperatorKind.LessThanOrEqual:                      opIdx = 1;                      break;                    case BinaryOperatorKind.GreaterThan:                      opIdx = 2;                      break;                    case BinaryOperatorKind.GreaterThanOrEqual:                      opIdx = 3;                      break;                    default:                      throw ExceptionUtilities.UnexpectedValue(op.OperatorKind.Operator());              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,CodeForJump,The following statement contains a magic number: if (IsUnsignedBinaryOperator(op))              {                  opIdx += 2 * IL_OP_CODE_ROW_LENGTH; //unsigned              }              else if (IsFloat(op.OperatorKind))              {                  opIdx += 4 * IL_OP_CODE_ROW_LENGTH;  //float              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,CodeForJump,The following statement contains a magic number: if (IsUnsignedBinaryOperator(op))              {                  opIdx += 2 * IL_OP_CODE_ROW_LENGTH; //unsigned              }              else if (IsFloat(op.OperatorKind))              {                  opIdx += 4 * IL_OP_CODE_ROW_LENGTH;  //float              }
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGen,Optimizer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,RemoveIntersectingLocals,The following statement contains a magic number: foreach (var pair in ordered)              {                  if (!info.ContainsKey(pair.i))                  {                      // this pair belongs to a local that is already rejected                      // no need to waste time on it                      continue;                  }                    var newDef = pair.d;                  var cnt = defs.Count;                    bool intersects;                    // 5000 here is just a "sufficiently large number"                  // in practice cnt rarely exceeds 200                  if (cnt > 5000)                  {                      // too many locals/spans.                       // This is an n^2 check and optimizing further may become costly.                      // reject all following definition spans                      intersects = true;                  }                  else                  {                      intersects = false;                      for (int i = 0; i < cnt; i++)                      {                          var def = defs[i];                            if (newDef.ConflictsWith(def))                          {                              intersects = true;                              break;                          }                      }                  }                    if (intersects)                  {                      info[pair.i].LocalDefs.Free();                      info.Remove(pair.i);                  }                  else                  {                      defs.Add(newDef);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeConstructorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,GenerateMethodBody,The following statement contains a magic number: BoundStatement[] statements = new BoundStatement[paramCount + 2];
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeGetHashCodeMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\AnonymousTypeMethodBodySynthesizer.cs,GenerateMethodBody,The following statement contains a magic number: const int HASH_FACTOR = -1521134295;
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedStringSwitchHashMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,ComputeStringHash,The following statement contains a magic number: if (text != null)              {                  hashCode = unchecked((uint)2166136261);                    int i = 0;                  goto start;                again:                  hashCode = unchecked((text[i] ^ hashCode) * 16777619);                  i = i + 1;                start:                  if (i < text.Length)                      goto again;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedStringSwitchHashMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,ComputeStringHash,The following statement contains a magic number: if (text != null)              {                  hashCode = unchecked((uint)2166136261);                    int i = 0;                  goto start;                again:                  hashCode = unchecked((text[i] ^ hashCode) * 16777619);                  i = i + 1;                start:                  if (i < text.Length)                      goto again;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedStringSwitchHashMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,GenerateMethodBody,The following statement contains a magic number: try              {                  LocalSymbol i = F.SynthesizedLocal(F.SpecialType(SpecialType.System_Int32));                  LocalSymbol hashCode = F.SynthesizedLocal(F.SpecialType(SpecialType.System_UInt32));                    LabelSymbol again = F.GenerateLabel("again");                  LabelSymbol start = F.GenerateLabel("start");                    ParameterSymbol text = this.Parameters[0];                    //  This method should be kept consistent with ComputeStringHash                    //uint hashCode = 0;                  //if (text != null)                  //{                  //    hashCode = unchecked((uint)2166136261);                    //    int i = 0;                  //    goto start;                    //again:                  //    hashCode = (text[i] ^ hashCode) * 16777619;                  //    i = i + 1;                    //start:                  //    if (i < text.Length)                  //        goto again;                    //}                  //return hashCode;                    var body = F.Block(                          ImmutableArray.Create<LocalSymbol>(hashCode' i)'                          F.If(                              F.Binary(BinaryOperatorKind.ObjectNotEqual' F.SpecialType(SpecialType.System_Boolean)'                                  F.Parameter(text)'                                  F.Null(text.Type))'                              F.Block(                                  F.Assignment(F.Local(hashCode)' F.Literal((uint)2166136261))'                                  F.Assignment(F.Local(i)' F.Literal(0))'                                  F.Goto(start)'                                  F.Label(again)'                                  F.Assignment(                                      F.Local(hashCode)'                                      F.Binary(BinaryOperatorKind.Multiplication' hashCode.Type'                                          F.Binary(BinaryOperatorKind.Xor' hashCode.Type'                                              F.Convert(hashCode.Type'                                                  F.Call(                                                      F.Parameter(text)'                                                      F.SpecialMethod(SpecialMember.System_String__Chars)'                                                      F.Local(i))'                                                  ConversionKind.ImplicitNumeric)'                                              F.Local(hashCode))'                                          F.Literal(16777619)))'                                  F.Assignment(                                      F.Local(i)'                                      F.Binary(BinaryOperatorKind.Addition' i.Type'                                          F.Local(i)'                                          F.Literal(1)))'                                  F.Label(start)'                                  F.If(                                      F.Binary(BinaryOperatorKind.LessThan' F.SpecialType(SpecialType.System_Boolean)'                                          F.Local(i)'                                          F.Call(F.Parameter(text)' F.SpecialMethod(SpecialMember.System_String__Length)))'                                      F.Goto(again))))'                          F.Return(F.Local(hashCode))                      );                    // NOTE: we created this block in its most-lowered form' so analysis is unnecessary                  F.CloseMethod(body);              }              catch (SyntheticBoundNodeFactory.MissingPredefinedMember ex)              {                  diagnostics.Add(ex.Diagnostic);                  F.CloseMethod(F.ThrowNull());              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedStringSwitchHashMethod,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodBodySynthesizer.Lowered.cs,GenerateMethodBody,The following statement contains a magic number: try              {                  LocalSymbol i = F.SynthesizedLocal(F.SpecialType(SpecialType.System_Int32));                  LocalSymbol hashCode = F.SynthesizedLocal(F.SpecialType(SpecialType.System_UInt32));                    LabelSymbol again = F.GenerateLabel("again");                  LabelSymbol start = F.GenerateLabel("start");                    ParameterSymbol text = this.Parameters[0];                    //  This method should be kept consistent with ComputeStringHash                    //uint hashCode = 0;                  //if (text != null)                  //{                  //    hashCode = unchecked((uint)2166136261);                    //    int i = 0;                  //    goto start;                    //again:                  //    hashCode = (text[i] ^ hashCode) * 16777619;                  //    i = i + 1;                    //start:                  //    if (i < text.Length)                  //        goto again;                    //}                  //return hashCode;                    var body = F.Block(                          ImmutableArray.Create<LocalSymbol>(hashCode' i)'                          F.If(                              F.Binary(BinaryOperatorKind.ObjectNotEqual' F.SpecialType(SpecialType.System_Boolean)'                                  F.Parameter(text)'                                  F.Null(text.Type))'                              F.Block(                                  F.Assignment(F.Local(hashCode)' F.Literal((uint)2166136261))'                                  F.Assignment(F.Local(i)' F.Literal(0))'                                  F.Goto(start)'                                  F.Label(again)'                                  F.Assignment(                                      F.Local(hashCode)'                                      F.Binary(BinaryOperatorKind.Multiplication' hashCode.Type'                                          F.Binary(BinaryOperatorKind.Xor' hashCode.Type'                                              F.Convert(hashCode.Type'                                                  F.Call(                                                      F.Parameter(text)'                                                      F.SpecialMethod(SpecialMember.System_String__Chars)'                                                      F.Local(i))'                                                  ConversionKind.ImplicitNumeric)'                                              F.Local(hashCode))'                                          F.Literal(16777619)))'                                  F.Assignment(                                      F.Local(i)'                                      F.Binary(BinaryOperatorKind.Addition' i.Type'                                          F.Local(i)'                                          F.Literal(1)))'                                  F.Label(start)'                                  F.If(                                      F.Binary(BinaryOperatorKind.LessThan' F.SpecialType(SpecialType.System_Boolean)'                                          F.Local(i)'                                          F.Call(F.Parameter(text)' F.SpecialMethod(SpecialMember.System_String__Length)))'                                      F.Goto(again))))'                          F.Return(F.Local(hashCode))                      );                    // NOTE: we created this block in its most-lowered form' so analysis is unnecessary                  F.CloseMethod(body);              }              catch (SyntheticBoundNodeFactory.MissingPredefinedMember ex)              {                  diagnostics.Add(ex.Diagnostic);                  F.CloseMethod(F.ThrowNull());              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,ArrayTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\ArrayTypeSymbolAdapter.cs,ArrayTypeSymbol,The following statement contains a magic number: Debug.Assert(constructedInterfaces.Length <= 2);
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,AbstractTypeMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AbstractTypeMap.cs,SubstituteArrayType,The following statement contains a magic number: Debug.Assert(0 <= interfaces.Length && interfaces.Length <= 2);
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,AbstractTypeMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AbstractTypeMap.cs,SubstituteArrayType,The following statement contains a magic number: if (interfaces.Length == 1)              {                  Debug.Assert(interfaces[0] is NamedTypeSymbol); // IList<T>                  interfaces = ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)SubstituteType(interfaces[0]));              }              else if (interfaces.Length == 2)              {                  Debug.Assert(interfaces[0] is NamedTypeSymbol); // IList<T>                  interfaces = ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)SubstituteType(interfaces[0])' (NamedTypeSymbol)SubstituteType(interfaces[1]));              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypePublicSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\PublicSymbols\AnonymousType.TypePublicSymbol.cs,AnonymousTypePublicSymbol,The following statement contains a magic number: Symbol[] members = new Symbol[fieldsCount * 2 + 1];
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeTemplateSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\SynthesizedSymbols\AnonymousType.TemplateSymbol.cs,AnonymousTypeTemplateSymbol,The following statement contains a magic number: Symbol[] members = new Symbol[fieldsCount * 3 + 1];
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeTemplateSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\SynthesizedSymbols\AnonymousType.TemplateSymbol.cs,AnonymousTypeTemplateSymbol,The following statement contains a magic number: MethodSymbol[] specialMembers = new MethodSymbol[3];
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeTemplateSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\SynthesizedSymbols\AnonymousType.TemplateSymbol.cs,AnonymousTypeTemplateSymbol,The following statement contains a magic number: specialMembers[2] = new AnonymousTypeToStringMethodSymbol(this);
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeTemplateSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\SynthesizedSymbols\AnonymousType.TemplateSymbol.cs,TrySynthesizeDebuggerDisplayAttribute,The following statement contains a magic number: if (this.Properties.Length == 0)                  {                      displayString = "\\{ }";                  }                  else                  {                      var builder = PooledStringBuilder.GetInstance();                      var sb = builder.Builder;                        sb.Append("\\{ ");                      int displayCount = Math.Min(this.Properties.Length' 10);                        for (var fieldIndex = 0; fieldIndex < displayCount; fieldIndex++)                      {                          string fieldName = this.Properties[fieldIndex].Name;                            if (fieldIndex > 0)                          {                              sb.Append("' ");                          }                            sb.Append(fieldName);                          sb.Append(" = {");                          sb.Append(fieldName);                          sb.Append("}");                      }                        if (this.Properties.Length > displayCount)                      {                          sb.Append(" ...");                      }                        sb.Append(" }");                      displayString = builder.ToStringAndFree();                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\SourceAttributeData.cs,GetTargetAttributeSignatureIndex,The following statement contains a magic number: for (int i = 0; i < description.Signatures.Length; i++)              {                  byte[] targetSignature = description.Signatures[i];                  if (targetSignature[0] != (byte)SignatureAttributes.Instance)                  {                      continue;                  }                    byte parameterCount = targetSignature[1];                  if (parameterCount != parameters.Length)                  {                      continue;                  }                    if ((SignatureTypeCode)targetSignature[2] != SignatureTypeCode.Void)                  {                      continue;                  }                    foundMatch = (targetSignature.Length == 3);                  int k = 0;                  for (int j = 3; j < targetSignature.Length; j++)                  {                      if (k >= parameters.Length)                      {                          break;                      }                        TypeSymbol parameterType = parameters[k].Type;                      SpecialType specType = parameterType.SpecialType;                      byte targetType = targetSignature[j];                        if (targetType == (byte)SignatureTypeCode.TypeHandle)                      {                          j++;                            if (parameterType.Kind != SymbolKind.NamedType && parameterType.Kind != SymbolKind.ErrorType)                          {                              foundMatch = false;                              break;                          }                            var namedType = (NamedTypeSymbol)parameterType;                          AttributeDescription.TypeHandleTargetInfo targetInfo = AttributeDescription.TypeHandleTargets[targetSignature[j]];                            // Compare name and containing symbol name. Uses HasNameQualifier                          // extension method to avoid string allocations.                          if (!string.Equals(namedType.MetadataName' targetInfo.Name' System.StringComparison.Ordinal) ||                              !namedType.HasNameQualifier(targetInfo.Namespace))                          {                              foundMatch = false;                              break;                          }                            targetType = (byte)targetInfo.Underlying;                            if (parameterType.IsEnumType())                          {                              specType = parameterType.GetEnumUnderlyingType().SpecialType;                          }                      }                      else if (parameterType.IsArray())                      {                          specType = ((ArrayTypeSymbol)parameterType).ElementType.SpecialType;                      }                        switch (targetType)                      {                          case (byte)SignatureTypeCode.Boolean:                              foundMatch = specType == SpecialType.System_Boolean;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Char:                              foundMatch = specType == SpecialType.System_Char;                              k += 1;                              break;                            case (byte)SignatureTypeCode.SByte:                              foundMatch = specType == SpecialType.System_SByte;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Byte:                              foundMatch = specType == SpecialType.System_Byte;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Int16:                              foundMatch = specType == SpecialType.System_Int16;                              k += 1;                              break;                            case (byte)SignatureTypeCode.UInt16:                              foundMatch = specType == SpecialType.System_UInt16;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Int32:                              foundMatch = specType == SpecialType.System_Int32;                              k += 1;                              break;                            case (byte)SignatureTypeCode.UInt32:                              foundMatch = specType == SpecialType.System_UInt32;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Int64:                              foundMatch = specType == SpecialType.System_Int64;                              k += 1;                              break;                            case (byte)SignatureTypeCode.UInt64:                              foundMatch = specType == SpecialType.System_UInt64;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Single:                              foundMatch = specType == SpecialType.System_Single;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Double:                              foundMatch = specType == SpecialType.System_Double;                              k += 1;                              break;                            case (byte)SignatureTypeCode.String:                              foundMatch = specType == SpecialType.System_String;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Object:                              foundMatch = specType == SpecialType.System_Object;                              k += 1;                              break;                            case (byte)SerializationTypeCode.Type:                              if ((object)lazySystemType == null)                              {                                  lazySystemType = GetSystemType(targetSymbol);                              }                                foundMatch = parameterType == lazySystemType;                              k += 1;                              break;                            case (byte)SignatureTypeCode.SZArray:                              // Skip over and check the next byte                              foundMatch = parameterType.IsArray();                              break;                            default:                              return -1;                      }                        if (!foundMatch)                      {                          break;                      }                  }                    if (foundMatch)                  {                      return i;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\SourceAttributeData.cs,GetTargetAttributeSignatureIndex,The following statement contains a magic number: for (int i = 0; i < description.Signatures.Length; i++)              {                  byte[] targetSignature = description.Signatures[i];                  if (targetSignature[0] != (byte)SignatureAttributes.Instance)                  {                      continue;                  }                    byte parameterCount = targetSignature[1];                  if (parameterCount != parameters.Length)                  {                      continue;                  }                    if ((SignatureTypeCode)targetSignature[2] != SignatureTypeCode.Void)                  {                      continue;                  }                    foundMatch = (targetSignature.Length == 3);                  int k = 0;                  for (int j = 3; j < targetSignature.Length; j++)                  {                      if (k >= parameters.Length)                      {                          break;                      }                        TypeSymbol parameterType = parameters[k].Type;                      SpecialType specType = parameterType.SpecialType;                      byte targetType = targetSignature[j];                        if (targetType == (byte)SignatureTypeCode.TypeHandle)                      {                          j++;                            if (parameterType.Kind != SymbolKind.NamedType && parameterType.Kind != SymbolKind.ErrorType)                          {                              foundMatch = false;                              break;                          }                            var namedType = (NamedTypeSymbol)parameterType;                          AttributeDescription.TypeHandleTargetInfo targetInfo = AttributeDescription.TypeHandleTargets[targetSignature[j]];                            // Compare name and containing symbol name. Uses HasNameQualifier                          // extension method to avoid string allocations.                          if (!string.Equals(namedType.MetadataName' targetInfo.Name' System.StringComparison.Ordinal) ||                              !namedType.HasNameQualifier(targetInfo.Namespace))                          {                              foundMatch = false;                              break;                          }                            targetType = (byte)targetInfo.Underlying;                            if (parameterType.IsEnumType())                          {                              specType = parameterType.GetEnumUnderlyingType().SpecialType;                          }                      }                      else if (parameterType.IsArray())                      {                          specType = ((ArrayTypeSymbol)parameterType).ElementType.SpecialType;                      }                        switch (targetType)                      {                          case (byte)SignatureTypeCode.Boolean:                              foundMatch = specType == SpecialType.System_Boolean;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Char:                              foundMatch = specType == SpecialType.System_Char;                              k += 1;                              break;                            case (byte)SignatureTypeCode.SByte:                              foundMatch = specType == SpecialType.System_SByte;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Byte:                              foundMatch = specType == SpecialType.System_Byte;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Int16:                              foundMatch = specType == SpecialType.System_Int16;                              k += 1;                              break;                            case (byte)SignatureTypeCode.UInt16:                              foundMatch = specType == SpecialType.System_UInt16;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Int32:                              foundMatch = specType == SpecialType.System_Int32;                              k += 1;                              break;                            case (byte)SignatureTypeCode.UInt32:                              foundMatch = specType == SpecialType.System_UInt32;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Int64:                              foundMatch = specType == SpecialType.System_Int64;                              k += 1;                              break;                            case (byte)SignatureTypeCode.UInt64:                              foundMatch = specType == SpecialType.System_UInt64;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Single:                              foundMatch = specType == SpecialType.System_Single;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Double:                              foundMatch = specType == SpecialType.System_Double;                              k += 1;                              break;                            case (byte)SignatureTypeCode.String:                              foundMatch = specType == SpecialType.System_String;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Object:                              foundMatch = specType == SpecialType.System_Object;                              k += 1;                              break;                            case (byte)SerializationTypeCode.Type:                              if ((object)lazySystemType == null)                              {                                  lazySystemType = GetSystemType(targetSymbol);                              }                                foundMatch = parameterType == lazySystemType;                              k += 1;                              break;                            case (byte)SignatureTypeCode.SZArray:                              // Skip over and check the next byte                              foundMatch = parameterType.IsArray();                              break;                            default:                              return -1;                      }                        if (!foundMatch)                      {                          break;                      }                  }                    if (foundMatch)                  {                      return i;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Attributes\SourceAttributeData.cs,GetTargetAttributeSignatureIndex,The following statement contains a magic number: for (int i = 0; i < description.Signatures.Length; i++)              {                  byte[] targetSignature = description.Signatures[i];                  if (targetSignature[0] != (byte)SignatureAttributes.Instance)                  {                      continue;                  }                    byte parameterCount = targetSignature[1];                  if (parameterCount != parameters.Length)                  {                      continue;                  }                    if ((SignatureTypeCode)targetSignature[2] != SignatureTypeCode.Void)                  {                      continue;                  }                    foundMatch = (targetSignature.Length == 3);                  int k = 0;                  for (int j = 3; j < targetSignature.Length; j++)                  {                      if (k >= parameters.Length)                      {                          break;                      }                        TypeSymbol parameterType = parameters[k].Type;                      SpecialType specType = parameterType.SpecialType;                      byte targetType = targetSignature[j];                        if (targetType == (byte)SignatureTypeCode.TypeHandle)                      {                          j++;                            if (parameterType.Kind != SymbolKind.NamedType && parameterType.Kind != SymbolKind.ErrorType)                          {                              foundMatch = false;                              break;                          }                            var namedType = (NamedTypeSymbol)parameterType;                          AttributeDescription.TypeHandleTargetInfo targetInfo = AttributeDescription.TypeHandleTargets[targetSignature[j]];                            // Compare name and containing symbol name. Uses HasNameQualifier                          // extension method to avoid string allocations.                          if (!string.Equals(namedType.MetadataName' targetInfo.Name' System.StringComparison.Ordinal) ||                              !namedType.HasNameQualifier(targetInfo.Namespace))                          {                              foundMatch = false;                              break;                          }                            targetType = (byte)targetInfo.Underlying;                            if (parameterType.IsEnumType())                          {                              specType = parameterType.GetEnumUnderlyingType().SpecialType;                          }                      }                      else if (parameterType.IsArray())                      {                          specType = ((ArrayTypeSymbol)parameterType).ElementType.SpecialType;                      }                        switch (targetType)                      {                          case (byte)SignatureTypeCode.Boolean:                              foundMatch = specType == SpecialType.System_Boolean;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Char:                              foundMatch = specType == SpecialType.System_Char;                              k += 1;                              break;                            case (byte)SignatureTypeCode.SByte:                              foundMatch = specType == SpecialType.System_SByte;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Byte:                              foundMatch = specType == SpecialType.System_Byte;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Int16:                              foundMatch = specType == SpecialType.System_Int16;                              k += 1;                              break;                            case (byte)SignatureTypeCode.UInt16:                              foundMatch = specType == SpecialType.System_UInt16;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Int32:                              foundMatch = specType == SpecialType.System_Int32;                              k += 1;                              break;                            case (byte)SignatureTypeCode.UInt32:                              foundMatch = specType == SpecialType.System_UInt32;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Int64:                              foundMatch = specType == SpecialType.System_Int64;                              k += 1;                              break;                            case (byte)SignatureTypeCode.UInt64:                              foundMatch = specType == SpecialType.System_UInt64;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Single:                              foundMatch = specType == SpecialType.System_Single;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Double:                              foundMatch = specType == SpecialType.System_Double;                              k += 1;                              break;                            case (byte)SignatureTypeCode.String:                              foundMatch = specType == SpecialType.System_String;                              k += 1;                              break;                            case (byte)SignatureTypeCode.Object:                              foundMatch = specType == SpecialType.System_Object;                              k += 1;                              break;                            case (byte)SerializationTypeCode.Type:                              if ((object)lazySystemType == null)                              {                                  lazySystemType = GetSystemType(targetSymbol);                              }                                foundMatch = parameterType == lazySystemType;                              k += 1;                              break;                            case (byte)SignatureTypeCode.SZArray:                              // Skip over and check the next byte                              foundMatch = parameterType.IsArray();                              break;                            default:                              return -1;                      }                        if (!foundMatch)                      {                          break;                      }                  }                    if (foundMatch)                  {                      return i;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,ByRefReturnErrorTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ByRefReturnErrorTypeSymbol.cs,GetHashCode,The following statement contains a magic number: return Hash.Combine(_referencedType.GetHashCode()' 13);
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,DecimalValue,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstantValueUtils.cs,DecimalValue,The following statement contains a magic number: High = unchecked((uint)bits[2]);
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,DecimalValue,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstantValueUtils.cs,DecimalValue,The following statement contains a magic number: Scale = (byte)((bits[3] & 0xFF0000) >> 16);
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,DecimalValue,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstantValueUtils.cs,DecimalValue,The following statement contains a magic number: Scale = (byte)((bits[3] & 0xFF0000) >> 16);
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,DecimalValue,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\ConstantValueUtils.cs,DecimalValue,The following statement contains a magic number: IsNegative = ((bits[3] & 0x80000000) != 0);
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,ConstantEvaluationHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ConstantEvaluationHelpers.cs,CheckGraph,The following statement contains a magic number: int i = 10;
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportNameCollisionDiagnosticsForAddedModules,The following statement contains a magic number: if (constituent.Length > 2 || (constituent.Length == 2 && constituent[0].ContainingModule.Ordinal != 0 && constituent[1].ContainingModule.Ordinal != 0))              {                  var topLevelTypesFromModules = ArrayBuilder<NamedTypeSymbol>.GetInstance();                    foreach (var moduleNs in constituent)                  {                      Debug.Assert(moduleNs.Extent.Kind == NamespaceKind.Module);                        if (moduleNs.ContainingModule.Ordinal != 0)                      {                          topLevelTypesFromModules.AddRange(moduleNs.GetTypeMembers());                      }                  }                    topLevelTypesFromModules.Sort(NameCollisionForAddedModulesTypeComparer.Singleton);                    bool reportedAnError = false;                    for (int i = 0; i < topLevelTypesFromModules.Count - 1; i++)                  {                      NamedTypeSymbol x = topLevelTypesFromModules[i];                      NamedTypeSymbol y = topLevelTypesFromModules[i + 1];                        if (x.Arity == y.Arity && x.Name == y.Name)                      {                          if (!reportedAnError)                          {                              // Skip synthetic <Module> type which every .NET module has.                              if (x.Arity != 0 || !x.ContainingNamespace.IsGlobalNamespace || x.Name != "<Module>")                              {                                  diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS' y.Locations[0]'                                                  y.ToDisplayString(SymbolDisplayFormat.ShortFormat)'                                                  y.ContainingNamespace);                              }                                reportedAnError = true;                          }                      }                      else                      {                          reportedAnError = false;                      }                  }                    topLevelTypesFromModules.Free();                    // Descent into child namespaces.                  foreach (Symbol member in mergedNs.GetMembers())                  {                      if (member.Kind == SymbolKind.Namespace)                      {                          ReportNameCollisionDiagnosticsForAddedModules((NamespaceSymbol)member' diagnostics);                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,ReportNameCollisionDiagnosticsForAddedModules,The following statement contains a magic number: if (constituent.Length > 2 || (constituent.Length == 2 && constituent[0].ContainingModule.Ordinal != 0 && constituent[1].ContainingModule.Ordinal != 0))              {                  var topLevelTypesFromModules = ArrayBuilder<NamedTypeSymbol>.GetInstance();                    foreach (var moduleNs in constituent)                  {                      Debug.Assert(moduleNs.Extent.Kind == NamespaceKind.Module);                        if (moduleNs.ContainingModule.Ordinal != 0)                      {                          topLevelTypesFromModules.AddRange(moduleNs.GetTypeMembers());                      }                  }                    topLevelTypesFromModules.Sort(NameCollisionForAddedModulesTypeComparer.Singleton);                    bool reportedAnError = false;                    for (int i = 0; i < topLevelTypesFromModules.Count - 1; i++)                  {                      NamedTypeSymbol x = topLevelTypesFromModules[i];                      NamedTypeSymbol y = topLevelTypesFromModules[i + 1];                        if (x.Arity == y.Arity && x.Name == y.Name)                      {                          if (!reportedAnError)                          {                              // Skip synthetic <Module> type which every .NET module has.                              if (x.Arity != 0 || !x.ContainingNamespace.IsGlobalNamespace || x.Name != "<Module>")                              {                                  diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS' y.Locations[0]'                                                  y.ToDisplayString(SymbolDisplayFormat.ShortFormat)'                                                  y.ContainingNamespace);                              }                                reportedAnError = true;                          }                      }                      else                      {                          reportedAnError = false;                      }                  }                    topLevelTypesFromModules.Free();                    // Descent into child namespaces.                  foreach (Symbol member in mergedNs.GetMembers())                  {                      if (member.Kind == SymbolKind.Namespace)                      {                          ReportNameCollisionDiagnosticsForAddedModules((NamespaceSymbol)member' diagnostics);                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SourceLocalSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceLocalSymbol.cs,SetSpecificallyNotPinned,The following statement contains a magic number: Debug.Assert((_isSpecificallyNotPinned & 2) == 0' "Shouldn't be writing after first read.");
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckInterfaceUnification,The following statement contains a magic number: if (numInterfaces < 2)              {                  return;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SourceModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceModuleSymbol.cs,ValidateLinkedAssemblies,The following statement contains a magic number: foreach (AssemblySymbol a in GetReferencedAssemblySymbols())              {                  cancellationToken.ThrowIfCancellationRequested();                    if (!a.IsMissing && a.IsLinked)                  {                      bool hasGuidAttribute = false;                      bool hasImportedFromTypeLibOrPrimaryInteropAssemblyAttribute = false;                        foreach (var attrData in a.GetAttributes())                      {                          if (attrData.IsTargetAttribute(a' AttributeDescription.GuidAttribute))                          {                              string guidString;                              if (attrData.TryGetGuidAttributeValue(out guidString))                              {                                  hasGuidAttribute = true;                              }                          }                          else if (attrData.IsTargetAttribute(a' AttributeDescription.ImportedFromTypeLibAttribute))                          {                              if (attrData.CommonConstructorArguments.Length == 1)                              {                                  hasImportedFromTypeLibOrPrimaryInteropAssemblyAttribute = true;                              }                          }                          else if (attrData.IsTargetAttribute(a' AttributeDescription.PrimaryInteropAssemblyAttribute))                          {                              if (attrData.CommonConstructorArguments.Length == 2)                              {                                  hasImportedFromTypeLibOrPrimaryInteropAssemblyAttribute = true;                              }                          }                            if (hasGuidAttribute && hasImportedFromTypeLibOrPrimaryInteropAssemblyAttribute)                          {                              break;                          }                      }                        if (!hasGuidAttribute)                      {                          // ERRID_PIAHasNoAssemblyGuid1/ERR_NoPIAAssemblyMissingAttribute                          diagnostics.Add(ErrorCode.ERR_NoPIAAssemblyMissingAttribute' NoLocation.Singleton' a' AttributeDescription.GuidAttribute.FullName);                      }                        if (!hasImportedFromTypeLibOrPrimaryInteropAssemblyAttribute)                      {                          // ERRID_PIAHasNoTypeLibAttribute1/ERR_NoPIAAssemblyMissingAttributes                          diagnostics.Add(ErrorCode.ERR_NoPIAAssemblyMissingAttributes' NoLocation.Singleton' a'                                                     AttributeDescription.ImportedFromTypeLibAttribute.FullName'                                                     AttributeDescription.PrimaryInteropAssemblyAttribute.FullName);                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamespaceSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol.cs,GetMembers,The following statement contains a magic number: if ((_flags & LazyAllMembersIsSorted) != 0)              {                  return _lazyAllMembers;              }              else              {                  var allMembers = this.GetMembersUnordered();                    if (allMembers.Length >= 2)                  {                      // The array isn't sorted. Sort it and remember that we sorted it.                      allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);                      ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers' allMembers);                  }                    ThreadSafeFlagOperations.Set(ref _flags' LazyAllMembersIsSorted);                  return allMembers;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamespaceSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamespaceSymbol.cs,MakeNameToMembersMap,The following statement contains a magic number: var memberOfArity = new Symbol[10];
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SourceUserDefinedOperatorSymbolBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceUserDefinedOperatorSymbolBase.cs,DoesOperatorHaveCorrectArity,The following statement contains a magic number: switch (name)              {                  case WellKnownMemberNames.IncrementOperatorName:                  case WellKnownMemberNames.DecrementOperatorName:                  case WellKnownMemberNames.UnaryNegationOperatorName:                  case WellKnownMemberNames.UnaryPlusOperatorName:                  case WellKnownMemberNames.LogicalNotOperatorName:                  case WellKnownMemberNames.OnesComplementOperatorName:                  case WellKnownMemberNames.TrueOperatorName:                  case WellKnownMemberNames.FalseOperatorName:                  case WellKnownMemberNames.ImplicitConversionName:                  case WellKnownMemberNames.ExplicitConversionName:                      return parameterCount == 1;                  default:                      return parameterCount == 2;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SubstitutedNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\SubstitutedNamedTypeSymbol.cs,GetMembersWorker,The following statement contains a magic number: var cache = _lazyMembersByNameCache ??                          (_lazyMembersByNameCache = new ConcurrentCache<string' ImmutableArray<Symbol>>(8));
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,MakeIteratorFinallyMethodName,The following statement contains a magic number: return "<>m__Finally" + StringExtensions.GetNumeral(Math.Abs(iteratorState + 2));
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,TryParseAnonymousTypeParameterName,The following statement contains a magic number: if (typeParameterName.StartsWith("<"' StringComparison.Ordinal) &&                  typeParameterName.EndsWith(">j__TPar"' StringComparison.Ordinal))              {                  propertyName = typeParameterName.Substring(1' typeParameterName.Length - 9);                  return true;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,GeneratedNames,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\GeneratedNames.cs,TryParseGeneratedName,The following statement contains a magic number: if (name.StartsWith("CS$<"' StringComparison.Ordinal))              {                  openBracketOffset = 3;              }              else if (name.StartsWith("<"' StringComparison.Ordinal))              {                  openBracketOffset = 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedEntryPointSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedEntryPointSymbol.cs,CreateSubmissionFactoryBody,The following statement contains a magic number: Debug.Assert(ctor.ParameterCount == 2);
Magic Number,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,GetMethodKey,The following statement contains a magic number: if (methodSymbol.IsExplicitInterfaceImplementation)              {                  Symbol symbol = methodSymbol.AssociatedSymbol ?? methodSymbol;                  Debug.Assert(symbol.DeclaringSyntaxReferences.Length < 2' "Can't have a partial explicit interface implementation");                  SyntaxReference reference = symbol.DeclaringSyntaxReferences.FirstOrDefault();                  if (reference != null)                  {                      var syntax = reference.GetSyntax();                      switch (syntax.Kind())                      {                          case SyntaxKind.MethodDeclaration:                              MethodDeclarationSyntax methodDecl = (MethodDeclarationSyntax)syntax;                              aliasQualifierOpt = methodDecl.ExplicitInterfaceSpecifier.Name.GetAliasQualifierOpt();                              break;                          case SyntaxKind.IndexerDeclaration:                          case SyntaxKind.PropertyDeclaration:                          case SyntaxKind.EventDeclaration:                              BasePropertyDeclarationSyntax propertyDecl = (BasePropertyDeclarationSyntax)syntax;                              aliasQualifierOpt = propertyDecl.ExplicitInterfaceSpecifier.Name.GetAliasQualifierOpt();                              break;                          case SyntaxKind.EventFieldDeclaration:                              Debug.Assert(false' "Field-like events are never explicit interface implementations");                              break;                          default:                              Debug.Assert(false' "Unexpected syntax kind " + syntax.Kind());                              break;                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedEvent,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedEvent.cs,EmbedCorrespondingComEventInterfaceMethodInternal,The following statement contains a magic number: foreach (var attrData in underlyingContainingType.GetAttributes())              {                  if (attrData.IsTargetAttribute(underlyingContainingType' AttributeDescription.ComEventInterfaceAttribute))                  {                      bool foundMatch = false;                      NamedTypeSymbol sourceInterface = null;                        if (attrData.CommonConstructorArguments.Length == 2)                      {                          sourceInterface = attrData.CommonConstructorArguments[0].Value as NamedTypeSymbol;                            if ((object)sourceInterface != null)                          {                              foundMatch = EmbedMatchingInterfaceMethods(sourceInterface' syntaxNodeOpt' diagnostics);                                foreach (NamedTypeSymbol source in sourceInterface.AllInterfacesNoUseSiteDiagnostics)                              {                                  if (EmbedMatchingInterfaceMethods(source' syntaxNodeOpt' diagnostics))                                  {                                      foundMatch = true;                                  }                              }                          }                      }                        if (!foundMatch && isUsedForComAwareEventBinding)                      {                          if ((object)sourceInterface == null)                          {                              // ERRID_SourceInterfaceMustBeInterface/ERR_MissingSourceInterface                              EmbeddedTypesManager.Error(diagnostics' ErrorCode.ERR_MissingSourceInterface' syntaxNodeOpt' underlyingContainingType' UnderlyingEvent);                          }                          else                          {                              HashSet<DiagnosticInfo> useSiteDiagnostics = null;                              sourceInterface.AllInterfacesWithDefinitionUseSiteDiagnostics(ref useSiteDiagnostics);                              diagnostics.Add(syntaxNodeOpt == null ? NoLocation.Singleton : syntaxNodeOpt.Location' useSiteDiagnostics);                                // ERRID_EventNoPIANoBackingMember/ERR_MissingMethodOnSourceInterface                              EmbeddedTypesManager.Error(diagnostics' ErrorCode.ERR_MissingMethodOnSourceInterface' syntaxNodeOpt' sourceInterface' UnderlyingEvent.MetadataName' UnderlyingEvent);                          }                      }                        break;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,AbstractLexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\AbstractLexer.cs,AddError,The following statement contains a magic number: if (error != null)              {                  if (_errors == null)                  {                      _errors = new List<SyntaxDiagnosticInfo>(8);                  }                    _errors.Add(error);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParsePragmaDirective,The following statement contains a magic number: if (this.CurrentToken.ContextualKind == SyntaxKind.WarningKeyword)              {                  var warning = this.EatContextualToken(SyntaxKind.WarningKeyword);                  SyntaxToken style;                  if (this.CurrentToken.Kind == SyntaxKind.DisableKeyword || this.CurrentToken.Kind == SyntaxKind.RestoreKeyword)                  {                      style = this.EatToken();                      var ids = new SeparatedSyntaxListBuilder<ExpressionSyntax>(10);                      while (this.CurrentToken.Kind != SyntaxKind.EndOfDirectiveToken)                      {                          SyntaxToken id;                          ExpressionSyntax idExpression;                            if (this.CurrentToken.Kind == SyntaxKind.NumericLiteralToken)                          {                              // Previous versions of the compiler used to report a warning (CS1691)                              // whenever an unrecognized warning code was supplied in a #pragma directive                              // (or via /nowarn /warnaserror flags on the command line).                              // Going forward' we won't generate any warning in such cases. This will make                              // maintainance of backwards compatibility easier (we no longer need to worry                              // about breaking existing projects / command lines if we deprecate / remove                              // an old warning code).                              id = this.EatToken();                              idExpression = SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression' id);                          }                          else if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)                          {                              // Lexing / parsing of identifiers inside #pragma warning directives is identical                              // to that inside #define directives except that very long identifiers inside #define                              // are truncated to 128 characters to maintain backwards compatibility with previous                              // versions of the compiler. (See TruncateIdentifier() below.)                              // Since support for identifiers inside #pragma warning directivess is new'                               // we don't have any backwards compatibility constraints. So we can preserve the                              // identifier exactly as it appears in source.                              id = this.EatToken();                              idExpression = SyntaxFactory.IdentifierName(id);                          }                          else                          {                              id = this.EatToken(SyntaxKind.NumericLiteralToken' ErrorCode.WRN_IdentifierOrNumericLiteralExpected' reportError: isActive);                              idExpression = SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression' id);                          }                            hasError = hasError || id.ContainsDiagnostics;                          ids.Add(idExpression);                            if (this.CurrentToken.Kind != SyntaxKind.CommaToken)                          {                              break;                          }                            ids.AddSeparator(this.EatToken());                      }                        var end = this.ParseEndOfDirective(hasError || !isActive' afterPragma: true);                      return SyntaxFactory.PragmaWarningDirectiveTrivia(hash' pragma' warning' style' ids.ToList()' end' isActive);                  }                  else                  {                      style = this.EatToken(SyntaxKind.DisableKeyword' ErrorCode.WRN_IllegalPPWarning' reportError: isActive);                      var end = this.ParseEndOfDirective(ignoreErrors: true' afterPragma: true);                      return SyntaxFactory.PragmaWarningDirectiveTrivia(hash' pragma' warning' style' default(SeparatedSyntaxList<ExpressionSyntax>)' end' isActive);                  }              }              else if (this.CurrentToken.Kind == SyntaxKind.ChecksumKeyword)              {                  var checksum = this.EatToken();                  var file = this.EatToken(SyntaxKind.StringLiteralToken' ErrorCode.WRN_IllegalPPChecksum' reportError: isActive);                  var guid = this.EatToken(SyntaxKind.StringLiteralToken' ErrorCode.WRN_IllegalPPChecksum' reportError: isActive && !file.IsMissing);                  if (isActive && !guid.IsMissing)                  {                      Guid tmp;                      if (!Guid.TryParse(guid.ValueText' out tmp))                      {                          guid = this.AddError(guid' ErrorCode.WRN_IllegalPPChecksum);                      }                  }                    var bytes = this.EatToken(SyntaxKind.StringLiteralToken' ErrorCode.WRN_IllegalPPChecksum' reportError: isActive && !guid.IsMissing);                  if (isActive && !bytes.IsMissing)                  {                      if (bytes.ValueText.Length % 2 != 0)                      {                          bytes = this.AddError(bytes' ErrorCode.WRN_IllegalPPChecksum);                      }                      else                      {                          foreach (char c in bytes.ValueText)                          {                              if (!SyntaxFacts.IsHexDigit(c))                              {                                  bytes = this.AddError(bytes' ErrorCode.WRN_IllegalPPChecksum);                                  break;                              }                          }                      }                  }                    hasError = file.ContainsDiagnostics | guid.ContainsDiagnostics | bytes.ContainsDiagnostics;                  var eod = this.ParseEndOfDirective(ignoreErrors: hasError' afterPragma: true);                  return SyntaxFactory.PragmaChecksumDirectiveTrivia(hash' pragma' checksum' file' guid' bytes' eod' isActive);              }              else              {                  var warning = this.EatToken(SyntaxKind.WarningKeyword' ErrorCode.WRN_IllegalPragma' reportError: isActive);                  var style = this.EatToken(SyntaxKind.DisableKeyword' reportError: false);                  var eod = this.ParseEndOfDirective(ignoreErrors: true' afterPragma: true);                  return SyntaxFactory.PragmaWarningDirectiveTrivia(hash' pragma' warning' style' default(SeparatedSyntaxList<ExpressionSyntax>)' eod' isActive);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParsePragmaDirective,The following statement contains a magic number: if (this.CurrentToken.ContextualKind == SyntaxKind.WarningKeyword)              {                  var warning = this.EatContextualToken(SyntaxKind.WarningKeyword);                  SyntaxToken style;                  if (this.CurrentToken.Kind == SyntaxKind.DisableKeyword || this.CurrentToken.Kind == SyntaxKind.RestoreKeyword)                  {                      style = this.EatToken();                      var ids = new SeparatedSyntaxListBuilder<ExpressionSyntax>(10);                      while (this.CurrentToken.Kind != SyntaxKind.EndOfDirectiveToken)                      {                          SyntaxToken id;                          ExpressionSyntax idExpression;                            if (this.CurrentToken.Kind == SyntaxKind.NumericLiteralToken)                          {                              // Previous versions of the compiler used to report a warning (CS1691)                              // whenever an unrecognized warning code was supplied in a #pragma directive                              // (or via /nowarn /warnaserror flags on the command line).                              // Going forward' we won't generate any warning in such cases. This will make                              // maintainance of backwards compatibility easier (we no longer need to worry                              // about breaking existing projects / command lines if we deprecate / remove                              // an old warning code).                              id = this.EatToken();                              idExpression = SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression' id);                          }                          else if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)                          {                              // Lexing / parsing of identifiers inside #pragma warning directives is identical                              // to that inside #define directives except that very long identifiers inside #define                              // are truncated to 128 characters to maintain backwards compatibility with previous                              // versions of the compiler. (See TruncateIdentifier() below.)                              // Since support for identifiers inside #pragma warning directivess is new'                               // we don't have any backwards compatibility constraints. So we can preserve the                              // identifier exactly as it appears in source.                              id = this.EatToken();                              idExpression = SyntaxFactory.IdentifierName(id);                          }                          else                          {                              id = this.EatToken(SyntaxKind.NumericLiteralToken' ErrorCode.WRN_IdentifierOrNumericLiteralExpected' reportError: isActive);                              idExpression = SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression' id);                          }                            hasError = hasError || id.ContainsDiagnostics;                          ids.Add(idExpression);                            if (this.CurrentToken.Kind != SyntaxKind.CommaToken)                          {                              break;                          }                            ids.AddSeparator(this.EatToken());                      }                        var end = this.ParseEndOfDirective(hasError || !isActive' afterPragma: true);                      return SyntaxFactory.PragmaWarningDirectiveTrivia(hash' pragma' warning' style' ids.ToList()' end' isActive);                  }                  else                  {                      style = this.EatToken(SyntaxKind.DisableKeyword' ErrorCode.WRN_IllegalPPWarning' reportError: isActive);                      var end = this.ParseEndOfDirective(ignoreErrors: true' afterPragma: true);                      return SyntaxFactory.PragmaWarningDirectiveTrivia(hash' pragma' warning' style' default(SeparatedSyntaxList<ExpressionSyntax>)' end' isActive);                  }              }              else if (this.CurrentToken.Kind == SyntaxKind.ChecksumKeyword)              {                  var checksum = this.EatToken();                  var file = this.EatToken(SyntaxKind.StringLiteralToken' ErrorCode.WRN_IllegalPPChecksum' reportError: isActive);                  var guid = this.EatToken(SyntaxKind.StringLiteralToken' ErrorCode.WRN_IllegalPPChecksum' reportError: isActive && !file.IsMissing);                  if (isActive && !guid.IsMissing)                  {                      Guid tmp;                      if (!Guid.TryParse(guid.ValueText' out tmp))                      {                          guid = this.AddError(guid' ErrorCode.WRN_IllegalPPChecksum);                      }                  }                    var bytes = this.EatToken(SyntaxKind.StringLiteralToken' ErrorCode.WRN_IllegalPPChecksum' reportError: isActive && !guid.IsMissing);                  if (isActive && !bytes.IsMissing)                  {                      if (bytes.ValueText.Length % 2 != 0)                      {                          bytes = this.AddError(bytes' ErrorCode.WRN_IllegalPPChecksum);                      }                      else                      {                          foreach (char c in bytes.ValueText)                          {                              if (!SyntaxFacts.IsHexDigit(c))                              {                                  bytes = this.AddError(bytes' ErrorCode.WRN_IllegalPPChecksum);                                  break;                              }                          }                      }                  }                    hasError = file.ContainsDiagnostics | guid.ContainsDiagnostics | bytes.ContainsDiagnostics;                  var eod = this.ParseEndOfDirective(ignoreErrors: hasError' afterPragma: true);                  return SyntaxFactory.PragmaChecksumDirectiveTrivia(hash' pragma' checksum' file' guid' bytes' eod' isActive);              }              else              {                  var warning = this.EatToken(SyntaxKind.WarningKeyword' ErrorCode.WRN_IllegalPragma' reportError: isActive);                  var style = this.EatToken(SyntaxKind.DisableKeyword' reportError: false);                  var eod = this.ParseEndOfDirective(ignoreErrors: true' afterPragma: true);                  return SyntaxFactory.PragmaWarningDirectiveTrivia(hash' pragma' warning' style' default(SeparatedSyntaxList<ExpressionSyntax>)' eod' isActive);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,ParseEndOfDirective,The following statement contains a magic number: if (this.CurrentToken.Kind != SyntaxKind.EndOfDirectiveToken &&                  this.CurrentToken.Kind != SyntaxKind.EndOfFileToken)              {                  skippedTokens = new SyntaxListBuilder<SyntaxToken>(10);                    if (!ignoreErrors)                  {                      ErrorCode errorCode = ErrorCode.ERR_EndOfPPLineExpected;                      if (afterPragma)                      {                          errorCode = ErrorCode.WRN_EndOfPPLineExpected;                      }                      else if (afterLineNumber)                      {                          errorCode = ErrorCode.ERR_MissingPPFile;                      }                      else if (afterReference)                      {                          errorCode = ErrorCode.ERR_ExpectedPPFile;                      }                        skippedTokens.Add(this.AddError(this.EatToken().WithoutDiagnosticsGreen()' errorCode));                  }                    while (this.CurrentToken.Kind != SyntaxKind.EndOfDirectiveToken &&                         this.CurrentToken.Kind != SyntaxKind.EndOfFileToken)                  {                      skippedTokens.Add(this.EatToken().WithoutDiagnosticsGreen());                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseXmlCDataSection,The following statement contains a magic number: var textTokens = new SyntaxListBuilder<SyntaxToken>(10);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseXmlProcessingInstruction,The following statement contains a magic number: var textTokens = new SyntaxListBuilder<SyntaxToken>(10);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following statement contains a magic number: switch (text.Length)              {                  case 3:                      if (text == DocumentationCommentXmlNames.SeeElementName)                      {                          return s_seeToken;                      }                      break;                    case 4:                      switch (text)                      {                          case DocumentationCommentXmlNames.CodeElementName:                              return s_codeToken;                            case DocumentationCommentXmlNames.ListElementName:                              return s_listToken;                      }                      break;                    case 5:                      switch (text)                      {                          case DocumentationCommentXmlNames.ParameterElementName:                              return s_paramToken;                            case DocumentationCommentXmlNames.ValueElementName:                              return s_valueToken;                      }                      break;                    case 7:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExampleElementName:                              return s_exampleToken;                            case DocumentationCommentXmlNames.IncludeElementName:                              return s_includeToken;                            case DocumentationCommentXmlNames.RemarksElementName:                              return s_remarksToken;                            case DocumentationCommentXmlNames.SeeAlsoElementName:                              return s_seealsoToken;                            case DocumentationCommentXmlNames.SummaryElementName:                              return s_summaryToken;                      }                      break;                    case 9:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExceptionElementName:                              return s_exceptionToken;                            case DocumentationCommentXmlNames.TypeParameterElementName:                              return s_typeparamToken;                      }                      break;                    case 10:                      if (text == DocumentationCommentXmlNames.PermissionElementName)                      {                          return s_permissionToken;                      }                      break;                    case 12:                      if (text == DocumentationCommentXmlNames.TypeParameterElementName)                      {                          return s_typeparamrefToken;                      }                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following statement contains a magic number: switch (text.Length)              {                  case 3:                      if (text == DocumentationCommentXmlNames.SeeElementName)                      {                          return s_seeToken;                      }                      break;                    case 4:                      switch (text)                      {                          case DocumentationCommentXmlNames.CodeElementName:                              return s_codeToken;                            case DocumentationCommentXmlNames.ListElementName:                              return s_listToken;                      }                      break;                    case 5:                      switch (text)                      {                          case DocumentationCommentXmlNames.ParameterElementName:                              return s_paramToken;                            case DocumentationCommentXmlNames.ValueElementName:                              return s_valueToken;                      }                      break;                    case 7:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExampleElementName:                              return s_exampleToken;                            case DocumentationCommentXmlNames.IncludeElementName:                              return s_includeToken;                            case DocumentationCommentXmlNames.RemarksElementName:                              return s_remarksToken;                            case DocumentationCommentXmlNames.SeeAlsoElementName:                              return s_seealsoToken;                            case DocumentationCommentXmlNames.SummaryElementName:                              return s_summaryToken;                      }                      break;                    case 9:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExceptionElementName:                              return s_exceptionToken;                            case DocumentationCommentXmlNames.TypeParameterElementName:                              return s_typeparamToken;                      }                      break;                    case 10:                      if (text == DocumentationCommentXmlNames.PermissionElementName)                      {                          return s_permissionToken;                      }                      break;                    case 12:                      if (text == DocumentationCommentXmlNames.TypeParameterElementName)                      {                          return s_typeparamrefToken;                      }                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following statement contains a magic number: switch (text.Length)              {                  case 3:                      if (text == DocumentationCommentXmlNames.SeeElementName)                      {                          return s_seeToken;                      }                      break;                    case 4:                      switch (text)                      {                          case DocumentationCommentXmlNames.CodeElementName:                              return s_codeToken;                            case DocumentationCommentXmlNames.ListElementName:                              return s_listToken;                      }                      break;                    case 5:                      switch (text)                      {                          case DocumentationCommentXmlNames.ParameterElementName:                              return s_paramToken;                            case DocumentationCommentXmlNames.ValueElementName:                              return s_valueToken;                      }                      break;                    case 7:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExampleElementName:                              return s_exampleToken;                            case DocumentationCommentXmlNames.IncludeElementName:                              return s_includeToken;                            case DocumentationCommentXmlNames.RemarksElementName:                              return s_remarksToken;                            case DocumentationCommentXmlNames.SeeAlsoElementName:                              return s_seealsoToken;                            case DocumentationCommentXmlNames.SummaryElementName:                              return s_summaryToken;                      }                      break;                    case 9:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExceptionElementName:                              return s_exceptionToken;                            case DocumentationCommentXmlNames.TypeParameterElementName:                              return s_typeparamToken;                      }                      break;                    case 10:                      if (text == DocumentationCommentXmlNames.PermissionElementName)                      {                          return s_permissionToken;                      }                      break;                    case 12:                      if (text == DocumentationCommentXmlNames.TypeParameterElementName)                      {                          return s_typeparamrefToken;                      }                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following statement contains a magic number: switch (text.Length)              {                  case 3:                      if (text == DocumentationCommentXmlNames.SeeElementName)                      {                          return s_seeToken;                      }                      break;                    case 4:                      switch (text)                      {                          case DocumentationCommentXmlNames.CodeElementName:                              return s_codeToken;                            case DocumentationCommentXmlNames.ListElementName:                              return s_listToken;                      }                      break;                    case 5:                      switch (text)                      {                          case DocumentationCommentXmlNames.ParameterElementName:                              return s_paramToken;                            case DocumentationCommentXmlNames.ValueElementName:                              return s_valueToken;                      }                      break;                    case 7:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExampleElementName:                              return s_exampleToken;                            case DocumentationCommentXmlNames.IncludeElementName:                              return s_includeToken;                            case DocumentationCommentXmlNames.RemarksElementName:                              return s_remarksToken;                            case DocumentationCommentXmlNames.SeeAlsoElementName:                              return s_seealsoToken;                            case DocumentationCommentXmlNames.SummaryElementName:                              return s_summaryToken;                      }                      break;                    case 9:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExceptionElementName:                              return s_exceptionToken;                            case DocumentationCommentXmlNames.TypeParameterElementName:                              return s_typeparamToken;                      }                      break;                    case 10:                      if (text == DocumentationCommentXmlNames.PermissionElementName)                      {                          return s_permissionToken;                      }                      break;                    case 12:                      if (text == DocumentationCommentXmlNames.TypeParameterElementName)                      {                          return s_typeparamrefToken;                      }                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following statement contains a magic number: switch (text.Length)              {                  case 3:                      if (text == DocumentationCommentXmlNames.SeeElementName)                      {                          return s_seeToken;                      }                      break;                    case 4:                      switch (text)                      {                          case DocumentationCommentXmlNames.CodeElementName:                              return s_codeToken;                            case DocumentationCommentXmlNames.ListElementName:                              return s_listToken;                      }                      break;                    case 5:                      switch (text)                      {                          case DocumentationCommentXmlNames.ParameterElementName:                              return s_paramToken;                            case DocumentationCommentXmlNames.ValueElementName:                              return s_valueToken;                      }                      break;                    case 7:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExampleElementName:                              return s_exampleToken;                            case DocumentationCommentXmlNames.IncludeElementName:                              return s_includeToken;                            case DocumentationCommentXmlNames.RemarksElementName:                              return s_remarksToken;                            case DocumentationCommentXmlNames.SeeAlsoElementName:                              return s_seealsoToken;                            case DocumentationCommentXmlNames.SummaryElementName:                              return s_summaryToken;                      }                      break;                    case 9:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExceptionElementName:                              return s_exceptionToken;                            case DocumentationCommentXmlNames.TypeParameterElementName:                              return s_typeparamToken;                      }                      break;                    case 10:                      if (text == DocumentationCommentXmlNames.PermissionElementName)                      {                          return s_permissionToken;                      }                      break;                    case 12:                      if (text == DocumentationCommentXmlNames.TypeParameterElementName)                      {                          return s_typeparamrefToken;                      }                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following statement contains a magic number: switch (text.Length)              {                  case 3:                      if (text == DocumentationCommentXmlNames.SeeElementName)                      {                          return s_seeToken;                      }                      break;                    case 4:                      switch (text)                      {                          case DocumentationCommentXmlNames.CodeElementName:                              return s_codeToken;                            case DocumentationCommentXmlNames.ListElementName:                              return s_listToken;                      }                      break;                    case 5:                      switch (text)                      {                          case DocumentationCommentXmlNames.ParameterElementName:                              return s_paramToken;                            case DocumentationCommentXmlNames.ValueElementName:                              return s_valueToken;                      }                      break;                    case 7:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExampleElementName:                              return s_exampleToken;                            case DocumentationCommentXmlNames.IncludeElementName:                              return s_includeToken;                            case DocumentationCommentXmlNames.RemarksElementName:                              return s_remarksToken;                            case DocumentationCommentXmlNames.SeeAlsoElementName:                              return s_seealsoToken;                            case DocumentationCommentXmlNames.SummaryElementName:                              return s_summaryToken;                      }                      break;                    case 9:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExceptionElementName:                              return s_exceptionToken;                            case DocumentationCommentXmlNames.TypeParameterElementName:                              return s_typeparamToken;                      }                      break;                    case 10:                      if (text == DocumentationCommentXmlNames.PermissionElementName)                      {                          return s_permissionToken;                      }                      break;                    case 12:                      if (text == DocumentationCommentXmlNames.TypeParameterElementName)                      {                          return s_typeparamrefToken;                      }                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following statement contains a magic number: switch (text.Length)              {                  case 3:                      if (text == DocumentationCommentXmlNames.SeeElementName)                      {                          return s_seeToken;                      }                      break;                    case 4:                      switch (text)                      {                          case DocumentationCommentXmlNames.CodeElementName:                              return s_codeToken;                            case DocumentationCommentXmlNames.ListElementName:                              return s_listToken;                      }                      break;                    case 5:                      switch (text)                      {                          case DocumentationCommentXmlNames.ParameterElementName:                              return s_paramToken;                            case DocumentationCommentXmlNames.ValueElementName:                              return s_valueToken;                      }                      break;                    case 7:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExampleElementName:                              return s_exampleToken;                            case DocumentationCommentXmlNames.IncludeElementName:                              return s_includeToken;                            case DocumentationCommentXmlNames.RemarksElementName:                              return s_remarksToken;                            case DocumentationCommentXmlNames.SeeAlsoElementName:                              return s_seealsoToken;                            case DocumentationCommentXmlNames.SummaryElementName:                              return s_summaryToken;                      }                      break;                    case 9:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExceptionElementName:                              return s_exceptionToken;                            case DocumentationCommentXmlNames.TypeParameterElementName:                              return s_typeparamToken;                      }                      break;                    case 10:                      if (text == DocumentationCommentXmlNames.PermissionElementName)                      {                          return s_permissionToken;                      }                      break;                    case 12:                      if (text == DocumentationCommentXmlNames.TypeParameterElementName)                      {                          return s_typeparamrefToken;                      }                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlAttribute,The following statement contains a magic number: if (text.Length != 4)              {                  return null;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,CreateForInsufficientStack,The following statement contains a magic number: var builder = new SyntaxListBuilder(4);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanExternAliasDirective,The following statement contains a magic number: return this.CurrentToken.Kind == SyntaxKind.ExternKeyword                  && this.PeekToken(1).Kind == SyntaxKind.IdentifierToken && this.PeekToken(1).ContextualKind == SyntaxKind.AliasKeyword                  && this.PeekToken(2).Kind == SyntaxKind.IdentifierToken                  && this.PeekToken(3).Kind == SyntaxKind.SemicolonToken;
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanExternAliasDirective,The following statement contains a magic number: return this.CurrentToken.Kind == SyntaxKind.ExternKeyword                  && this.PeekToken(1).Kind == SyntaxKind.IdentifierToken && this.PeekToken(1).ContextualKind == SyntaxKind.AliasKeyword                  && this.PeekToken(2).Kind == SyntaxKind.IdentifierToken                  && this.PeekToken(3).Kind == SyntaxKind.SemicolonToken;
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleGlobalAttributeDeclaration,The following statement contains a magic number: return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken                  && IsGlobalAttributeTarget(this.PeekToken(1))                  && this.PeekToken(2).Kind == SyntaxKind.ColonToken;
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleTypeParameterConstraintClauseStart,The following statement contains a magic number: return                  this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&                  this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&                  this.PeekToken(2).Kind == SyntaxKind.ColonToken;
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseOperatorDeclaration,The following statement contains a magic number: switch (paramList.Parameters.Count)              {                  case 1:                      if (opToken.IsMissing || !SyntaxFacts.IsOverloadableUnaryOperator(opKind))                      {                          SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset' opTokenErrorWidth' ErrorCode.ERR_OvlUnaryOperatorExpected);                          opToken = WithAdditionalDiagnostics(opToken' diagInfo);                      }                        break;                  case 2:                      if (opToken.IsMissing || !SyntaxFacts.IsOverloadableBinaryOperator(opKind))                      {                          SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset' opTokenErrorWidth' ErrorCode.ERR_OvlBinaryOperatorExpected);                          opToken = WithAdditionalDiagnostics(opToken' diagInfo);                      }                        break;                  default:                      if (opToken.IsMissing)                      {                          SyntaxDiagnosticInfo diagInfo = MakeError(opTokenErrorOffset' opTokenErrorWidth' ErrorCode.ERR_OvlOperatorExpected);                          opToken = WithAdditionalDiagnostics(opToken' diagInfo);                      }                      else if (SyntaxFacts.IsOverloadableBinaryOperator(opKind))                      {                          opToken = this.AddError(opToken' ErrorCode.ERR_BadBinOpArgs' SyntaxFacts.GetText(opKind));                      }                      else if (SyntaxFacts.IsOverloadableUnaryOperator(opKind))                      {                          opToken = this.AddError(opToken' ErrorCode.ERR_BadUnOpArgs' SyntaxFacts.GetText(opKind));                      }                      else                      {                          opToken = this.AddError(opToken' ErrorCode.ERR_OvlOperatorExpected);                      }                        break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleMethodDeclarationFollowingNullableType,The following statement contains a magic number: if (parameter.Type == null)              {                  // has arglist:                  //   (__arglist                  if (parameter.Identifier.Kind == SyntaxKind.ArgListKeyword)                  {                      return true;                  }              }              else if (parameter.Type.Kind == SyntaxKind.NullableType)              {                  // nullable type with modifiers                  //   (ref T?                  //   (out T?                  if (parameter.Modifiers.Count > 0)                  {                      return true;                  }                    // nullable type' identifier' and separator or closing parent                  //   (T ? idf'                  //   (T ? idf)                  if (!parameter.Identifier.IsMissing &&                      (separatedParameters.Count >= 2 && !separatedParameters[1].IsMissing ||                       separatedParameters.Count == 1 && !paramList.CloseParenToken.IsMissing))                  {                      return true;                  }              }              else if (parameter.Type.Kind == SyntaxKind.IdentifierName &&                      ((IdentifierNameSyntax)parameter.Type).Identifier.ContextualKind == SyntaxKind.FromKeyword)              {                  // assume that "from" is meant to be a query start ("from" bound to a type is rare):                  // (from                  return false;              }              else              {                  // has a name and a non-nullable type:                  //   (T idf                  //   (ref T idf                  //   (out T idf                  if (!parameter.Identifier.IsMissing)                  {                      return true;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleNewExpression,The following statement contains a magic number: if (modifier == SyntaxModifier.Partial)              {                  if (SyntaxFacts.IsPredefinedType(PeekToken(2).Kind))                  {                      return false;                  }                    // class' struct' enum' interface keywords' but also other modifiers that are not allowed after                   // partial keyword but start class declaration' so we can assume the user just swapped them.                  if (IsPossibleStartOfTypeDeclaration(PeekToken(2).Kind))                  {                      return false;                  }              }              else if (modifier != SyntaxModifier.None)              {                  return false;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleNewExpression,The following statement contains a magic number: if (modifier == SyntaxModifier.Partial)              {                  if (SyntaxFacts.IsPredefinedType(PeekToken(2).Kind))                  {                      return false;                  }                    // class' struct' enum' interface keywords' but also other modifiers that are not allowed after                   // partial keyword but start class declaration' so we can assume the user just swapped them.                  if (IsPossibleStartOfTypeDeclaration(PeekToken(2).Kind))                  {                      return false;                  }              }              else if (modifier != SyntaxModifier.None)              {                  return false;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleNewExpression,The following statement contains a magic number: bool? typedIdentifier = IsPossibleTypedIdentifierStart(nextToken' PeekToken(2)' allowThisKeyword: true);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsLargeEnoughNonEmptyStatementList,The following statement contains a magic number: if (statements.Count == 0)              {                  return false;              }              else if (statements.Count == 1)              {                  // If we have a single statement' it might be small' like "return null"' or large'                  // like a loop or if or switch with many statements inside. Use the width as a proxy for                  // how big it is. If it's small' its better to forgoe a many children list anyway' since the                  // weak reference would consume as much memory as is saved.                  return statements[0].Width > 60;              }              else              {                  // For 2 or more statements' go ahead and create a many-children lists.                  return true;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetPrecedence,The following statement contains a magic number: switch (op)              {                  case SyntaxKind.SimpleAssignmentExpression:                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return 1;                  case SyntaxKind.CoalesceExpression:                      return 2;                  case SyntaxKind.LogicalOrExpression:                      return 3;                  case SyntaxKind.LogicalAndExpression:                      return 4;                  case SyntaxKind.BitwiseOrExpression:                      return 5;                  case SyntaxKind.ExclusiveOrExpression:                      return 6;                  case SyntaxKind.BitwiseAndExpression:                      return 7;                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                      return 8;                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      return 9;                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return 10;                  case SyntaxKind.AddExpression:                  case SyntaxKind.SubtractExpression:                      return 11;                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                      return 12;                  case SyntaxKind.UnaryPlusExpression:                  case SyntaxKind.UnaryMinusExpression:                  case SyntaxKind.BitwiseNotExpression:                  case SyntaxKind.LogicalNotExpression:                  case SyntaxKind.PreIncrementExpression:                  case SyntaxKind.PreDecrementExpression:                  case SyntaxKind.TypeOfExpression:                  case SyntaxKind.SizeOfExpression:                  case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                  case SyntaxKind.MakeRefExpression:                  case SyntaxKind.RefValueExpression:                  case SyntaxKind.RefTypeExpression:                  case SyntaxKind.AwaitExpression:                      return 13;                  case SyntaxKind.CastExpression:                      return 14;                  case SyntaxKind.PointerIndirectionExpression:                      return 15;                  case SyntaxKind.AddressOfExpression:                      return 16;                  default:                      return 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanParenthesizedImplicitlyTypedLambda,The following statement contains a magic number: if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken                  && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))                  && this.PeekToken(2).Kind == SyntaxKind.CommaToken)              {                  return true;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanParenthesizedImplicitlyTypedLambda,The following statement contains a magic number: if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken                  && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))                  && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken                  && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)              {                  return true;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanParenthesizedImplicitlyTypedLambda,The following statement contains a magic number: if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken                  && (!this.IsInQuery || !IsTokenQueryContextualKeyword(this.PeekToken(1)))                  && this.PeekToken(2).Kind == SyntaxKind.CloseParenToken                  && this.PeekToken(3).Kind == SyntaxKind.EqualsGreaterThanToken)              {                  return true;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanParenthesizedImplicitlyTypedLambda,The following statement contains a magic number: if (this.PeekToken(1).Kind == SyntaxKind.CloseParenToken                  && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)              {                  return true;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanExplicitlyTypedLambda,The following statement contains a magic number: try              {                  // do we have the following:                  //   case 1: ( T x '                  //   case 2: ( T x ) =>                  //   case 3: ( out T x'                  //   case 4: ( ref T x'                  //   case 5: ( out T x ) =>                  //   case 6: ( ref T x ) =>                  //                  // if so then parse it as a lambda                    // Advance past the open paren.                  this.EatToken();                    // Eat 'out' or 'ref' for cases [3' 6]                  if (this.CurrentToken.Kind == SyntaxKind.RefKeyword || this.CurrentToken.Kind == SyntaxKind.OutKeyword)                  {                      this.EatToken();                  }                    // NOTE: if we see "out" or ref" and part of cases 3'4'5'6 followed by EOF' we'll parse as a lambda.                  if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)                  {                      return true;                  }                    // NOTE: advances CurrentToken                  if (this.ScanType() == ScanTypeFlags.NotType)                  {                      return false;                  }                    if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)                  {                      return true;                  }                    if (!this.IsTrueIdentifier())                  {                      return false;                  }                    switch (this.PeekToken(1).Kind)                  {                      case SyntaxKind.EndOfFileToken:                      case SyntaxKind.CommaToken:                          return true;                        case SyntaxKind.CloseParenToken:                          switch (this.PeekToken(2).Kind)                          {                              case SyntaxKind.EndOfFileToken:                              case SyntaxKind.EqualsGreaterThanToken:                                  return true;                                default:                                  return false;                          }                      default:                          return false;                  }              }              finally              {                  this.Reset(ref resetPoint);                  this.Release(ref resetPoint);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanAsyncLambda,The following statement contains a magic number: if (this.PeekToken(1).Kind == SyntaxKind.IdentifierToken && this.PeekToken(2).Kind == SyntaxKind.EqualsGreaterThanToken)              {                  return true;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsQueryExpressionAfterFrom,The following statement contains a magic number: if (pk1 == SyntaxKind.IdentifierToken)              {                  var pk2 = this.PeekToken(2).Kind;                  if (pk2 == SyntaxKind.InKeyword)                  {                      return true;                  }                    if (mayBeVariableDeclaration)                  {                      if (pk2 == SyntaxKind.SemicolonToken ||    // from x;                          pk2 == SyntaxKind.CommaToken ||        // from x' y;                          pk2 == SyntaxKind.EqualsToken)         // from x = null;                      {                          return false;                      }                  }                    if (mayBeMemberDeclaration)                  {                      // from idf { ...   property decl                      // from idf(...     method decl                      if (pk2 == SyntaxKind.OpenParenToken ||                          pk2 == SyntaxKind.OpenBraceToken)                      {                          return false;                      }                        // otherwise we need to scan a type                  }                  else                  {                      return true;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseInterpolatedStringToken,The following statement contains a magic number: var isVerbatim = originalText.Length > 2 && originalText[1] == '@';
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseInterpolatedStringToken,The following statement contains a magic number: var openQuoteIndex = isVerbatim ? 2 : 1;
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,Lexer,The following statement contains a magic number: _identBuffer = new char[32];
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LocationOf,The following statement contains a magic number: return (XmlDocCommentLocation)((int)(mode & LexerMode.MaskXmlDocCommentLocation) >> 16);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,MutateLocation,The following statement contains a magic number: _mode |= (LexerMode)((int)location << 16);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,StyleOf,The following statement contains a magic number: return (XmlDocCommentStyle)((int)(mode & LexerMode.MaskXmlDocCommentStyle) >> 20);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanSyntaxToken,The following statement contains a magic number: switch (character)              {                  case '\"':                  case '\'':                      this.ScanStringLiteral(ref info);                      break;                    case '/':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.SlashEqualsToken;                      }                      else                      {                          info.Kind = SyntaxKind.SlashToken;                      }                        break;                    case '.':                      if (!this.ScanNumericLiteral(ref info))                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.DotToken;                      }                        break;                    case ''':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.CommaToken;                      break;                    case ':':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == ':')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.ColonColonToken;                      }                      else                      {                          info.Kind = SyntaxKind.ColonToken;                      }                        break;                    case ';':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.SemicolonToken;                      break;                    case '~':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.TildeToken;                      break;                    case '!':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.ExclamationEqualsToken;                      }                      else                      {                          info.Kind = SyntaxKind.ExclamationToken;                      }                        break;                    case '=':                      TextWindow.AdvanceChar();                      if ((character = TextWindow.PeekChar()) == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.EqualsEqualsToken;                      }                      else if (character == '>')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.EqualsGreaterThanToken;                      }                      else                      {                          info.Kind = SyntaxKind.EqualsToken;                      }                        break;                    case '*':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.AsteriskEqualsToken;                      }                      else                      {                          info.Kind = SyntaxKind.AsteriskToken;                      }                        break;                    case '(':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.OpenParenToken;                      break;                    case ')':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.CloseParenToken;                      break;                    case '{':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.OpenBraceToken;                      break;                    case '}':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.CloseBraceToken;                      break;                    case '[':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.OpenBracketToken;                      break;                    case ']':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.CloseBracketToken;                      break;                    case '?':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '?')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.QuestionQuestionToken;                      }                      else                      {                          info.Kind = SyntaxKind.QuestionToken;                      }                        break;                    case '+':                      TextWindow.AdvanceChar();                      if ((character = TextWindow.PeekChar()) == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.PlusEqualsToken;                      }                      else if (character == '+')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.PlusPlusToken;                      }                      else                      {                          info.Kind = SyntaxKind.PlusToken;                      }                        break;                    case '-':                      TextWindow.AdvanceChar();                      if ((character = TextWindow.PeekChar()) == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.MinusEqualsToken;                      }                      else if (character == '-')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.MinusMinusToken;                      }                      else if (character == '>')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.MinusGreaterThanToken;                      }                      else                      {                          info.Kind = SyntaxKind.MinusToken;                      }                        break;                    case '%':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.PercentEqualsToken;                      }                      else                      {                          info.Kind = SyntaxKind.PercentToken;                      }                        break;                    case '&':                      TextWindow.AdvanceChar();                      if ((character = TextWindow.PeekChar()) == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.AmpersandEqualsToken;                      }                      else if (TextWindow.PeekChar() == '&')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.AmpersandAmpersandToken;                      }                      else                      {                          info.Kind = SyntaxKind.AmpersandToken;                      }                        break;                    case '^':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.CaretEqualsToken;                      }                      else                      {                          info.Kind = SyntaxKind.CaretToken;                      }                        break;                    case '|':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.BarEqualsToken;                      }                      else if (TextWindow.PeekChar() == '|')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.BarBarToken;                      }                      else                      {                          info.Kind = SyntaxKind.BarToken;                      }                        break;                    case '<':                      if (this.ModeIs(LexerMode.DebuggerSyntax) && TextWindow.PeekChar(1) == '>')                      {                          // For "<>f_AnonymousType"' which is an identifier in DebuggerSyntax mode                          goto case 'a';                      }                        TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.LessThanEqualsToken;                      }                      else if (TextWindow.PeekChar() == '<')                      {                          if (this.ModeIs(LexerMode.DebuggerSyntax) && TextWindow.PeekChar(1) == '>')                          {                              // For "GenericOf<<>f__AnonymousType>"                              info.Kind = SyntaxKind.LessThanToken;                              break;                          }                            TextWindow.AdvanceChar();                          if (TextWindow.PeekChar() == '=')                          {                              TextWindow.AdvanceChar();                              info.Kind = SyntaxKind.LessThanLessThanEqualsToken;                          }                          else                          {                              info.Kind = SyntaxKind.LessThanLessThanToken;                          }                      }                      else                      {                          info.Kind = SyntaxKind.LessThanToken;                      }                        break;                    case '>':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.GreaterThanEqualsToken;                      }                      else                      {                          info.Kind = SyntaxKind.GreaterThanToken;                      }                        break;                    case '@':                      if (TextWindow.PeekChar(1) == '"')                      {                          this.ScanVerbatimStringLiteral(ref info);                      }                      else if (!this.ScanIdentifierOrKeyword(ref info))                      {                          TextWindow.AdvanceChar();                          info.Text = TextWindow.GetText(intern: true);                          this.AddError(ErrorCode.ERR_ExpectedVerbatimLiteral);                      }                        break;                    case '$':                      if (TextWindow.PeekChar(1) == '"')                      {                          this.ScanInterpolatedStringLiteral(false' ref info);                          CheckFeatureAvailability(MessageID.IDS_FeatureInterpolatedStrings);                          break;                      }                      else if (TextWindow.PeekChar(1) == '@' && TextWindow.PeekChar(2) == '"')                      {                          this.ScanInterpolatedStringLiteral(true' ref info);                          CheckFeatureAvailability(MessageID.IDS_FeatureInterpolatedStrings);                          break;                      }                      else if (this.ModeIs(LexerMode.DebuggerSyntax))                      {                          goto case 'a';                      }                        goto default;                    // All the 'common' identifier characters are represented directly in                  // these switch cases for optimal perf.  Calling IsIdentifierChar() functions is relatively                  // expensive.                  case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                  case 'g':                  case 'h':                  case 'i':                  case 'j':                  case 'k':                  case 'l':                  case 'm':                  case 'n':                  case 'o':                  case 'p':                  case 'q':                  case 'r':                  case 's':                  case 't':                  case 'u':                  case 'v':                  case 'w':                  case 'x':                  case 'y':                  case 'z':                  case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                  case 'G':                  case 'H':                  case 'I':                  case 'J':                  case 'K':                  case 'L':                  case 'M':                  case 'N':                  case 'O':                  case 'P':                  case 'Q':                  case 'R':                  case 'S':                  case 'T':                  case 'U':                  case 'V':                  case 'W':                  case 'X':                  case 'Y':                  case 'Z':                  case '_':                      this.ScanIdentifierOrKeyword(ref info);                      break;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      this.ScanNumericLiteral(ref info);                      break;                    case '\\':                      {                          // Could be unicode escape. Try that.                          character = TextWindow.PeekCharOrUnicodeEscape(out surrogateCharacter);                            isEscaped = true;                          if (SyntaxFacts.IsIdentifierStartCharacter(character))                          {                              goto case 'a';                          }                            goto default;                      }                    case SlidingTextWindow.InvalidCharacter:                      if (!TextWindow.IsReallyAtEnd())                      {                          goto default;                      }                        if (_directives.HasUnfinishedIf())                      {                          this.AddError(ErrorCode.ERR_EndifDirectiveExpected);                      }                        if (_directives.HasUnfinishedRegion())                      {                          this.AddError(ErrorCode.ERR_EndRegionDirectiveExpected);                      }                        info.Kind = SyntaxKind.EndOfFileToken;                      break;                    default:                      if (SyntaxFacts.IsIdentifierStartCharacter(character))                      {                          goto case 'a';                      }                        if (isEscaped)                      {                          SyntaxDiagnosticInfo error;                          TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter' out error);                          AddError(error);                      }                      else                      {                          TextWindow.AdvanceChar();                      }                        info.Text = TextWindow.GetText(intern: true);                        this.AddError(ErrorCode.ERR_UnexpectedCharacter' info.Text);                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanNumericLiteral,The following statement contains a magic number: if (ch == '0' && ((ch = TextWindow.PeekChar(1)) == 'x' || ch == 'X'))              {                  TextWindow.AdvanceChar(2);                  isHex = true;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,GrowIdentBuffer,The following statement contains a magic number: var tmp = new char[_identBuffer.Length * 2];
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_SlowPath,The following statement contains a magic number: while (true)              {                  char surrogateCharacter = SlidingTextWindow.InvalidCharacter;                  bool isEscaped = false;                  char ch = TextWindow.PeekChar();              top:                  switch (ch)                  {                      case '\\':                          if (!isEscaped && TextWindow.IsUnicodeEscape())                          {                              // ^^^^^^^ otherwise \u005Cu1234 looks just like \u1234! (i.e. escape within escape)                              info.HasIdentifierEscapeSequence = true;                              isEscaped = true;                              ch = TextWindow.PeekUnicodeEscape(out surrogateCharacter);                              goto top;                          }                            goto default;                      case '$':                          if (!this.ModeIs(LexerMode.DebuggerSyntax) || _identLen > 0)                          {                              goto LoopExit;                          }                            break;                      case SlidingTextWindow.InvalidCharacter:                          if (!TextWindow.IsReallyAtEnd())                          {                              goto default;                          }                            goto LoopExit;                      case '_':                      case 'A':                      case 'B':                      case 'C':                      case 'D':                      case 'E':                      case 'F':                      case 'G':                      case 'H':                      case 'I':                      case 'J':                      case 'K':                      case 'L':                      case 'M':                      case 'N':                      case 'O':                      case 'P':                      case 'Q':                      case 'R':                      case 'S':                      case 'T':                      case 'U':                      case 'V':                      case 'W':                      case 'X':                      case 'Y':                      case 'Z':                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                      case 'g':                      case 'h':                      case 'i':                      case 'j':                      case 'k':                      case 'l':                      case 'm':                      case 'n':                      case 'o':                      case 'p':                      case 'q':                      case 'r':                      case 's':                      case 't':                      case 'u':                      case 'v':                      case 'w':                      case 'x':                      case 'y':                      case 'z':                          {                              // Again' these are the 'common' identifier characters...                              break;                          }                        case '0':                          {                              if (_identLen == 0)                              {                                  // Debugger syntax allows @0x[hexdigit]+ for object address identifiers.                                  if (info.IsVerbatim &&                                      this.ModeIs(LexerMode.DebuggerSyntax) &&                                      (char.ToLower(TextWindow.PeekChar(1)) == 'x'))                                  {                                      isObjectAddress = true;                                  }                                  else                                  {                                      goto LoopExit;                                  }                              }                                // Again' these are the 'common' identifier characters...                              break;                          }                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          {                              if (_identLen == 0)                              {                                  goto LoopExit;                              }                                // Again' these are the 'common' identifier characters...                              break;                          }                        case ' ':                      case '\t':                      case '.':                      case ';':                      case '(':                      case ')':                      case ''':                          // ...and these are the 'common' stop characters.                          goto LoopExit;                      case '<':                          if (_identLen == 0 && this.ModeIs(LexerMode.DebuggerSyntax) && TextWindow.PeekChar(1) == '>')                          {                              // In DebuggerSyntax mode' identifiers are allowed to begin with <>.                              TextWindow.AdvanceChar(2);                              this.AddIdentChar('<');                              this.AddIdentChar('>');                              continue;                          }                            goto LoopExit;                      default:                          {                              // This is the 'expensive' call                              if (_identLen == 0 && ch > 127 && SyntaxFacts.IsIdentifierStartCharacter(ch))                              {                                  break;                              }                              else if (_identLen > 0 && ch > 127 && SyntaxFacts.IsIdentifierPartCharacter(ch))                              {                                  //// BUG 424819 : Handle identifier chars > 0xFFFF via surrogate pairs                                  if (SyntaxFacts.IsFormattingChar(ch))                                  {                                      if (isEscaped)                                      {                                          SyntaxDiagnosticInfo error;                                          TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter' out error);                                          AddError(error);                                      }                                      else                                      {                                          TextWindow.AdvanceChar();                                      }                                        continue; // Ignore formatting characters                                  }                                    break;                              }                              else                              {                                  // Not a valid identifier character' so bail.                                  goto LoopExit;                              }                          }                  }                    if (isEscaped)                  {                      SyntaxDiagnosticInfo error;                      TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter' out error);                      AddError(error);                  }                  else                  {                      TextWindow.AdvanceChar();                  }                    this.AddIdentChar(ch);                  if (surrogateCharacter != SlidingTextWindow.InvalidCharacter)                  {                      this.AddIdentChar(surrogateCharacter);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_SlowPath,The following statement contains a magic number: while (true)              {                  char surrogateCharacter = SlidingTextWindow.InvalidCharacter;                  bool isEscaped = false;                  char ch = TextWindow.PeekChar();              top:                  switch (ch)                  {                      case '\\':                          if (!isEscaped && TextWindow.IsUnicodeEscape())                          {                              // ^^^^^^^ otherwise \u005Cu1234 looks just like \u1234! (i.e. escape within escape)                              info.HasIdentifierEscapeSequence = true;                              isEscaped = true;                              ch = TextWindow.PeekUnicodeEscape(out surrogateCharacter);                              goto top;                          }                            goto default;                      case '$':                          if (!this.ModeIs(LexerMode.DebuggerSyntax) || _identLen > 0)                          {                              goto LoopExit;                          }                            break;                      case SlidingTextWindow.InvalidCharacter:                          if (!TextWindow.IsReallyAtEnd())                          {                              goto default;                          }                            goto LoopExit;                      case '_':                      case 'A':                      case 'B':                      case 'C':                      case 'D':                      case 'E':                      case 'F':                      case 'G':                      case 'H':                      case 'I':                      case 'J':                      case 'K':                      case 'L':                      case 'M':                      case 'N':                      case 'O':                      case 'P':                      case 'Q':                      case 'R':                      case 'S':                      case 'T':                      case 'U':                      case 'V':                      case 'W':                      case 'X':                      case 'Y':                      case 'Z':                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                      case 'g':                      case 'h':                      case 'i':                      case 'j':                      case 'k':                      case 'l':                      case 'm':                      case 'n':                      case 'o':                      case 'p':                      case 'q':                      case 'r':                      case 's':                      case 't':                      case 'u':                      case 'v':                      case 'w':                      case 'x':                      case 'y':                      case 'z':                          {                              // Again' these are the 'common' identifier characters...                              break;                          }                        case '0':                          {                              if (_identLen == 0)                              {                                  // Debugger syntax allows @0x[hexdigit]+ for object address identifiers.                                  if (info.IsVerbatim &&                                      this.ModeIs(LexerMode.DebuggerSyntax) &&                                      (char.ToLower(TextWindow.PeekChar(1)) == 'x'))                                  {                                      isObjectAddress = true;                                  }                                  else                                  {                                      goto LoopExit;                                  }                              }                                // Again' these are the 'common' identifier characters...                              break;                          }                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          {                              if (_identLen == 0)                              {                                  goto LoopExit;                              }                                // Again' these are the 'common' identifier characters...                              break;                          }                        case ' ':                      case '\t':                      case '.':                      case ';':                      case '(':                      case ')':                      case ''':                          // ...and these are the 'common' stop characters.                          goto LoopExit;                      case '<':                          if (_identLen == 0 && this.ModeIs(LexerMode.DebuggerSyntax) && TextWindow.PeekChar(1) == '>')                          {                              // In DebuggerSyntax mode' identifiers are allowed to begin with <>.                              TextWindow.AdvanceChar(2);                              this.AddIdentChar('<');                              this.AddIdentChar('>');                              continue;                          }                            goto LoopExit;                      default:                          {                              // This is the 'expensive' call                              if (_identLen == 0 && ch > 127 && SyntaxFacts.IsIdentifierStartCharacter(ch))                              {                                  break;                              }                              else if (_identLen > 0 && ch > 127 && SyntaxFacts.IsIdentifierPartCharacter(ch))                              {                                  //// BUG 424819 : Handle identifier chars > 0xFFFF via surrogate pairs                                  if (SyntaxFacts.IsFormattingChar(ch))                                  {                                      if (isEscaped)                                      {                                          SyntaxDiagnosticInfo error;                                          TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter' out error);                                          AddError(error);                                      }                                      else                                      {                                          TextWindow.AdvanceChar();                                      }                                        continue; // Ignore formatting characters                                  }                                    break;                              }                              else                              {                                  // Not a valid identifier character' so bail.                                  goto LoopExit;                              }                          }                  }                    if (isEscaped)                  {                      SyntaxDiagnosticInfo error;                      TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter' out error);                      AddError(error);                  }                  else                  {                      TextWindow.AdvanceChar();                  }                    this.AddIdentChar(ch);                  if (surrogateCharacter != SlidingTextWindow.InvalidCharacter)                  {                      this.AddIdentChar(surrogateCharacter);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_SlowPath,The following statement contains a magic number: while (true)              {                  char surrogateCharacter = SlidingTextWindow.InvalidCharacter;                  bool isEscaped = false;                  char ch = TextWindow.PeekChar();              top:                  switch (ch)                  {                      case '\\':                          if (!isEscaped && TextWindow.IsUnicodeEscape())                          {                              // ^^^^^^^ otherwise \u005Cu1234 looks just like \u1234! (i.e. escape within escape)                              info.HasIdentifierEscapeSequence = true;                              isEscaped = true;                              ch = TextWindow.PeekUnicodeEscape(out surrogateCharacter);                              goto top;                          }                            goto default;                      case '$':                          if (!this.ModeIs(LexerMode.DebuggerSyntax) || _identLen > 0)                          {                              goto LoopExit;                          }                            break;                      case SlidingTextWindow.InvalidCharacter:                          if (!TextWindow.IsReallyAtEnd())                          {                              goto default;                          }                            goto LoopExit;                      case '_':                      case 'A':                      case 'B':                      case 'C':                      case 'D':                      case 'E':                      case 'F':                      case 'G':                      case 'H':                      case 'I':                      case 'J':                      case 'K':                      case 'L':                      case 'M':                      case 'N':                      case 'O':                      case 'P':                      case 'Q':                      case 'R':                      case 'S':                      case 'T':                      case 'U':                      case 'V':                      case 'W':                      case 'X':                      case 'Y':                      case 'Z':                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                      case 'g':                      case 'h':                      case 'i':                      case 'j':                      case 'k':                      case 'l':                      case 'm':                      case 'n':                      case 'o':                      case 'p':                      case 'q':                      case 'r':                      case 's':                      case 't':                      case 'u':                      case 'v':                      case 'w':                      case 'x':                      case 'y':                      case 'z':                          {                              // Again' these are the 'common' identifier characters...                              break;                          }                        case '0':                          {                              if (_identLen == 0)                              {                                  // Debugger syntax allows @0x[hexdigit]+ for object address identifiers.                                  if (info.IsVerbatim &&                                      this.ModeIs(LexerMode.DebuggerSyntax) &&                                      (char.ToLower(TextWindow.PeekChar(1)) == 'x'))                                  {                                      isObjectAddress = true;                                  }                                  else                                  {                                      goto LoopExit;                                  }                              }                                // Again' these are the 'common' identifier characters...                              break;                          }                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          {                              if (_identLen == 0)                              {                                  goto LoopExit;                              }                                // Again' these are the 'common' identifier characters...                              break;                          }                        case ' ':                      case '\t':                      case '.':                      case ';':                      case '(':                      case ')':                      case ''':                          // ...and these are the 'common' stop characters.                          goto LoopExit;                      case '<':                          if (_identLen == 0 && this.ModeIs(LexerMode.DebuggerSyntax) && TextWindow.PeekChar(1) == '>')                          {                              // In DebuggerSyntax mode' identifiers are allowed to begin with <>.                              TextWindow.AdvanceChar(2);                              this.AddIdentChar('<');                              this.AddIdentChar('>');                              continue;                          }                            goto LoopExit;                      default:                          {                              // This is the 'expensive' call                              if (_identLen == 0 && ch > 127 && SyntaxFacts.IsIdentifierStartCharacter(ch))                              {                                  break;                              }                              else if (_identLen > 0 && ch > 127 && SyntaxFacts.IsIdentifierPartCharacter(ch))                              {                                  //// BUG 424819 : Handle identifier chars > 0xFFFF via surrogate pairs                                  if (SyntaxFacts.IsFormattingChar(ch))                                  {                                      if (isEscaped)                                      {                                          SyntaxDiagnosticInfo error;                                          TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter' out error);                                          AddError(error);                                      }                                      else                                      {                                          TextWindow.AdvanceChar();                                      }                                        continue; // Ignore formatting characters                                  }                                    break;                              }                              else                              {                                  // Not a valid identifier character' so bail.                                  goto LoopExit;                              }                          }                  }                    if (isEscaped)                  {                      SyntaxDiagnosticInfo error;                      TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter' out error);                      AddError(error);                  }                  else                  {                      TextWindow.AdvanceChar();                  }                    this.AddIdentChar(ch);                  if (surrogateCharacter != SlidingTextWindow.InvalidCharacter)                  {                      this.AddIdentChar(surrogateCharacter);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_SlowPath,The following statement contains a magic number: if (_identLen > 0)              {                  info.Text = TextWindow.GetInternedText();                    // id buffer is identical to width in input                  if (_identLen == width)                  {                      info.StringValue = info.Text;                  }                  else                  {                      info.StringValue = TextWindow.Intern(_identBuffer' 0' _identLen);                  }                    if (isObjectAddress)                  {                      // @0x[hexdigit]+                      const int objectAddressOffset = 2;                      Debug.Assert(string.Equals(info.Text.Substring(0' objectAddressOffset + 1)' "@0x"' StringComparison.OrdinalIgnoreCase));                      var valueText = TextWindow.Intern(_identBuffer' objectAddressOffset' _identLen - objectAddressOffset);                      // Verify valid hex value.                      if ((valueText.Length == 0) || !valueText.All(IsValidHexDigit))                      {                          goto Fail;                      }                      // Parse hex value to check for overflow.                      this.GetValueUInt64(valueText' isHex: true);                  }                    return true;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_CrefSlowPath,The following statement contains a magic number: while (true)              {                  int beforeConsumed = TextWindow.Position;                  char consumedChar;                  char consumedSurrogate;                    if (TextWindow.PeekChar() == '&')                  {                      if (!TextWindow.TryScanXmlEntity(out consumedChar' out consumedSurrogate))                      {                          // If it's not a valid entity' then it's not part of the identifier.                          TextWindow.Reset(beforeConsumed);                          goto LoopExit;                      }                  }                  else                  {                      consumedChar = TextWindow.NextChar();                      consumedSurrogate = SlidingTextWindow.InvalidCharacter;                  }                    // NOTE: If the surrogate is non-zero' then consumedChar won't match                  // any of the cases below (UTF-16 guarantees that members of surrogate                  // pairs aren't separately valid).                    bool isEscaped = false;              top:                  switch (consumedChar)                  {                      case '\\':                          // NOTE: For completeness' we should allow xml entities in unicode escape                          // sequences (DevDiv #16321).  Since it is not currently a priority' we will                          // try to make the interim behavior sensible: we will only attempt to scan                          // a unicode escape if NONE of the characters are XML entities (including                          // the backslash' which we have already consumed).                          // When we're ready to implement this behavior' we can drop the position                          // check and use AdvanceIfMatches instead of PeekChar.                          if (!isEscaped && (TextWindow.Position == beforeConsumed + 1) &&                              (TextWindow.PeekChar() == 'u' || TextWindow.PeekChar() == 'U'))                          {                              Debug.Assert(consumedSurrogate == SlidingTextWindow.InvalidCharacter' "Since consumedChar == '\\'");                                info.HasIdentifierEscapeSequence = true;                                TextWindow.Reset(beforeConsumed);                              // ^^^^^^^ otherwise \u005Cu1234 looks just like \u1234! (i.e. escape within escape)                              isEscaped = true;                              SyntaxDiagnosticInfo error;                              consumedChar = TextWindow.NextUnicodeEscape(out consumedSurrogate' out error);                              AddCrefError(error);                              goto top;                          }                            goto default;                        case '_':                      case 'A':                      case 'B':                      case 'C':                      case 'D':                      case 'E':                      case 'F':                      case 'G':                      case 'H':                      case 'I':                      case 'J':                      case 'K':                      case 'L':                      case 'M':                      case 'N':                      case 'O':                      case 'P':                      case 'Q':                      case 'R':                      case 'S':                      case 'T':                      case 'U':                      case 'V':                      case 'W':                      case 'X':                      case 'Y':                      case 'Z':                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                      case 'g':                      case 'h':                      case 'i':                      case 'j':                      case 'k':                      case 'l':                      case 'm':                      case 'n':                      case 'o':                      case 'p':                      case 'q':                      case 'r':                      case 's':                      case 't':                      case 'u':                      case 'v':                      case 'w':                      case 'x':                      case 'y':                      case 'z':                          {                              // Again' these are the 'common' identifier characters...                              break;                          }                        case '0':                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          {                              if (_identLen == 0)                              {                                  TextWindow.Reset(beforeConsumed);                                  goto LoopExit;                              }                                // Again' these are the 'common' identifier characters...                              break;                          }                        case ' ':                      case '$':                      case '\t':                      case '.':                      case ';':                      case '(':                      case ')':                      case ''':                      case '<':                          // ...and these are the 'common' stop characters.                          TextWindow.Reset(beforeConsumed);                          goto LoopExit;                      case SlidingTextWindow.InvalidCharacter:                          if (!TextWindow.IsReallyAtEnd())                          {                              goto default;                          }                            TextWindow.Reset(beforeConsumed);                          goto LoopExit;                      default:                          {                              // This is the 'expensive' call                              if (_identLen == 0 && consumedChar > 127 && SyntaxFacts.IsIdentifierStartCharacter(consumedChar))                              {                                  break;                              }                              else if (_identLen > 0 && consumedChar > 127 && SyntaxFacts.IsIdentifierPartCharacter(consumedChar))                              {                                  //// BUG 424819 : Handle identifier chars > 0xFFFF via surrogate pairs                                  if (SyntaxFacts.IsFormattingChar(consumedChar))                                  {                                      continue; // Ignore formatting characters                                  }                                    break;                              }                              else                              {                                  // Not a valid identifier character' so bail.                                  TextWindow.Reset(beforeConsumed);                                  goto LoopExit;                              }                          }                  }                    this.AddIdentChar(consumedChar);                  if (consumedSurrogate != SlidingTextWindow.InvalidCharacter)                  {                      this.AddIdentChar(consumedSurrogate);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanIdentifier_CrefSlowPath,The following statement contains a magic number: while (true)              {                  int beforeConsumed = TextWindow.Position;                  char consumedChar;                  char consumedSurrogate;                    if (TextWindow.PeekChar() == '&')                  {                      if (!TextWindow.TryScanXmlEntity(out consumedChar' out consumedSurrogate))                      {                          // If it's not a valid entity' then it's not part of the identifier.                          TextWindow.Reset(beforeConsumed);                          goto LoopExit;                      }                  }                  else                  {                      consumedChar = TextWindow.NextChar();                      consumedSurrogate = SlidingTextWindow.InvalidCharacter;                  }                    // NOTE: If the surrogate is non-zero' then consumedChar won't match                  // any of the cases below (UTF-16 guarantees that members of surrogate                  // pairs aren't separately valid).                    bool isEscaped = false;              top:                  switch (consumedChar)                  {                      case '\\':                          // NOTE: For completeness' we should allow xml entities in unicode escape                          // sequences (DevDiv #16321).  Since it is not currently a priority' we will                          // try to make the interim behavior sensible: we will only attempt to scan                          // a unicode escape if NONE of the characters are XML entities (including                          // the backslash' which we have already consumed).                          // When we're ready to implement this behavior' we can drop the position                          // check and use AdvanceIfMatches instead of PeekChar.                          if (!isEscaped && (TextWindow.Position == beforeConsumed + 1) &&                              (TextWindow.PeekChar() == 'u' || TextWindow.PeekChar() == 'U'))                          {                              Debug.Assert(consumedSurrogate == SlidingTextWindow.InvalidCharacter' "Since consumedChar == '\\'");                                info.HasIdentifierEscapeSequence = true;                                TextWindow.Reset(beforeConsumed);                              // ^^^^^^^ otherwise \u005Cu1234 looks just like \u1234! (i.e. escape within escape)                              isEscaped = true;                              SyntaxDiagnosticInfo error;                              consumedChar = TextWindow.NextUnicodeEscape(out consumedSurrogate' out error);                              AddCrefError(error);                              goto top;                          }                            goto default;                        case '_':                      case 'A':                      case 'B':                      case 'C':                      case 'D':                      case 'E':                      case 'F':                      case 'G':                      case 'H':                      case 'I':                      case 'J':                      case 'K':                      case 'L':                      case 'M':                      case 'N':                      case 'O':                      case 'P':                      case 'Q':                      case 'R':                      case 'S':                      case 'T':                      case 'U':                      case 'V':                      case 'W':                      case 'X':                      case 'Y':                      case 'Z':                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                      case 'g':                      case 'h':                      case 'i':                      case 'j':                      case 'k':                      case 'l':                      case 'm':                      case 'n':                      case 'o':                      case 'p':                      case 'q':                      case 'r':                      case 's':                      case 't':                      case 'u':                      case 'v':                      case 'w':                      case 'x':                      case 'y':                      case 'z':                          {                              // Again' these are the 'common' identifier characters...                              break;                          }                        case '0':                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          {                              if (_identLen == 0)                              {                                  TextWindow.Reset(beforeConsumed);                                  goto LoopExit;                              }                                // Again' these are the 'common' identifier characters...                              break;                          }                        case ' ':                      case '$':                      case '\t':                      case '.':                      case ';':                      case '(':                      case ')':                      case ''':                      case '<':                          // ...and these are the 'common' stop characters.                          TextWindow.Reset(beforeConsumed);                          goto LoopExit;                      case SlidingTextWindow.InvalidCharacter:                          if (!TextWindow.IsReallyAtEnd())                          {                              goto default;                          }                            TextWindow.Reset(beforeConsumed);                          goto LoopExit;                      default:                          {                              // This is the 'expensive' call                              if (_identLen == 0 && consumedChar > 127 && SyntaxFacts.IsIdentifierStartCharacter(consumedChar))                              {                                  break;                              }                              else if (_identLen > 0 && consumedChar > 127 && SyntaxFacts.IsIdentifierPartCharacter(consumedChar))                              {                                  //// BUG 424819 : Handle identifier chars > 0xFFFF via surrogate pairs                                  if (SyntaxFacts.IsFormattingChar(consumedChar))                                  {                                      continue; // Ignore formatting characters                                  }                                    break;                              }                              else                              {                                  // Not a valid identifier character' so bail.                                  TextWindow.Reset(beforeConsumed);                                  goto LoopExit;                              }                          }                  }                    this.AddIdentChar(consumedChar);                  if (consumedSurrogate != SlidingTextWindow.InvalidCharacter)                  {                      this.AddIdentChar(consumedSurrogate);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexSyntaxTrivia,The following statement contains a magic number: while (true)              {                  this.Start();                  char ch = TextWindow.PeekChar();                  if (ch == ' ')                  {                      this.AddTrivia(this.ScanWhitespace()' ref triviaList);                      continue;                  }                  else if (ch > 127)                  {                      if (SyntaxFacts.IsWhitespace(ch))                      {                          ch = ' ';                      }                      else if (SyntaxFacts.IsNewLine(ch))                      {                          ch = '\n';                      }                  }                    switch (ch)                  {                      case ' ':                      case '\t':       // Horizontal tab                      case '\v':       // Vertical Tab                      case '\f':       // Form-feed                      case '\u001A':                          this.AddTrivia(this.ScanWhitespace()' ref triviaList);                          break;                      case '/':                          if ((ch = TextWindow.PeekChar(1)) == '/')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine)' ref triviaList);                                  break;                              }                                // normal single line comment                              this.ScanToEndOfLine();                              var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                          else if (ch == '*')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&                                  TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited)' ref triviaList);                                  break;                              }                                bool isTerminated;                              this.ScanMultiLineComment(out isTerminated);                              if (!isTerminated)                              {                                  // The comment didn't end.  Report an error at the start point.                                  this.AddError(ErrorCode.ERR_OpenEndedComment);                              }                                var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                            // not trivia                          return;                      case '\r':                      case '\n':                          this.AddTrivia(this.ScanEndOfLine()' ref triviaList);                          if (isTrailing)                          {                              return;                          }                            onlyWhitespaceOnLine = true;                          break;                      case '#':                          if (_allowPreprocessorDirectives)                          {                              this.LexDirectiveAndExcludedTrivia(afterFirstToken' isTrailing || !onlyWhitespaceOnLine' ref triviaList);                              break;                          }                          else                          {                              return;                          }                      default:                          return;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexSyntaxTrivia,The following statement contains a magic number: while (true)              {                  this.Start();                  char ch = TextWindow.PeekChar();                  if (ch == ' ')                  {                      this.AddTrivia(this.ScanWhitespace()' ref triviaList);                      continue;                  }                  else if (ch > 127)                  {                      if (SyntaxFacts.IsWhitespace(ch))                      {                          ch = ' ';                      }                      else if (SyntaxFacts.IsNewLine(ch))                      {                          ch = '\n';                      }                  }                    switch (ch)                  {                      case ' ':                      case '\t':       // Horizontal tab                      case '\v':       // Vertical Tab                      case '\f':       // Form-feed                      case '\u001A':                          this.AddTrivia(this.ScanWhitespace()' ref triviaList);                          break;                      case '/':                          if ((ch = TextWindow.PeekChar(1)) == '/')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine)' ref triviaList);                                  break;                              }                                // normal single line comment                              this.ScanToEndOfLine();                              var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                          else if (ch == '*')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&                                  TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited)' ref triviaList);                                  break;                              }                                bool isTerminated;                              this.ScanMultiLineComment(out isTerminated);                              if (!isTerminated)                              {                                  // The comment didn't end.  Report an error at the start point.                                  this.AddError(ErrorCode.ERR_OpenEndedComment);                              }                                var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                            // not trivia                          return;                      case '\r':                      case '\n':                          this.AddTrivia(this.ScanEndOfLine()' ref triviaList);                          if (isTrailing)                          {                              return;                          }                            onlyWhitespaceOnLine = true;                          break;                      case '#':                          if (_allowPreprocessorDirectives)                          {                              this.LexDirectiveAndExcludedTrivia(afterFirstToken' isTrailing || !onlyWhitespaceOnLine' ref triviaList);                              break;                          }                          else                          {                              return;                          }                      default:                          return;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexSyntaxTrivia,The following statement contains a magic number: while (true)              {                  this.Start();                  char ch = TextWindow.PeekChar();                  if (ch == ' ')                  {                      this.AddTrivia(this.ScanWhitespace()' ref triviaList);                      continue;                  }                  else if (ch > 127)                  {                      if (SyntaxFacts.IsWhitespace(ch))                      {                          ch = ' ';                      }                      else if (SyntaxFacts.IsNewLine(ch))                      {                          ch = '\n';                      }                  }                    switch (ch)                  {                      case ' ':                      case '\t':       // Horizontal tab                      case '\v':       // Vertical Tab                      case '\f':       // Form-feed                      case '\u001A':                          this.AddTrivia(this.ScanWhitespace()' ref triviaList);                          break;                      case '/':                          if ((ch = TextWindow.PeekChar(1)) == '/')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine)' ref triviaList);                                  break;                              }                                // normal single line comment                              this.ScanToEndOfLine();                              var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                          else if (ch == '*')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&                                  TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited)' ref triviaList);                                  break;                              }                                bool isTerminated;                              this.ScanMultiLineComment(out isTerminated);                              if (!isTerminated)                              {                                  // The comment didn't end.  Report an error at the start point.                                  this.AddError(ErrorCode.ERR_OpenEndedComment);                              }                                var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                            // not trivia                          return;                      case '\r':                      case '\n':                          this.AddTrivia(this.ScanEndOfLine()' ref triviaList);                          if (isTrailing)                          {                              return;                          }                            onlyWhitespaceOnLine = true;                          break;                      case '#':                          if (_allowPreprocessorDirectives)                          {                              this.LexDirectiveAndExcludedTrivia(afterFirstToken' isTrailing || !onlyWhitespaceOnLine' ref triviaList);                              break;                          }                          else                          {                              return;                          }                      default:                          return;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexSyntaxTrivia,The following statement contains a magic number: while (true)              {                  this.Start();                  char ch = TextWindow.PeekChar();                  if (ch == ' ')                  {                      this.AddTrivia(this.ScanWhitespace()' ref triviaList);                      continue;                  }                  else if (ch > 127)                  {                      if (SyntaxFacts.IsWhitespace(ch))                      {                          ch = ' ';                      }                      else if (SyntaxFacts.IsNewLine(ch))                      {                          ch = '\n';                      }                  }                    switch (ch)                  {                      case ' ':                      case '\t':       // Horizontal tab                      case '\v':       // Vertical Tab                      case '\f':       // Form-feed                      case '\u001A':                          this.AddTrivia(this.ScanWhitespace()' ref triviaList);                          break;                      case '/':                          if ((ch = TextWindow.PeekChar(1)) == '/')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine)' ref triviaList);                                  break;                              }                                // normal single line comment                              this.ScanToEndOfLine();                              var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                          else if (ch == '*')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&                                  TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited)' ref triviaList);                                  break;                              }                                bool isTerminated;                              this.ScanMultiLineComment(out isTerminated);                              if (!isTerminated)                              {                                  // The comment didn't end.  Report an error at the start point.                                  this.AddError(ErrorCode.ERR_OpenEndedComment);                              }                                var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                            // not trivia                          return;                      case '\r':                      case '\n':                          this.AddTrivia(this.ScanEndOfLine()' ref triviaList);                          if (isTrailing)                          {                              return;                          }                            onlyWhitespaceOnLine = true;                          break;                      case '#':                          if (_allowPreprocessorDirectives)                          {                              this.LexDirectiveAndExcludedTrivia(afterFirstToken' isTrailing || !onlyWhitespaceOnLine' ref triviaList);                              break;                          }                          else                          {                              return;                          }                      default:                          return;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexSyntaxTrivia,The following statement contains a magic number: while (true)              {                  this.Start();                  char ch = TextWindow.PeekChar();                  if (ch == ' ')                  {                      this.AddTrivia(this.ScanWhitespace()' ref triviaList);                      continue;                  }                  else if (ch > 127)                  {                      if (SyntaxFacts.IsWhitespace(ch))                      {                          ch = ' ';                      }                      else if (SyntaxFacts.IsNewLine(ch))                      {                          ch = '\n';                      }                  }                    switch (ch)                  {                      case ' ':                      case '\t':       // Horizontal tab                      case '\v':       // Vertical Tab                      case '\f':       // Form-feed                      case '\u001A':                          this.AddTrivia(this.ScanWhitespace()' ref triviaList);                          break;                      case '/':                          if ((ch = TextWindow.PeekChar(1)) == '/')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine)' ref triviaList);                                  break;                              }                                // normal single line comment                              this.ScanToEndOfLine();                              var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                          else if (ch == '*')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&                                  TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited)' ref triviaList);                                  break;                              }                                bool isTerminated;                              this.ScanMultiLineComment(out isTerminated);                              if (!isTerminated)                              {                                  // The comment didn't end.  Report an error at the start point.                                  this.AddError(ErrorCode.ERR_OpenEndedComment);                              }                                var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                            // not trivia                          return;                      case '\r':                      case '\n':                          this.AddTrivia(this.ScanEndOfLine()' ref triviaList);                          if (isTrailing)                          {                              return;                          }                            onlyWhitespaceOnLine = true;                          break;                      case '#':                          if (_allowPreprocessorDirectives)                          {                              this.LexDirectiveAndExcludedTrivia(afterFirstToken' isTrailing || !onlyWhitespaceOnLine' ref triviaList);                              break;                          }                          else                          {                              return;                          }                      default:                          return;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexSyntaxTrivia,The following statement contains a magic number: while (true)              {                  this.Start();                  char ch = TextWindow.PeekChar();                  if (ch == ' ')                  {                      this.AddTrivia(this.ScanWhitespace()' ref triviaList);                      continue;                  }                  else if (ch > 127)                  {                      if (SyntaxFacts.IsWhitespace(ch))                      {                          ch = ' ';                      }                      else if (SyntaxFacts.IsNewLine(ch))                      {                          ch = '\n';                      }                  }                    switch (ch)                  {                      case ' ':                      case '\t':       // Horizontal tab                      case '\v':       // Vertical Tab                      case '\f':       // Form-feed                      case '\u001A':                          this.AddTrivia(this.ScanWhitespace()' ref triviaList);                          break;                      case '/':                          if ((ch = TextWindow.PeekChar(1)) == '/')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine)' ref triviaList);                                  break;                              }                                // normal single line comment                              this.ScanToEndOfLine();                              var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                          else if (ch == '*')                          {                              if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&                                  TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')                              {                                  // Doc comments should never be in trailing trivia.                                  // Stop processing so that it will be leading trivia on the next token.                                  if (isTrailing)                                  {                                      return;                                  }                                    this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited)' ref triviaList);                                  break;                              }                                bool isTerminated;                              this.ScanMultiLineComment(out isTerminated);                              if (!isTerminated)                              {                                  // The comment didn't end.  Report an error at the start point.                                  this.AddError(ErrorCode.ERR_OpenEndedComment);                              }                                var text = TextWindow.GetText(false);                              this.AddTrivia(SyntaxFactory.Comment(text)' ref triviaList);                              onlyWhitespaceOnLine = false;                              break;                          }                            // not trivia                          return;                      case '\r':                      case '\n':                          this.AddTrivia(this.ScanEndOfLine()' ref triviaList);                          if (isTrailing)                          {                              return;                          }                            onlyWhitespaceOnLine = true;                          break;                      case '#':                          if (_allowPreprocessorDirectives)                          {                              this.LexDirectiveAndExcludedTrivia(afterFirstToken' isTrailing || !onlyWhitespaceOnLine' ref triviaList);                              break;                          }                          else                          {                              return;                          }                      default:                          return;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanMultiLineComment,The following statement contains a magic number: if (TextWindow.PeekChar() == '/' && TextWindow.PeekChar(1) == '*')              {                  TextWindow.AdvanceChar(2);                    char ch;                  while (true)                  {                      if ((ch = TextWindow.PeekChar()) == SlidingTextWindow.InvalidCharacter && TextWindow.IsReallyAtEnd())                      {                          isTerminated = false;                          break;                      }                      else if (ch == '*' && TextWindow.PeekChar(1) == '/')                      {                          TextWindow.AdvanceChar(2);                          isTerminated = true;                          break;                      }                      else                      {                          TextWindow.AdvanceChar();                      }                  }                    return true;              }              else              {                  isTerminated = false;                  return false;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanMultiLineComment,The following statement contains a magic number: if (TextWindow.PeekChar() == '/' && TextWindow.PeekChar(1) == '*')              {                  TextWindow.AdvanceChar(2);                    char ch;                  while (true)                  {                      if ((ch = TextWindow.PeekChar()) == SlidingTextWindow.InvalidCharacter && TextWindow.IsReallyAtEnd())                      {                          isTerminated = false;                          break;                      }                      else if (ch == '*' && TextWindow.PeekChar(1) == '/')                      {                          TextWindow.AdvanceChar(2);                          isTerminated = true;                          break;                      }                      else                      {                          TextWindow.AdvanceChar();                      }                  }                    return true;              }              else              {                  isTerminated = false;                  return false;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanWhitespace,The following statement contains a magic number: switch (ch)              {                  case '\t':       // Horizontal tab                  case '\v':       // Vertical Tab                  case '\f':       // Form-feed                  case '\u001A':                      onlySpaces = false;                      goto case ' ';                    case ' ':                      TextWindow.AdvanceChar();                      hashCode = Hash.CombineFNVHash(hashCode' ch);                      goto top;                    case '\r':      // Carriage Return                  case '\n':      // Line-feed                      break;                    default:                      if (ch > 127 && SyntaxFacts.IsWhitespace(ch))                      {                          goto case '\t';                      }                        break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanDirectiveToken,The following statement contains a magic number: switch (character = TextWindow.PeekChar())              {                  case SlidingTextWindow.InvalidCharacter:                      if (!TextWindow.IsReallyAtEnd())                      {                          goto default;                      }                      // don't consume end characters here                      info.Kind = SyntaxKind.EndOfDirectiveToken;                      break;                    case '\r':                  case '\n':                      // don't consume end characters here                      info.Kind = SyntaxKind.EndOfDirectiveToken;                      break;                    case '#':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.HashToken;                      break;                    case '(':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.OpenParenToken;                      break;                    case ')':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.CloseParenToken;                      break;                    case ''':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.CommaToken;                      break;                    case '!':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.ExclamationEqualsToken;                      }                      else                      {                          info.Kind = SyntaxKind.ExclamationToken;                      }                        break;                    case '=':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.EqualsEqualsToken;                      }                      else                      {                          info.Kind = SyntaxKind.EqualsToken;                      }                        break;                    case '&':                      if (TextWindow.PeekChar(1) == '&')                      {                          TextWindow.AdvanceChar(2);                          info.Kind = SyntaxKind.AmpersandAmpersandToken;                          break;                      }                        goto default;                    case '|':                      if (TextWindow.PeekChar(1) == '|')                      {                          TextWindow.AdvanceChar(2);                          info.Kind = SyntaxKind.BarBarToken;                          break;                      }                        goto default;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      this.ScanInteger();                      info.Kind = SyntaxKind.NumericLiteralToken;                      info.Text = TextWindow.GetText(true);                      info.ValueKind = SpecialType.System_Int32;                      info.IntValue = this.GetValueInt32(info.Text' false);                      break;                    case '\"':                      this.ScanStringLiteral(ref info' false);                      break;                    case '\\':                      {                          // Could be unicode escape. Try that.                          character = TextWindow.PeekCharOrUnicodeEscape(out surrogateCharacter);                          isEscaped = true;                          if (SyntaxFacts.IsIdentifierStartCharacter(character))                          {                              this.ScanIdentifierOrKeyword(ref info);                              break;                          }                            goto default;                      }                    default:                      if (!isEscaped && SyntaxFacts.IsNewLine(character))                      {                          goto case '\n';                      }                        if (SyntaxFacts.IsIdentifierStartCharacter(character))                      {                          this.ScanIdentifierOrKeyword(ref info);                      }                      else                      {                          // unknown single character                          if (isEscaped)                          {                              SyntaxDiagnosticInfo error;                              TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter' out error);                              AddError(error);                          }                          else                          {                              TextWindow.AdvanceChar();                          }                            info.Kind = SyntaxKind.None;                          info.Text = TextWindow.GetText(true);                      }                        break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanDirectiveToken,The following statement contains a magic number: switch (character = TextWindow.PeekChar())              {                  case SlidingTextWindow.InvalidCharacter:                      if (!TextWindow.IsReallyAtEnd())                      {                          goto default;                      }                      // don't consume end characters here                      info.Kind = SyntaxKind.EndOfDirectiveToken;                      break;                    case '\r':                  case '\n':                      // don't consume end characters here                      info.Kind = SyntaxKind.EndOfDirectiveToken;                      break;                    case '#':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.HashToken;                      break;                    case '(':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.OpenParenToken;                      break;                    case ')':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.CloseParenToken;                      break;                    case ''':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.CommaToken;                      break;                    case '!':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.ExclamationEqualsToken;                      }                      else                      {                          info.Kind = SyntaxKind.ExclamationToken;                      }                        break;                    case '=':                      TextWindow.AdvanceChar();                      if (TextWindow.PeekChar() == '=')                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.EqualsEqualsToken;                      }                      else                      {                          info.Kind = SyntaxKind.EqualsToken;                      }                        break;                    case '&':                      if (TextWindow.PeekChar(1) == '&')                      {                          TextWindow.AdvanceChar(2);                          info.Kind = SyntaxKind.AmpersandAmpersandToken;                          break;                      }                        goto default;                    case '|':                      if (TextWindow.PeekChar(1) == '|')                      {                          TextWindow.AdvanceChar(2);                          info.Kind = SyntaxKind.BarBarToken;                          break;                      }                        goto default;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      this.ScanInteger();                      info.Kind = SyntaxKind.NumericLiteralToken;                      info.Text = TextWindow.GetText(true);                      info.ValueKind = SpecialType.System_Int32;                      info.IntValue = this.GetValueInt32(info.Text' false);                      break;                    case '\"':                      this.ScanStringLiteral(ref info' false);                      break;                    case '\\':                      {                          // Could be unicode escape. Try that.                          character = TextWindow.PeekCharOrUnicodeEscape(out surrogateCharacter);                          isEscaped = true;                          if (SyntaxFacts.IsIdentifierStartCharacter(character))                          {                              this.ScanIdentifierOrKeyword(ref info);                              break;                          }                            goto default;                      }                    default:                      if (!isEscaped && SyntaxFacts.IsNewLine(character))                      {                          goto case '\n';                      }                        if (SyntaxFacts.IsIdentifierStartCharacter(character))                      {                          this.ScanIdentifierOrKeyword(ref info);                      }                      else                      {                          // unknown single character                          if (isEscaped)                          {                              SyntaxDiagnosticInfo error;                              TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter' out error);                              AddError(error);                          }                          else                          {                              TextWindow.AdvanceChar();                          }                            info.Kind = SyntaxKind.None;                          info.Text = TextWindow.GetText(true);                      }                        break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlTagStart,The following statement contains a magic number: if (TextWindow.PeekChar(1) == '!')              {                  if (TextWindow.PeekChar(2) == '-'                      && TextWindow.PeekChar(3) == '-')                  {                      TextWindow.AdvanceChar(4);                      info.Kind = SyntaxKind.XmlCommentStartToken;                  }                  else if (TextWindow.PeekChar(2) == '['                      && TextWindow.PeekChar(3) == 'C'                      && TextWindow.PeekChar(4) == 'D'                      && TextWindow.PeekChar(5) == 'A'                      && TextWindow.PeekChar(6) == 'T'                      && TextWindow.PeekChar(7) == 'A'                      && TextWindow.PeekChar(8) == '[')                  {                      TextWindow.AdvanceChar(9);                      info.Kind = SyntaxKind.XmlCDataStartToken;                  }                  else                  {                      // TODO: Take the < by itself' I guess?                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.LessThanToken;                  }              }              else if (TextWindow.PeekChar(1) == '/')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.LessThanSlashToken;              }              else if (TextWindow.PeekChar(1) == '?')              {                  TextWindow.AdvanceChar(2);                  info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;              }              else              {                  TextWindow.AdvanceChar();                  info.Kind = SyntaxKind.LessThanToken;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlEntity,The following statement contains a magic number: if (IsXmlNameStartChar(ch = TextWindow.PeekChar()))              {                  while (IsXmlNameChar(ch = TextWindow.PeekChar()))                  {                      // Important bit of information here: none of \0' \r' \n' and crucially for                      // delimited comments' * are considered Xml name characters. Also' since                      // entities appear in xml text and attribute text' it's relevant here that                      // none of <' /' >' '' "' =' are Xml name characters. Note that - and ] are                      // irrelevant--entities do not appear in comments or cdata.                        TextWindow.AdvanceChar();                      _builder.Append(ch);                  }                    switch (_builder.ToString())                  {                      case "lt":                          info.StringValue = "<";                          break;                      case "gt":                          info.StringValue = ">";                          break;                      case "amp":                          info.StringValue = "&";                          break;                      case "apos":                          info.StringValue = "'";                          break;                      case "quot":                          info.StringValue = "\"";                          break;                      default:                          error = XmlParseErrorCode.XML_RefUndefinedEntity_1;                          errorArgs = new[] { _builder.ToString() };                          break;                  }              }              else if (ch == '#')              {                  TextWindow.AdvanceChar();                  bool isHex = TextWindow.PeekChar() == 'x';                  uint charValue = 0;                    if (isHex)                  {                      TextWindow.AdvanceChar(); // x                      while (SyntaxFacts.IsHexDigit(ch = TextWindow.PeekChar()))                      {                          TextWindow.AdvanceChar();                            // disallow overflow                          if (charValue <= 0x7FFFFFF)                          {                              charValue = (charValue << 4) + (uint)SyntaxFacts.HexValue(ch);                          }                      }                  }                  else                  {                      while (SyntaxFacts.IsDecDigit(ch = TextWindow.PeekChar()))                      {                          TextWindow.AdvanceChar();                            // disallow overflow                          if (charValue <= 0x7FFFFFF)                          {                              charValue = (charValue << 3) + (charValue << 1) + (uint)SyntaxFacts.DecValue(ch);                          }                      }                  }                    if (TextWindow.PeekChar() != ';')                  {                      error = XmlParseErrorCode.XML_InvalidCharEntity;                  }                    if (MatchesProductionForXmlChar(charValue))                  {                      char lowSurrogate;                      char highSurrogate = SlidingTextWindow.GetCharsFromUtf32(charValue' out lowSurrogate);                        _builder.Append(highSurrogate);                      if (lowSurrogate != SlidingTextWindow.InvalidCharacter)                      {                          _builder.Append(lowSurrogate);                      }                        info.StringValue = _builder.ToString();                  }                  else                  {                      if (error == null)                      {                          error = XmlParseErrorCode.XML_InvalidUnicodeChar;                      }                  }              }              else              {                  if (SyntaxFacts.IsWhitespace(ch) || SyntaxFacts.IsNewLine(ch))                  {                      if (error == null)                      {                          error = XmlParseErrorCode.XML_InvalidWhitespace;                      }                  }                  else                  {                      if (error == null)                      {                          error = XmlParseErrorCode.XML_InvalidToken;                          errorArgs = new[] { ch.ToString() };                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlEntity,The following statement contains a magic number: if (IsXmlNameStartChar(ch = TextWindow.PeekChar()))              {                  while (IsXmlNameChar(ch = TextWindow.PeekChar()))                  {                      // Important bit of information here: none of \0' \r' \n' and crucially for                      // delimited comments' * are considered Xml name characters. Also' since                      // entities appear in xml text and attribute text' it's relevant here that                      // none of <' /' >' '' "' =' are Xml name characters. Note that - and ] are                      // irrelevant--entities do not appear in comments or cdata.                        TextWindow.AdvanceChar();                      _builder.Append(ch);                  }                    switch (_builder.ToString())                  {                      case "lt":                          info.StringValue = "<";                          break;                      case "gt":                          info.StringValue = ">";                          break;                      case "amp":                          info.StringValue = "&";                          break;                      case "apos":                          info.StringValue = "'";                          break;                      case "quot":                          info.StringValue = "\"";                          break;                      default:                          error = XmlParseErrorCode.XML_RefUndefinedEntity_1;                          errorArgs = new[] { _builder.ToString() };                          break;                  }              }              else if (ch == '#')              {                  TextWindow.AdvanceChar();                  bool isHex = TextWindow.PeekChar() == 'x';                  uint charValue = 0;                    if (isHex)                  {                      TextWindow.AdvanceChar(); // x                      while (SyntaxFacts.IsHexDigit(ch = TextWindow.PeekChar()))                      {                          TextWindow.AdvanceChar();                            // disallow overflow                          if (charValue <= 0x7FFFFFF)                          {                              charValue = (charValue << 4) + (uint)SyntaxFacts.HexValue(ch);                          }                      }                  }                  else                  {                      while (SyntaxFacts.IsDecDigit(ch = TextWindow.PeekChar()))                      {                          TextWindow.AdvanceChar();                            // disallow overflow                          if (charValue <= 0x7FFFFFF)                          {                              charValue = (charValue << 3) + (charValue << 1) + (uint)SyntaxFacts.DecValue(ch);                          }                      }                  }                    if (TextWindow.PeekChar() != ';')                  {                      error = XmlParseErrorCode.XML_InvalidCharEntity;                  }                    if (MatchesProductionForXmlChar(charValue))                  {                      char lowSurrogate;                      char highSurrogate = SlidingTextWindow.GetCharsFromUtf32(charValue' out lowSurrogate);                        _builder.Append(highSurrogate);                      if (lowSurrogate != SlidingTextWindow.InvalidCharacter)                      {                          _builder.Append(lowSurrogate);                      }                        info.StringValue = _builder.ToString();                  }                  else                  {                      if (error == null)                      {                          error = XmlParseErrorCode.XML_InvalidUnicodeChar;                      }                  }              }              else              {                  if (SyntaxFacts.IsWhitespace(ch) || SyntaxFacts.IsNewLine(ch))                  {                      if (error == null)                      {                          error = XmlParseErrorCode.XML_InvalidWhitespace;                      }                  }                  else                  {                      if (error == null)                      {                          error = XmlParseErrorCode.XML_InvalidToken;                          errorArgs = new[] { ch.ToString() };                      }                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlText,The following statement contains a magic number: if (TextWindow.PeekChar() == ']' && TextWindow.PeekChar(1) == ']' && TextWindow.PeekChar(2) == '>')              {                  TextWindow.AdvanceChar(3);                  info.StringValue = info.Text = TextWindow.GetText(false);                  this.AddError(XmlParseErrorCode.XML_CDataEndTagNotAllowed);                  return;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlText,The following statement contains a magic number: if (TextWindow.PeekChar() == ']' && TextWindow.PeekChar(1) == ']' && TextWindow.PeekChar(2) == '>')              {                  TextWindow.AdvanceChar(3);                  info.StringValue = info.Text = TextWindow.GetText(false);                  this.AddError(XmlParseErrorCode.XML_CDataEndTagNotAllowed);                  return;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlText,The following statement contains a magic number: while (true)              {                  var ch = TextWindow.PeekChar();                  switch (ch)                  {                      case SlidingTextWindow.InvalidCharacter:                          if (!TextWindow.IsReallyAtEnd())                          {                              goto default;                          }                            info.StringValue = info.Text = TextWindow.GetText(false);                          return;                      case '&':                      case '<':                      case '\r':                      case '\n':                          info.StringValue = info.Text = TextWindow.GetText(false);                          return;                        case '*':                          if (this.StyleIs(XmlDocCommentStyle.Delimited) && TextWindow.PeekChar(1) == '/')                          {                              // we're at the end of the comment' but don't lex it yet.                              info.StringValue = info.Text = TextWindow.GetText(false);                              return;                          }                            goto default;                        case ']':                          if (TextWindow.PeekChar(1) == ']' && TextWindow.PeekChar(2) == '>')                          {                              info.StringValue = info.Text = TextWindow.GetText(false);                              return;                          }                            goto default;                        default:                          if (SyntaxFacts.IsNewLine(ch))                          {                              goto case '\n';                          }                            TextWindow.AdvanceChar();                          break;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlElementTagToken,The following statement contains a magic number: switch (ch = TextWindow.PeekChar())              {                  case '<':                      this.ScanXmlTagStart(ref info);                      break;                    case '>':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.GreaterThanToken;                      break;                    case '/':                      if (TextWindow.PeekChar(1) == '>')                      {                          TextWindow.AdvanceChar(2);                          info.Kind = SyntaxKind.SlashGreaterThanToken;                          break;                      }                        goto default;                    case '"':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.DoubleQuoteToken;                      break;                    case '\'':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.SingleQuoteToken;                      break;                    case '=':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.EqualsToken;                      break;                    case ':':                      TextWindow.AdvanceChar();                      info.Kind = SyntaxKind.ColonToken;                      break;                    case '\r':                  case '\n':                      // Assert?                      break;                    case SlidingTextWindow.InvalidCharacter:                      if (!TextWindow.IsReallyAtEnd())                      {                          goto default;                      }                        info.Kind = SyntaxKind.EndOfDocumentationCommentToken;                      break;                    case '*':                      if (this.StyleIs(XmlDocCommentStyle.Delimited) && TextWindow.PeekChar(1) == '/')                      {                          // Assert? We should have gotten this in the leading trivia.                          Debug.Assert(false' "Should have picked up leading indentationTrivia' but didn't.");                          break;                      }                        goto default;                    default:                      if (IsXmlNameStartChar(ch))                      {                          this.ScanXmlName(ref info);                          info.StringValue = info.Text;                          info.Kind = SyntaxKind.IdentifierToken;                      }                      else if (SyntaxFacts.IsWhitespace(ch) || SyntaxFacts.IsNewLine(ch))                      {                          // whitespace! needed to do a better job with trivia                          Debug.Assert(false' "Should have picked up leading indentationTrivia' but didn't.");                      }                      else                      {                          TextWindow.AdvanceChar();                          info.Kind = SyntaxKind.None;                          info.StringValue = info.Text = TextWindow.GetText(false);                      }                        break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlCDataSectionTextToken,The following statement contains a magic number: switch (ch = TextWindow.PeekChar())              {                  case ']':                      if (TextWindow.PeekChar(1) == ']' && TextWindow.PeekChar(2) == '>')                      {                          TextWindow.AdvanceChar(3);                          info.Kind = SyntaxKind.XmlCDataEndToken;                          break;                      }                        goto default;                    case '\r':                  case '\n':                      this.ScanEndOfLine();                      info.StringValue = info.Text = TextWindow.GetText(false);                      info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;                      this.MutateLocation(XmlDocCommentLocation.Exterior);                      break;                    case SlidingTextWindow.InvalidCharacter:                      if (!TextWindow.IsReallyAtEnd())                      {                          goto default;                      }                        info.Kind = SyntaxKind.EndOfDocumentationCommentToken;                      break;                    default:                      if (SyntaxFacts.IsNewLine(ch))                      {                          goto case '\n';                      }                        this.ScanXmlCDataSectionText(ref info);                      info.Kind = SyntaxKind.XmlTextLiteralToken;                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlCDataSectionTextToken,The following statement contains a magic number: switch (ch = TextWindow.PeekChar())              {                  case ']':                      if (TextWindow.PeekChar(1) == ']' && TextWindow.PeekChar(2) == '>')                      {                          TextWindow.AdvanceChar(3);                          info.Kind = SyntaxKind.XmlCDataEndToken;                          break;                      }                        goto default;                    case '\r':                  case '\n':                      this.ScanEndOfLine();                      info.StringValue = info.Text = TextWindow.GetText(false);                      info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;                      this.MutateLocation(XmlDocCommentLocation.Exterior);                      break;                    case SlidingTextWindow.InvalidCharacter:                      if (!TextWindow.IsReallyAtEnd())                      {                          goto default;                      }                        info.Kind = SyntaxKind.EndOfDocumentationCommentToken;                      break;                    default:                      if (SyntaxFacts.IsNewLine(ch))                      {                          goto case '\n';                      }                        this.ScanXmlCDataSectionText(ref info);                      info.Kind = SyntaxKind.XmlTextLiteralToken;                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlCDataSectionText,The following statement contains a magic number: while (true)              {                  var ch = TextWindow.PeekChar();                  switch (ch)                  {                      case ']':                          if (TextWindow.PeekChar(1) == ']' && TextWindow.PeekChar(2) == '>')                          {                              info.StringValue = info.Text = TextWindow.GetText(false);                              return;                          }                            goto default;                        case '\r':                      case '\n':                          info.StringValue = info.Text = TextWindow.GetText(false);                          return;                        case SlidingTextWindow.InvalidCharacter:                          if (!TextWindow.IsReallyAtEnd())                          {                              goto default;                          }                            info.StringValue = info.Text = TextWindow.GetText(false);                          return;                        case '*':                          if (this.StyleIs(XmlDocCommentStyle.Delimited) && TextWindow.PeekChar(1) == '/')                          {                              // we're at the end of the comment' but don't lex it yet.                              info.StringValue = info.Text = TextWindow.GetText(false);                              return;                          }                            goto default;                        default:                          if (SyntaxFacts.IsNewLine(ch))                          {                              goto case '\n';                          }                            TextWindow.AdvanceChar();                          break;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlCommentTextToken,The following statement contains a magic number: switch (ch = TextWindow.PeekChar())              {                  case '-':                      if (TextWindow.PeekChar(1) == '-')                      {                          if (TextWindow.PeekChar(2) == '>')                          {                              TextWindow.AdvanceChar(3);                              info.Kind = SyntaxKind.XmlCommentEndToken;                              break;                          }                          else                          {                              TextWindow.AdvanceChar(2);                              info.Kind = SyntaxKind.MinusMinusToken;                              break;                          }                      }                        goto default;                    case '\r':                  case '\n':                      this.ScanEndOfLine();                      info.StringValue = info.Text = TextWindow.GetText(false);                      info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;                      this.MutateLocation(XmlDocCommentLocation.Exterior);                      break;                    case SlidingTextWindow.InvalidCharacter:                      if (!TextWindow.IsReallyAtEnd())                      {                          goto default;                      }                      info.Kind = SyntaxKind.EndOfDocumentationCommentToken;                      break;                    default:                      if (SyntaxFacts.IsNewLine(ch))                      {                          goto case '\n';                      }                        this.ScanXmlCommentText(ref info);                      info.Kind = SyntaxKind.XmlTextLiteralToken;                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlCommentTextToken,The following statement contains a magic number: switch (ch = TextWindow.PeekChar())              {                  case '-':                      if (TextWindow.PeekChar(1) == '-')                      {                          if (TextWindow.PeekChar(2) == '>')                          {                              TextWindow.AdvanceChar(3);                              info.Kind = SyntaxKind.XmlCommentEndToken;                              break;                          }                          else                          {                              TextWindow.AdvanceChar(2);                              info.Kind = SyntaxKind.MinusMinusToken;                              break;                          }                      }                        goto default;                    case '\r':                  case '\n':                      this.ScanEndOfLine();                      info.StringValue = info.Text = TextWindow.GetText(false);                      info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;                      this.MutateLocation(XmlDocCommentLocation.Exterior);                      break;                    case SlidingTextWindow.InvalidCharacter:                      if (!TextWindow.IsReallyAtEnd())                      {                          goto default;                      }                      info.Kind = SyntaxKind.EndOfDocumentationCommentToken;                      break;                    default:                      if (SyntaxFacts.IsNewLine(ch))                      {                          goto case '\n';                      }                        this.ScanXmlCommentText(ref info);                      info.Kind = SyntaxKind.XmlTextLiteralToken;                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlCommentTextToken,The following statement contains a magic number: switch (ch = TextWindow.PeekChar())              {                  case '-':                      if (TextWindow.PeekChar(1) == '-')                      {                          if (TextWindow.PeekChar(2) == '>')                          {                              TextWindow.AdvanceChar(3);                              info.Kind = SyntaxKind.XmlCommentEndToken;                              break;                          }                          else                          {                              TextWindow.AdvanceChar(2);                              info.Kind = SyntaxKind.MinusMinusToken;                              break;                          }                      }                        goto default;                    case '\r':                  case '\n':                      this.ScanEndOfLine();                      info.StringValue = info.Text = TextWindow.GetText(false);                      info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;                      this.MutateLocation(XmlDocCommentLocation.Exterior);                      break;                    case SlidingTextWindow.InvalidCharacter:                      if (!TextWindow.IsReallyAtEnd())                      {                          goto default;                      }                      info.Kind = SyntaxKind.EndOfDocumentationCommentToken;                      break;                    default:                      if (SyntaxFacts.IsNewLine(ch))                      {                          goto case '\n';                      }                        this.ScanXmlCommentText(ref info);                      info.Kind = SyntaxKind.XmlTextLiteralToken;                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlProcessingInstructionTextToken,The following statement contains a magic number: switch (ch = TextWindow.PeekChar())              {                  case '?':                      if (TextWindow.PeekChar(1) == '>')                      {                          TextWindow.AdvanceChar(2);                          info.Kind = SyntaxKind.XmlProcessingInstructionEndToken;                          break;                      }                        goto default;                    case '\r':                  case '\n':                      this.ScanEndOfLine();                      info.StringValue = info.Text = TextWindow.GetText(false);                      info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;                      this.MutateLocation(XmlDocCommentLocation.Exterior);                      break;                    case SlidingTextWindow.InvalidCharacter:                      if (!TextWindow.IsReallyAtEnd())                      {                          goto default;                      }                        info.Kind = SyntaxKind.EndOfDocumentationCommentToken;                      break;                    default:                      if (SyntaxFacts.IsNewLine(ch))                      {                          goto case '\n';                      }                        this.ScanXmlProcessingInstructionText(ref info);                      info.Kind = SyntaxKind.XmlTextLiteralToken;                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The following statement contains a magic number: if (this.LocationIs(XmlDocCommentLocation.Start) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  // Read the /** that begins an XML doc comment. Since these are recognized only                  // when the trailing character is not a '*'' we wind up in the interior of the                  // doc comment at the end.                    if (TextWindow.PeekChar() == '/'                      && TextWindow.PeekChar(1) == '*'                      && TextWindow.PeekChar(2) == '*'                      && TextWindow.PeekChar(3) != '*')                  {                      TextWindow.AdvanceChar(3);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.Interior);                      return;                  }              }              else if (this.LocationIs(XmlDocCommentLocation.Start) || this.LocationIs(XmlDocCommentLocation.Exterior))              {                  // We're in the exterior of an XML doc comment and need to eat the beginnings of                  // lines' for single line and delimited comments. We chew up white space until                  // a non-whitespace character' and then make the right decision depending on                  // what kind of comment we're in.                    while (true)                  {                      char ch = TextWindow.PeekChar();                      switch (ch)                      {                          case ' ':                          case '\t':                          case '\v':                          case '\f':                              TextWindow.AdvanceChar();                              break;                            case '/':                              if (this.StyleIs(XmlDocCommentStyle.SingleLine) && TextWindow.PeekChar(1) == '/' && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  TextWindow.AdvanceChar(3);                                  var text = TextWindow.GetText(true);                                  this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                                  return;                              }                                goto default;                            case '*':                              if (this.StyleIs(XmlDocCommentStyle.Delimited))                              {                                  while (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) != '/')                                  {                                      TextWindow.AdvanceChar();                                  }                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                  {                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  }                                    // This setup ensures that on the final line of a comment' if we have                                  // the string "  */"' the "*/" part is separated from the whitespace                                  // and therefore recognizable as the end of the comment.                                    if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                                  {                                      TextWindow.AdvanceChar(2);                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia("*/")' ref trivia);                                      this.MutateLocation(XmlDocCommentLocation.End);                                  }                                  else                                  {                                      this.MutateLocation(XmlDocCommentLocation.Interior);                                  }                                    return;                              }                                goto default;                            default:                              if (SyntaxFacts.IsWhitespace(ch))                              {                                  goto case ' ';                              }                                // so here we have something else. if this is a single-line xml                              // doc comment' that means we're on a line that's no longer a doc                              // comment' so we need to rewind. if we're in a delimited doc comment'                              // then that means we hit pay dirt and we're back into xml text.                                if (this.StyleIs(XmlDocCommentStyle.SingleLine))                              {                                  TextWindow.Reset(start);                                  this.MutateLocation(XmlDocCommentLocation.End);                              }                              else // XmlDocCommentStyle.Delimited                              {                                  Debug.Assert(this.StyleIs(XmlDocCommentStyle.Delimited));                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                              }                                return;                      }                  }              }              else if (!this.LocationIs(XmlDocCommentLocation.End) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                  {                      TextWindow.AdvanceChar(2);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.End);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The following statement contains a magic number: if (this.LocationIs(XmlDocCommentLocation.Start) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  // Read the /** that begins an XML doc comment. Since these are recognized only                  // when the trailing character is not a '*'' we wind up in the interior of the                  // doc comment at the end.                    if (TextWindow.PeekChar() == '/'                      && TextWindow.PeekChar(1) == '*'                      && TextWindow.PeekChar(2) == '*'                      && TextWindow.PeekChar(3) != '*')                  {                      TextWindow.AdvanceChar(3);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.Interior);                      return;                  }              }              else if (this.LocationIs(XmlDocCommentLocation.Start) || this.LocationIs(XmlDocCommentLocation.Exterior))              {                  // We're in the exterior of an XML doc comment and need to eat the beginnings of                  // lines' for single line and delimited comments. We chew up white space until                  // a non-whitespace character' and then make the right decision depending on                  // what kind of comment we're in.                    while (true)                  {                      char ch = TextWindow.PeekChar();                      switch (ch)                      {                          case ' ':                          case '\t':                          case '\v':                          case '\f':                              TextWindow.AdvanceChar();                              break;                            case '/':                              if (this.StyleIs(XmlDocCommentStyle.SingleLine) && TextWindow.PeekChar(1) == '/' && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  TextWindow.AdvanceChar(3);                                  var text = TextWindow.GetText(true);                                  this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                                  return;                              }                                goto default;                            case '*':                              if (this.StyleIs(XmlDocCommentStyle.Delimited))                              {                                  while (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) != '/')                                  {                                      TextWindow.AdvanceChar();                                  }                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                  {                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  }                                    // This setup ensures that on the final line of a comment' if we have                                  // the string "  */"' the "*/" part is separated from the whitespace                                  // and therefore recognizable as the end of the comment.                                    if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                                  {                                      TextWindow.AdvanceChar(2);                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia("*/")' ref trivia);                                      this.MutateLocation(XmlDocCommentLocation.End);                                  }                                  else                                  {                                      this.MutateLocation(XmlDocCommentLocation.Interior);                                  }                                    return;                              }                                goto default;                            default:                              if (SyntaxFacts.IsWhitespace(ch))                              {                                  goto case ' ';                              }                                // so here we have something else. if this is a single-line xml                              // doc comment' that means we're on a line that's no longer a doc                              // comment' so we need to rewind. if we're in a delimited doc comment'                              // then that means we hit pay dirt and we're back into xml text.                                if (this.StyleIs(XmlDocCommentStyle.SingleLine))                              {                                  TextWindow.Reset(start);                                  this.MutateLocation(XmlDocCommentLocation.End);                              }                              else // XmlDocCommentStyle.Delimited                              {                                  Debug.Assert(this.StyleIs(XmlDocCommentStyle.Delimited));                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                              }                                return;                      }                  }              }              else if (!this.LocationIs(XmlDocCommentLocation.End) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                  {                      TextWindow.AdvanceChar(2);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.End);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The following statement contains a magic number: if (this.LocationIs(XmlDocCommentLocation.Start) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  // Read the /** that begins an XML doc comment. Since these are recognized only                  // when the trailing character is not a '*'' we wind up in the interior of the                  // doc comment at the end.                    if (TextWindow.PeekChar() == '/'                      && TextWindow.PeekChar(1) == '*'                      && TextWindow.PeekChar(2) == '*'                      && TextWindow.PeekChar(3) != '*')                  {                      TextWindow.AdvanceChar(3);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.Interior);                      return;                  }              }              else if (this.LocationIs(XmlDocCommentLocation.Start) || this.LocationIs(XmlDocCommentLocation.Exterior))              {                  // We're in the exterior of an XML doc comment and need to eat the beginnings of                  // lines' for single line and delimited comments. We chew up white space until                  // a non-whitespace character' and then make the right decision depending on                  // what kind of comment we're in.                    while (true)                  {                      char ch = TextWindow.PeekChar();                      switch (ch)                      {                          case ' ':                          case '\t':                          case '\v':                          case '\f':                              TextWindow.AdvanceChar();                              break;                            case '/':                              if (this.StyleIs(XmlDocCommentStyle.SingleLine) && TextWindow.PeekChar(1) == '/' && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  TextWindow.AdvanceChar(3);                                  var text = TextWindow.GetText(true);                                  this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                                  return;                              }                                goto default;                            case '*':                              if (this.StyleIs(XmlDocCommentStyle.Delimited))                              {                                  while (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) != '/')                                  {                                      TextWindow.AdvanceChar();                                  }                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                  {                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  }                                    // This setup ensures that on the final line of a comment' if we have                                  // the string "  */"' the "*/" part is separated from the whitespace                                  // and therefore recognizable as the end of the comment.                                    if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                                  {                                      TextWindow.AdvanceChar(2);                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia("*/")' ref trivia);                                      this.MutateLocation(XmlDocCommentLocation.End);                                  }                                  else                                  {                                      this.MutateLocation(XmlDocCommentLocation.Interior);                                  }                                    return;                              }                                goto default;                            default:                              if (SyntaxFacts.IsWhitespace(ch))                              {                                  goto case ' ';                              }                                // so here we have something else. if this is a single-line xml                              // doc comment' that means we're on a line that's no longer a doc                              // comment' so we need to rewind. if we're in a delimited doc comment'                              // then that means we hit pay dirt and we're back into xml text.                                if (this.StyleIs(XmlDocCommentStyle.SingleLine))                              {                                  TextWindow.Reset(start);                                  this.MutateLocation(XmlDocCommentLocation.End);                              }                              else // XmlDocCommentStyle.Delimited                              {                                  Debug.Assert(this.StyleIs(XmlDocCommentStyle.Delimited));                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                              }                                return;                      }                  }              }              else if (!this.LocationIs(XmlDocCommentLocation.End) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                  {                      TextWindow.AdvanceChar(2);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.End);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The following statement contains a magic number: if (this.LocationIs(XmlDocCommentLocation.Start) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  // Read the /** that begins an XML doc comment. Since these are recognized only                  // when the trailing character is not a '*'' we wind up in the interior of the                  // doc comment at the end.                    if (TextWindow.PeekChar() == '/'                      && TextWindow.PeekChar(1) == '*'                      && TextWindow.PeekChar(2) == '*'                      && TextWindow.PeekChar(3) != '*')                  {                      TextWindow.AdvanceChar(3);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.Interior);                      return;                  }              }              else if (this.LocationIs(XmlDocCommentLocation.Start) || this.LocationIs(XmlDocCommentLocation.Exterior))              {                  // We're in the exterior of an XML doc comment and need to eat the beginnings of                  // lines' for single line and delimited comments. We chew up white space until                  // a non-whitespace character' and then make the right decision depending on                  // what kind of comment we're in.                    while (true)                  {                      char ch = TextWindow.PeekChar();                      switch (ch)                      {                          case ' ':                          case '\t':                          case '\v':                          case '\f':                              TextWindow.AdvanceChar();                              break;                            case '/':                              if (this.StyleIs(XmlDocCommentStyle.SingleLine) && TextWindow.PeekChar(1) == '/' && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  TextWindow.AdvanceChar(3);                                  var text = TextWindow.GetText(true);                                  this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                                  return;                              }                                goto default;                            case '*':                              if (this.StyleIs(XmlDocCommentStyle.Delimited))                              {                                  while (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) != '/')                                  {                                      TextWindow.AdvanceChar();                                  }                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                  {                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  }                                    // This setup ensures that on the final line of a comment' if we have                                  // the string "  */"' the "*/" part is separated from the whitespace                                  // and therefore recognizable as the end of the comment.                                    if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                                  {                                      TextWindow.AdvanceChar(2);                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia("*/")' ref trivia);                                      this.MutateLocation(XmlDocCommentLocation.End);                                  }                                  else                                  {                                      this.MutateLocation(XmlDocCommentLocation.Interior);                                  }                                    return;                              }                                goto default;                            default:                              if (SyntaxFacts.IsWhitespace(ch))                              {                                  goto case ' ';                              }                                // so here we have something else. if this is a single-line xml                              // doc comment' that means we're on a line that's no longer a doc                              // comment' so we need to rewind. if we're in a delimited doc comment'                              // then that means we hit pay dirt and we're back into xml text.                                if (this.StyleIs(XmlDocCommentStyle.SingleLine))                              {                                  TextWindow.Reset(start);                                  this.MutateLocation(XmlDocCommentLocation.End);                              }                              else // XmlDocCommentStyle.Delimited                              {                                  Debug.Assert(this.StyleIs(XmlDocCommentStyle.Delimited));                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                              }                                return;                      }                  }              }              else if (!this.LocationIs(XmlDocCommentLocation.End) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                  {                      TextWindow.AdvanceChar(2);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.End);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The following statement contains a magic number: if (this.LocationIs(XmlDocCommentLocation.Start) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  // Read the /** that begins an XML doc comment. Since these are recognized only                  // when the trailing character is not a '*'' we wind up in the interior of the                  // doc comment at the end.                    if (TextWindow.PeekChar() == '/'                      && TextWindow.PeekChar(1) == '*'                      && TextWindow.PeekChar(2) == '*'                      && TextWindow.PeekChar(3) != '*')                  {                      TextWindow.AdvanceChar(3);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.Interior);                      return;                  }              }              else if (this.LocationIs(XmlDocCommentLocation.Start) || this.LocationIs(XmlDocCommentLocation.Exterior))              {                  // We're in the exterior of an XML doc comment and need to eat the beginnings of                  // lines' for single line and delimited comments. We chew up white space until                  // a non-whitespace character' and then make the right decision depending on                  // what kind of comment we're in.                    while (true)                  {                      char ch = TextWindow.PeekChar();                      switch (ch)                      {                          case ' ':                          case '\t':                          case '\v':                          case '\f':                              TextWindow.AdvanceChar();                              break;                            case '/':                              if (this.StyleIs(XmlDocCommentStyle.SingleLine) && TextWindow.PeekChar(1) == '/' && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  TextWindow.AdvanceChar(3);                                  var text = TextWindow.GetText(true);                                  this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                                  return;                              }                                goto default;                            case '*':                              if (this.StyleIs(XmlDocCommentStyle.Delimited))                              {                                  while (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) != '/')                                  {                                      TextWindow.AdvanceChar();                                  }                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                  {                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  }                                    // This setup ensures that on the final line of a comment' if we have                                  // the string "  */"' the "*/" part is separated from the whitespace                                  // and therefore recognizable as the end of the comment.                                    if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                                  {                                      TextWindow.AdvanceChar(2);                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia("*/")' ref trivia);                                      this.MutateLocation(XmlDocCommentLocation.End);                                  }                                  else                                  {                                      this.MutateLocation(XmlDocCommentLocation.Interior);                                  }                                    return;                              }                                goto default;                            default:                              if (SyntaxFacts.IsWhitespace(ch))                              {                                  goto case ' ';                              }                                // so here we have something else. if this is a single-line xml                              // doc comment' that means we're on a line that's no longer a doc                              // comment' so we need to rewind. if we're in a delimited doc comment'                              // then that means we hit pay dirt and we're back into xml text.                                if (this.StyleIs(XmlDocCommentStyle.SingleLine))                              {                                  TextWindow.Reset(start);                                  this.MutateLocation(XmlDocCommentLocation.End);                              }                              else // XmlDocCommentStyle.Delimited                              {                                  Debug.Assert(this.StyleIs(XmlDocCommentStyle.Delimited));                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                              }                                return;                      }                  }              }              else if (!this.LocationIs(XmlDocCommentLocation.End) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                  {                      TextWindow.AdvanceChar(2);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.End);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The following statement contains a magic number: if (this.LocationIs(XmlDocCommentLocation.Start) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  // Read the /** that begins an XML doc comment. Since these are recognized only                  // when the trailing character is not a '*'' we wind up in the interior of the                  // doc comment at the end.                    if (TextWindow.PeekChar() == '/'                      && TextWindow.PeekChar(1) == '*'                      && TextWindow.PeekChar(2) == '*'                      && TextWindow.PeekChar(3) != '*')                  {                      TextWindow.AdvanceChar(3);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.Interior);                      return;                  }              }              else if (this.LocationIs(XmlDocCommentLocation.Start) || this.LocationIs(XmlDocCommentLocation.Exterior))              {                  // We're in the exterior of an XML doc comment and need to eat the beginnings of                  // lines' for single line and delimited comments. We chew up white space until                  // a non-whitespace character' and then make the right decision depending on                  // what kind of comment we're in.                    while (true)                  {                      char ch = TextWindow.PeekChar();                      switch (ch)                      {                          case ' ':                          case '\t':                          case '\v':                          case '\f':                              TextWindow.AdvanceChar();                              break;                            case '/':                              if (this.StyleIs(XmlDocCommentStyle.SingleLine) && TextWindow.PeekChar(1) == '/' && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  TextWindow.AdvanceChar(3);                                  var text = TextWindow.GetText(true);                                  this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                                  return;                              }                                goto default;                            case '*':                              if (this.StyleIs(XmlDocCommentStyle.Delimited))                              {                                  while (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) != '/')                                  {                                      TextWindow.AdvanceChar();                                  }                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                  {                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  }                                    // This setup ensures that on the final line of a comment' if we have                                  // the string "  */"' the "*/" part is separated from the whitespace                                  // and therefore recognizable as the end of the comment.                                    if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                                  {                                      TextWindow.AdvanceChar(2);                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia("*/")' ref trivia);                                      this.MutateLocation(XmlDocCommentLocation.End);                                  }                                  else                                  {                                      this.MutateLocation(XmlDocCommentLocation.Interior);                                  }                                    return;                              }                                goto default;                            default:                              if (SyntaxFacts.IsWhitespace(ch))                              {                                  goto case ' ';                              }                                // so here we have something else. if this is a single-line xml                              // doc comment' that means we're on a line that's no longer a doc                              // comment' so we need to rewind. if we're in a delimited doc comment'                              // then that means we hit pay dirt and we're back into xml text.                                if (this.StyleIs(XmlDocCommentStyle.SingleLine))                              {                                  TextWindow.Reset(start);                                  this.MutateLocation(XmlDocCommentLocation.End);                              }                              else // XmlDocCommentStyle.Delimited                              {                                  Debug.Assert(this.StyleIs(XmlDocCommentStyle.Delimited));                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                              }                                return;                      }                  }              }              else if (!this.LocationIs(XmlDocCommentLocation.End) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                  {                      TextWindow.AdvanceChar(2);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.End);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The following statement contains a magic number: if (this.LocationIs(XmlDocCommentLocation.Start) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  // Read the /** that begins an XML doc comment. Since these are recognized only                  // when the trailing character is not a '*'' we wind up in the interior of the                  // doc comment at the end.                    if (TextWindow.PeekChar() == '/'                      && TextWindow.PeekChar(1) == '*'                      && TextWindow.PeekChar(2) == '*'                      && TextWindow.PeekChar(3) != '*')                  {                      TextWindow.AdvanceChar(3);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.Interior);                      return;                  }              }              else if (this.LocationIs(XmlDocCommentLocation.Start) || this.LocationIs(XmlDocCommentLocation.Exterior))              {                  // We're in the exterior of an XML doc comment and need to eat the beginnings of                  // lines' for single line and delimited comments. We chew up white space until                  // a non-whitespace character' and then make the right decision depending on                  // what kind of comment we're in.                    while (true)                  {                      char ch = TextWindow.PeekChar();                      switch (ch)                      {                          case ' ':                          case '\t':                          case '\v':                          case '\f':                              TextWindow.AdvanceChar();                              break;                            case '/':                              if (this.StyleIs(XmlDocCommentStyle.SingleLine) && TextWindow.PeekChar(1) == '/' && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  TextWindow.AdvanceChar(3);                                  var text = TextWindow.GetText(true);                                  this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                                  return;                              }                                goto default;                            case '*':                              if (this.StyleIs(XmlDocCommentStyle.Delimited))                              {                                  while (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) != '/')                                  {                                      TextWindow.AdvanceChar();                                  }                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                  {                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  }                                    // This setup ensures that on the final line of a comment' if we have                                  // the string "  */"' the "*/" part is separated from the whitespace                                  // and therefore recognizable as the end of the comment.                                    if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                                  {                                      TextWindow.AdvanceChar(2);                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia("*/")' ref trivia);                                      this.MutateLocation(XmlDocCommentLocation.End);                                  }                                  else                                  {                                      this.MutateLocation(XmlDocCommentLocation.Interior);                                  }                                    return;                              }                                goto default;                            default:                              if (SyntaxFacts.IsWhitespace(ch))                              {                                  goto case ' ';                              }                                // so here we have something else. if this is a single-line xml                              // doc comment' that means we're on a line that's no longer a doc                              // comment' so we need to rewind. if we're in a delimited doc comment'                              // then that means we hit pay dirt and we're back into xml text.                                if (this.StyleIs(XmlDocCommentStyle.SingleLine))                              {                                  TextWindow.Reset(start);                                  this.MutateLocation(XmlDocCommentLocation.End);                              }                              else // XmlDocCommentStyle.Delimited                              {                                  Debug.Assert(this.StyleIs(XmlDocCommentStyle.Delimited));                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                              }                                return;                      }                  }              }              else if (!this.LocationIs(XmlDocCommentLocation.End) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                  {                      TextWindow.AdvanceChar(2);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.End);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,LexXmlDocCommentLeadingTrivia,The following statement contains a magic number: if (this.LocationIs(XmlDocCommentLocation.Start) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  // Read the /** that begins an XML doc comment. Since these are recognized only                  // when the trailing character is not a '*'' we wind up in the interior of the                  // doc comment at the end.                    if (TextWindow.PeekChar() == '/'                      && TextWindow.PeekChar(1) == '*'                      && TextWindow.PeekChar(2) == '*'                      && TextWindow.PeekChar(3) != '*')                  {                      TextWindow.AdvanceChar(3);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.Interior);                      return;                  }              }              else if (this.LocationIs(XmlDocCommentLocation.Start) || this.LocationIs(XmlDocCommentLocation.Exterior))              {                  // We're in the exterior of an XML doc comment and need to eat the beginnings of                  // lines' for single line and delimited comments. We chew up white space until                  // a non-whitespace character' and then make the right decision depending on                  // what kind of comment we're in.                    while (true)                  {                      char ch = TextWindow.PeekChar();                      switch (ch)                      {                          case ' ':                          case '\t':                          case '\v':                          case '\f':                              TextWindow.AdvanceChar();                              break;                            case '/':                              if (this.StyleIs(XmlDocCommentStyle.SingleLine) && TextWindow.PeekChar(1) == '/' && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')                              {                                  TextWindow.AdvanceChar(3);                                  var text = TextWindow.GetText(true);                                  this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                                  return;                              }                                goto default;                            case '*':                              if (this.StyleIs(XmlDocCommentStyle.Delimited))                              {                                  while (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) != '/')                                  {                                      TextWindow.AdvanceChar();                                  }                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                  {                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  }                                    // This setup ensures that on the final line of a comment' if we have                                  // the string "  */"' the "*/" part is separated from the whitespace                                  // and therefore recognizable as the end of the comment.                                    if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                                  {                                      TextWindow.AdvanceChar(2);                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia("*/")' ref trivia);                                      this.MutateLocation(XmlDocCommentLocation.End);                                  }                                  else                                  {                                      this.MutateLocation(XmlDocCommentLocation.Interior);                                  }                                    return;                              }                                goto default;                            default:                              if (SyntaxFacts.IsWhitespace(ch))                              {                                  goto case ' ';                              }                                // so here we have something else. if this is a single-line xml                              // doc comment' that means we're on a line that's no longer a doc                              // comment' so we need to rewind. if we're in a delimited doc comment'                              // then that means we hit pay dirt and we're back into xml text.                                if (this.StyleIs(XmlDocCommentStyle.SingleLine))                              {                                  TextWindow.Reset(start);                                  this.MutateLocation(XmlDocCommentLocation.End);                              }                              else // XmlDocCommentStyle.Delimited                              {                                  Debug.Assert(this.StyleIs(XmlDocCommentStyle.Delimited));                                    var text = TextWindow.GetText(true);                                  if (!String.IsNullOrEmpty(text))                                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                                  this.MutateLocation(XmlDocCommentLocation.Interior);                              }                                return;                      }                  }              }              else if (!this.LocationIs(XmlDocCommentLocation.End) && this.StyleIs(XmlDocCommentStyle.Delimited))              {                  if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')                  {                      TextWindow.AdvanceChar(2);                      var text = TextWindow.GetText(true);                      this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text)' ref trivia);                      this.MutateLocation(XmlDocCommentLocation.End);                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanVerbatimStringLiteral,The following statement contains a magic number: if (TextWindow.PeekChar() == '@' && TextWindow.PeekChar(1) == '"')              {                  TextWindow.AdvanceChar(2);                  bool done = false;                  char ch;                  _builder.Length = 0;                  while (!done)                  {                      switch (ch = TextWindow.PeekChar())                      {                          case '"':                              TextWindow.AdvanceChar();                              if (TextWindow.PeekChar() == '"')                              {                                  // Doubled quote -- skip & put the single quote in the string                                  TextWindow.AdvanceChar();                                  _builder.Append(ch);                              }                              else                              {                                  done = true;                              }                                break;                            case SlidingTextWindow.InvalidCharacter:                              if (!TextWindow.IsReallyAtEnd())                              {                                  goto default;                              }                                // Reached the end of the source without finding the end-quote.  Give                              // an error back at the starting point.                              this.AddError(ErrorCode.ERR_UnterminatedStringLit);                              done = true;                              break;                            default:                              if (!allowNewlines && SyntaxFacts.IsNewLine(ch))                              {                                  this.AddError(ErrorCode.ERR_UnterminatedStringLit);                                  done = true;                                  break;                              }                                TextWindow.AdvanceChar();                              _builder.Append(ch);                              break;                      }                  }                    info.Kind = SyntaxKind.StringLiteralToken;                  info.Text = TextWindow.GetText(false);                  info.StringValue = _builder.ToString();              }              else              {                  info.Kind = SyntaxKind.None;                  info.Text = null;                  info.StringValue = null;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,InterpolatedStringScanner,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer_StringLiteral.cs,ScanInterpolatedStringLiteralContents,The following statement contains a magic number: while (true)                  {                      if (IsAtEnd())                      {                          // error: end of line before end of string                          return;                      }                        switch (lexer.TextWindow.PeekChar())                      {                          case '"':                              if (isVerbatim && lexer.TextWindow.PeekChar(1) == '"')                              {                                  lexer.TextWindow.AdvanceChar(); // "                                  lexer.TextWindow.AdvanceChar(); // "                                  continue;                              }                              // found the end of the string                              return;                          case '}':                              var pos = lexer.TextWindow.Position;                              lexer.TextWindow.AdvanceChar(); // }                              // ensure any } characters are doubled up                              if (lexer.TextWindow.PeekChar() == '}')                              {                                  lexer.TextWindow.AdvanceChar(); // }                              }                              else if (error == null)                              {                                  error = lexer.MakeError(pos' 1' ErrorCode.ERR_UnescapedCurly' "}");                              }                              continue;                          case '{':                              if (lexer.TextWindow.PeekChar(1) == '{')                              {                                  lexer.TextWindow.AdvanceChar();                                  lexer.TextWindow.AdvanceChar();                              }                              else                              {                                  int openBracePosition = lexer.TextWindow.Position;                                  lexer.TextWindow.AdvanceChar();                                  int colonPosition = 0;                                  ScanInterpolatedStringLiteralHoleBalancedText('}'' true' ref colonPosition);                                  int closeBracePosition = lexer.TextWindow.Position;                                  bool closeBraceMissing = false;                                  if (lexer.TextWindow.PeekChar() == '}')                                  {                                      lexer.TextWindow.AdvanceChar();                                  }                                  else                                  {                                      closeBraceMissing = true;                                      if (error == null)                                      {                                          error = lexer.MakeError(openBracePosition - 1' 2' ErrorCode.ERR_UnclosedExpressionHole);                                      }                                  }                                    interpolations?.Add(new Interpolation(openBracePosition' colonPosition' closeBracePosition' closeBraceMissing));                              }                              continue;                          case '\\':                              if (isVerbatim)                              {                                  goto default;                              }                                var escapeStart = lexer.TextWindow.Position;                              char c2;                              char ch = lexer.ScanEscapeSequence(out c2);                              if ((ch == '{' || ch == '}') && error == null)                              {                                  error = lexer.MakeError(escapeStart' lexer.TextWindow.Position - escapeStart' ErrorCode.ERR_EscapedCurly' ch);                              }                                continue;                          default:                              // found some other character in the string portion                              lexer.TextWindow.AdvanceChar();                              continue;                      }                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,InterpolatedStringScanner,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer_StringLiteral.cs,ScanInterpolatedStringLiteralHoleBalancedText,The following statement contains a magic number: while (true)                  {                      if (IsAtEnd())                      {                          // the caller will complain                          return;                      }                        char ch = lexer.TextWindow.PeekChar();                      switch (ch)                      {                          case '#':                              // preprocessor directives not allowed.                              if (error == null)                              {                                  error = lexer.MakeError(lexer.TextWindow.Position' 1' ErrorCode.ERR_SyntaxError' endingChar.ToString());                              }                                lexer.TextWindow.AdvanceChar();                              continue;                          case '$':                              if (lexer.TextWindow.PeekChar(1) == '"' || lexer.TextWindow.PeekChar(1) == '@' && lexer.TextWindow.PeekChar(2) == '"')                              {                                  bool isVerbatimSubstring = lexer.TextWindow.PeekChar(1) == '@';                                  var interpolations = default(ArrayBuilder<Interpolation>);                                  var info = default(TokenInfo);                                  bool wasVerbatim = this.isVerbatim;                                  bool wasAllowNewlines = this.allowNewlines;                                  try                                  {                                      this.isVerbatim = isVerbatimSubstring;                                      this.allowNewlines &= isVerbatim;                                      bool closeQuoteMissing;                                      ScanInterpolatedStringLiteralTop(interpolations' ref info' out closeQuoteMissing);                                  }                                  finally                                  {                                      this.isVerbatim = wasVerbatim;                                      this.allowNewlines = wasAllowNewlines;                                  }                                  continue;                              }                                goto default;                          case ':':                              // the first colon not nested within matching delimiters is the start of the format string                              if (isHole)                              {                                  Debug.Assert(colonPosition == 0);                                  colonPosition = lexer.TextWindow.Position;                                  ScanFormatSpecifier();                                  return;                              }                                goto default;                          case '}':                          case ')':                          case ']':                              if (ch == endingChar)                              {                                  return;                              }                                if (error == null)                              {                                  error = lexer.MakeError(lexer.TextWindow.Position' 1' ErrorCode.ERR_SyntaxError' endingChar.ToString());                              }                                goto default;                          case '"':                          case '\'':                              // handle string or character literal inside an expression hole.                              ScanInterpolatedStringLiteralNestedString(ch);                              continue;                          case '@':                              if (lexer.TextWindow.PeekChar(1) == '"')                              {                                  // check for verbatim string inside an expression hole.                                  ScanInterpolatedStringLiteralNestedVerbatimString();                                  continue;                              }                                goto default;                          case '/':                              switch (lexer.TextWindow.PeekChar(1))                              {                                  case '/':                                      if (isVerbatim && allowNewlines)                                      {                                          lexer.TextWindow.AdvanceChar(); // skip /                                          lexer.TextWindow.AdvanceChar(); // skip /                                          while (!IsAtEnd(false))                                          {                                              lexer.TextWindow.AdvanceChar(); // skip // comment character                                          }                                      }                                      else                                      {                                          // error: single-line comment not allowed in an interpolated string                                          if (error == null)                                          {                                              error = lexer.MakeError(lexer.TextWindow.Position' 2' ErrorCode.ERR_SingleLineCommentInExpressionHole);                                          }                                            lexer.TextWindow.AdvanceChar();                                          lexer.TextWindow.AdvanceChar();                                      }                                      continue;                                  case '*':                                      // check for and scan /* comment */                                      ScanInterpolatedStringLiteralNestedComment();                                      continue;                                  default:                                      lexer.TextWindow.AdvanceChar();                                      continue;                              }                          case '{':                              // TODO: after the colon this has no special meaning.                              ScanInterpolatedStringLiteralHoleBracketed('{'' '}');                              continue;                          case '(':                              // TODO: after the colon this has no special meaning.                              ScanInterpolatedStringLiteralHoleBracketed('('' ')');                              continue;                          case '[':                              // TODO: after the colon this has no special meaning.                              ScanInterpolatedStringLiteralHoleBracketed('['' ']');                              continue;                          default:                              // part of code in the expression hole                              lexer.TextWindow.AdvanceChar();                              continue;                      }                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,InterpolatedStringScanner,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer_StringLiteral.cs,ScanInterpolatedStringLiteralHoleBalancedText,The following statement contains a magic number: while (true)                  {                      if (IsAtEnd())                      {                          // the caller will complain                          return;                      }                        char ch = lexer.TextWindow.PeekChar();                      switch (ch)                      {                          case '#':                              // preprocessor directives not allowed.                              if (error == null)                              {                                  error = lexer.MakeError(lexer.TextWindow.Position' 1' ErrorCode.ERR_SyntaxError' endingChar.ToString());                              }                                lexer.TextWindow.AdvanceChar();                              continue;                          case '$':                              if (lexer.TextWindow.PeekChar(1) == '"' || lexer.TextWindow.PeekChar(1) == '@' && lexer.TextWindow.PeekChar(2) == '"')                              {                                  bool isVerbatimSubstring = lexer.TextWindow.PeekChar(1) == '@';                                  var interpolations = default(ArrayBuilder<Interpolation>);                                  var info = default(TokenInfo);                                  bool wasVerbatim = this.isVerbatim;                                  bool wasAllowNewlines = this.allowNewlines;                                  try                                  {                                      this.isVerbatim = isVerbatimSubstring;                                      this.allowNewlines &= isVerbatim;                                      bool closeQuoteMissing;                                      ScanInterpolatedStringLiteralTop(interpolations' ref info' out closeQuoteMissing);                                  }                                  finally                                  {                                      this.isVerbatim = wasVerbatim;                                      this.allowNewlines = wasAllowNewlines;                                  }                                  continue;                              }                                goto default;                          case ':':                              // the first colon not nested within matching delimiters is the start of the format string                              if (isHole)                              {                                  Debug.Assert(colonPosition == 0);                                  colonPosition = lexer.TextWindow.Position;                                  ScanFormatSpecifier();                                  return;                              }                                goto default;                          case '}':                          case ')':                          case ']':                              if (ch == endingChar)                              {                                  return;                              }                                if (error == null)                              {                                  error = lexer.MakeError(lexer.TextWindow.Position' 1' ErrorCode.ERR_SyntaxError' endingChar.ToString());                              }                                goto default;                          case '"':                          case '\'':                              // handle string or character literal inside an expression hole.                              ScanInterpolatedStringLiteralNestedString(ch);                              continue;                          case '@':                              if (lexer.TextWindow.PeekChar(1) == '"')                              {                                  // check for verbatim string inside an expression hole.                                  ScanInterpolatedStringLiteralNestedVerbatimString();                                  continue;                              }                                goto default;                          case '/':                              switch (lexer.TextWindow.PeekChar(1))                              {                                  case '/':                                      if (isVerbatim && allowNewlines)                                      {                                          lexer.TextWindow.AdvanceChar(); // skip /                                          lexer.TextWindow.AdvanceChar(); // skip /                                          while (!IsAtEnd(false))                                          {                                              lexer.TextWindow.AdvanceChar(); // skip // comment character                                          }                                      }                                      else                                      {                                          // error: single-line comment not allowed in an interpolated string                                          if (error == null)                                          {                                              error = lexer.MakeError(lexer.TextWindow.Position' 2' ErrorCode.ERR_SingleLineCommentInExpressionHole);                                          }                                            lexer.TextWindow.AdvanceChar();                                          lexer.TextWindow.AdvanceChar();                                      }                                      continue;                                  case '*':                                      // check for and scan /* comment */                                      ScanInterpolatedStringLiteralNestedComment();                                      continue;                                  default:                                      lexer.TextWindow.AdvanceChar();                                      continue;                              }                          case '{':                              // TODO: after the colon this has no special meaning.                              ScanInterpolatedStringLiteralHoleBracketed('{'' '}');                              continue;                          case '(':                              // TODO: after the colon this has no special meaning.                              ScanInterpolatedStringLiteralHoleBracketed('('' ')');                              continue;                          case '[':                              // TODO: after the colon this has no special meaning.                              ScanInterpolatedStringLiteralHoleBracketed('['' ']');                              continue;                          default:                              // part of code in the expression hole                              lexer.TextWindow.AdvanceChar();                              continue;                      }                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,MoreChars,The following statement contains a magic number: if (_offset >= _characterWindowCount)              {                  if (this.Position >= _textEnd)                  {                      return false;                  }                    // if lexeme scanning is sufficiently into the char buffer'                   // then refocus the window onto the lexeme                  if (_lexemeStart > (_characterWindowCount / 4))                  {                      Array.Copy(_characterWindow'                          _lexemeStart'                          _characterWindow'                          0'                          _characterWindowCount - _lexemeStart);                      _characterWindowCount -= _lexemeStart;                      _offset -= _lexemeStart;                      _basis += _lexemeStart;                      _lexemeStart = 0;                  }                    if (_characterWindowCount >= _characterWindow.Length)                  {                      // grow char array' since we need more contiguous space                      char[] oldWindow = _characterWindow;                      char[] newWindow = new char[_characterWindow.Length * 2];                      Array.Copy(oldWindow' 0' newWindow' 0' _characterWindowCount);                      s_windowPool.ForgetTrackedObject(oldWindow' newWindow);                      _characterWindow = newWindow;                  }                    int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount)'                      _characterWindow.Length - _characterWindowCount);                  _text.CopyTo(_basis + _characterWindowCount'                      _characterWindow'                      _characterWindowCount'                      amountToRead);                  _characterWindowCount += amountToRead;                  return amountToRead > 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,MoreChars,The following statement contains a magic number: if (_offset >= _characterWindowCount)              {                  if (this.Position >= _textEnd)                  {                      return false;                  }                    // if lexeme scanning is sufficiently into the char buffer'                   // then refocus the window onto the lexeme                  if (_lexemeStart > (_characterWindowCount / 4))                  {                      Array.Copy(_characterWindow'                          _lexemeStart'                          _characterWindow'                          0'                          _characterWindowCount - _lexemeStart);                      _characterWindowCount -= _lexemeStart;                      _offset -= _lexemeStart;                      _basis += _lexemeStart;                      _lexemeStart = 0;                  }                    if (_characterWindowCount >= _characterWindow.Length)                  {                      // grow char array' since we need more contiguous space                      char[] oldWindow = _characterWindow;                      char[] newWindow = new char[_characterWindow.Length * 2];                      Array.Copy(oldWindow' 0' newWindow' 0' _characterWindowCount);                      s_windowPool.ForgetTrackedObject(oldWindow' newWindow);                      _characterWindow = newWindow;                  }                    int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount)'                      _characterWindow.Length - _characterWindowCount);                  _text.CopyTo(_basis + _characterWindowCount'                      _characterWindow'                      _characterWindowCount'                      amountToRead);                  _characterWindowCount += amountToRead;                  return amountToRead > 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,ScanUnicodeEscape,The following statement contains a magic number: if (character == 'U')              {                  uint uintChar = 0;                    this.AdvanceChar();                  if (!SyntaxFacts.IsHexDigit(this.PeekChar()))                  {                      if (!peek)                      {                          info = CreateIllegalEscapeDiagnostic(start);                      }                  }                  else                  {                      for (int i = 0; i < 8; i++)                      {                          character = this.PeekChar();                          if (!SyntaxFacts.IsHexDigit(character))                          {                              if (!peek)                              {                                  info = CreateIllegalEscapeDiagnostic(start);                              }                                break;                          }                            uintChar = (uint)((uintChar << 4) + SyntaxFacts.HexValue(character));                          this.AdvanceChar();                      }                        if (uintChar > 0x0010FFFF)                      {                          if (!peek)                          {                              info = CreateIllegalEscapeDiagnostic(start);                          }                      }                      else                      {                          character = GetCharsFromUtf32(uintChar' out surrogateCharacter);                      }                  }              }              else              {                  Debug.Assert(character == 'u' || character == 'x');                    int intChar = 0;                  this.AdvanceChar();                  if (!SyntaxFacts.IsHexDigit(this.PeekChar()))                  {                      if (!peek)                      {                          info = CreateIllegalEscapeDiagnostic(start);                      }                  }                  else                  {                      for (int i = 0; i < 4; i++)                      {                          char ch2 = this.PeekChar();                          if (!SyntaxFacts.IsHexDigit(ch2))                          {                              if (character == 'u')                              {                                  if (!peek)                                  {                                      info = CreateIllegalEscapeDiagnostic(start);                                  }                              }                                break;                          }                            intChar = (intChar << 4) + SyntaxFacts.HexValue(ch2);                          this.AdvanceChar();                      }                        character = (char)intChar;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,ScanUnicodeEscape,The following statement contains a magic number: if (character == 'U')              {                  uint uintChar = 0;                    this.AdvanceChar();                  if (!SyntaxFacts.IsHexDigit(this.PeekChar()))                  {                      if (!peek)                      {                          info = CreateIllegalEscapeDiagnostic(start);                      }                  }                  else                  {                      for (int i = 0; i < 8; i++)                      {                          character = this.PeekChar();                          if (!SyntaxFacts.IsHexDigit(character))                          {                              if (!peek)                              {                                  info = CreateIllegalEscapeDiagnostic(start);                              }                                break;                          }                            uintChar = (uint)((uintChar << 4) + SyntaxFacts.HexValue(character));                          this.AdvanceChar();                      }                        if (uintChar > 0x0010FFFF)                      {                          if (!peek)                          {                              info = CreateIllegalEscapeDiagnostic(start);                          }                      }                      else                      {                          character = GetCharsFromUtf32(uintChar' out surrogateCharacter);                      }                  }              }              else              {                  Debug.Assert(character == 'u' || character == 'x');                    int intChar = 0;                  this.AdvanceChar();                  if (!SyntaxFacts.IsHexDigit(this.PeekChar()))                  {                      if (!peek)                      {                          info = CreateIllegalEscapeDiagnostic(start);                      }                  }                  else                  {                      for (int i = 0; i < 4; i++)                      {                          char ch2 = this.PeekChar();                          if (!SyntaxFacts.IsHexDigit(ch2))                          {                              if (character == 'u')                              {                                  if (!peek)                                  {                                      info = CreateIllegalEscapeDiagnostic(start);                                  }                              }                                break;                          }                            intChar = (intChar << 4) + SyntaxFacts.HexValue(ch2);                          this.AdvanceChar();                      }                        character = (char)intChar;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,ScanUnicodeEscape,The following statement contains a magic number: if (character == 'U')              {                  uint uintChar = 0;                    this.AdvanceChar();                  if (!SyntaxFacts.IsHexDigit(this.PeekChar()))                  {                      if (!peek)                      {                          info = CreateIllegalEscapeDiagnostic(start);                      }                  }                  else                  {                      for (int i = 0; i < 8; i++)                      {                          character = this.PeekChar();                          if (!SyntaxFacts.IsHexDigit(character))                          {                              if (!peek)                              {                                  info = CreateIllegalEscapeDiagnostic(start);                              }                                break;                          }                            uintChar = (uint)((uintChar << 4) + SyntaxFacts.HexValue(character));                          this.AdvanceChar();                      }                        if (uintChar > 0x0010FFFF)                      {                          if (!peek)                          {                              info = CreateIllegalEscapeDiagnostic(start);                          }                      }                      else                      {                          character = GetCharsFromUtf32(uintChar' out surrogateCharacter);                      }                  }              }              else              {                  Debug.Assert(character == 'u' || character == 'x');                    int intChar = 0;                  this.AdvanceChar();                  if (!SyntaxFacts.IsHexDigit(this.PeekChar()))                  {                      if (!peek)                      {                          info = CreateIllegalEscapeDiagnostic(start);                      }                  }                  else                  {                      for (int i = 0; i < 4; i++)                      {                          char ch2 = this.PeekChar();                          if (!SyntaxFacts.IsHexDigit(ch2))                          {                              if (character == 'u')                              {                                  if (!peek)                                  {                                      info = CreateIllegalEscapeDiagnostic(start);                                  }                              }                                break;                          }                            intChar = (intChar << 4) + SyntaxFacts.HexValue(ch2);                          this.AdvanceChar();                      }                        character = (char)intChar;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,ScanUnicodeEscape,The following statement contains a magic number: if (character == 'U')              {                  uint uintChar = 0;                    this.AdvanceChar();                  if (!SyntaxFacts.IsHexDigit(this.PeekChar()))                  {                      if (!peek)                      {                          info = CreateIllegalEscapeDiagnostic(start);                      }                  }                  else                  {                      for (int i = 0; i < 8; i++)                      {                          character = this.PeekChar();                          if (!SyntaxFacts.IsHexDigit(character))                          {                              if (!peek)                              {                                  info = CreateIllegalEscapeDiagnostic(start);                              }                                break;                          }                            uintChar = (uint)((uintChar << 4) + SyntaxFacts.HexValue(character));                          this.AdvanceChar();                      }                        if (uintChar > 0x0010FFFF)                      {                          if (!peek)                          {                              info = CreateIllegalEscapeDiagnostic(start);                          }                      }                      else                      {                          character = GetCharsFromUtf32(uintChar' out surrogateCharacter);                      }                  }              }              else              {                  Debug.Assert(character == 'u' || character == 'x');                    int intChar = 0;                  this.AdvanceChar();                  if (!SyntaxFacts.IsHexDigit(this.PeekChar()))                  {                      if (!peek)                      {                          info = CreateIllegalEscapeDiagnostic(start);                      }                  }                  else                  {                      for (int i = 0; i < 4; i++)                      {                          char ch2 = this.PeekChar();                          if (!SyntaxFacts.IsHexDigit(ch2))                          {                              if (character == 'u')                              {                                  if (!peek)                                  {                                      info = CreateIllegalEscapeDiagnostic(start);                                  }                              }                                break;                          }                            intChar = (intChar << 4) + SyntaxFacts.HexValue(ch2);                          this.AdvanceChar();                      }                        character = (char)intChar;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,TryScanXmlEntity,The following statement contains a magic number: switch (this.PeekChar())              {                  case 'l':                      if (AdvanceIfMatches("lt;"))                      {                          ch = '<';                          return true;                      }                      break;                  case 'g':                      if (AdvanceIfMatches("gt;"))                      {                          ch = '>';                          return true;                      }                      break;                  case 'a':                      if (AdvanceIfMatches("amp;"))                      {                          ch = '&';                          return true;                      }                      else if (AdvanceIfMatches("apos;"))                      {                          ch = '\'';                          return true;                      }                      break;                  case 'q':                      if (AdvanceIfMatches("quot;"))                      {                          ch = '"';                          return true;                      }                      break;                  case '#':                      {                          this.AdvanceChar(); //#                            uint uintChar = 0;                            if (AdvanceIfMatches("x"))                          {                              char digit;                              while (SyntaxFacts.IsHexDigit(digit = this.PeekChar()))                              {                                  this.AdvanceChar();                                    // disallow overflow                                  if (uintChar <= 0x7FFFFFF)                                  {                                      uintChar = (uintChar << 4) + (uint)SyntaxFacts.HexValue(digit);                                  }                                  else                                  {                                      return false;                                  }                              }                          }                          else                          {                              char digit;                              while (SyntaxFacts.IsDecDigit(digit = this.PeekChar()))                              {                                  this.AdvanceChar();                                    // disallow overflow                                  if (uintChar <= 0x7FFFFFF)                                  {                                      uintChar = (uintChar << 3) + (uintChar << 1) + (uint)SyntaxFacts.DecValue(digit);                                  }                                  else                                  {                                      return false;                                  }                              }                          }                            if (AdvanceIfMatches(";"))                          {                              ch = GetCharsFromUtf32(uintChar' out surrogate);                              return true;                          }                            break;                      }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,TryScanXmlEntity,The following statement contains a magic number: switch (this.PeekChar())              {                  case 'l':                      if (AdvanceIfMatches("lt;"))                      {                          ch = '<';                          return true;                      }                      break;                  case 'g':                      if (AdvanceIfMatches("gt;"))                      {                          ch = '>';                          return true;                      }                      break;                  case 'a':                      if (AdvanceIfMatches("amp;"))                      {                          ch = '&';                          return true;                      }                      else if (AdvanceIfMatches("apos;"))                      {                          ch = '\'';                          return true;                      }                      break;                  case 'q':                      if (AdvanceIfMatches("quot;"))                      {                          ch = '"';                          return true;                      }                      break;                  case '#':                      {                          this.AdvanceChar(); //#                            uint uintChar = 0;                            if (AdvanceIfMatches("x"))                          {                              char digit;                              while (SyntaxFacts.IsHexDigit(digit = this.PeekChar()))                              {                                  this.AdvanceChar();                                    // disallow overflow                                  if (uintChar <= 0x7FFFFFF)                                  {                                      uintChar = (uintChar << 4) + (uint)SyntaxFacts.HexValue(digit);                                  }                                  else                                  {                                      return false;                                  }                              }                          }                          else                          {                              char digit;                              while (SyntaxFacts.IsDecDigit(digit = this.PeekChar()))                              {                                  this.AdvanceChar();                                    // disallow overflow                                  if (uintChar <= 0x7FFFFFF)                                  {                                      uintChar = (uintChar << 3) + (uintChar << 1) + (uint)SyntaxFacts.DecValue(digit);                                  }                                  else                                  {                                      return false;                                  }                              }                          }                            if (AdvanceIfMatches(";"))                          {                              ch = GetCharsFromUtf32(uintChar' out surrogate);                              return true;                          }                            break;                      }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,GetText,The following statement contains a magic number: switch (length)              {                  case 0:                      return string.Empty;                    case 1:                      if (_characterWindow[offset] == ' ')                      {                          return " ";                      }                      break;                    case 2:                      char firstChar = _characterWindow[offset];                      if (firstChar == '\r' && _characterWindow[offset + 1] == '\n')                      {                          return "\r\n";                      }                      if (firstChar == '/' && _characterWindow[offset + 1] == '/')                      {                          return "//";                      }                      break;                    case 3:                      if (_characterWindow[offset] == '/' && _characterWindow[offset + 1] == '/' && _characterWindow[offset + 2] == ' ')                      {                          return "// ";                      }                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,GetText,The following statement contains a magic number: switch (length)              {                  case 0:                      return string.Empty;                    case 1:                      if (_characterWindow[offset] == ' ')                      {                          return " ";                      }                      break;                    case 2:                      char firstChar = _characterWindow[offset];                      if (firstChar == '\r' && _characterWindow[offset + 1] == '\n')                      {                          return "\r\n";                      }                      if (firstChar == '/' && _characterWindow[offset + 1] == '/')                      {                          return "//";                      }                      break;                    case 3:                      if (_characterWindow[offset] == '/' && _characterWindow[offset + 1] == '/' && _characterWindow[offset + 2] == ' ')                      {                          return "// ";                      }                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,GetText,The following statement contains a magic number: switch (length)              {                  case 0:                      return string.Empty;                    case 1:                      if (_characterWindow[offset] == ' ')                      {                          return " ";                      }                      break;                    case 2:                      char firstChar = _characterWindow[offset];                      if (firstChar == '\r' && _characterWindow[offset + 1] == '\n')                      {                          return "\r\n";                      }                      if (firstChar == '/' && _characterWindow[offset + 1] == '/')                      {                          return "//";                      }                      break;                    case 3:                      if (_characterWindow[offset] == '/' && _characterWindow[offset + 1] == '/' && _characterWindow[offset + 2] == ' ')                      {                          return "// ";                      }                      break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxListPool,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxListPool.cs,Allocate,The following statement contains a magic number: if (_freeIndex > 0)              {                  _freeIndex--;                  item = _freeList[_freeIndex].Value;                  _freeList[_freeIndex].Value = null;              }              else              {                  item = new SyntaxListBuilder(10);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxListPool,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxListPool.cs,Grow,The following statement contains a magic number: var tmp = new ArrayElement<SyntaxListBuilder>[_freeList.Length * 2];
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxParser.cs,SyntaxParser,The following statement contains a magic number: if (this.IsIncremental || allowModeReset)              {                  _firstBlender = new Blender(lexer' oldTree' changes);                  _blendedTokens = s_blendedNodesPool.Allocate();              }              else              {                  _firstBlender = default(Blender);                  _lexedTokens = new ArrayElement<SyntaxToken>[32];              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxParser.cs,PreLex,The following statement contains a magic number: var size = Math.Min(4096' Math.Max(32' this.lexer.TextWindow.Text.Length / 2));
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxParser.cs,PreLex,The following statement contains a magic number: var size = Math.Min(4096' Math.Max(32' this.lexer.TextWindow.Text.Length / 2));
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxParser.cs,PreLex,The following statement contains a magic number: var size = Math.Min(4096' Math.Max(32' this.lexer.TextWindow.Text.Length / 2));
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxParser.cs,AddTokenSlot,The following statement contains a magic number: if (_tokenOffset > (_blendedTokens.Length >> 1)                  && (_resetStart == -1 || _resetStart > _firstToken))              {                  int shiftOffset = (_resetStart == -1) ? _tokenOffset : _resetStart - _firstToken;                  int shiftCount = _tokenCount - shiftOffset;                  Debug.Assert(shiftOffset > 0);                  _firstBlender = _blendedTokens[shiftOffset - 1].Blender;                  if (shiftCount > 0)                  {                      Array.Copy(_blendedTokens' shiftOffset' _blendedTokens' 0' shiftCount);                  }                    _firstToken += shiftOffset;                  _tokenCount -= shiftOffset;                  _tokenOffset -= shiftOffset;              }              else              {                  var old = _blendedTokens;                  Array.Resize(ref _blendedTokens' _blendedTokens.Length * 2);                  s_blendedNodesPool.ForgetTrackedObject(old' replacement: _blendedTokens);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxParser.cs,AddLexedTokenSlot,The following statement contains a magic number: if (_tokenOffset > (_lexedTokens.Length >> 1)                  && (_resetStart == -1 || _resetStart > _firstToken))              {                  int shiftOffset = (_resetStart == -1) ? _tokenOffset : _resetStart - _firstToken;                  int shiftCount = _tokenCount - shiftOffset;                  Debug.Assert(shiftOffset > 0);                  if (shiftCount > 0)                  {                      Array.Copy(_lexedTokens' shiftOffset' _lexedTokens' 0' shiftCount);                  }                    _firstToken += shiftOffset;                  _tokenCount -= shiftOffset;                  _tokenOffset -= shiftOffset;              }              else              {                  var tmp = new ArrayElement<SyntaxToken>[_lexedTokens.Length * 2];                  Array.Copy(_lexedTokens' tmp' _lexedTokens.Length);                  _lexedTokens = tmp;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SyntaxParser.cs,AddSkippedSyntax,The following statement contains a magic number: var builder = new SyntaxListBuilder(4);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Enumerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\ChildSyntaxList.Enumerator.cs,Enumerator,The following statement contains a magic number: if (node != null && node.ContainsDiagnostics)                  {                      _stack = new NodeIteration[8];                      this.PushNodeOrToken(node);                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Enumerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\ChildSyntaxList.Enumerator.cs,Push,The following statement contains a magic number: if (_count >= _stack.Length)                  {                      var tmp = new NodeIteration[_stack.Length * 2];                      Array.Copy(_stack' tmp' _stack.Length);                      _stack = tmp;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SeparatedSyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SeparatedSyntaxListBuilder.cs,Create,The following statement contains a magic number: return new SeparatedSyntaxListBuilder<TNode>(8);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxList,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxList.cs,List,The following statement contains a magic number: if (children.Length < 10)              {                  return new WithManyChildren(children);              }              else              {                  return new WithLotsOfChildren(children);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,WithThreeChildren,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxList.WithThreeChildren.cs,WithThreeChildren,The following statement contains a magic number: this.SlotCount = 3;
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,WithThreeChildren,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxList.WithThreeChildren.cs,WithThreeChildren,The following statement contains a magic number: this.SlotCount = 3;
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,WithThreeChildren,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxList.WithThreeChildren.cs,GetSlot,The following statement contains a magic number: switch (index)                  {                      case 0:                          return _child0;                      case 1:                          return _child1;                      case 2:                          return _child2;                      default:                          return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,WithThreeChildren,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxList.WithThreeChildren.cs,CopyTo,The following statement contains a magic number: array[offset + 2].Value = _child2;
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,WithTwoChildren,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxList.WithTwoChildren.cs,WithTwoChildren,The following statement contains a magic number: this.SlotCount = 2;
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,WithTwoChildren,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxList.WithTwoChildren.cs,WithTwoChildren,The following statement contains a magic number: this.SlotCount = 2;
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxListBuilder.cs,EnsureAdditionalCapacity,The following statement contains a magic number: int newSize =                  requiredSize < 8 ? 8 :                  requiredSize >= (int.MaxValue / 2) ? int.MaxValue :                  Math.Max(requiredSize' currentSize * 2);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxListBuilder.cs,EnsureAdditionalCapacity,The following statement contains a magic number: int newSize =                  requiredSize < 8 ? 8 :                  requiredSize >= (int.MaxValue / 2) ? int.MaxValue :                  Math.Max(requiredSize' currentSize * 2);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxListBuilder.cs,EnsureAdditionalCapacity,The following statement contains a magic number: int newSize =                  requiredSize < 8 ? 8 :                  requiredSize >= (int.MaxValue / 2) ? int.MaxValue :                  Math.Max(requiredSize' currentSize * 2);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxListBuilder.cs,EnsureAdditionalCapacity,The following statement contains a magic number: int newSize =                  requiredSize < 8 ? 8 :                  requiredSize >= (int.MaxValue / 2) ? int.MaxValue :                  Math.Max(requiredSize' currentSize * 2);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxListBuilder.cs,ToListNode,The following statement contains a magic number: switch (this.Count)              {                  case 0:                      return null;                  case 1:                      return _nodes[0];                  case 2:                      return SyntaxList.List(_nodes[0]' _nodes[1]);                  case 3:                      return SyntaxList.List(_nodes[0]' _nodes[1]' _nodes[2]);                  default:                      var tmp = new ArrayElement<CSharpSyntaxNode>[this.Count];                      Array.Copy(_nodes' tmp' this.Count);                      return SyntaxList.List(tmp);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxListBuilder.cs,ToListNode,The following statement contains a magic number: switch (this.Count)              {                  case 0:                      return null;                  case 1:                      return _nodes[0];                  case 2:                      return SyntaxList.List(_nodes[0]' _nodes[1]);                  case 3:                      return SyntaxList.List(_nodes[0]' _nodes[1]' _nodes[2]);                  default:                      var tmp = new ArrayElement<CSharpSyntaxNode>[this.Count];                      Array.Copy(_nodes' tmp' this.Count);                      return SyntaxList.List(tmp);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxListBuilder.cs,ToListNode,The following statement contains a magic number: switch (this.Count)              {                  case 0:                      return null;                  case 1:                      return _nodes[0];                  case 2:                      return SyntaxList.List(_nodes[0]' _nodes[1]);                  case 3:                      return SyntaxList.List(_nodes[0]' _nodes[1]' _nodes[2]);                  default:                      var tmp = new ArrayElement<CSharpSyntaxNode>[this.Count];                      Array.Copy(_nodes' tmp' this.Count);                      return SyntaxList.List(tmp);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,CSharpSyntaxNode,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNode.cs,GetSlotOffset,The following statement contains a magic number: System.Diagnostics.Debug.Assert(index < 11);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,CSharpSyntaxNode,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNode.cs,EnumerateNodes,The following statement contains a magic number: var stack = new Stack<ChildSyntaxList.Enumerator>(24);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,CSharpSyntaxNode,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNode.cs,GetDirectives,The following statement contains a magic number: if ((this.flags & NodeFlags.ContainsDirectives) != 0)              {                  var list = new List<DirectiveTriviaSyntax>(32);                  GetDirectives(this' list);                  return list;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,CSharpSyntaxNode,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNode.cs,CreateList,The following statement contains a magic number: switch (list.Length)              {                  case 0:                      return null;                  case 1:                      if (alwaysCreateListNode)                      {                          goto default;                      }                      else                      {                          return list[0];                      }                  case 2:                      return SyntaxList.List(list[0]' list[1]);                  case 3:                      return SyntaxList.List(list[0]' list[1]' list[2]);                  default:                      return SyntaxList.List(list);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,CSharpSyntaxNode,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNode.cs,CreateList,The following statement contains a magic number: switch (list.Length)              {                  case 0:                      return null;                  case 1:                      if (alwaysCreateListNode)                      {                          goto default;                      }                      else                      {                          return list[0];                      }                  case 2:                      return SyntaxList.List(list[0]' list[1]);                  case 3:                      return SyntaxList.List(list[0]' list[1]' list[2]);                  default:                      return SyntaxList.List(list);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,CSharpSyntaxNode,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\InternalSyntax\SyntaxNode.cs,CreateList,The following statement contains a magic number: switch (list.Length)              {                  case 0:                      return null;                  case 1:                      if (alwaysCreateListNode)                      {                          goto default;                      }                      else                      {                          return list[0];                      }                  case 2:                      return SyntaxList.List(list[0]' list[1]);                  case 3:                      return SyntaxList.List(list[0]' list[1]' list[2]);                  default:                      return SyntaxList.List(list);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,ComputeMethodKind,The following statement contains a magic number: if (this.HasSpecialName)              {                  if (_name.StartsWith("."' StringComparison.Ordinal))                  {                      // 10.5.1 Instance constructor                      // An instance constructor shall be an instance (not static or virtual) method'                      // it shall be named .ctor' and marked instance' rtspecialname' and specialname (§15.4.2.6).                      // An instance constructor can have parameters' but shall not return a value.                      // An instance constructor cannot take generic type parameters.                        // 10.5.3 Type initializer                      // This method shall be static' take no parameters' return no value'                      // be marked with rtspecialname and specialname (§15.4.2.6)' and be named .cctor.                        if ((_flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&                          _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&                          this.ReturnsVoid && this.Arity == 0)                      {                          if (this.IsStatic)                          {                              if (Parameters.Length == 0)                              {                                  return MethodKind.StaticConstructor;                              }                          }                          else                          {                              return MethodKind.Constructor;                          }                      }                        return MethodKind.Ordinary;                  }                  else if (!this.HasRuntimeSpecialName && this.IsStatic && this.DeclaredAccessibility == Accessibility.Public)                  {                      switch (_name)                      {                          case WellKnownMemberNames.AdditionOperatorName:                          case WellKnownMemberNames.BitwiseAndOperatorName:                          case WellKnownMemberNames.BitwiseOrOperatorName:                          case WellKnownMemberNames.DivisionOperatorName:                          case WellKnownMemberNames.EqualityOperatorName:                          case WellKnownMemberNames.ExclusiveOrOperatorName:                          case WellKnownMemberNames.GreaterThanOperatorName:                          case WellKnownMemberNames.GreaterThanOrEqualOperatorName:                          case WellKnownMemberNames.InequalityOperatorName:                          case WellKnownMemberNames.LeftShiftOperatorName:                          case WellKnownMemberNames.LessThanOperatorName:                          case WellKnownMemberNames.LessThanOrEqualOperatorName:                          case WellKnownMemberNames.ModulusOperatorName:                          case WellKnownMemberNames.MultiplyOperatorName:                          case WellKnownMemberNames.RightShiftOperatorName:                          case WellKnownMemberNames.SubtractionOperatorName:                              return IsValidUserDefinedOperatorSignature(2) ? MethodKind.UserDefinedOperator : MethodKind.Ordinary;                          case WellKnownMemberNames.DecrementOperatorName:                          case WellKnownMemberNames.FalseOperatorName:                          case WellKnownMemberNames.IncrementOperatorName:                          case WellKnownMemberNames.LogicalNotOperatorName:                          case WellKnownMemberNames.OnesComplementOperatorName:                          case WellKnownMemberNames.TrueOperatorName:                          case WellKnownMemberNames.UnaryNegationOperatorName:                          case WellKnownMemberNames.UnaryPlusOperatorName:                              return IsValidUserDefinedOperatorSignature(1) ? MethodKind.UserDefinedOperator : MethodKind.Ordinary;                          case WellKnownMemberNames.ImplicitConversionName:                          case WellKnownMemberNames.ExplicitConversionName:                              return IsValidUserDefinedOperatorSignature(1) ? MethodKind.Conversion : MethodKind.Ordinary;                              // UNDONE: Non-C#-supported overloaded operator case WellKnownMemberNames.ConcatenateOperatorName:                              // UNDONE: Non-C#-supported overloaded operator case WellKnownMemberNames.ExponentOperatorName:                              // UNDONE: Non-C#-supported overloaded operator case WellKnownMemberNames.IntegerDivisionOperatorName:                              // UNDONE: Non-C#-supported overloaded operator case WellKnownMemberNames.LikeOperatorName:                      }                        return MethodKind.Ordinary;                  }              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateReadOnlyMemberNames,The following statement contains a magic number: switch (names.Count)              {                  case 0:                      return SpecializedCollections.EmptySet<string>();                    case 1:                      return SpecializedCollections.SingletonCollection(names.First());                    case 2:                  case 3:                  case 4:                  case 5:                  case 6:                      // PERF: Small collections can be implemented as ImmutableArray.                      // While lookup is O(n)' when n is small' the memory savings are more valuable.                      // Size 6 was chosen because that represented 50% of the names generated in the Picasso end to end.                      // This causes boxing' but that's still superior to a wrapped HashSet                      return ImmutableArray.CreateRange(names);                    default:                      return SpecializedCollections.ReadOnlySet(names);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateReadOnlyMemberNames,The following statement contains a magic number: switch (names.Count)              {                  case 0:                      return SpecializedCollections.EmptySet<string>();                    case 1:                      return SpecializedCollections.SingletonCollection(names.First());                    case 2:                  case 3:                  case 4:                  case 5:                  case 6:                      // PERF: Small collections can be implemented as ImmutableArray.                      // While lookup is O(n)' when n is small' the memory savings are more valuable.                      // Size 6 was chosen because that represented 50% of the names generated in the Picasso end to end.                      // This causes boxing' but that's still superior to a wrapped HashSet                      return ImmutableArray.CreateRange(names);                    default:                      return SpecializedCollections.ReadOnlySet(names);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateReadOnlyMemberNames,The following statement contains a magic number: switch (names.Count)              {                  case 0:                      return SpecializedCollections.EmptySet<string>();                    case 1:                      return SpecializedCollections.SingletonCollection(names.First());                    case 2:                  case 3:                  case 4:                  case 5:                  case 6:                      // PERF: Small collections can be implemented as ImmutableArray.                      // While lookup is O(n)' when n is small' the memory savings are more valuable.                      // Size 6 was chosen because that represented 50% of the names generated in the Picasso end to end.                      // This causes boxing' but that's still superior to a wrapped HashSet                      return ImmutableArray.CreateRange(names);                    default:                      return SpecializedCollections.ReadOnlySet(names);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateReadOnlyMemberNames,The following statement contains a magic number: switch (names.Count)              {                  case 0:                      return SpecializedCollections.EmptySet<string>();                    case 1:                      return SpecializedCollections.SingletonCollection(names.First());                    case 2:                  case 3:                  case 4:                  case 5:                  case 6:                      // PERF: Small collections can be implemented as ImmutableArray.                      // While lookup is O(n)' when n is small' the memory savings are more valuable.                      // Size 6 was chosen because that represented 50% of the names generated in the Picasso end to end.                      // This causes boxing' but that's still superior to a wrapped HashSet                      return ImmutableArray.CreateRange(names);                    default:                      return SpecializedCollections.ReadOnlySet(names);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PENamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PENamedTypeSymbol.cs,CreateReadOnlyMemberNames,The following statement contains a magic number: switch (names.Count)              {                  case 0:                      return SpecializedCollections.EmptySet<string>();                    case 1:                      return SpecializedCollections.SingletonCollection(names.First());                    case 2:                  case 3:                  case 4:                  case 5:                  case 6:                      // PERF: Small collections can be implemented as ImmutableArray.                      // While lookup is O(n)' when n is small' the memory savings are more valuable.                      // Size 6 was chosen because that represented 50% of the names generated in the Picasso end to end.                      // This causes boxing' but that's still superior to a wrapped HashSet                      return ImmutableArray.CreateRange(names);                    default:                      return SpecializedCollections.ReadOnlySet(names);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEPropertySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEPropertySymbol.cs,GetParameters,The following statement contains a magic number: if (propertyParams.Length < 2)              {                  return ImmutableArray<ParameterSymbol>.Empty;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting,RetargetingSymbolTranslator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Retargeting\RetargetingSymbolTranslator.cs,RetargetNoPiaLocalType,The following statement contains a magic number: if (type.ContainingSymbol.Kind != SymbolKind.NamedType &&                      type.Arity == 0)                  {                      // Get type's identity                        bool isInterface = type.IsInterface;                      bool hasGuid = false;                      string interfaceGuid = null;                      string scope = null;                        if (isInterface)                      {                          // Get type's Guid                          hasGuid = type.GetGuidString(out interfaceGuid);                      }                        MetadataTypeName name = MetadataTypeName.FromFullName(type.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat)' forcedArity: type.Arity);                      string identifier = null;                        if ((object)type.ContainingModule == (object)_retargetingModule.UnderlyingModule)                      {                          // This is a local type explicitly declared in source. Get information from TypeIdentifier attribute.                          foreach (var attrData in type.GetAttributes())                          {                              int signatureIndex = attrData.GetTargetAttributeSignatureIndex(type' AttributeDescription.TypeIdentifierAttribute);                                if (signatureIndex != -1)                              {                                  Debug.Assert(signatureIndex == 0 || signatureIndex == 1);                                    if (signatureIndex == 1 && attrData.CommonConstructorArguments.Length == 2)                                  {                                      scope = attrData.CommonConstructorArguments[0].Value as string;                                      identifier = attrData.CommonConstructorArguments[1].Value as string;                                  }                                    break;                              }                          }                      }                      else                      {                          Debug.Assert((object)type.ContainingAssembly != (object)RetargetingAssembly.UnderlyingAssembly);                            // Note' this logic should match the one in EmbeddedType.Cci.IReference.GetAttributes.                          // Here we are trying to predict what attributes we will emit on embedded type' which corresponds the                           // type we are retargeting. That function actually emits the attributes.                            if (!(hasGuid && isInterface))                          {                              type.ContainingAssembly.GetGuidString(out scope);                              identifier = name.FullName;                          }                      }                        result = MetadataDecoder.SubstituteNoPiaLocalType(                          ref name'                          isInterface'                          type.BaseTypeNoUseSiteDiagnostics'                          interfaceGuid'                          scope'                          identifier'                          RetargetingAssembly);                        Debug.Assert((object)result != null);                  }                  else                  {                      // TODO: report better error?                      result = new UnsupportedMetadataTypeSymbol();                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SeparatedSyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SeparatedSyntaxListBuilder.cs,Create,The following statement contains a magic number: return new SeparatedSyntaxListBuilder<TNode>(8);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,LineBreaksAfterCloseBrace,The following statement contains a magic number: if (nextToken.Kind() == SyntaxKind.CloseBraceToken)              {                  return 1;              }              else if (                  nextToken.Kind() == SyntaxKind.CatchKeyword ||                  nextToken.Kind() == SyntaxKind.FinallyKeyword ||                  nextToken.Kind() == SyntaxKind.ElseKeyword)              {                  return 1;              }              else if (                  nextToken.Kind() == SyntaxKind.WhileKeyword &&                  nextToken.Parent.Kind() == SyntaxKind.DoStatement)              {                  return 1;              }              else              {                  return 2;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,LineBreaksAfterSemicolon,The following statement contains a magic number: if (currentToken.Parent.Kind() == SyntaxKind.ForStatement)              {                  return 0;              }              else if (nextToken.Kind() == SyntaxKind.CloseBraceToken)              {                  return 1;              }              else if (currentToken.Parent.Kind() == SyntaxKind.UsingDirective)              {                  return nextToken.Parent.Kind() == SyntaxKind.UsingDirective ? 1 : 2;              }              else if (currentToken.Parent.Kind() == SyntaxKind.ExternAliasDirective)              {                  return nextToken.Parent.Kind() == SyntaxKind.ExternAliasDirective ? 1 : 2;              }              else              {                  return 1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,LineBreaksAfterSemicolon,The following statement contains a magic number: if (currentToken.Parent.Kind() == SyntaxKind.ForStatement)              {                  return 0;              }              else if (nextToken.Kind() == SyntaxKind.CloseBraceToken)              {                  return 1;              }              else if (currentToken.Parent.Kind() == SyntaxKind.UsingDirective)              {                  return nextToken.Parent.Kind() == SyntaxKind.UsingDirective ? 1 : 2;              }              else if (currentToken.Parent.Kind() == SyntaxKind.ExternAliasDirective)              {                  return nextToken.Parent.Kind() == SyntaxKind.ExternAliasDirective ? 1 : 2;              }              else              {                  return 1;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,WithThreeChildren,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxList.WithThreeChildren.cs,GetNodeSlot,The following statement contains a magic number: switch (index)                  {                      case 0:                          return this.GetRedElement(ref _child0' 0);                      case 1:                          return this.GetRedElementIfNotToken(ref _child1);                      case 2:                          return this.GetRedElement(ref _child2' 2);                      default:                          return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,WithThreeChildren,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxList.WithThreeChildren.cs,GetNodeSlot,The following statement contains a magic number: switch (index)                  {                      case 0:                          return this.GetRedElement(ref _child0' 0);                      case 1:                          return this.GetRedElementIfNotToken(ref _child1);                      case 2:                          return this.GetRedElement(ref _child2' 2);                      default:                          return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,WithThreeChildren,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxList.WithThreeChildren.cs,GetCachedSlot,The following statement contains a magic number: switch (index)                  {                      case 0:                          return _child0;                      case 1:                          return _child1;                      case 2:                          return _child2;                      default:                          return null;                  }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxListBuilder.cs,AddInternal,The following statement contains a magic number: if (_nodes == null || Count >= _nodes.Length)              {                  this.Grow(Count == 0 ? 8 : _nodes.Length * 2);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxListBuilder.cs,AddInternal,The following statement contains a magic number: if (_nodes == null || Count >= _nodes.Length)              {                  this.Grow(Count == 0 ? 8 : _nodes.Length * 2);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxListBuilder.cs,ToListNode,The following statement contains a magic number: switch (this.Count)              {                  case 0:                      return null;                  case 1:                      return (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].Value;                  case 2:                      return Syntax.InternalSyntax.SyntaxList.List((Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].Value);                  case 3:                      return Syntax.InternalSyntax.SyntaxList.List((Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[2].Value);                  default:                      var tmp = new ArrayElement<Syntax.InternalSyntax.CSharpSyntaxNode>[this.Count];                      for (int i = 0; i < this.Count; i++)                      {                          tmp[i].Value = (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[i].Value;                      }                        return Syntax.InternalSyntax.SyntaxList.List(tmp);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxListBuilder.cs,ToListNode,The following statement contains a magic number: switch (this.Count)              {                  case 0:                      return null;                  case 1:                      return (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].Value;                  case 2:                      return Syntax.InternalSyntax.SyntaxList.List((Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].Value);                  case 3:                      return Syntax.InternalSyntax.SyntaxList.List((Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[2].Value);                  default:                      var tmp = new ArrayElement<Syntax.InternalSyntax.CSharpSyntaxNode>[this.Count];                      for (int i = 0; i < this.Count; i++)                      {                          tmp[i].Value = (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[i].Value;                      }                        return Syntax.InternalSyntax.SyntaxList.List(tmp);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxListBuilder.cs,ToListNode,The following statement contains a magic number: switch (this.Count)              {                  case 0:                      return null;                  case 1:                      return (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].Value;                  case 2:                      return Syntax.InternalSyntax.SyntaxList.List((Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].Value);                  case 3:                      return Syntax.InternalSyntax.SyntaxList.List((Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].Value' (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[2].Value);                  default:                      var tmp = new ArrayElement<Syntax.InternalSyntax.CSharpSyntaxNode>[this.Count];                      for (int i = 0; i < this.Count; i++)                      {                          tmp[i].Value = (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[i].Value;                      }                        return Syntax.InternalSyntax.SyntaxList.List(tmp);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxListBuilder.cs,Create,The following statement contains a magic number: return new SyntaxListBuilder<TNode>(8);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxNodeOrTokenListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxNodeOrTokenListBuilder.cs,Add,The following statement contains a magic number: if (_nodes == null || _count >= _nodes.Length)              {                  this.Grow(_count == 0 ? 8 : _nodes.Length * 2);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxNodeOrTokenListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxNodeOrTokenListBuilder.cs,Add,The following statement contains a magic number: if (_nodes == null || _count >= _nodes.Length)              {                  this.Grow(_count == 0 ? 8 : _nodes.Length * 2);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxNodeOrTokenListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxNodeOrTokenListBuilder.cs,ToList,The following statement contains a magic number: if (_count > 0)              {                  switch (_count)                  {                      case 1:                          if (_nodes[0].IsToken)                          {                              return new SyntaxNodeOrTokenList(                                  Syntax.InternalSyntax.SyntaxList.List(new[] { _nodes[0] }).CreateRed()'                                  index: 0);                          }                          else                          {                              return new SyntaxNodeOrTokenList(_nodes[0].CreateRed()' index: 0);                          }                      case 2:                          return new SyntaxNodeOrTokenList(                              Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1]).CreateRed()'                              index: 0);                      case 3:                          return new SyntaxNodeOrTokenList(                              Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1]' _nodes[2]).CreateRed()'                              index: 0);                      default:                          var tmp = new ArrayElement<Syntax.InternalSyntax.CSharpSyntaxNode>[_count];                          for (int i = 0; i < _count; i++)                          {                              tmp[i].Value = _nodes[i];                          }                            return new SyntaxNodeOrTokenList(Syntax.InternalSyntax.SyntaxList.List(tmp).CreateRed()' index: 0);                  }              }              else              {                  return default(SyntaxNodeOrTokenList);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxNodeOrTokenListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxNodeOrTokenListBuilder.cs,ToList,The following statement contains a magic number: if (_count > 0)              {                  switch (_count)                  {                      case 1:                          if (_nodes[0].IsToken)                          {                              return new SyntaxNodeOrTokenList(                                  Syntax.InternalSyntax.SyntaxList.List(new[] { _nodes[0] }).CreateRed()'                                  index: 0);                          }                          else                          {                              return new SyntaxNodeOrTokenList(_nodes[0].CreateRed()' index: 0);                          }                      case 2:                          return new SyntaxNodeOrTokenList(                              Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1]).CreateRed()'                              index: 0);                      case 3:                          return new SyntaxNodeOrTokenList(                              Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1]' _nodes[2]).CreateRed()'                              index: 0);                      default:                          var tmp = new ArrayElement<Syntax.InternalSyntax.CSharpSyntaxNode>[_count];                          for (int i = 0; i < _count; i++)                          {                              tmp[i].Value = _nodes[i];                          }                            return new SyntaxNodeOrTokenList(Syntax.InternalSyntax.SyntaxList.List(tmp).CreateRed()' index: 0);                  }              }              else              {                  return default(SyntaxNodeOrTokenList);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxNodeOrTokenListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxNodeOrTokenListBuilder.cs,ToList,The following statement contains a magic number: if (_count > 0)              {                  switch (_count)                  {                      case 1:                          if (_nodes[0].IsToken)                          {                              return new SyntaxNodeOrTokenList(                                  Syntax.InternalSyntax.SyntaxList.List(new[] { _nodes[0] }).CreateRed()'                                  index: 0);                          }                          else                          {                              return new SyntaxNodeOrTokenList(_nodes[0].CreateRed()' index: 0);                          }                      case 2:                          return new SyntaxNodeOrTokenList(                              Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1]).CreateRed()'                              index: 0);                      case 3:                          return new SyntaxNodeOrTokenList(                              Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1]' _nodes[2]).CreateRed()'                              index: 0);                      default:                          var tmp = new ArrayElement<Syntax.InternalSyntax.CSharpSyntaxNode>[_count];                          for (int i = 0; i < _count; i++)                          {                              tmp[i].Value = _nodes[i];                          }                            return new SyntaxNodeOrTokenList(Syntax.InternalSyntax.SyntaxList.List(tmp).CreateRed()' index: 0);                  }              }              else              {                  return default(SyntaxNodeOrTokenList);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxTokenListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxTokenListBuilder.cs,Create,The following statement contains a magic number: return new SyntaxTokenListBuilder(8);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxTokenListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxTokenListBuilder.cs,ToList,The following statement contains a magic number: if (_count > 0)              {                  switch (_count)                  {                      case 1:                          return new SyntaxTokenList(null' _nodes[0]' 0' 0);                      case 2:                          return new SyntaxTokenList(null' Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1])' 0' 0);                      case 3:                          return new SyntaxTokenList(null' Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1]' _nodes[2])' 0' 0);                      default:                          return new SyntaxTokenList(null' Syntax.InternalSyntax.SyntaxList.List(_nodes' _count)' 0' 0);                  }              }              else              {                  return default(SyntaxTokenList);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxTokenListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxTokenListBuilder.cs,ToList,The following statement contains a magic number: if (_count > 0)              {                  switch (_count)                  {                      case 1:                          return new SyntaxTokenList(null' _nodes[0]' 0' 0);                      case 2:                          return new SyntaxTokenList(null' Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1])' 0' 0);                      case 3:                          return new SyntaxTokenList(null' Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1]' _nodes[2])' 0' 0);                      default:                          return new SyntaxTokenList(null' Syntax.InternalSyntax.SyntaxList.List(_nodes' _count)' 0' 0);                  }              }              else              {                  return default(SyntaxTokenList);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxTokenListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxTokenListBuilder.cs,ToList,The following statement contains a magic number: if (_count > 0)              {                  switch (_count)                  {                      case 1:                          return new SyntaxTokenList(null' _nodes[0]' 0' 0);                      case 2:                          return new SyntaxTokenList(null' Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1])' 0' 0);                      case 3:                          return new SyntaxTokenList(null' Syntax.InternalSyntax.SyntaxList.List(_nodes[0]' _nodes[1]' _nodes[2])' 0' 0);                      default:                          return new SyntaxTokenList(null' Syntax.InternalSyntax.SyntaxList.List(_nodes' _count)' 0' 0);                  }              }              else              {                  return default(SyntaxTokenList);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxTriviaListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxTriviaListBuilder.cs,Create,The following statement contains a magic number: return new SyntaxTriviaListBuilder(4);
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxTriviaListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxTriviaListBuilder.cs,Add,The following statement contains a magic number: if (_nodes == null || _count >= _nodes.Length)              {                  this.Grow(_count == 0 ? 8 : _nodes.Length * 2);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxTriviaListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxTriviaListBuilder.cs,Add,The following statement contains a magic number: if (_nodes == null || _count >= _nodes.Length)              {                  this.Grow(_count == 0 ? 8 : _nodes.Length * 2);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxTriviaListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxTriviaListBuilder.cs,ToList,The following statement contains a magic number: if (_count > 0)              {                  if (_previous != null)                  {                      this.Grow(_count);                  }                    switch (_count)                  {                      case 1:                          return new SyntaxTriviaList(default(SyntaxToken)' _nodes[0].UnderlyingNode' position: 0' index: 0);                      case 2:                          return new SyntaxTriviaList(default(SyntaxToken)' Syntax.InternalSyntax.SyntaxList.List(                              (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].UnderlyingNode'                              (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].UnderlyingNode)' position: 0' index: 0);                      case 3:                          return new SyntaxTriviaList(default(SyntaxToken)'                              Syntax.InternalSyntax.SyntaxList.List(                                  (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].UnderlyingNode'                                  (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].UnderlyingNode'                                  (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[2].UnderlyingNode)'                              position: 0' index: 0);                      default:                          {                              var tmp = new ArrayElement<Syntax.InternalSyntax.CSharpSyntaxNode>[_count];                              for (int i = 0; i < _count; i++)                              {                                  tmp[i].Value = (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[i].UnderlyingNode;                              }                                return new SyntaxTriviaList(default(SyntaxToken)' Syntax.InternalSyntax.SyntaxList.List(tmp)' position: 0' index: 0);                          }                  }              }              else              {                  return default(SyntaxTriviaList);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxTriviaListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxTriviaListBuilder.cs,ToList,The following statement contains a magic number: if (_count > 0)              {                  if (_previous != null)                  {                      this.Grow(_count);                  }                    switch (_count)                  {                      case 1:                          return new SyntaxTriviaList(default(SyntaxToken)' _nodes[0].UnderlyingNode' position: 0' index: 0);                      case 2:                          return new SyntaxTriviaList(default(SyntaxToken)' Syntax.InternalSyntax.SyntaxList.List(                              (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].UnderlyingNode'                              (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].UnderlyingNode)' position: 0' index: 0);                      case 3:                          return new SyntaxTriviaList(default(SyntaxToken)'                              Syntax.InternalSyntax.SyntaxList.List(                                  (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].UnderlyingNode'                                  (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].UnderlyingNode'                                  (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[2].UnderlyingNode)'                              position: 0' index: 0);                      default:                          {                              var tmp = new ArrayElement<Syntax.InternalSyntax.CSharpSyntaxNode>[_count];                              for (int i = 0; i < _count; i++)                              {                                  tmp[i].Value = (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[i].UnderlyingNode;                              }                                return new SyntaxTriviaList(default(SyntaxToken)' Syntax.InternalSyntax.SyntaxList.List(tmp)' position: 0' index: 0);                          }                  }              }              else              {                  return default(SyntaxTriviaList);              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxTriviaListBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxTriviaListBuilder.cs,ToList,The following statement contains a magic number: if (_count > 0)              {                  if (_previous != null)                  {                      this.Grow(_count);                  }                    switch (_count)                  {                      case 1:                          return new SyntaxTriviaList(default(SyntaxToken)' _nodes[0].UnderlyingNode' position: 0' index: 0);                      case 2:                          return new SyntaxTriviaList(default(SyntaxToken)' Syntax.InternalSyntax.SyntaxList.List(                              (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].UnderlyingNode'                              (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].UnderlyingNode)' position: 0' index: 0);                      case 3:                          return new SyntaxTriviaList(default(SyntaxToken)'                              Syntax.InternalSyntax.SyntaxList.List(                                  (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[0].UnderlyingNode'                                  (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[1].UnderlyingNode'                                  (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[2].UnderlyingNode)'                              position: 0' index: 0);                      default:                          {                              var tmp = new ArrayElement<Syntax.InternalSyntax.CSharpSyntaxNode>[_count];                              for (int i = 0; i < _count; i++)                              {                                  tmp[i].Value = (Syntax.InternalSyntax.CSharpSyntaxNode)_nodes[i].UnderlyingNode;                              }                                return new SyntaxTriviaList(default(SyntaxToken)' Syntax.InternalSyntax.SyntaxList.List(tmp)' position: 0' index: 0);                          }                  }              }              else              {                  return default(SyntaxTriviaList);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReportDiagnosticsIfObsolete,The following switch statement is missing a default case: switch (symbol.Kind)              {                  case SymbolKind.NamedType:                  case SymbolKind.Field:                  case SymbolKind.Method:                  case SymbolKind.Event:                  case SymbolKind.Property:                      ReportDiagnosticsIfObsolete(diagnostics' symbol' node' hasBaseReceiver' this.ContainingMemberOrLambda' this.ContainingType' this.Flags);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsAnonymousTypesAllowed,The following switch statement is missing a default case: switch (member.Kind)              {                  case SymbolKind.Method:                      return true;                    case SymbolKind.Field:                      return !((FieldSymbol)member).IsConst;                    case SymbolKind.NamedType:                      //  allow usage of anonymous types in script classes                      return ((NamedTypeSymbol)member).IsScriptClass;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsValidConstraintType,The following switch statement is missing a default case: switch (type.SpecialType)              {                  case SpecialType.System_Object:                  case SpecialType.System_ValueType:                  case SpecialType.System_Enum:                  case SpecialType.System_Delegate:                  case SpecialType.System_MulticastDelegate:                  case SpecialType.System_Array:                      // "Constraint cannot be special class '{0}'"                      Error(diagnostics' ErrorCode.ERR_SpecialTypeAsBound' syntax' type);                      return false;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldConstantConversion,The following switch statement is missing a default case: switch (conversion.Kind)              {                  case ConversionKind.Identity:                  case ConversionKind.NullLiteral:                      return sourceConstantValue;                    case ConversionKind.ImplicitConstant:                      return FoldConstantNumericConversion(syntax' sourceConstantValue' destination' diagnostics);                    case ConversionKind.ExplicitNumeric:                  case ConversionKind.ImplicitNumeric:                  case ConversionKind.ExplicitEnumeration:                  case ConversionKind.ImplicitEnumeration:                      // The C# specification categorizes conversion from literal zero to nullable enum as                       // an Implicit Enumeration Conversion. Such a thing should not be constant folded                      // because nullable enums are never constants.                        if (destination.IsNullableType())                      {                          return null;                      }                        return FoldConstantNumericConversion(syntax' sourceConstantValue' destination' diagnostics);                    case ConversionKind.ExplicitReference:                  case ConversionKind.ImplicitReference:                      return sourceConstantValue.IsNull ? sourceConstantValue : null;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (value.Discriminator)                  {                      case ConstantValueTypeDiscriminator.Byte:                          byte byteValue = value.ByteValue;                          switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)byteValue;                              case SpecialType.System_Char: return (char)byteValue;                              case SpecialType.System_UInt16: return (ushort)byteValue;                              case SpecialType.System_UInt32: return (uint)byteValue;                              case SpecialType.System_UInt64: return (ulong)byteValue;                              case SpecialType.System_SByte: return (sbyte)byteValue;                              case SpecialType.System_Int16: return (short)byteValue;                              case SpecialType.System_Int32: return (int)byteValue;                              case SpecialType.System_Int64: return (long)byteValue;                              case SpecialType.System_Single:                              case SpecialType.System_Double: return (double)byteValue;                              case SpecialType.System_Decimal: return (decimal)byteValue;                          }                          break;                      case ConstantValueTypeDiscriminator.Char:                          char charValue = value.CharValue;                          switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)charValue;                              case SpecialType.System_Char: return (char)charValue;                              case SpecialType.System_UInt16: return (ushort)charValue;                              case SpecialType.System_UInt32: return (uint)charValue;                              case SpecialType.System_UInt64: return (ulong)charValue;                              case SpecialType.System_SByte: return (sbyte)charValue;                              case SpecialType.System_Int16: return (short)charValue;                              case SpecialType.System_Int32: return (int)charValue;                              case SpecialType.System_Int64: return (long)charValue;                              case SpecialType.System_Single:                              case SpecialType.System_Double: return (double)charValue;                              case SpecialType.System_Decimal: return (decimal)charValue;                          }                          break;                      case ConstantValueTypeDiscriminator.UInt16:                          ushort uint16Value = value.UInt16Value;                          switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)uint16Value;                              case SpecialType.System_Char: return (char)uint16Value;                              case SpecialType.System_UInt16: return (ushort)uint16Value;                              case SpecialType.System_UInt32: return (uint)uint16Value;                              case SpecialType.System_UInt64: return (ulong)uint16Value;                              case SpecialType.System_SByte: return (sbyte)uint16Value;                              case SpecialType.System_Int16: return (short)uint16Value;                              case SpecialType.System_Int32: return (int)uint16Value;                              case SpecialType.System_Int64: return (long)uint16Value;                              case SpecialType.System_Single:                              case SpecialType.System_Double: return (double)uint16Value;                              case SpecialType.System_Decimal: return (decimal)uint16Value;                          }                          break;                      case ConstantValueTypeDiscriminator.UInt32:                          uint uint32Value = value.UInt32Value;                          switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)uint32Value;                              case SpecialType.System_Char: return (char)uint32Value;                              case SpecialType.System_UInt16: return (ushort)uint32Value;                              case SpecialType.System_UInt32: return (uint)uint32Value;                              case SpecialType.System_UInt64: return (ulong)uint32Value;                              case SpecialType.System_SByte: return (sbyte)uint32Value;                              case SpecialType.System_Int16: return (short)uint32Value;                              case SpecialType.System_Int32: return (int)uint32Value;                              case SpecialType.System_Int64: return (long)uint32Value;                              case SpecialType.System_Single: return (double)(float)uint32Value;                              case SpecialType.System_Double: return (double)uint32Value;                              case SpecialType.System_Decimal: return (decimal)uint32Value;                          }                          break;                      case ConstantValueTypeDiscriminator.UInt64:                          ulong uint64Value = value.UInt64Value;                          switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)uint64Value;                              case SpecialType.System_Char: return (char)uint64Value;                              case SpecialType.System_UInt16: return (ushort)uint64Value;                              case SpecialType.System_UInt32: return (uint)uint64Value;                              case SpecialType.System_UInt64: return (ulong)uint64Value;                              case SpecialType.System_SByte: return (sbyte)uint64Value;                              case SpecialType.System_Int16: return (short)uint64Value;                              case SpecialType.System_Int32: return (int)uint64Value;                              case SpecialType.System_Int64: return (long)uint64Value;                              case SpecialType.System_Single: return (double)(float)uint64Value;                              case SpecialType.System_Double: return (double)uint64Value;                              case SpecialType.System_Decimal: return (decimal)uint64Value;                          }                          break;                      case ConstantValueTypeDiscriminator.SByte:                          sbyte sbyteValue = value.SByteValue;                          switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)sbyteValue;                              case SpecialType.System_Char: return (char)sbyteValue;                              case SpecialType.System_UInt16: return (ushort)sbyteValue;                              case SpecialType.System_UInt32: return (uint)sbyteValue;                              case SpecialType.System_UInt64: return (ulong)sbyteValue;                              case SpecialType.System_SByte: return (sbyte)sbyteValue;                              case SpecialType.System_Int16: return (short)sbyteValue;                              case SpecialType.System_Int32: return (int)sbyteValue;                              case SpecialType.System_Int64: return (long)sbyteValue;                              case SpecialType.System_Single:                              case SpecialType.System_Double: return (double)sbyteValue;                              case SpecialType.System_Decimal: return (decimal)sbyteValue;                          }                          break;                      case ConstantValueTypeDiscriminator.Int16:                          short int16Value = value.Int16Value;                          switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)int16Value;                              case SpecialType.System_Char: return (char)int16Value;                              case SpecialType.System_UInt16: return (ushort)int16Value;                              case SpecialType.System_UInt32: return (uint)int16Value;                              case SpecialType.System_UInt64: return (ulong)int16Value;                              case SpecialType.System_SByte: return (sbyte)int16Value;                              case SpecialType.System_Int16: return (short)int16Value;                              case SpecialType.System_Int32: return (int)int16Value;                              case SpecialType.System_Int64: return (long)int16Value;                              case SpecialType.System_Single:                              case SpecialType.System_Double: return (double)int16Value;                              case SpecialType.System_Decimal: return (decimal)int16Value;                          }                          break;                      case ConstantValueTypeDiscriminator.Int32:                          int int32Value = value.Int32Value;                          switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)int32Value;                              case SpecialType.System_Char: return (char)int32Value;                              case SpecialType.System_UInt16: return (ushort)int32Value;                              case SpecialType.System_UInt32: return (uint)int32Value;                              case SpecialType.System_UInt64: return (ulong)int32Value;                              case SpecialType.System_SByte: return (sbyte)int32Value;                              case SpecialType.System_Int16: return (short)int32Value;                              case SpecialType.System_Int32: return (int)int32Value;                              case SpecialType.System_Int64: return (long)int32Value;                              case SpecialType.System_Single: return (double)(float)int32Value;                              case SpecialType.System_Double: return (double)int32Value;                              case SpecialType.System_Decimal: return (decimal)int32Value;                          }                          break;                      case ConstantValueTypeDiscriminator.Int64:                          long int64Value = value.Int64Value;                          switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)int64Value;                              case SpecialType.System_Char: return (char)int64Value;                              case SpecialType.System_UInt16: return (ushort)int64Value;                              case SpecialType.System_UInt32: return (uint)int64Value;                              case SpecialType.System_UInt64: return (ulong)int64Value;                              case SpecialType.System_SByte: return (sbyte)int64Value;                              case SpecialType.System_Int16: return (short)int64Value;                              case SpecialType.System_Int32: return (int)int64Value;                              case SpecialType.System_Int64: return (long)int64Value;                              case SpecialType.System_Single: return (double)(float)int64Value;                              case SpecialType.System_Double: return (double)int64Value;                              case SpecialType.System_Decimal: return (decimal)int64Value;                          }                          break;                      case ConstantValueTypeDiscriminator.Single:                      case ConstantValueTypeDiscriminator.Double:                          // This code used to invoke CheckConstantBounds and return constant zero if the value is not within the target type.                          // The C# spec says that in this case the result of the conversion is an unspecified value of the destination type.                          // Zero is a perfectly valid unspecified value' so that behavior was formally correct.                          // But it did not agree with the behavior of the native C# compiler' that apparently returned a value that                          // would resulted from a runtime conversion with normal CLR overflow behavior.                          // To avoid breaking programs that might accidentally rely on that unspecified behavior                          // we now removed that check and just allow conversion to overflow.                          double doubleValue = value.DoubleValue;                          switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)doubleValue;                              case SpecialType.System_Char: return (char)doubleValue;                              case SpecialType.System_UInt16: return (ushort)doubleValue;                              case SpecialType.System_UInt32: return (uint)doubleValue;                              case SpecialType.System_UInt64: return (ulong)doubleValue;                              case SpecialType.System_SByte: return (sbyte)doubleValue;                              case SpecialType.System_Int16: return (short)doubleValue;                              case SpecialType.System_Int32: return (int)doubleValue;                              case SpecialType.System_Int64: return (long)doubleValue;                              case SpecialType.System_Single: return (double)(float)doubleValue;                              case SpecialType.System_Double: return (double)doubleValue;                              case SpecialType.System_Decimal: return (value.Discriminator == ConstantValueTypeDiscriminator.Single) ? (decimal)(float)doubleValue : (decimal)doubleValue;                          }                          break;                      case ConstantValueTypeDiscriminator.Decimal:                          decimal decimalValue = CheckConstantBounds(destinationType' value.DecimalValue) ? value.DecimalValue : 0m;                          switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)decimalValue;                              case SpecialType.System_Char: return (char)decimalValue;                              case SpecialType.System_UInt16: return (ushort)decimalValue;                              case SpecialType.System_UInt32: return (uint)decimalValue;                              case SpecialType.System_UInt64: return (ulong)decimalValue;                              case SpecialType.System_SByte: return (sbyte)decimalValue;                              case SpecialType.System_Int16: return (short)decimalValue;                              case SpecialType.System_Int32: return (int)decimalValue;                              case SpecialType.System_Int64: return (long)decimalValue;                              case SpecialType.System_Single: return (double)(float)decimalValue;                              case SpecialType.System_Double: return (double)decimalValue;                              case SpecialType.System_Decimal: return (decimal)decimalValue;                          }                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)byteValue;                              case SpecialType.System_Char: return (char)byteValue;                              case SpecialType.System_UInt16: return (ushort)byteValue;                              case SpecialType.System_UInt32: return (uint)byteValue;                              case SpecialType.System_UInt64: return (ulong)byteValue;                              case SpecialType.System_SByte: return (sbyte)byteValue;                              case SpecialType.System_Int16: return (short)byteValue;                              case SpecialType.System_Int32: return (int)byteValue;                              case SpecialType.System_Int64: return (long)byteValue;                              case SpecialType.System_Single:                              case SpecialType.System_Double: return (double)byteValue;                              case SpecialType.System_Decimal: return (decimal)byteValue;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)charValue;                              case SpecialType.System_Char: return (char)charValue;                              case SpecialType.System_UInt16: return (ushort)charValue;                              case SpecialType.System_UInt32: return (uint)charValue;                              case SpecialType.System_UInt64: return (ulong)charValue;                              case SpecialType.System_SByte: return (sbyte)charValue;                              case SpecialType.System_Int16: return (short)charValue;                              case SpecialType.System_Int32: return (int)charValue;                              case SpecialType.System_Int64: return (long)charValue;                              case SpecialType.System_Single:                              case SpecialType.System_Double: return (double)charValue;                              case SpecialType.System_Decimal: return (decimal)charValue;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)uint16Value;                              case SpecialType.System_Char: return (char)uint16Value;                              case SpecialType.System_UInt16: return (ushort)uint16Value;                              case SpecialType.System_UInt32: return (uint)uint16Value;                              case SpecialType.System_UInt64: return (ulong)uint16Value;                              case SpecialType.System_SByte: return (sbyte)uint16Value;                              case SpecialType.System_Int16: return (short)uint16Value;                              case SpecialType.System_Int32: return (int)uint16Value;                              case SpecialType.System_Int64: return (long)uint16Value;                              case SpecialType.System_Single:                              case SpecialType.System_Double: return (double)uint16Value;                              case SpecialType.System_Decimal: return (decimal)uint16Value;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)uint32Value;                              case SpecialType.System_Char: return (char)uint32Value;                              case SpecialType.System_UInt16: return (ushort)uint32Value;                              case SpecialType.System_UInt32: return (uint)uint32Value;                              case SpecialType.System_UInt64: return (ulong)uint32Value;                              case SpecialType.System_SByte: return (sbyte)uint32Value;                              case SpecialType.System_Int16: return (short)uint32Value;                              case SpecialType.System_Int32: return (int)uint32Value;                              case SpecialType.System_Int64: return (long)uint32Value;                              case SpecialType.System_Single: return (double)(float)uint32Value;                              case SpecialType.System_Double: return (double)uint32Value;                              case SpecialType.System_Decimal: return (decimal)uint32Value;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)uint64Value;                              case SpecialType.System_Char: return (char)uint64Value;                              case SpecialType.System_UInt16: return (ushort)uint64Value;                              case SpecialType.System_UInt32: return (uint)uint64Value;                              case SpecialType.System_UInt64: return (ulong)uint64Value;                              case SpecialType.System_SByte: return (sbyte)uint64Value;                              case SpecialType.System_Int16: return (short)uint64Value;                              case SpecialType.System_Int32: return (int)uint64Value;                              case SpecialType.System_Int64: return (long)uint64Value;                              case SpecialType.System_Single: return (double)(float)uint64Value;                              case SpecialType.System_Double: return (double)uint64Value;                              case SpecialType.System_Decimal: return (decimal)uint64Value;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)sbyteValue;                              case SpecialType.System_Char: return (char)sbyteValue;                              case SpecialType.System_UInt16: return (ushort)sbyteValue;                              case SpecialType.System_UInt32: return (uint)sbyteValue;                              case SpecialType.System_UInt64: return (ulong)sbyteValue;                              case SpecialType.System_SByte: return (sbyte)sbyteValue;                              case SpecialType.System_Int16: return (short)sbyteValue;                              case SpecialType.System_Int32: return (int)sbyteValue;                              case SpecialType.System_Int64: return (long)sbyteValue;                              case SpecialType.System_Single:                              case SpecialType.System_Double: return (double)sbyteValue;                              case SpecialType.System_Decimal: return (decimal)sbyteValue;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)int16Value;                              case SpecialType.System_Char: return (char)int16Value;                              case SpecialType.System_UInt16: return (ushort)int16Value;                              case SpecialType.System_UInt32: return (uint)int16Value;                              case SpecialType.System_UInt64: return (ulong)int16Value;                              case SpecialType.System_SByte: return (sbyte)int16Value;                              case SpecialType.System_Int16: return (short)int16Value;                              case SpecialType.System_Int32: return (int)int16Value;                              case SpecialType.System_Int64: return (long)int16Value;                              case SpecialType.System_Single:                              case SpecialType.System_Double: return (double)int16Value;                              case SpecialType.System_Decimal: return (decimal)int16Value;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)int32Value;                              case SpecialType.System_Char: return (char)int32Value;                              case SpecialType.System_UInt16: return (ushort)int32Value;                              case SpecialType.System_UInt32: return (uint)int32Value;                              case SpecialType.System_UInt64: return (ulong)int32Value;                              case SpecialType.System_SByte: return (sbyte)int32Value;                              case SpecialType.System_Int16: return (short)int32Value;                              case SpecialType.System_Int32: return (int)int32Value;                              case SpecialType.System_Int64: return (long)int32Value;                              case SpecialType.System_Single: return (double)(float)int32Value;                              case SpecialType.System_Double: return (double)int32Value;                              case SpecialType.System_Decimal: return (decimal)int32Value;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)int64Value;                              case SpecialType.System_Char: return (char)int64Value;                              case SpecialType.System_UInt16: return (ushort)int64Value;                              case SpecialType.System_UInt32: return (uint)int64Value;                              case SpecialType.System_UInt64: return (ulong)int64Value;                              case SpecialType.System_SByte: return (sbyte)int64Value;                              case SpecialType.System_Int16: return (short)int64Value;                              case SpecialType.System_Int32: return (int)int64Value;                              case SpecialType.System_Int64: return (long)int64Value;                              case SpecialType.System_Single: return (double)(float)int64Value;                              case SpecialType.System_Double: return (double)int64Value;                              case SpecialType.System_Decimal: return (decimal)int64Value;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)doubleValue;                              case SpecialType.System_Char: return (char)doubleValue;                              case SpecialType.System_UInt16: return (ushort)doubleValue;                              case SpecialType.System_UInt32: return (uint)doubleValue;                              case SpecialType.System_UInt64: return (ulong)doubleValue;                              case SpecialType.System_SByte: return (sbyte)doubleValue;                              case SpecialType.System_Int16: return (short)doubleValue;                              case SpecialType.System_Int32: return (int)doubleValue;                              case SpecialType.System_Int64: return (long)doubleValue;                              case SpecialType.System_Single: return (double)(float)doubleValue;                              case SpecialType.System_Double: return (double)doubleValue;                              case SpecialType.System_Decimal: return (value.Discriminator == ConstantValueTypeDiscriminator.Single) ? (decimal)(float)doubleValue : (decimal)doubleValue;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,DoUncheckedConversion,The following switch statement is missing a default case: switch (destinationType)                          {                              case SpecialType.System_Byte: return (byte)decimalValue;                              case SpecialType.System_Char: return (char)decimalValue;                              case SpecialType.System_UInt16: return (ushort)decimalValue;                              case SpecialType.System_UInt32: return (uint)decimalValue;                              case SpecialType.System_UInt64: return (ulong)decimalValue;                              case SpecialType.System_SByte: return (sbyte)decimalValue;                              case SpecialType.System_Int16: return (short)decimalValue;                              case SpecialType.System_Int32: return (int)decimalValue;                              case SpecialType.System_Int64: return (long)decimalValue;                              case SpecialType.System_Single: return (double)(float)decimalValue;                              case SpecialType.System_Double: return (double)decimalValue;                              case SpecialType.System_Decimal: return (decimal)decimalValue;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckConstantBounds,The following switch statement is missing a default case: switch (destinationType)              {                  case SpecialType.System_Byte: return (byte.MinValue - 1D) < value && value < (byte.MaxValue + 1D);                  case SpecialType.System_Char: return (char.MinValue - 1D) < value && value < (char.MaxValue + 1D);                  case SpecialType.System_UInt16: return (ushort.MinValue - 1D) < value && value < (ushort.MaxValue + 1D);                  case SpecialType.System_UInt32: return (uint.MinValue - 1D) < value && value < (uint.MaxValue + 1D);                  case SpecialType.System_UInt64: return (ulong.MinValue - 1D) < value && value < (ulong.MaxValue + 1D);                  case SpecialType.System_SByte: return (sbyte.MinValue - 1D) < value && value < (sbyte.MaxValue + 1D);                  case SpecialType.System_Int16: return (short.MinValue - 1D) < value && value < (short.MaxValue + 1D);                  case SpecialType.System_Int32: return (int.MinValue - 1D) < value && value < (int.MaxValue + 1D);                  // Note: Using <= to compare the min value matches the native compiler.                  case SpecialType.System_Int64: return (long.MinValue - 1D) <= value && value < (long.MaxValue + 1D);                  case SpecialType.System_Decimal: return ((double)decimal.MinValue - 1D) < value && value < ((double)decimal.MaxValue + 1D);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckConstantBounds,The following switch statement is missing a default case: switch (destinationType)              {                  case SpecialType.System_Byte: return (byte.MinValue - 1M) < value && value < (byte.MaxValue + 1M);                  case SpecialType.System_Char: return (char.MinValue - 1M) < value && value < (char.MaxValue + 1M);                  case SpecialType.System_UInt16: return (ushort.MinValue - 1M) < value && value < (ushort.MaxValue + 1M);                  case SpecialType.System_UInt32: return (uint.MinValue - 1M) < value && value < (uint.MaxValue + 1M);                  case SpecialType.System_UInt64: return (ulong.MinValue - 1M) < value && value < (ulong.MaxValue + 1M);                  case SpecialType.System_SByte: return (sbyte.MinValue - 1M) < value && value < (sbyte.MaxValue + 1M);                  case SpecialType.System_Int16: return (short.MinValue - 1M) < value && value < (short.MaxValue + 1M);                  case SpecialType.System_Int32: return (int.MinValue - 1M) < value && value < (int.MaxValue + 1M);                  case SpecialType.System_Int64: return (long.MinValue - 1M) < value && value < (long.MaxValue + 1M);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CanonicalizeConstant,The following switch statement is missing a default case: switch (value.Discriminator)              {                  case ConstantValueTypeDiscriminator.SByte: return (decimal)value.SByteValue;                  case ConstantValueTypeDiscriminator.Int16: return (decimal)value.Int16Value;                  case ConstantValueTypeDiscriminator.Int32: return (decimal)value.Int32Value;                  case ConstantValueTypeDiscriminator.Int64: return (decimal)value.Int64Value;                  case ConstantValueTypeDiscriminator.Byte: return (decimal)value.ByteValue;                  case ConstantValueTypeDiscriminator.Char: return (decimal)value.CharValue;                  case ConstantValueTypeDiscriminator.UInt16: return (decimal)value.UInt16Value;                  case ConstantValueTypeDiscriminator.UInt32: return (decimal)value.UInt32Value;                  case ConstantValueTypeDiscriminator.UInt64: return (decimal)value.UInt64Value;                  case ConstantValueTypeDiscriminator.Single:                  case ConstantValueTypeDiscriminator.Double: return value.DoubleValue;                  case ConstantValueTypeDiscriminator.Decimal: return value.DecimalValue;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldParameterlessValueTypeConstructor,The following switch statement is missing a default case: switch (specialType)              {                  case SpecialType.System_SByte:                  case SpecialType.System_Int16:                  case SpecialType.System_Int32:                  case SpecialType.System_Int64:                  case SpecialType.System_Byte:                  case SpecialType.System_UInt16:                  case SpecialType.System_UInt32:                  case SpecialType.System_UInt64:                  case SpecialType.System_Single:                  case SpecialType.System_Double:                  case SpecialType.System_Decimal:                  case SpecialType.System_Boolean:                  case SpecialType.System_Char:                      return ConstantValue.Default(specialType);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindLeftOfPotentialColorColorMemberAccess,The following switch statement is missing a default case: switch (leftSymbol.Kind)                      {                          case SymbolKind.Field:                          case SymbolKind.Local:                          case SymbolKind.Parameter:                          case SymbolKind.Property:                          case SymbolKind.RangeVariable:                              var leftType = boundValue.Type;                              Debug.Assert((object)leftType != null);                                var leftName = node.Identifier.ValueText;                              if (leftType.Name == leftName || IsUsingAliasInScope(leftName))                              {                                  var typeDiagnostics = new DiagnosticBag();                                  var boundType = BindNamespaceOrType(node' typeDiagnostics);                                  if (boundType.Type == leftType)                                  {                                      // NOTE: ReplaceTypeOrValueReceiver will call CheckValue explicitly.                                      var newValueDiagnostics = new DiagnosticBag();                                      newValueDiagnostics.AddRangeAndFree(valueDiagnostics);                                        return new BoundTypeOrValueExpression(left' new BoundTypeOrValueData(leftSymbol' boundValue' newValueDiagnostics' boundType' typeDiagnostics)' leftType);                                  }                              }                              break;                                // case SymbolKind.Event: //SPEC: 7.6.4.1 (a.k.a. Color Color) doesn't cover events                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetNonMethodMemberType,The following switch statement is missing a default case: switch (symbolOpt.Kind)                  {                      case SymbolKind.Field:                          resultType = ((FieldSymbol)symbolOpt).GetFieldType(this.FieldsBeingBound);                          break;                      case SymbolKind.Property:                          resultType = ((PropertySymbol)symbolOpt).Type;                          break;                      case SymbolKind.Event:                          resultType = ((EventSymbol)symbolOpt).Type;                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindConditionalAccessExpression,The following switch statement is missing a default case: switch (parent.Kind())                      {                          case SyntaxKind.ExpressionStatement:                              resultIsNotUsed = ((ExpressionStatementSyntax)parent).Expression == node;                              break;                            case SyntaxKind.SimpleLambdaExpression:                              resultIsNotUsed = (((SimpleLambdaExpressionSyntax)parent).Body == node) && ContainingMethodOrLambdaReturnsVoid();                              break;                            case SyntaxKind.ParenthesizedLambdaExpression:                              resultIsNotUsed = (((ParenthesizedLambdaExpressionSyntax)parent).Body == node) && ContainingMethodOrLambdaReturnsVoid();                              break;                            case SyntaxKind.ArrowExpressionClause:                              resultIsNotUsed = (((ArrowExpressionClauseSyntax)parent).Expression == node) && ContainingMethodOrLambdaReturnsVoid();                              break;                            case SyntaxKind.ForStatement:                              // Incrementors and Initializers doesn't have to produce a value                              var loop = (ForStatementSyntax)parent;                              resultIsNotUsed = loop.Incrementors.Contains(node) || loop.Initializers.Contains(node);                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindDynamicInvocation,The following switch statement is missing a default case: switch (receiver.Kind)                      {                          case BoundKind.BaseReference:                              Error(diagnostics' ErrorCode.ERR_NoDynamicPhantomOnBase' node' methodGroup.Name);                              hasErrors = true;                              break;                            case BoundKind.ThisReference:                              if (InConstructorInitializer && receiver.WasCompilerGenerated)                              {                                  // Only a static method can be called in a constructor initializer. If we were not in a ctor initializer                                  // the runtime binder would ignore the receiver' but in a ctor initializer we can't read "this" before                                   // the base constructor is called. We need to handle thisas a type qualified static method call.                                  expression = methodGroup.Update(                                      methodGroup.TypeArgumentsOpt'                                      methodGroup.Name'                                      methodGroup.Methods'                                      methodGroup.LookupSymbolOpt'                                      methodGroup.LookupError'                                      methodGroup.Flags & ~BoundMethodGroupFlags.HasImplicitReceiver'                                      receiverOpt: new BoundTypeExpression(node' null' this.ContainingType)'                                      resultKind: methodGroup.ResultKind);                              }                                break;                            case BoundKind.TypeOrValueExpression:                              var typeOrValue = (BoundTypeOrValueExpression)receiver;                                // Unfortunately' the runtime binder doesn't have APIs that would allow us to pass both "type or value".                              // Ideally the runtime binder would choose between type and value based on the result of the overload resolution.                              // We need to pick one or the other here. Dev11 compiler passes the type only if the value can't be accessed.                              bool inStaticContext;                              bool useType = IsInstance(typeOrValue.Data.ValueSymbol) && !HasThis(isExplicit: false' inStaticContext: out inStaticContext);                                BoundExpression finalReceiver = ReplaceTypeOrValueReceiver(typeOrValue' useType' diagnostics);                                expression = methodGroup.Update(                                      methodGroup.TypeArgumentsOpt'                                      methodGroup.Name'                                      methodGroup.Methods'                                      methodGroup.LookupSymbolOpt'                                      methodGroup.LookupError'                                      methodGroup.Flags'                                      finalReceiver'                                      methodGroup.ResultKind);                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,GetLocationForOverloadResolutionDiagnostic,The following switch statement is missing a default case: switch (expression.Kind())                  {                      case SyntaxKind.QualifiedName:                          return ((QualifiedNameSyntax)expression).Right.GetLocation();                        case SyntaxKind.SimpleMemberAccessExpression:                      case SyntaxKind.PointerMemberAccessExpression:                          return ((MemberAccessExpressionSyntax)expression).Name.GetLocation();                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,ReplaceTypeOrValueReceiver,The following switch statement is missing a default case: switch (receiver.Kind)              {                  case BoundKind.TypeOrValueExpression:                      var typeOrValue = (BoundTypeOrValueExpression)receiver;                      if (useType)                      {                          diagnostics.AddRange(typeOrValue.Data.TypeDiagnostics);                          return typeOrValue.Data.TypeExpression;                      }                      else                      {                          diagnostics.AddRange(typeOrValue.Data.ValueDiagnostics);                          return CheckValue(typeOrValue.Data.ValueExpression' BindValueKind.RValue' diagnostics);                      }                    case BoundKind.QueryClause:                      // a query clause may wrap a TypeOrValueExpression.                      var q = (BoundQueryClause)receiver;                      var value = q.Value;                      var replaced = ReplaceTypeOrValueReceiver(value' useType' diagnostics);                      return (value == replaced) ? q : q.Update(replaced' q.DefinedSymbol' q.Operation' q.Cast' q.Binder' q.UnoptimizedForm' q.Type);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BuildArgumentsForErrorRecovery,The following switch statement is missing a default case: switch (oldArgument.Kind)                              {                                  case BoundKind.UnboundLambda:                                      NamedTypeSymbol parameterType = parameters[i].Type as NamedTypeSymbol;                                      if ((object)parameterType != null)                                      {                                          newArguments[i] = ((UnboundLambda)oldArgument).Bind(parameterType);                                      }                                      break;                              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsInvocableMember,The following switch statement is missing a default case: switch (symbol.Kind)              {                  case SymbolKind.Method:                  case SymbolKind.Event: // Spec says it doesn't matter whether it is field-like                      return true;                    case SymbolKind.Field:                      type = ((FieldSymbol)symbol).GetFieldType(this.FieldsBeingBound);                      break;                    case SymbolKind.Property:                      type = ((PropertySymbol)symbol).Type;                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,AddMemberLookupSymbolsInfoInType,The following switch statement is missing a default case: switch (type.TypeKind)              {                  case TypeKind.TypeParameter:                      this.AddMemberLookupSymbolsInfoInTypeParameter(result' (TypeParameterSymbol)type' options' originalBinder);                      break;                    case TypeKind.Interface:                      this.AddMemberLookupSymbolsInfoInInterface(result' type' options' originalBinder' type);                      break;                    case TypeKind.Class:                  case TypeKind.Struct:                  case TypeKind.Enum:                  case TypeKind.Delegate:                  case TypeKind.Array:                  case TypeKind.Dynamic:                      this.AddMemberLookupSymbolsInfoInClass(result' type' options' originalBinder' type);                      break;                    case TypeKind.Submission:                      this.AddMemberLookupSymbolsInfoInSubmissions(result' type' options' originalBinder);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindCompoundAssignment,The following switch statement is missing a default case: switch (kindOperator)                  {                      case BinaryOperatorKind.Addition:                      case BinaryOperatorKind.Subtraction:                          return BindEventAssignment(node' (BoundEventAccess)left' right' kindOperator' diagnostics);                            // fallthrough for other operators' if RHS is dynamic we produce dynamic operation' otherwise we'll report an error ...                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsSimpleBinaryOperator,The following switch statement is missing a default case: switch (kind)              {                  case SyntaxKind.AddExpression:                  case SyntaxKind.MultiplyExpression:                  case SyntaxKind.SubtractExpression:                  case SyntaxKind.DivideExpression:                  case SyntaxKind.ModuloExpression:                  case SyntaxKind.EqualsExpression:                  case SyntaxKind.NotEqualsExpression:                  case SyntaxKind.GreaterThanExpression:                  case SyntaxKind.LessThanExpression:                  case SyntaxKind.GreaterThanOrEqualExpression:                  case SyntaxKind.LessThanOrEqualExpression:                  case SyntaxKind.BitwiseAndExpression:                  case SyntaxKind.BitwiseOrExpression:                  case SyntaxKind.ExclusiveOrExpression:                  case SyntaxKind.LeftShiftExpression:                  case SyntaxKind.RightShiftExpression:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldDecimalBinaryOperators,The following switch statement is missing a default case: switch (kind)              {                  case BinaryOperatorKind.DecimalAddition:                      return valueLeft.DecimalValue + valueRight.DecimalValue;                  case BinaryOperatorKind.DecimalSubtraction:                      return valueLeft.DecimalValue - valueRight.DecimalValue;                  case BinaryOperatorKind.DecimalMultiplication:                      return valueLeft.DecimalValue * valueRight.DecimalValue;                  case BinaryOperatorKind.DecimalDivision:                      return valueLeft.DecimalValue / valueRight.DecimalValue;                  case BinaryOperatorKind.DecimalRemainder:                      return valueLeft.DecimalValue % valueRight.DecimalValue;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldUncheckedIntegralBinaryOperator,The following switch statement is missing a default case: switch (kind)                  {                      case BinaryOperatorKind.IntAddition:                          return valueLeft.Int32Value + valueRight.Int32Value;                      case BinaryOperatorKind.LongAddition:                          return valueLeft.Int64Value + valueRight.Int64Value;                      case BinaryOperatorKind.UIntAddition:                          return valueLeft.UInt32Value + valueRight.UInt32Value;                      case BinaryOperatorKind.ULongAddition:                          return valueLeft.UInt64Value + valueRight.UInt64Value;                      case BinaryOperatorKind.IntSubtraction:                          return valueLeft.Int32Value - valueRight.Int32Value;                      case BinaryOperatorKind.LongSubtraction:                          return valueLeft.Int64Value - valueRight.Int64Value;                      case BinaryOperatorKind.UIntSubtraction:                          return valueLeft.UInt32Value - valueRight.UInt32Value;                      case BinaryOperatorKind.ULongSubtraction:                          return valueLeft.UInt64Value - valueRight.UInt64Value;                      case BinaryOperatorKind.IntMultiplication:                          return valueLeft.Int32Value * valueRight.Int32Value;                      case BinaryOperatorKind.LongMultiplication:                          return valueLeft.Int64Value * valueRight.Int64Value;                      case BinaryOperatorKind.UIntMultiplication:                          return valueLeft.UInt32Value * valueRight.UInt32Value;                      case BinaryOperatorKind.ULongMultiplication:                          return valueLeft.UInt64Value * valueRight.UInt64Value;                        // even in unchecked context division may overflow:                      case BinaryOperatorKind.IntDivision:                          if (valueLeft.Int32Value == int.MinValue && valueRight.Int32Value == -1)                          {                              return int.MinValue;                          }                            return valueLeft.Int32Value / valueRight.Int32Value;                        case BinaryOperatorKind.LongDivision:                          if (valueLeft.Int64Value == long.MinValue && valueRight.Int64Value == -1)                          {                              return long.MinValue;                          }                            return valueLeft.Int64Value / valueRight.Int64Value;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldCheckedIntegralBinaryOperator,The following switch statement is missing a default case: switch (kind)                  {                      case BinaryOperatorKind.IntAddition:                          return valueLeft.Int32Value + valueRight.Int32Value;                      case BinaryOperatorKind.LongAddition:                          return valueLeft.Int64Value + valueRight.Int64Value;                      case BinaryOperatorKind.UIntAddition:                          return valueLeft.UInt32Value + valueRight.UInt32Value;                      case BinaryOperatorKind.ULongAddition:                          return valueLeft.UInt64Value + valueRight.UInt64Value;                      case BinaryOperatorKind.IntSubtraction:                          return valueLeft.Int32Value - valueRight.Int32Value;                      case BinaryOperatorKind.LongSubtraction:                          return valueLeft.Int64Value - valueRight.Int64Value;                      case BinaryOperatorKind.UIntSubtraction:                          return valueLeft.UInt32Value - valueRight.UInt32Value;                      case BinaryOperatorKind.ULongSubtraction:                          return valueLeft.UInt64Value - valueRight.UInt64Value;                      case BinaryOperatorKind.IntMultiplication:                          return valueLeft.Int32Value * valueRight.Int32Value;                      case BinaryOperatorKind.LongMultiplication:                          return valueLeft.Int64Value * valueRight.Int64Value;                      case BinaryOperatorKind.UIntMultiplication:                          return valueLeft.UInt32Value * valueRight.UInt32Value;                      case BinaryOperatorKind.ULongMultiplication:                          return valueLeft.UInt64Value * valueRight.UInt64Value;                      case BinaryOperatorKind.IntDivision:                          return valueLeft.Int32Value / valueRight.Int32Value;                      case BinaryOperatorKind.LongDivision:                          return valueLeft.Int64Value / valueRight.Int64Value;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldNeverOverflowBinaryOperators,The following switch statement is missing a default case: switch (kind)              {                  case BinaryOperatorKind.ObjectEqual:                      if (valueLeft.IsNull) return valueRight.IsNull;                      if (valueRight.IsNull) return false;                      break;                  case BinaryOperatorKind.ObjectNotEqual:                      if (valueLeft.IsNull) return !valueRight.IsNull;                      if (valueRight.IsNull) return true;                      break;                  case BinaryOperatorKind.DoubleAddition:                  case BinaryOperatorKind.FloatAddition:                      return valueLeft.DoubleValue + valueRight.DoubleValue;                  case BinaryOperatorKind.DoubleSubtraction:                  case BinaryOperatorKind.FloatSubtraction:                      return valueLeft.DoubleValue - valueRight.DoubleValue;                  case BinaryOperatorKind.DoubleMultiplication:                  case BinaryOperatorKind.FloatMultiplication:                      return valueLeft.DoubleValue * valueRight.DoubleValue;                  case BinaryOperatorKind.DoubleDivision:                  case BinaryOperatorKind.FloatDivision:                      return valueLeft.DoubleValue / valueRight.DoubleValue;                  case BinaryOperatorKind.DoubleRemainder:                  case BinaryOperatorKind.FloatRemainder:                      return valueLeft.DoubleValue % valueRight.DoubleValue;                  case BinaryOperatorKind.IntLeftShift:                      return valueLeft.Int32Value << valueRight.Int32Value;                  case BinaryOperatorKind.LongLeftShift:                      return valueLeft.Int64Value << valueRight.Int32Value;                  case BinaryOperatorKind.UIntLeftShift:                      return valueLeft.UInt32Value << valueRight.Int32Value;                  case BinaryOperatorKind.ULongLeftShift:                      return valueLeft.UInt64Value << valueRight.Int32Value;                  case BinaryOperatorKind.IntRightShift:                      return valueLeft.Int32Value >> valueRight.Int32Value;                  case BinaryOperatorKind.LongRightShift:                      return valueLeft.Int64Value >> valueRight.Int32Value;                  case BinaryOperatorKind.UIntRightShift:                      return valueLeft.UInt32Value >> valueRight.Int32Value;                  case BinaryOperatorKind.ULongRightShift:                      return valueLeft.UInt64Value >> valueRight.Int32Value;                  case BinaryOperatorKind.BoolAnd:                      return valueLeft.BooleanValue & valueRight.BooleanValue;                  case BinaryOperatorKind.IntAnd:                      return valueLeft.Int32Value & valueRight.Int32Value;                  case BinaryOperatorKind.LongAnd:                      return valueLeft.Int64Value & valueRight.Int64Value;                  case BinaryOperatorKind.UIntAnd:                      return valueLeft.UInt32Value & valueRight.UInt32Value;                  case BinaryOperatorKind.ULongAnd:                      return valueLeft.UInt64Value & valueRight.UInt64Value;                  case BinaryOperatorKind.BoolOr:                      return valueLeft.BooleanValue | valueRight.BooleanValue;                  case BinaryOperatorKind.IntOr:                      return valueLeft.Int32Value | valueRight.Int32Value;                  case BinaryOperatorKind.LongOr:                      return valueLeft.Int64Value | valueRight.Int64Value;                  case BinaryOperatorKind.UIntOr:                      return valueLeft.UInt32Value | valueRight.UInt32Value;                  case BinaryOperatorKind.ULongOr:                      return valueLeft.UInt64Value | valueRight.UInt64Value;                  case BinaryOperatorKind.BoolXor:                      return valueLeft.BooleanValue ^ valueRight.BooleanValue;                  case BinaryOperatorKind.IntXor:                      return valueLeft.Int32Value ^ valueRight.Int32Value;                  case BinaryOperatorKind.LongXor:                      return valueLeft.Int64Value ^ valueRight.Int64Value;                  case BinaryOperatorKind.UIntXor:                      return valueLeft.UInt32Value ^ valueRight.UInt32Value;                  case BinaryOperatorKind.ULongXor:                      return valueLeft.UInt64Value ^ valueRight.UInt64Value;                  case BinaryOperatorKind.LogicalBoolAnd:                      return valueLeft.BooleanValue && valueRight.BooleanValue;                  case BinaryOperatorKind.LogicalBoolOr:                      return valueLeft.BooleanValue || valueRight.BooleanValue;                  case BinaryOperatorKind.BoolEqual:                      return valueLeft.BooleanValue == valueRight.BooleanValue;                  case BinaryOperatorKind.StringEqual:                      return valueLeft.StringValue == valueRight.StringValue;                  case BinaryOperatorKind.DecimalEqual:                      return valueLeft.DecimalValue == valueRight.DecimalValue;                  case BinaryOperatorKind.FloatEqual:                  case BinaryOperatorKind.DoubleEqual:                      return valueLeft.DoubleValue == valueRight.DoubleValue;                  case BinaryOperatorKind.IntEqual:                      return valueLeft.Int32Value == valueRight.Int32Value;                  case BinaryOperatorKind.LongEqual:                      return valueLeft.Int64Value == valueRight.Int64Value;                  case BinaryOperatorKind.UIntEqual:                      return valueLeft.UInt32Value == valueRight.UInt32Value;                  case BinaryOperatorKind.ULongEqual:                      return valueLeft.UInt64Value == valueRight.UInt64Value;                  case BinaryOperatorKind.BoolNotEqual:                      return valueLeft.BooleanValue != valueRight.BooleanValue;                  case BinaryOperatorKind.StringNotEqual:                      return valueLeft.StringValue != valueRight.StringValue;                  case BinaryOperatorKind.DecimalNotEqual:                      return valueLeft.DecimalValue != valueRight.DecimalValue;                  case BinaryOperatorKind.FloatNotEqual:                  case BinaryOperatorKind.DoubleNotEqual:                      return valueLeft.DoubleValue != valueRight.DoubleValue;                  case BinaryOperatorKind.IntNotEqual:                      return valueLeft.Int32Value != valueRight.Int32Value;                  case BinaryOperatorKind.LongNotEqual:                      return valueLeft.Int64Value != valueRight.Int64Value;                  case BinaryOperatorKind.UIntNotEqual:                      return valueLeft.UInt32Value != valueRight.UInt32Value;                  case BinaryOperatorKind.ULongNotEqual:                      return valueLeft.UInt64Value != valueRight.UInt64Value;                  case BinaryOperatorKind.DecimalLessThan:                      return valueLeft.DecimalValue < valueRight.DecimalValue;                  case BinaryOperatorKind.FloatLessThan:                  case BinaryOperatorKind.DoubleLessThan:                      return valueLeft.DoubleValue < valueRight.DoubleValue;                  case BinaryOperatorKind.IntLessThan:                      return valueLeft.Int32Value < valueRight.Int32Value;                  case BinaryOperatorKind.LongLessThan:                      return valueLeft.Int64Value < valueRight.Int64Value;                  case BinaryOperatorKind.UIntLessThan:                      return valueLeft.UInt32Value < valueRight.UInt32Value;                  case BinaryOperatorKind.ULongLessThan:                      return valueLeft.UInt64Value < valueRight.UInt64Value;                  case BinaryOperatorKind.DecimalGreaterThan:                      return valueLeft.DecimalValue > valueRight.DecimalValue;                  case BinaryOperatorKind.FloatGreaterThan:                  case BinaryOperatorKind.DoubleGreaterThan:                      return valueLeft.DoubleValue > valueRight.DoubleValue;                  case BinaryOperatorKind.IntGreaterThan:                      return valueLeft.Int32Value > valueRight.Int32Value;                  case BinaryOperatorKind.LongGreaterThan:                      return valueLeft.Int64Value > valueRight.Int64Value;                  case BinaryOperatorKind.UIntGreaterThan:                      return valueLeft.UInt32Value > valueRight.UInt32Value;                  case BinaryOperatorKind.ULongGreaterThan:                      return valueLeft.UInt64Value > valueRight.UInt64Value;                  case BinaryOperatorKind.DecimalLessThanOrEqual:                      return valueLeft.DecimalValue <= valueRight.DecimalValue;                  case BinaryOperatorKind.FloatLessThanOrEqual:                  case BinaryOperatorKind.DoubleLessThanOrEqual:                      return valueLeft.DoubleValue <= valueRight.DoubleValue;                  case BinaryOperatorKind.IntLessThanOrEqual:                      return valueLeft.Int32Value <= valueRight.Int32Value;                  case BinaryOperatorKind.LongLessThanOrEqual:                      return valueLeft.Int64Value <= valueRight.Int64Value;                  case BinaryOperatorKind.UIntLessThanOrEqual:                      return valueLeft.UInt32Value <= valueRight.UInt32Value;                  case BinaryOperatorKind.ULongLessThanOrEqual:                      return valueLeft.UInt64Value <= valueRight.UInt64Value;                  case BinaryOperatorKind.DecimalGreaterThanOrEqual:                      return valueLeft.DecimalValue >= valueRight.DecimalValue;                  case BinaryOperatorKind.FloatGreaterThanOrEqual:                  case BinaryOperatorKind.DoubleGreaterThanOrEqual:                      return valueLeft.DoubleValue >= valueRight.DoubleValue;                  case BinaryOperatorKind.IntGreaterThanOrEqual:                      return valueLeft.Int32Value >= valueRight.Int32Value;                  case BinaryOperatorKind.LongGreaterThanOrEqual:                      return valueLeft.Int64Value >= valueRight.Int64Value;                  case BinaryOperatorKind.UIntGreaterThanOrEqual:                      return valueLeft.UInt32Value >= valueRight.UInt32Value;                  case BinaryOperatorKind.ULongGreaterThanOrEqual:                      return valueLeft.UInt64Value >= valueRight.UInt64Value;                  case BinaryOperatorKind.UIntDivision:                      return valueLeft.UInt32Value / valueRight.UInt32Value;                  case BinaryOperatorKind.ULongDivision:                      return valueLeft.UInt64Value / valueRight.UInt64Value;                    // MinValue % -1 always overflows at runtime but never at compile time                  case BinaryOperatorKind.IntRemainder:                      return (valueRight.Int32Value != -1) ? valueLeft.Int32Value % valueRight.Int32Value : 0;                  case BinaryOperatorKind.LongRemainder:                      return (valueRight.Int64Value != -1) ? valueLeft.Int64Value % valueRight.Int64Value : 0;                  case BinaryOperatorKind.UIntRemainder:                      return valueLeft.UInt32Value % valueRight.UInt32Value;                  case BinaryOperatorKind.ULongRemainder:                      return valueLeft.UInt64Value % valueRight.UInt64Value;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,SyntaxKindToBinaryOperatorKind,The following switch statement is missing a default case: switch (kind)              {                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.MultiplyExpression: return BinaryOperatorKind.Multiplication;                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.DivideExpression: return BinaryOperatorKind.Division;                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.ModuloExpression: return BinaryOperatorKind.Remainder;                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.AddExpression: return BinaryOperatorKind.Addition;                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.SubtractExpression: return BinaryOperatorKind.Subtraction;                  case SyntaxKind.RightShiftAssignmentExpression:                  case SyntaxKind.RightShiftExpression: return BinaryOperatorKind.RightShift;                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.LeftShiftExpression: return BinaryOperatorKind.LeftShift;                  case SyntaxKind.EqualsExpression: return BinaryOperatorKind.Equal;                  case SyntaxKind.NotEqualsExpression: return BinaryOperatorKind.NotEqual;                  case SyntaxKind.GreaterThanExpression: return BinaryOperatorKind.GreaterThan;                  case SyntaxKind.LessThanExpression: return BinaryOperatorKind.LessThan;                  case SyntaxKind.GreaterThanOrEqualExpression: return BinaryOperatorKind.GreaterThanOrEqual;                  case SyntaxKind.LessThanOrEqualExpression: return BinaryOperatorKind.LessThanOrEqual;                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.BitwiseAndExpression: return BinaryOperatorKind.And;                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.BitwiseOrExpression: return BinaryOperatorKind.Or;                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.ExclusiveOrExpression: return BinaryOperatorKind.Xor;                  case SyntaxKind.LogicalAndExpression: return BinaryOperatorKind.LogicalAnd;                  case SyntaxKind.LogicalOrExpression: return BinaryOperatorKind.LogicalOr;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAddressOfExpression,The following switch statement is missing a default case: switch (operand.Kind)              {                  case BoundKind.MethodGroup:                  case BoundKind.Lambda:                  case BoundKind.UnboundLambda:                      {                          Debug.Assert(hasErrors);                          return new BoundAddressOfOperator(node' operand' isFixedStatementAddressOfExpression' CreateErrorType()' hasErrors: true);                      }              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldNeverOverflowUnaryOperator,The following switch statement is missing a default case: switch (kind)              {                  case UnaryOperatorKind.DecimalUnaryMinus:                      return -value.DecimalValue;                  case UnaryOperatorKind.DoubleUnaryMinus:                  case UnaryOperatorKind.FloatUnaryMinus:                      return -value.DoubleValue;                  case UnaryOperatorKind.DecimalUnaryPlus:                      return +value.DecimalValue;                  case UnaryOperatorKind.FloatUnaryPlus:                  case UnaryOperatorKind.DoubleUnaryPlus:                      return +value.DoubleValue;                  case UnaryOperatorKind.LongUnaryPlus:                      return +value.Int64Value;                  case UnaryOperatorKind.ULongUnaryPlus:                      return +value.UInt64Value;                  case UnaryOperatorKind.IntUnaryPlus:                      return +value.Int32Value;                  case UnaryOperatorKind.UIntUnaryPlus:                      return +value.UInt32Value;                  case UnaryOperatorKind.BoolLogicalNegation:                      return !value.BooleanValue;                  case UnaryOperatorKind.IntBitwiseComplement:                      return ~value.Int32Value;                  case UnaryOperatorKind.LongBitwiseComplement:                      return ~value.Int64Value;                  case UnaryOperatorKind.UIntBitwiseComplement:                      return ~value.UInt32Value;                  case UnaryOperatorKind.ULongBitwiseComplement:                      return ~value.UInt64Value;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldUncheckedIntegralUnaryOperator,The following switch statement is missing a default case: switch (kind)                  {                      case UnaryOperatorKind.LongUnaryMinus:                          return -value.Int64Value;                      case UnaryOperatorKind.IntUnaryMinus:                          return -value.Int32Value;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,FoldCheckedIntegralUnaryOperator,The following switch statement is missing a default case: switch (kind)                  {                      case UnaryOperatorKind.LongUnaryMinus:                          return -value.Int64Value;                      case UnaryOperatorKind.IntUnaryMinus:                          return -value.Int32Value;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,SyntaxKindToUnaryOperatorKind,The following switch statement is missing a default case: switch (kind)              {                  case SyntaxKind.PreIncrementExpression: return UnaryOperatorKind.PrefixIncrement;                  case SyntaxKind.PostIncrementExpression: return UnaryOperatorKind.PostfixIncrement;                  case SyntaxKind.PreDecrementExpression: return UnaryOperatorKind.PrefixDecrement;                  case SyntaxKind.PostDecrementExpression: return UnaryOperatorKind.PostfixDecrement;                  case SyntaxKind.UnaryPlusExpression: return UnaryOperatorKind.UnaryPlus;                  case SyntaxKind.UnaryMinusExpression: return UnaryOperatorKind.UnaryMinus;                  case SyntaxKind.LogicalNotExpression: return UnaryOperatorKind.LogicalNegation;                  case SyntaxKind.BitwiseNotExpression: return UnaryOperatorKind.BitwiseComplement;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsDivisionByZero,The following switch statement is missing a default case: switch (kind)              {                  case BinaryOperatorKind.DecimalDivision:                  case BinaryOperatorKind.DecimalRemainder:                      return valueRight.DecimalValue == 0.0m;                  case BinaryOperatorKind.IntDivision:                  case BinaryOperatorKind.IntRemainder:                      return valueRight.Int32Value == 0;                  case BinaryOperatorKind.LongDivision:                  case BinaryOperatorKind.LongRemainder:                      return valueRight.Int64Value == 0;                  case BinaryOperatorKind.UIntDivision:                  case BinaryOperatorKind.UIntRemainder:                      return valueRight.UInt32Value == 0;                  case BinaryOperatorKind.ULongDivision:                  case BinaryOperatorKind.ULongRemainder:                      return valueRight.UInt64Value == 0;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindIsOperator,The following switch statement is missing a default case: switch (operand.Kind)              {                  case BoundKind.UnboundLambda:                  case BoundKind.Lambda:                  case BoundKind.MethodGroup:  // New in Roslyn - see DevDiv #864740.                      // operand for an is or as expression cannot be a lambda expression or method group                      Error(diagnostics' ErrorCode.ERR_LambdaInIsAs' node);                      return new BoundIsOperator(node' operand' typeExpression' Conversion.NoConversion' resultType' hasErrors: true);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,BindAsOperator,The following switch statement is missing a default case: switch (operand.Kind)              {                  case BoundKind.UnboundLambda:                  case BoundKind.Lambda:                  case BoundKind.MethodGroup:  // New in Roslyn - see DevDiv #864740.                      // operand for an is or as expression cannot be a lambda expression or method group                      Error(diagnostics' ErrorCode.ERR_LambdaInIsAs' node);                      return new BoundAsOperator(node' operand' typeExpression' Conversion.NoConversion' resultType' hasErrors: true);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckIsVariable,The following switch statement is missing a default case: switch (kind)                      {                          case BindValueKind.RValue:                          case BindValueKind.RValueOrMethodGroup:                              Debug.Assert(false' "Why call CheckIsVariable if you want an RValue?");                              goto case BindValueKind.Assignment;                          case BindValueKind.Assignment:                          case BindValueKind.CompoundAssignment:                              return true;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,CheckValue,The following switch statement is missing a default case: switch (expr.Kind)              {                  case BoundKind.PropertyGroup:                      expr = BindIndexedPropertyAccess((BoundPropertyGroup)expr' mustHaveAllOptionalParameters: false' diagnostics: diagnostics);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,Binder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder.cs,IsViableType,The following switch statement is missing a default case: switch (s.Kind)                  {                      case SymbolKind.Alias:                          if (((AliasSymbol)s).Target.Kind == SymbolKind.NamedType) return true;                          break;                      case SymbolKind.NamedType:                      case SymbolKind.TypeParameter:                          return true;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitNamedArgument,The following switch statement is missing a default case: switch (argument.Kind)                  {                      case BoundKind.AssignmentOperator:                          var assignment = (BoundAssignmentOperator)argument;                            switch (assignment.Left.Kind)                          {                              case BoundKind.FieldAccess:                                  var fa = (BoundFieldAccess)assignment.Left;                                  visitedArgument = new KeyValuePair<String' TypedConstant>(fa.FieldSymbol.Name' VisitExpression(assignment.Right' diagnostics' ref attrHasErrors' argument.HasAnyErrors));                                  break;                                case BoundKind.PropertyAccess:                                  var pa = (BoundPropertyAccess)assignment.Left;                                  visitedArgument = new KeyValuePair<String' TypedConstant>(pa.PropertySymbol.Name' VisitExpression(assignment.Right' diagnostics' ref attrHasErrors' argument.HasAnyErrors));                                  break;                          }                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,AttributeExpressionVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Attributes.cs,VisitNamedArgument,The following switch statement is missing a default case: switch (assignment.Left.Kind)                          {                              case BoundKind.FieldAccess:                                  var fa = (BoundFieldAccess)assignment.Left;                                  visitedArgument = new KeyValuePair<String' TypedConstant>(fa.FieldSymbol.Name' VisitExpression(assignment.Right' diagnostics' ref attrHasErrors' argument.HasAnyErrors));                                  break;                                case BoundKind.PropertyAccess:                                  var pa = (BoundPropertyAccess)assignment.Left;                                  visitedArgument = new KeyValuePair<String' TypedConstant>(pa.PropertySymbol.Name' VisitExpression(assignment.Right' diagnostics' ref attrHasErrors' argument.HasAnyErrors));                                  break;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,BinderFactoryVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\BinderFactory.BinderFactoryVisitor.cs,VisitXmlNameAttribute,The following switch statement is missing a default case: switch (elementKind)                          {                              case XmlNameAttributeElementKind.Parameter:                              case XmlNameAttributeElementKind.ParameterReference:                                  result = GetParameterNameAttributeValueBinder(memberSyntax' result);                                  break;                              case XmlNameAttributeElementKind.TypeParameter:                                  result = GetTypeParameterNameAttributeValueBinder(memberSyntax' includeContainingSymbols: false' nextBinder: result);                                  break;                              case XmlNameAttributeElementKind.TypeParameterReference:                                  result = GetTypeParameterNameAttributeValueBinder(memberSyntax' includeContainingSymbols: true' nextBinder: result);                                  break;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,ContextualAttributeBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\ContextualAttributeBinder.cs,GetAttributedMember,The following switch statement is missing a default case: switch (symbol.Kind)                  {                      case SymbolKind.Method:                      case SymbolKind.Property:                      case SymbolKind.Event:                          return symbol;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,Imports,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Imports.cs,LookupExtensionMethodsInUsings,The following switch statement is missing a default case: switch (nsOrType.NamespaceOrType.Kind)                  {                      case SymbolKind.Namespace:                          {                              var count = methods.Count;                              ((NamespaceSymbol)nsOrType.NamespaceOrType).GetExtensionMethods(methods' name' arity' options);                                // If we found any extension methods' then consider this using as used.                              if (methods.Count != count)                              {                                  MarkImportDirective(nsOrType.UsingDirective' callerIsSemanticModel);                                  seenNamespaceWithExtensionMethods = true;                              }                                break;                          }                        case SymbolKind.NamedType:                          {                              var count = methods.Count;                              ((NamedTypeSymbol)nsOrType.NamespaceOrType).GetExtensionMethods(methods' name' arity' options);                                // If we found any extension methods' then consider this using as used.                              if (methods.Count != count)                              {                                  MarkImportDirective(nsOrType.UsingDirective' callerIsSemanticModel);                                  seenStaticClassWithExtensionMethods = true;                              }                                break;                          }                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,InMethodBinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\InMethodBinder.cs,GetIteratorElementTypeFromReturnType,The following switch statement is missing a default case: switch (returnType.OriginalDefinition.SpecialType)                  {                      case SpecialType.System_Collections_IEnumerable:                      case SpecialType.System_Collections_IEnumerator:                          return GetSpecialType(SpecialType.System_Object' diagnostics' errorLocationNode);                        case SpecialType.System_Collections_Generic_IEnumerable_T:                      case SpecialType.System_Collections_Generic_IEnumerator_T:                          return ((NamedTypeSymbol)returnType).TypeArgumentsNoUseSiteDiagnostics[0];                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,ClassifyImplicitBuiltInConversionFromExpression,The following switch statement is missing a default case: switch (sourceExpression.Kind)              {                  case BoundKind.Literal:                      kind = ClassifyNullLiteralConversion(sourceExpression' destination);                      if (kind != ConversionKind.NoConversion)                      {                          return new Conversion(kind);                      }                      break;                    case BoundKind.UnboundLambda:                      if (HasAnonymousFunctionConversion(sourceExpression' destination))                      {                          return Conversion.AnonymousFunction;                      }                      break;                    case BoundKind.MethodGroup:                      Conversion methodGroupConversion = GetMethodGroupConversion((BoundMethodGroup)sourceExpression' destination' ref useSiteDiagnostics);                      if (methodGroupConversion.Exists)                      {                          return methodGroupConversion;                      }                      break;                    case BoundKind.InterpolatedString:                      Conversion interpolatedStringConversion = GetInterpolatedStringConversion((BoundInterpolatedString)sourceExpression' destination' ref useSiteDiagnostics);                      if (interpolatedStringConversion.Exists)                      {                          return interpolatedStringConversion;                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,IsConstantNumericZero,The following switch statement is missing a default case: switch (value.Discriminator)              {                  case ConstantValueTypeDiscriminator.SByte:                      return value.SByteValue == 0;                  case ConstantValueTypeDiscriminator.Byte:                      return value.ByteValue == 0;                  case ConstantValueTypeDiscriminator.Int16:                      return value.Int16Value == 0;                  case ConstantValueTypeDiscriminator.Int32:                      return value.Int32Value == 0;                  case ConstantValueTypeDiscriminator.Int64:                      return value.Int64Value == 0;                  case ConstantValueTypeDiscriminator.UInt16:                      return value.UInt16Value == 0;                  case ConstantValueTypeDiscriminator.UInt32:                      return value.UInt32Value == 0;                  case ConstantValueTypeDiscriminator.UInt64:                      return value.UInt64Value == 0;                  case ConstantValueTypeDiscriminator.Single:                  case ConstantValueTypeDiscriminator.Double:                      return value.DoubleValue == 0;                  case ConstantValueTypeDiscriminator.Decimal:                      return value.DecimalValue == 0;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasSpecialIntPtrConversion,The following switch statement is missing a default case: switch (otherType.SpecialType)              {                  case SpecialType.System_SByte:                  case SpecialType.System_Byte:                  case SpecialType.System_Int16:                  case SpecialType.System_UInt16:                  case SpecialType.System_Char:                  case SpecialType.System_Int32:                  case SpecialType.System_UInt32:                  case SpecialType.System_Int64:                  case SpecialType.System_UInt64:                  case SpecialType.System_Double:                  case SpecialType.System_Single:                  case SpecialType.System_Decimal:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasImplicitReferenceConversion,The following switch statement is missing a default case: switch (source.TypeKind)              {                  case TypeKind.Class:                      // SPEC:  From any class type S to any class type T provided S is derived from T.                      if (destination.IsClassType() && IsBaseClass(source' destination' ref useSiteDiagnostics))                      {                          return true;                      }                        if (HasImplicitConversionToInterface(source' destination' ref useSiteDiagnostics))                      {                          return true;                      }                      break;                    case TypeKind.Interface:                      // SPEC: From any interface-type S to any interface-type T' provided S is derived from T.                      // NOTE: This handles variance conversions                      if (HasImplicitConversionToInterface(source' destination' ref useSiteDiagnostics))                      {                          return true;                      }                      break;                    case TypeKind.Delegate:                      // SPEC: From any delegate-type to System.Delegate and the interfaces it implements.                      // NOTE: This handles variance conversions.                      if (HasImplicitConversionFromDelegate(source' destination' ref useSiteDiagnostics))                      {                          return true;                      }                      break;                    case TypeKind.TypeParameter:                      if (HasImplicitReferenceTypeParameterConversion((TypeParameterSymbol)source' destination' ref useSiteDiagnostics))                      {                          return true;                      }                      break;                    case TypeKind.Array:                      // SPEC: From an array-type S ... to an array-type T' provided ...                      // SPEC: From any array-type to System.Array and the interfaces it implements.                      // SPEC: From a single-dimensional array type S[] to IList<T>' provided ...                      if (HasImplicitConversionFromArray(source' destination' ref useSiteDiagnostics))                      {                          return true;                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasExplicitDelegateConversion,The following switch statement is missing a default case: switch (original.TypeParameters[i].Variance)                  {                      case VarianceKind.None:                          if (!HasIdentityConversion(sourceArg' destinationArg))                          {                              return false;                          }                            break;                      case VarianceKind.Out:                          if (!HasIdentityOrReferenceConversion(sourceArg' destinationArg' ref useSiteDiagnostics))                          {                              return false;                          }                            break;                      case VarianceKind.In:                          bool hasIdentityConversion = HasIdentityConversion(sourceArg' destinationArg);                          bool bothAreReferenceTypes = sourceArg.IsReferenceType && destinationArg.IsReferenceType;                          if (!(hasIdentityConversion || bothAreReferenceTypes))                          {                              return false;                          }                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasPointerToIntegerConversion,The following switch statement is missing a default case: switch (destination.StrippedType().SpecialType)              {                  case SpecialType.System_SByte:                  case SpecialType.System_Byte:                  case SpecialType.System_Int16:                  case SpecialType.System_UInt16:                  case SpecialType.System_Int32:                  case SpecialType.System_UInt32:                  case SpecialType.System_Int64:                  case SpecialType.System_UInt64:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,ConversionsBase,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,HasIntegerToPointerConversion,The following switch statement is missing a default case: switch (source.SpecialType)              {                  case SpecialType.System_SByte:                  case SpecialType.System_Byte:                  case SpecialType.System_Int16:                  case SpecialType.System_UInt16:                  case SpecialType.System_Int32:                  case SpecialType.System_UInt32:                  case SpecialType.System_Int64:                  case SpecialType.System_UInt64:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,ConversionEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Conversions\ConversionEasyOut.cs,TypeToIndex,The following switch statement is missing a default case: switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetDelegateOperations,The following switch statement is missing a default case: switch (OperatorKindExtensions.Operator(kind))                  {                      case BinaryOperatorKind.Equal:                      case BinaryOperatorKind.NotEqual:                          TypeSymbol systemDelegateType = _binder.GetSpecialType(SpecialType.System_Delegate' _binder.Compilation.SemanticDiagnostics' left.Syntax);                            if (Conversions.ClassifyImplicitConversionFromExpression(left' systemDelegateType' ref useSiteDiagnostics).IsValid &&                              Conversions.ClassifyImplicitConversionFromExpression(right' systemDelegateType' ref useSiteDiagnostics).IsValid)                          {                              AddDelegateOperation(kind' systemDelegateType' operators);                          }                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperation,The following switch statement is missing a default case: switch (kind)              {                  case BinaryOperatorKind.Addition:                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingAddition' enumType' underlying' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumAddition' underlying' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingAddition' nullableEnum' nullableUnderlying' nullableEnum));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumAddition' nullableUnderlying' nullableEnum' nullableEnum));                      break;                  case BinaryOperatorKind.Subtraction:                      if (Strict)                      {                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying));                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum));                      }                      else                      {                          // SPEC VIOLATION:                          // The native compiler has bugs in overload resolution involving binary operator- for enums'                          // which we duplicate by hardcoding Priority values among the operators. When present on both                          // methods being compared during overload resolution' Priority values are used to decide between                          // two candidates (instead of the usual language-specified rules).                          bool isExactSubtraction = right.Type?.StrippedType() == underlying;                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumSubtraction' enumType' enumType' underlying)                          { Priority = 2 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.EnumAndUnderlyingSubtraction' enumType' underlying' enumType)                          { Priority = isExactSubtraction ? 1 : 3 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumSubtraction' nullableEnum' nullableEnum' nullableUnderlying)                          { Priority = 12 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedEnumAndUnderlyingSubtraction' nullableEnum' nullableUnderlying' nullableEnum)                          { Priority = isExactSubtraction ? 11 : 13 });                            // Due to a bug' the native compiler allows "underlying - enum"' so Roslyn does as well.                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UnderlyingAndEnumSubtraction' underlying' enumType' enumType)                          { Priority = 4 });                          operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LiftedUnderlyingAndEnumSubtraction' nullableUnderlying' nullableEnum' nullableEnum)                          { Priority = 14 });                      }                      break;                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                  case BinaryOperatorKind.LessThanOrEqual:                      var boolean = Compilation.GetSpecialType(SpecialType.System_Boolean);                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' boolean));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' boolean));                      break;                  case BinaryOperatorKind.And:                  case BinaryOperatorKind.Or:                  case BinaryOperatorKind.Xor:                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Enum' enumType' enumType' enumType));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Lifted | BinaryOperatorKind.Enum' nullableEnum' nullableEnum' nullableEnum));                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerArithmeticOperators,The following switch statement is missing a default case: switch (kind)              {                  case BinaryOperatorKind.Addition:                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndIntAddition' pointerType' Compilation.GetSpecialType(SpecialType.System_Int32)' pointerType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndUIntAddition' pointerType' Compilation.GetSpecialType(SpecialType.System_UInt32)' pointerType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndLongAddition' pointerType' Compilation.GetSpecialType(SpecialType.System_Int64)' pointerType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndULongAddition' pointerType' Compilation.GetSpecialType(SpecialType.System_UInt64)' pointerType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.IntAndPointerAddition' Compilation.GetSpecialType(SpecialType.System_Int32)' pointerType' pointerType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.UIntAndPointerAddition' Compilation.GetSpecialType(SpecialType.System_UInt32)' pointerType' pointerType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.LongAndPointerAddition' Compilation.GetSpecialType(SpecialType.System_Int64)' pointerType' pointerType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.ULongAndPointerAddition' Compilation.GetSpecialType(SpecialType.System_UInt64)' pointerType' pointerType));                      break;                  case BinaryOperatorKind.Subtraction:                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndIntSubtraction' pointerType' Compilation.GetSpecialType(SpecialType.System_Int32)' pointerType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndUIntSubtraction' pointerType' Compilation.GetSpecialType(SpecialType.System_UInt32)' pointerType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndLongSubtraction' pointerType' Compilation.GetSpecialType(SpecialType.System_Int64)' pointerType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerAndULongSubtraction' pointerType' Compilation.GetSpecialType(SpecialType.System_UInt64)' pointerType));                      operators.Add(new BinaryOperatorSignature(BinaryOperatorKind.PointerSubtraction' pointerType' pointerType' Compilation.GetSpecialType(SpecialType.System_Int64)));                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerComparisonOperators,The following switch statement is missing a default case: switch (kind)              {                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                  case BinaryOperatorKind.LessThanOrEqual:                      var voidPointerType = new PointerTypeSymbol(Compilation.GetSpecialType(SpecialType.System_Void));                      operators.Add(new BinaryOperatorSignature(kind | BinaryOperatorKind.Pointer' voidPointerType' voidPointerType' Compilation.GetSpecialType(SpecialType.System_Boolean)));                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperations,The following switch statement is missing a default case: switch (kind)              {                  case BinaryOperatorKind.Multiplication:                  case BinaryOperatorKind.Division:                  case BinaryOperatorKind.Remainder:                  case BinaryOperatorKind.RightShift:                  case BinaryOperatorKind.LeftShift:                  case BinaryOperatorKind.LogicalAnd:                  case BinaryOperatorKind.LogicalOr:                      return;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetEnumOperations,The following switch statement is missing a default case: switch (kind)              {                  case UnaryOperatorKind.PostfixIncrement:                  case UnaryOperatorKind.PostfixDecrement:                  case UnaryOperatorKind.PrefixIncrement:                  case UnaryOperatorKind.PrefixDecrement:                  case UnaryOperatorKind.BitwiseComplement:                      operators.Add(new UnaryOperatorSignature(kind | UnaryOperatorKind.Enum' enumType' enumType));                      operators.Add(new UnaryOperatorSignature(kind | UnaryOperatorKind.Lifted | UnaryOperatorKind.Enum' nullableEnum' nullableEnum));                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetPointerOperation,The following switch statement is missing a default case: switch (kind)              {                  case UnaryOperatorKind.PostfixIncrement:                  case UnaryOperatorKind.PostfixDecrement:                  case UnaryOperatorKind.PrefixIncrement:                  case UnaryOperatorKind.PrefixDecrement:                      op = new UnaryOperatorSignature(kind | UnaryOperatorKind.Pointer' pointerType' pointerType);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,GetUserDefinedUnaryOperatorsFromType,The following switch statement is missing a default case: switch (kind)                  {                      case UnaryOperatorKind.UnaryPlus:                      case UnaryOperatorKind.PrefixDecrement:                      case UnaryOperatorKind.PrefixIncrement:                      case UnaryOperatorKind.UnaryMinus:                      case UnaryOperatorKind.PostfixDecrement:                      case UnaryOperatorKind.PostfixIncrement:                      case UnaryOperatorKind.LogicalNegation:                      case UnaryOperatorKind.BitwiseComplement:                          if (operandType.IsValueType && !operandType.IsNullableType() &&                              resultType.IsValueType && !resultType.IsNullableType())                          {                              operators.Add(new UnaryOperatorSignature(                                  UnaryOperatorKind.Lifted | UnaryOperatorKind.UserDefined | kind'                                  MakeNullable(operandType)' MakeNullable(resultType)' op));                          }                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,PreferExpandedFormOverNormalForm,The following switch statement is missing a default case: switch (normalResult.Kind)              {                  case MemberResolutionKind.RequiredParameterMissing:                  case MemberResolutionKind.NoCorrespondingParameter:                      switch (expandedResult.Kind)                      {                          case MemberResolutionKind.BadArguments:                          case MemberResolutionKind.NameUsedForPositional:                          case MemberResolutionKind.TypeInferenceFailed:                          case MemberResolutionKind.TypeInferenceExtensionInstanceArgument:                          case MemberResolutionKind.ConstructedParameterFailedConstraintCheck:                          case MemberResolutionKind.NoCorrespondingNamedParameter:                              return true;                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OverloadResolution,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,PreferExpandedFormOverNormalForm,The following switch statement is missing a default case: switch (expandedResult.Kind)                      {                          case MemberResolutionKind.BadArguments:                          case MemberResolutionKind.NameUsedForPositional:                          case MemberResolutionKind.TypeInferenceFailed:                          case MemberResolutionKind.TypeInferenceExtensionInstanceArgument:                          case MemberResolutionKind.ConstructedParameterFailedConstraintCheck:                          case MemberResolutionKind.NoCorrespondingNamedParameter:                              return true;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,BinopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\BinaryOperatorEasyOut.cs,TypeToIndex,The following switch statement is missing a default case: switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OperatorFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorFacts.cs,DefinitelyHasNoUserDefinedOperators,The following switch statement is missing a default case: switch (type.SpecialType)              {                  case SpecialType.System_Array:                  case SpecialType.System_Boolean:                  case SpecialType.System_Byte:                  case SpecialType.System_Char:                  case SpecialType.System_Decimal:                  case SpecialType.System_Delegate:                  case SpecialType.System_Double:                  case SpecialType.System_Enum:                  case SpecialType.System_Int16:                  case SpecialType.System_Int32:                  case SpecialType.System_Int64:                  case SpecialType.System_MulticastDelegate:                  case SpecialType.System_Object:                  case SpecialType.System_SByte:                  case SpecialType.System_Single:                  case SpecialType.System_String:                  case SpecialType.System_UInt16:                  case SpecialType.System_UInt32:                  case SpecialType.System_UInt64:                  case SpecialType.System_ValueType:                  case SpecialType.System_Void:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,WithOverflowChecksIfApplicable,The following switch statement is missing a default case: switch (kind.Operator())                      {                          case UnaryOperatorKind.PrefixIncrement:                          case UnaryOperatorKind.PostfixIncrement:                          case UnaryOperatorKind.PrefixDecrement:                          case UnaryOperatorKind.PostfixDecrement:                          case UnaryOperatorKind.UnaryMinus:                              return kind | UnaryOperatorKind.Checked;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,IsIntegral,The following switch statement is missing a default case: switch (kind.OperandTypes())              {                  case UnaryOperatorKind.SByte:                  case UnaryOperatorKind.Byte:                  case UnaryOperatorKind.Short:                  case UnaryOperatorKind.UShort:                  case UnaryOperatorKind.Int:                  case UnaryOperatorKind.UInt:                  case UnaryOperatorKind.Long:                  case UnaryOperatorKind.ULong:                  case UnaryOperatorKind.Char:                  case UnaryOperatorKind.Enum:                  case UnaryOperatorKind.Pointer:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,IsComparison,The following switch statement is missing a default case: switch (kind.Operator())              {                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.LessThanOrEqual:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,EmitsAsCheckedInstruction,The following switch statement is missing a default case: switch (kind.Operator())              {                  case BinaryOperatorKind.Addition:                  case BinaryOperatorKind.Subtraction:                  case BinaryOperatorKind.Multiplication:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,WithOverflowChecksIfApplicable,The following switch statement is missing a default case: switch (kind.Operator())                      {                          case BinaryOperatorKind.Addition:                          case BinaryOperatorKind.Subtraction:                          case BinaryOperatorKind.Multiplication:                          case BinaryOperatorKind.Division:                              return kind | BinaryOperatorKind.Checked;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,IsEnum,The following switch statement is missing a default case: switch (kind.OperandTypes())              {                  case BinaryOperatorKind.Enum:                  case BinaryOperatorKind.EnumAndUnderlying:                  case BinaryOperatorKind.UnderlyingAndEnum:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,IsIntegral,The following switch statement is missing a default case: switch (kind.OperandTypes())              {                  case BinaryOperatorKind.Int:                  case BinaryOperatorKind.UInt:                  case BinaryOperatorKind.Long:                  case BinaryOperatorKind.ULong:                  case BinaryOperatorKind.Char:                  case BinaryOperatorKind.Enum:                  case BinaryOperatorKind.EnumAndUnderlying:                  case BinaryOperatorKind.UnderlyingAndEnum:                  case BinaryOperatorKind.Pointer:                  case BinaryOperatorKind.PointerAndInt:                  case BinaryOperatorKind.PointerAndUInt:                  case BinaryOperatorKind.PointerAndLong:                  case BinaryOperatorKind.PointerAndULong:                  case BinaryOperatorKind.IntAndPointer:                  case BinaryOperatorKind.UIntAndPointer:                  case BinaryOperatorKind.LongAndPointer:                  case BinaryOperatorKind.ULongAndPointer:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,ToExpressionType,The following switch statement is missing a default case: switch (kind.Operator())                  {                      case BinaryOperatorKind.Multiplication: return ExpressionType.MultiplyAssign;                      case BinaryOperatorKind.Addition: return ExpressionType.AddAssign;                      case BinaryOperatorKind.Subtraction: return ExpressionType.SubtractAssign;                      case BinaryOperatorKind.Division: return ExpressionType.DivideAssign;                      case BinaryOperatorKind.Remainder: return ExpressionType.ModuloAssign;                      case BinaryOperatorKind.LeftShift: return ExpressionType.LeftShiftAssign;                      case BinaryOperatorKind.RightShift: return ExpressionType.RightShiftAssign;                      case BinaryOperatorKind.And: return ExpressionType.AndAssign;                      case BinaryOperatorKind.Xor: return ExpressionType.ExclusiveOrAssign;                      case BinaryOperatorKind.Or: return ExpressionType.OrAssign;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,OperatorKindExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\OperatorKindExtensions.cs,ToExpressionType,The following switch statement is missing a default case: switch (kind.Operator())                  {                      case BinaryOperatorKind.Multiplication: return ExpressionType.Multiply;                      case BinaryOperatorKind.Addition: return ExpressionType.Add;                      case BinaryOperatorKind.Subtraction: return ExpressionType.Subtract;                      case BinaryOperatorKind.Division: return ExpressionType.Divide;                      case BinaryOperatorKind.Remainder: return ExpressionType.Modulo;                      case BinaryOperatorKind.LeftShift: return ExpressionType.LeftShift;                      case BinaryOperatorKind.RightShift: return ExpressionType.RightShift;                      case BinaryOperatorKind.Equal: return ExpressionType.Equal;                      case BinaryOperatorKind.NotEqual: return ExpressionType.NotEqual;                      case BinaryOperatorKind.GreaterThan: return ExpressionType.GreaterThan;                      case BinaryOperatorKind.LessThan: return ExpressionType.LessThan;                      case BinaryOperatorKind.GreaterThanOrEqual: return ExpressionType.GreaterThanOrEqual;                      case BinaryOperatorKind.LessThanOrEqual: return ExpressionType.LessThanOrEqual;                      case BinaryOperatorKind.And: return ExpressionType.And;                      case BinaryOperatorKind.Xor: return ExpressionType.ExclusiveOr;                      case BinaryOperatorKind.Or: return ExpressionType.Or;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,UnopEasyOut,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\Operators\UnaryOperatorEasyOut.cs,TypeToIndex,The following switch statement is missing a default case: switch (underlyingType.GetSpecialTypeSafe())                              {                                  case SpecialType.System_Boolean: return 15;                                  case SpecialType.System_Char: return 16;                                  case SpecialType.System_SByte: return 17;                                  case SpecialType.System_Int16: return 18;                                  case SpecialType.System_Int32: return 19;                                  case SpecialType.System_Int64: return 20;                                  case SpecialType.System_Byte: return 21;                                  case SpecialType.System_UInt16: return 22;                                  case SpecialType.System_UInt32: return 23;                                  case SpecialType.System_UInt64: return 24;                                  case SpecialType.System_Single: return 25;                                  case SpecialType.System_Double: return 26;                                  case SpecialType.System_Decimal: return 27;                              }
Missing Default,Microsoft.CodeAnalysis.CSharp,ArgumentAnalysisResult,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\ArgumentAnalysisResult.cs,Dump,The following switch statement is missing a default case: switch (Kind)              {                  case ArgumentAnalysisResultKind.Normal:                      s += "Valid in normal form.";                      break;                  case ArgumentAnalysisResultKind.Expanded:                      s += "Valid in expanded form.";                      break;                  case ArgumentAnalysisResultKind.NameUsedForPositional:                      s += "Invalid because argument " + ArgumentPosition + " had a name.";                      break;                  case ArgumentAnalysisResultKind.NoCorrespondingParameter:                      s += "Invalid because argument " + ArgumentPosition + " has no corresponding parameter.";                      break;                  case ArgumentAnalysisResultKind.NoCorrespondingNamedParameter:                      s += "Invalid because named argument " + ArgumentPosition + " has no corresponding parameter.";                      break;                  case ArgumentAnalysisResultKind.RequiredParameterMissing:                      s += "Invalid because parameter " + ParameterPosition + " has no corresponding argument.";                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,MethodTypeInferrer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\MethodTypeInference.cs,Dump,The following switch statement is missing a default case: switch (_dependencies[i' j])                          {                              case Dependency.NotDependent:                                  sb.Append("N");                                  break;                              case Dependency.Direct:                                  sb.Append("D");                                  break;                              case Dependency.Indirect:                                  sb.Append("I");                                  break;                              case Dependency.Unknown:                                  sb.Append("U");                                  break;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp,OverloadResolutionResult<TMember>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\OverloadResolution\OverloadResolutionResult.cs,ReportDiagnostics,The following switch statement is missing a default case: switch (firstSupported.Result.Kind)                      {                          // Otherwise' if there is any such method that has a named argument and a positional                           // argument for the same parameter then the first such method is the best bad method.                          case MemberResolutionKind.NameUsedForPositional:                              ReportNameUsedForPositional(firstSupported' diagnostics' arguments' symbols);                              return;                            // Otherwise' if there is any such method that has a named argument that corresponds                          // to no parameter then the first such method is the best bad method.                          case MemberResolutionKind.NoCorrespondingNamedParameter:                              ReportNoCorrespondingNamedParameter(firstSupported' name' diagnostics' arguments' delegateTypeBeingInvoked' symbols);                              return;                            // Otherwise' if there is any such method that has a required parameter                          // but no argument was supplied for it then the first such method is                           // the best bad method.                          case MemberResolutionKind.RequiredParameterMissing:                              // CONSIDER: for consistency with dev12' we would goto default except in omitted ref cases.                              ReportMissingRequiredParameter(firstSupported' diagnostics' arguments' delegateTypeBeingInvoked' symbols' location);                              return;                            // NOTE: For some reason' there is no specific handling for this result kind.                          case MemberResolutionKind.NoCorrespondingParameter:                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,DeriveUseSiteDiagnosticFromType,The following switch statement is missing a default case: switch (this.Kind)                      {                          case SymbolKind.Field:                          case SymbolKind.Method:                          case SymbolKind.Property:                          case SymbolKind.Event:                              info = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus' this);                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,Symbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Binder\Semantics\SemanticFacts.cs,GetAttributeTarget,The following switch statement is missing a default case: switch (namedType.TypeKind)                      {                          case TypeKind.Class:                              return AttributeTargets.Class;                            case TypeKind.Delegate:                              return AttributeTargets.Delegate;                            case TypeKind.Enum:                              return AttributeTargets.Enum;                            case TypeKind.Interface:                              return AttributeTargets.Interface;                            case TypeKind.Struct:                              return AttributeTargets.Struct;                            case TypeKind.TypeParameter:                              return AttributeTargets.GenericParameter;                            case TypeKind.Submission:                              // attributes can't be applied on a submission type:                              throw ExceptionUtilities.UnexpectedValue(namedType.TypeKind);                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,BoundExpressionExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpressionExtensions.cs,NullableAlwaysHasValue,The following switch statement is missing a default case: switch (conversion.ConversionKind)                  {                      case ConversionKind.ImplicitNullable:                      case ConversionKind.ExplicitNullable:                          // A conversion from X? to Y? will be non-null if the operand is non-null'                          // so simply recurse.                          return conversion.Operand.NullableAlwaysHasValue();                      case ConversionKind.ImplicitEnumeration:                          // The C# specification categorizes conversion from literal zero to nullable enum as                           // an Implicit Enumeration Conversion.                           return conversion.Operand.NullableAlwaysHasValue();                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,BoundExpressionExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundExpressionExtensions.cs,NullableNeverHasValue,The following switch statement is missing a default case: switch (conversion.ConversionKind)                  {                      case ConversionKind.NullLiteral:                          // Any "null literal conversion" is a conversion from the literal null to                          // a nullable value type; obviously it never has a value.                          return true;                      case ConversionKind.ImplicitNullable:                      case ConversionKind.ExplicitNullable:                          // A conversion from X? to Y? will be null if the operand is null'                          // so simply recurse.                          return conversion.Operand.NullableNeverHasValue();                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,BoundTreeVisitor<A;R>,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs,Visit,The following switch statement is missing a default case: switch (node.Kind)              {                  case BoundKind.TypeExpression:                      return VisitTypeExpression(node as BoundTypeExpression' arg);                  case BoundKind.NamespaceExpression:                      return VisitNamespaceExpression(node as BoundNamespaceExpression' arg);                  case BoundKind.UnaryOperator:                      return VisitUnaryOperator(node as BoundUnaryOperator' arg);                  case BoundKind.IncrementOperator:                      return VisitIncrementOperator(node as BoundIncrementOperator' arg);                  case BoundKind.BinaryOperator:                      return VisitBinaryOperator(node as BoundBinaryOperator' arg);                  case BoundKind.CompoundAssignmentOperator:                      return VisitCompoundAssignmentOperator(node as BoundCompoundAssignmentOperator' arg);                  case BoundKind.AssignmentOperator:                      return VisitAssignmentOperator(node as BoundAssignmentOperator' arg);                  case BoundKind.NullCoalescingOperator:                      return VisitNullCoalescingOperator(node as BoundNullCoalescingOperator' arg);                  case BoundKind.ConditionalOperator:                      return VisitConditionalOperator(node as BoundConditionalOperator' arg);                  case BoundKind.ArrayAccess:                      return VisitArrayAccess(node as BoundArrayAccess' arg);                  case BoundKind.TypeOfOperator:                      return VisitTypeOfOperator(node as BoundTypeOfOperator' arg);                  case BoundKind.DefaultOperator:                      return VisitDefaultOperator(node as BoundDefaultOperator' arg);                  case BoundKind.IsOperator:                      return VisitIsOperator(node as BoundIsOperator' arg);                  case BoundKind.AsOperator:                      return VisitAsOperator(node as BoundAsOperator' arg);                  case BoundKind.Conversion:                      return VisitConversion(node as BoundConversion' arg);                  case BoundKind.SequencePointExpression:                      return VisitSequencePointExpression(node as BoundSequencePointExpression' arg);                  case BoundKind.SequencePoint:                      return VisitSequencePoint(node as BoundSequencePoint' arg);                  case BoundKind.SequencePointWithSpan:                      return VisitSequencePointWithSpan(node as BoundSequencePointWithSpan' arg);                  case BoundKind.Block:                      return VisitBlock(node as BoundBlock' arg);                  case BoundKind.LocalDeclaration:                      return VisitLocalDeclaration(node as BoundLocalDeclaration' arg);                  case BoundKind.MultipleLocalDeclarations:                      return VisitMultipleLocalDeclarations(node as BoundMultipleLocalDeclarations' arg);                  case BoundKind.Sequence:                      return VisitSequence(node as BoundSequence' arg);                  case BoundKind.NoOpStatement:                      return VisitNoOpStatement(node as BoundNoOpStatement' arg);                  case BoundKind.ReturnStatement:                      return VisitReturnStatement(node as BoundReturnStatement' arg);                  case BoundKind.ThrowStatement:                      return VisitThrowStatement(node as BoundThrowStatement' arg);                  case BoundKind.ExpressionStatement:                      return VisitExpressionStatement(node as BoundExpressionStatement' arg);                  case BoundKind.SwitchStatement:                      return VisitSwitchStatement(node as BoundSwitchStatement' arg);                  case BoundKind.BreakStatement:                      return VisitBreakStatement(node as BoundBreakStatement' arg);                  case BoundKind.ContinueStatement:                      return VisitContinueStatement(node as BoundContinueStatement' arg);                  case BoundKind.IfStatement:                      return VisitIfStatement(node as BoundIfStatement' arg);                  case BoundKind.ForEachStatement:                      return VisitForEachStatement(node as BoundForEachStatement' arg);                  case BoundKind.TryStatement:                      return VisitTryStatement(node as BoundTryStatement' arg);                  case BoundKind.Literal:                      return VisitLiteral(node as BoundLiteral' arg);                  case BoundKind.ThisReference:                      return VisitThisReference(node as BoundThisReference' arg);                  case BoundKind.Local:                      return VisitLocal(node as BoundLocal' arg);                  case BoundKind.Parameter:                      return VisitParameter(node as BoundParameter' arg);                  case BoundKind.LabelStatement:                      return VisitLabelStatement(node as BoundLabelStatement' arg);                  case BoundKind.GotoStatement:                      return VisitGotoStatement(node as BoundGotoStatement' arg);                  case BoundKind.LabeledStatement:                      return VisitLabeledStatement(node as BoundLabeledStatement' arg);                  case BoundKind.StatementList:                      return VisitStatementList(node as BoundStatementList' arg);                  case BoundKind.ConditionalGoto:                      return VisitConditionalGoto(node as BoundConditionalGoto' arg);                  case BoundKind.Call:                      return VisitCall(node as BoundCall' arg);                  case BoundKind.ObjectCreationExpression:                      return VisitObjectCreationExpression(node as BoundObjectCreationExpression' arg);                  case BoundKind.DelegateCreationExpression:                      return VisitDelegateCreationExpression(node as BoundDelegateCreationExpression' arg);                  case BoundKind.FieldAccess:                      return VisitFieldAccess(node as BoundFieldAccess' arg);                  case BoundKind.PropertyAccess:                      return VisitPropertyAccess(node as BoundPropertyAccess' arg);                  case BoundKind.Lambda:                      return VisitLambda(node as BoundLambda' arg);                  case BoundKind.NameOfOperator:                      return VisitNameOfOperator(node as BoundNameOfOperator' arg);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,AttributeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\AttributeSemanticModel.cs,GetBindableSyntaxNode,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.Attribute:                      return node;                    case SyntaxKind.AttributeArgument:                      // Try to walk up to the AttributeSyntax                      var parent = node.Parent;                      if (parent != null)                      {                          parent = parent.Parent;                          if (parent != null)                          {                              return parent;                          }                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The following switch statement is missing a default case: switch (kind.OperandTypes())                  {                      case UnaryOperatorKind.SByte: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_SByte)); break;                      case UnaryOperatorKind.Byte: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Byte)); break;                      case UnaryOperatorKind.Short: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Int16)); break;                      case UnaryOperatorKind.UShort: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_UInt16)); break;                      case UnaryOperatorKind.Int: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Int32)); break;                      case UnaryOperatorKind.UInt: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_UInt32)); break;                      case UnaryOperatorKind.Long: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Int64)); break;                      case UnaryOperatorKind.ULong: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_UInt64)); break;                      case UnaryOperatorKind.Char: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Char)); break;                      case UnaryOperatorKind.Float: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Single)); break;                      case UnaryOperatorKind.Double: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Double)); break;                      case UnaryOperatorKind.Decimal: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Decimal)); break;                      case UnaryOperatorKind.Bool: opType = nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Boolean)); break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The following switch statement is missing a default case: switch (kind.OperandTypes())                  {                      case UnaryOperatorKind.SByte: opType = _compilation.GetSpecialType(SpecialType.System_SByte); break;                      case UnaryOperatorKind.Byte: opType = _compilation.GetSpecialType(SpecialType.System_Byte); break;                      case UnaryOperatorKind.Short: opType = _compilation.GetSpecialType(SpecialType.System_Int16); break;                      case UnaryOperatorKind.UShort: opType = _compilation.GetSpecialType(SpecialType.System_UInt16); break;                      case UnaryOperatorKind.Int: opType = _compilation.GetSpecialType(SpecialType.System_Int32); break;                      case UnaryOperatorKind.UInt: opType = _compilation.GetSpecialType(SpecialType.System_UInt32); break;                      case UnaryOperatorKind.Long: opType = _compilation.GetSpecialType(SpecialType.System_Int64); break;                      case UnaryOperatorKind.ULong: opType = _compilation.GetSpecialType(SpecialType.System_UInt64); break;                      case UnaryOperatorKind.Char: opType = _compilation.GetSpecialType(SpecialType.System_Char); break;                      case UnaryOperatorKind.Float: opType = _compilation.GetSpecialType(SpecialType.System_Single); break;                      case UnaryOperatorKind.Double: opType = _compilation.GetSpecialType(SpecialType.System_Double); break;                      case UnaryOperatorKind.Decimal: opType = _compilation.GetSpecialType(SpecialType.System_Decimal); break;                      case UnaryOperatorKind.Bool: opType = _compilation.GetSpecialType(SpecialType.System_Boolean); break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,GetSignature,The following switch statement is missing a default case: switch (kind.Operator())              {                  case BinaryOperatorKind.Multiplication:                  case BinaryOperatorKind.Division:                  case BinaryOperatorKind.Subtraction:                  case BinaryOperatorKind.Remainder:                  case BinaryOperatorKind.And:                  case BinaryOperatorKind.Or:                  case BinaryOperatorKind.Xor:                      return new BinaryOperatorSignature(kind' left' left' left);                  case BinaryOperatorKind.Addition:                      return new BinaryOperatorSignature(kind' LeftType(kind)' RightType(kind)' ReturnType(kind));                  case BinaryOperatorKind.LeftShift:                    case BinaryOperatorKind.RightShift:                      TypeSymbol returnType = _compilation.GetSpecialType(SpecialType.System_Int32);                        if (kind.IsLifted())                      {                          returnType = _compilation.GetSpecialType(SpecialType.System_Nullable_T).Construct(returnType);                      }                        return new BinaryOperatorSignature(kind' left' returnType' left);                    case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                  case BinaryOperatorKind.LessThanOrEqual:                      return new BinaryOperatorSignature(kind' left' left' _compilation.GetSpecialType(SpecialType.System_Boolean));              }
Missing Default,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,LeftType,The following switch statement is missing a default case: switch (kind.OperandTypes())                  {                      case BinaryOperatorKind.Int: return _compilation.GetSpecialType(SpecialType.System_Int32);                      case BinaryOperatorKind.UInt: return _compilation.GetSpecialType(SpecialType.System_UInt32);                      case BinaryOperatorKind.Long: return _compilation.GetSpecialType(SpecialType.System_Int64);                      case BinaryOperatorKind.ULong: return _compilation.GetSpecialType(SpecialType.System_UInt64);                      case BinaryOperatorKind.Float: return _compilation.GetSpecialType(SpecialType.System_Single);                      case BinaryOperatorKind.Double: return _compilation.GetSpecialType(SpecialType.System_Double);                      case BinaryOperatorKind.Decimal: return _compilation.GetSpecialType(SpecialType.System_Decimal);                      case BinaryOperatorKind.Bool: return _compilation.GetSpecialType(SpecialType.System_Boolean);                      case BinaryOperatorKind.ObjectAndString:                      case BinaryOperatorKind.Object:                          return _compilation.GetSpecialType(SpecialType.System_Object);                      case BinaryOperatorKind.String:                      case BinaryOperatorKind.StringAndObject:                          return _compilation.GetSpecialType(SpecialType.System_String);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,RightType,The following switch statement is missing a default case: switch (kind.OperandTypes())                  {                      case BinaryOperatorKind.Int: return _compilation.GetSpecialType(SpecialType.System_Int32);                      case BinaryOperatorKind.UInt: return _compilation.GetSpecialType(SpecialType.System_UInt32);                      case BinaryOperatorKind.Long: return _compilation.GetSpecialType(SpecialType.System_Int64);                      case BinaryOperatorKind.ULong: return _compilation.GetSpecialType(SpecialType.System_UInt64);                      case BinaryOperatorKind.Float: return _compilation.GetSpecialType(SpecialType.System_Single);                      case BinaryOperatorKind.Double: return _compilation.GetSpecialType(SpecialType.System_Double);                      case BinaryOperatorKind.Decimal: return _compilation.GetSpecialType(SpecialType.System_Decimal);                      case BinaryOperatorKind.Bool: return _compilation.GetSpecialType(SpecialType.System_Boolean);                      case BinaryOperatorKind.ObjectAndString:                      case BinaryOperatorKind.String:                          return _compilation.GetSpecialType(SpecialType.System_String);                      case BinaryOperatorKind.StringAndObject:                      case BinaryOperatorKind.Object:                          return _compilation.GetSpecialType(SpecialType.System_Object);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,ReturnType,The following switch statement is missing a default case: switch (kind.OperandTypes())                  {                      case BinaryOperatorKind.Int: return _compilation.GetSpecialType(SpecialType.System_Int32);                      case BinaryOperatorKind.UInt: return _compilation.GetSpecialType(SpecialType.System_UInt32);                      case BinaryOperatorKind.Long: return _compilation.GetSpecialType(SpecialType.System_Int64);                      case BinaryOperatorKind.ULong: return _compilation.GetSpecialType(SpecialType.System_UInt64);                      case BinaryOperatorKind.Float: return _compilation.GetSpecialType(SpecialType.System_Single);                      case BinaryOperatorKind.Double: return _compilation.GetSpecialType(SpecialType.System_Double);                      case BinaryOperatorKind.Decimal: return _compilation.GetSpecialType(SpecialType.System_Decimal);                      case BinaryOperatorKind.Bool: return _compilation.GetSpecialType(SpecialType.System_Boolean);                      case BinaryOperatorKind.Object: return _compilation.GetSpecialType(SpecialType.System_Object);                      case BinaryOperatorKind.ObjectAndString:                      case BinaryOperatorKind.StringAndObject:                      case BinaryOperatorKind.String:                          return _compilation.GetSpecialType(SpecialType.System_String);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,BuiltInOperators,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\BuiltInOperators.cs,LiftedType,The following switch statement is missing a default case: switch (kind.OperandTypes())              {                  case BinaryOperatorKind.Int: return nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Int32));                  case BinaryOperatorKind.UInt: return nullable.Construct(_compilation.GetSpecialType(SpecialType.System_UInt32));                  case BinaryOperatorKind.Long: return nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Int64));                  case BinaryOperatorKind.ULong: return nullable.Construct(_compilation.GetSpecialType(SpecialType.System_UInt64));                  case BinaryOperatorKind.Float: return nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Single));                  case BinaryOperatorKind.Double: return nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Double));                  case BinaryOperatorKind.Decimal: return nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Decimal));                  case BinaryOperatorKind.Bool: return nullable.Construct(_compilation.GetSpecialType(SpecialType.System_Boolean));              }
Missing Default,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,HasParameterList,The following switch statement is missing a default case: switch (crefSyntax.Kind())              {                  case SyntaxKind.NameMemberCref:                      return ((NameMemberCrefSyntax)crefSyntax).Parameters != null;                  case SyntaxKind.IndexerMemberCref:                      return ((IndexerMemberCrefSyntax)crefSyntax).Parameters != null;                  case SyntaxKind.OperatorMemberCref:                      return ((OperatorMemberCrefSyntax)crefSyntax).Parameters != null;                  case SyntaxKind.ConversionOperatorMemberCref:                      return ((ConversionOperatorMemberCrefSyntax)crefSyntax).Parameters != null;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetPropertyGroupSemanticSymbols,The following switch statement is missing a default case: switch (boundNodeForSyntacticParent.Kind)                  {                      case BoundKind.IndexerAccess:                          // If we are looking for info on P in P[args]' we want the symbol that overload resolution                          // chose for P.                          var indexer = (BoundIndexerAccess)boundNodeForSyntacticParent;                          var elementAccess = indexer.Syntax as ElementAccessExpressionSyntax;                          if (elementAccess != null && elementAccess.Expression == boundNode.Syntax && (object)indexer.Indexer != null)                          {                              if (indexer.OriginalIndexersOpt.IsDefault)                              {                                  // Overload resolution succeeded.                                  symbols = ImmutableArray.Create<Symbol>(indexer.Indexer);                                  resultKind = LookupResultKind.Viable;                              }                              else                              {                                  resultKind = indexer.ResultKind.WorseResultKind(LookupResultKind.OverloadResolutionFailure);                                  symbols = StaticCast<Symbol>.From(indexer.OriginalIndexersOpt);                              }                          }                          break;                        case BoundKind.BadExpression:                          // If the bad expression has symbol(s) from this property group' it better indicates any problems.                          ImmutableArray<Symbol> myPropertyGroup = propertyGroup;                            symbols = ((BoundBadExpression)boundNodeForSyntacticParent).Symbols.WhereAsArray(sym => myPropertyGroup.Contains(sym));                          if (symbols.Any())                          {                              resultKind = ((BoundBadExpression)boundNodeForSyntacticParent).ResultKind;                          }                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetDeclaredSymbolCore,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.LabeledStatement:                      return this.GetDeclaredSymbol((LabeledStatementSyntax)node' cancellationToken);                  case SyntaxKind.CaseSwitchLabel:                  case SyntaxKind.DefaultSwitchLabel:                      return this.GetDeclaredSymbol((SwitchLabelSyntax)node' cancellationToken);                  case SyntaxKind.AnonymousObjectCreationExpression:                      return this.GetDeclaredSymbol((AnonymousObjectCreationExpressionSyntax)node' cancellationToken);                  case SyntaxKind.AnonymousObjectMemberDeclarator:                      return this.GetDeclaredSymbol((AnonymousObjectMemberDeclaratorSyntax)node' cancellationToken);                  case SyntaxKind.VariableDeclarator:                      return this.GetDeclaredSymbol((VariableDeclaratorSyntax)node' cancellationToken);                  case SyntaxKind.NamespaceDeclaration:                      return this.GetDeclaredSymbol((NamespaceDeclarationSyntax)node' cancellationToken);                  case SyntaxKind.Parameter:                      return this.GetDeclaredSymbol((ParameterSyntax)node' cancellationToken);                  case SyntaxKind.TypeParameter:                      return this.GetDeclaredSymbol((TypeParameterSyntax)node' cancellationToken);                  case SyntaxKind.UsingDirective:                      var usingDirective = (UsingDirectiveSyntax)node;                      if (usingDirective.Alias != null)                      {                          return this.GetDeclaredSymbol(usingDirective' cancellationToken);                      }                        break;                  case SyntaxKind.ForEachStatement:                      return this.GetDeclaredSymbol((ForEachStatementSyntax)node' cancellationToken);                  case SyntaxKind.CatchDeclaration:                      return this.GetDeclaredSymbol((CatchDeclarationSyntax)node' cancellationToken);                  case SyntaxKind.JoinIntoClause:                      return this.GetDeclaredSymbol((JoinIntoClauseSyntax)node' cancellationToken);                  case SyntaxKind.QueryContinuation:                      return this.GetDeclaredSymbol((QueryContinuationSyntax)node' cancellationToken);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,CSharpSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs,GetTopmostNodeForDiagnosticAnalysis,The following switch statement is missing a default case: switch (symbol.Kind)              {                  case SymbolKind.Event:  // for field-like events                  case SymbolKind.Field:                      var fieldDecl = declaringSyntax.FirstAncestorOrSelf<BaseFieldDeclarationSyntax>();                      if (fieldDecl != null)                      {                          return fieldDecl;                      }                        break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,InitializerSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\InitializerSemanticModel.cs,Bind,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.EqualsValueClause:                      equalsValue = (EqualsValueClauseSyntax)node;                      break;                    case SyntaxKind.VariableDeclarator:                      equalsValue = ((VariableDeclaratorSyntax)node).Initializer;                      break;                    case SyntaxKind.PropertyDeclaration:                      equalsValue = ((PropertyDeclarationSyntax)node).Initializer;                      break;                    case SyntaxKind.Parameter:                      equalsValue = ((ParameterSyntax)node).Default;                      break;                    case SyntaxKind.EnumMemberDeclaration:                      equalsValue = ((EnumMemberDeclarationSyntax)node).EqualsValue;                      break;                    case SyntaxKind.BaseConstructorInitializer:                  case SyntaxKind.ThisConstructorInitializer:                      return binder.BindConstructorInitializer(((ConstructorInitializerSyntax)node).ArgumentList' (MethodSymbol)MemberSymbol' diagnostics);                    case SyntaxKind.ArgumentList:                      return binder.BindConstructorInitializer((ArgumentListSyntax)node' (MethodSymbol)MemberSymbol' diagnostics);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetBindingRoot,The following switch statement is missing a default case: switch (current.Kind())                  {                      case SyntaxKind.ParenthesizedLambdaExpression:                      case SyntaxKind.SimpleLambdaExpression:                      case SyntaxKind.AnonymousMethodExpression:                          // We can't use a statement that is inside a lambda.                          enclosingStatement = null;                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetBindableSyntaxNode,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.GetAccessorDeclaration:                  case SyntaxKind.SetAccessorDeclaration:                  case SyntaxKind.AddAccessorDeclaration:                  case SyntaxKind.RemoveAccessorDeclaration:                      return ((AccessorDeclarationSyntax)node).Body;                  case SyntaxKind.MethodDeclaration:                  case SyntaxKind.ConstructorDeclaration:                  case SyntaxKind.DestructorDeclaration:                  case SyntaxKind.OperatorDeclaration:                  case SyntaxKind.ConversionOperatorDeclaration:                      return ((BaseMethodDeclarationSyntax)node).Body;                  case SyntaxKind.GlobalStatement:                      return node;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,MemberSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs,GetBindableSyntaxNode,The following switch statement is missing a default case: switch (node.Kind())                  {                      case SyntaxKind.ParenthesizedExpression:                          node = ((ParenthesizedExpressionSyntax)node).Expression;                          continue;                        case SyntaxKind.CheckedExpression:                      case SyntaxKind.UncheckedExpression:                          node = ((CheckedExpressionSyntax)node).Expression;                          continue;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetMemberModel,The following switch statement is missing a default case: switch (memberDecl.Kind())                  {                      case SyntaxKind.AddAccessorDeclaration:                      case SyntaxKind.RemoveAccessorDeclaration:                      case SyntaxKind.GetAccessorDeclaration:                      case SyntaxKind.SetAccessorDeclaration:                          // NOTE: not UnknownAccessorDeclaration since there's no corresponding method symbol from which to build a member model.                          outsideMemberDecl = !LookupPosition.IsInBlock(position' ((AccessorDeclarationSyntax)memberDecl).Body);                          break;                      case SyntaxKind.ConstructorDeclaration:                          var constructorDecl = (ConstructorDeclarationSyntax)memberDecl;                          outsideMemberDecl =                              !LookupPosition.IsInConstructorParameterScope(position' constructorDecl) &&                              !LookupPosition.IsInParameterList(position' constructorDecl);                          break;                      case SyntaxKind.ConversionOperatorDeclaration:                      case SyntaxKind.DestructorDeclaration:                      case SyntaxKind.MethodDeclaration:                      case SyntaxKind.OperatorDeclaration:                          var methodDecl = (BaseMethodDeclarationSyntax)memberDecl;                          outsideMemberDecl =                              !LookupPosition.IsInBlock(position' methodDecl.Body) &&                              !LookupPosition.IsInParameterList(position' methodDecl) &&                              !LookupPosition.IsInExpressionBody(position' methodDecl.GetExpressionBodySyntax()' methodDecl.SemicolonToken);                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetMemberModel,The following switch statement is missing a default case: switch (memberDecl.Kind())                  {                      case SyntaxKind.DelegateDeclaration:                          {                              DelegateDeclarationSyntax delegateDecl = (DelegateDeclarationSyntax)memberDecl;                              return GetOrAddModelForParameterDefaultValue(delegateDecl.ParameterList.Parameters' span);                          }                      case SyntaxKind.MethodDeclaration:                      case SyntaxKind.ConversionOperatorDeclaration:                      case SyntaxKind.OperatorDeclaration:                          {                              var methodDecl = (BaseMethodDeclarationSyntax)memberDecl;                              var expressionBody = methodDecl.GetExpressionBodySyntax();                              return GetOrAddModelForParameterDefaultValue(methodDecl.ParameterList.Parameters' span) ??                                     GetOrAddModelIfContains(expressionBody' span) ??                                     GetOrAddModelIfContains(methodDecl.Body' span);                          }                        case SyntaxKind.ConstructorDeclaration:                          {                              ConstructorDeclarationSyntax constructorDecl = (ConstructorDeclarationSyntax)memberDecl;                              return GetOrAddModelForParameterDefaultValue(constructorDecl.ParameterList.Parameters' span) ??                                  GetOrAddModelIfContains(constructorDecl.Initializer' span) ??                                  GetOrAddModelIfContains(constructorDecl.Body' span);                          }                        case SyntaxKind.DestructorDeclaration:                          {                              DestructorDeclarationSyntax destructorDecl = (DestructorDeclarationSyntax)memberDecl;                              return GetOrAddModelIfContains(destructorDecl.Body' span);                          }                        case SyntaxKind.IndexerDeclaration:                          {                              var indexerDecl = (IndexerDeclarationSyntax)memberDecl;                              return GetOrAddModelForParameterDefaultValue(                                  indexerDecl.ParameterList.Parameters' span) ??                                  GetOrAddModelIfContains(indexerDecl.ExpressionBody' span);                          }                        case SyntaxKind.FieldDeclaration:                      case SyntaxKind.EventFieldDeclaration:                          {                              var fieldDecl = (BaseFieldDeclarationSyntax)memberDecl;                              foreach (var variableDecl in fieldDecl.Declaration.Variables)                              {                                  var binding = GetOrAddModelIfContains(variableDecl.Initializer' span);                                  if (binding != null)                                  {                                      return binding;                                  }                              }                          }                          break;                        case SyntaxKind.EnumMemberDeclaration:                          {                              var enumDecl = (EnumMemberDeclarationSyntax)memberDecl;                              return (enumDecl.EqualsValue != null) ?                                  GetOrAddModelIfContains(enumDecl.EqualsValue' span) :                                  null;                          }                        case SyntaxKind.PropertyDeclaration:                          {                              var propertyDecl = (PropertyDeclarationSyntax)memberDecl;                              return GetOrAddModelIfContains(propertyDecl.Initializer' span) ??                                  GetOrAddModelIfContains(propertyDecl.ExpressionBody' span);                          }                        case SyntaxKind.GetAccessorDeclaration:                      case SyntaxKind.SetAccessorDeclaration:                      case SyntaxKind.AddAccessorDeclaration:                      case SyntaxKind.RemoveAccessorDeclaration:                          // NOTE: not UnknownAccessorDeclaration since there's no corresponding method symbol from which to build a member model.                          return GetOrAddModelIfContains(((AccessorDeclarationSyntax)memberDecl).Body' span);                        case SyntaxKind.GlobalStatement:                          return GetOrAddModel(memberDecl);                        case SyntaxKind.Attribute:                          return GetOrAddModel(memberDecl);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxTreeSemanticModel,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs,GetDeclaredFieldSymbol,The following switch statement is missing a default case: switch (variableDecl.Parent.Parent.Kind())                  {                      case SyntaxKind.FieldDeclaration:                          return (SourceMemberFieldSymbol)declaredSymbol;                        case SyntaxKind.EventFieldDeclaration:                          return (SourceMemberFieldSymbol)((EventSymbol)declaredSymbol).AssociatedField;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,ClsComplianceChecker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\ClsComplianceChecker.cs,IsCompliantType,The following switch statement is missing a default case: switch (type.SpecialType)              {                  case SpecialType.System_TypedReference:                  case SpecialType.System_UIntPtr:                      // Hard-coded in dev11 (LangCompiler::isCLS_Type).                      return false;                    case SpecialType.System_SByte: // sic                  case SpecialType.System_UInt16:                  case SpecialType.System_UInt32:                  case SpecialType.System_UInt64:                      // Dev11 calls these "quasi-simple" types and hard-codes false.                      return false;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,GetParameters,The following switch statement is missing a default case: switch (symbol.Kind)              {                  case SymbolKind.NamedType:                      MethodSymbol delegateInvoke = ((NamedTypeSymbol)symbol).DelegateInvokeMethod;                      if ((object)delegateInvoke != null)                      {                          return delegateInvoke.Parameters;                      }                      break;                  case SymbolKind.Method:                  case SymbolKind.Property:                  case SymbolKind.Event:                      return symbol.GetParameters();              }
Missing Default,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,GetTypeParameters,The following switch statement is missing a default case: switch (symbol.Kind)              {                  case SymbolKind.Method:                  case SymbolKind.NamedType:                  case SymbolKind.ErrorType:                      return symbol.GetMemberTypeParameters();              }
Missing Default,Microsoft.CodeAnalysis.CSharp,DocumentationCommentCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.cs,IndexOfNewLine,The following switch statement is missing a default case: switch (str[start])                  {                      case '\r':                          if ((start + 1) < str.Length && str[start + 1] == '\n')                          {                              newLineLength = 2;                          }                          else                          {                              newLineLength = 1;                          }                          return start;                        case '\n':                          newLineLength = 1;                          return start;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,MakeNameBinder,The following switch statement is missing a default case: switch (memberSymbol.Kind)                      {                          case SymbolKind.Method:                              parameters = ((MethodSymbol)memberSymbol).Parameters;                              break;                          case SymbolKind.Property:                              parameters = ((PropertySymbol)memberSymbol).Parameters;                              break;                          case SymbolKind.NamedType:                          case SymbolKind.ErrorType:                              NamedTypeSymbol typeSymbol = (NamedTypeSymbol)memberSymbol;                              if (typeSymbol.IsDelegateType())                              {                                  parameters = typeSymbol.DelegateInvokeMethod.Parameters;                              }                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,IncludeElementExpander,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\DocumentationCommentCompiler.IncludeElementExpander.cs,MakeNameBinder,The following switch statement is missing a default case: switch (memberSymbol.Kind)                      {                          case SymbolKind.NamedType: // Includes delegates.                          case SymbolKind.ErrorType:                              NamedTypeSymbol typeSymbol = (NamedTypeSymbol)memberSymbol;                              if (typeSymbol.Arity > 0)                              {                                  binder = new WithClassTypeParametersBinder(typeSymbol' binder);                              }                              break;                          case SymbolKind.Method:                              MethodSymbol methodSymbol = (MethodSymbol)memberSymbol;                              if (methodSymbol.Arity > 0)                              {                                  binder = new WithMethodTypeParametersBinder(methodSymbol' binder);                              }                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,EntryPointCandidateFinder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\EntryPointCandidateFinder.cs,VisitNamedType,The following switch statement is missing a default case: switch (member.Kind)                  {                      case SymbolKind.NamedType:                          if (_visitNestedTypes)                          {                              member.Accept(this' arg);                          }                          break;                        case SymbolKind.Method:                          {                              MethodSymbol method = (MethodSymbol)member;                              if (method.IsPartialDefinition())                              {                                  if ((object)method.PartialImplementationPart == null)                                  {                                      continue;                                  }                              }                                if (_entryPointCandidates != null && method.IsEntryPointCandidate)                              {                                  _entryPointCandidates.Add(method);                              }                              break;                          }                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,MethodCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs,CompileNamedType,The following switch statement is missing a default case: switch (member.Kind)                  {                      case SymbolKind.NamedType:                          member.Accept(this' compilationState);                          break;                        case SymbolKind.Method:                          {                              MethodSymbol method = (MethodSymbol)member;                              if (method.IsSubmissionConstructor)                              {                                  Debug.Assert(submissionCtorOrdinal == -1);                                  submissionCtorOrdinal = memberOrdinal;                                  continue;                              }                                                                if (IsFieldLikeEventAccessor(method))                              {                                  continue;                              }                                if (method.IsPartialDefinition())                              {                                  method = method.PartialImplementationPart;                                  if ((object)method == null)                                  {                                      continue;                                  }                              }                                Binder.ProcessedFieldInitializers processedInitializers =                                  method.MethodKind == MethodKind.Constructor ? processedInstanceInitializers :                                  method.MethodKind == MethodKind.StaticConstructor ? processedStaticInitializers :                                  default(Binder.ProcessedFieldInitializers);                                CompileMethod(method' memberOrdinal' ref processedInitializers' synthesizedSubmissionFields' compilationState);                                // Set a flag to indicate that a static constructor is created.                              if (method.MethodKind == MethodKind.StaticConstructor)                              {                                  hasStaticConstructor = true;                              }                                break;                          }                        case SymbolKind.Property:                          {                              SourcePropertySymbol sourceProperty = member as SourcePropertySymbol;                              if ((object)sourceProperty != null && sourceProperty.IsSealed && compilationState.Emitting)                              {                                  CompileSynthesizedSealedAccessors(sourceProperty' compilationState);                              }                              break;                          }                        case SymbolKind.Event:                          {                              SourceEventSymbol eventSymbol = member as SourceEventSymbol;                              if ((object)eventSymbol != null && eventSymbol.HasAssociatedField && !eventSymbol.IsAbstract && compilationState.Emitting)                              {                                  CompileFieldLikeEventAccessor(eventSymbol' isAddMethod: true);                                  CompileFieldLikeEventAccessor(eventSymbol' isAddMethod: false);                              }                              break;                          }                        case SymbolKind.Field:                          {                              SourceMemberFieldSymbol fieldSymbol = member as SourceMemberFieldSymbol;                              if ((object)fieldSymbol != null)                              {                                  if (fieldSymbol.IsConst)                                  {                                      // We check specifically for constant fields with bad values because they never result                                      // in bound nodes being inserted into method bodies (in which case' they would be covered                                      // by the method-level check).                                      ConstantValue constantValue = fieldSymbol.GetConstantValue(ConstantFieldsInProgress.Empty' earlyDecodingWellKnownAttributes: false);                                      SetGlobalErrorIfTrue(constantValue == null || constantValue.IsBad);                                  }                                    if (fieldSymbol.IsFixed && compilationState.Emitting)                                  {                                      // force the generation of implementation types for fixed-size buffers                                      TypeSymbol discarded = fieldSymbol.FixedImplementationType(compilationState.ModuleBuilderOpt);                                  }                              }                              break;                          }                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,SynthesizedMetadataCompiler,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Compiler\SynthesizedMetadataCompiler.cs,VisitNamedType,The following switch statement is missing a default case: switch (member.Kind)                  {                      case SymbolKind.Property:                      case SymbolKind.NamedType:                          member.Accept(this);                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,DeclarationTreeBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTreeBuilder.cs,CheckMemberForAttributes,The following switch statement is missing a default case: switch (member.Kind)              {                  case SyntaxKind.CompilationUnit:                      return (((Syntax.InternalSyntax.CompilationUnitSyntax)member).AttributeLists).Any();                    case SyntaxKind.ClassDeclaration:                  case SyntaxKind.StructDeclaration:                  case SyntaxKind.InterfaceDeclaration:                  case SyntaxKind.EnumDeclaration:                      return (((Syntax.InternalSyntax.BaseTypeDeclarationSyntax)member).AttributeLists).Any();                    case SyntaxKind.DelegateDeclaration:                      return (((Syntax.InternalSyntax.DelegateDeclarationSyntax)member).AttributeLists).Any();                    case SyntaxKind.FieldDeclaration:                  case SyntaxKind.EventFieldDeclaration:                      return (((Syntax.InternalSyntax.BaseFieldDeclarationSyntax)member).AttributeLists).Any();                    case SyntaxKind.MethodDeclaration:                  case SyntaxKind.OperatorDeclaration:                  case SyntaxKind.ConversionOperatorDeclaration:                  case SyntaxKind.ConstructorDeclaration:                  case SyntaxKind.DestructorDeclaration:                      return (((Syntax.InternalSyntax.BaseMethodDeclarationSyntax)member).AttributeLists).Any();                    case SyntaxKind.PropertyDeclaration:                  case SyntaxKind.EventDeclaration:                  case SyntaxKind.IndexerDeclaration:                      var baseProp = (Syntax.InternalSyntax.BasePropertyDeclarationSyntax)member;                      bool hasAttributes = baseProp.AttributeLists.Any();                        if (!hasAttributes && baseProp.AccessorList != null)                      {                          foreach (var accessor in baseProp.AccessorList.Accessors)                          {                              hasAttributes |= accessor.AttributeLists.Any();                          }                      }                        return hasAttributes;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,DeclarationTreeBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Declarations\DeclarationTreeBuilder.cs,AddNonTypeMemberNames,The following switch statement is missing a default case: switch (member.Kind)              {                  case SyntaxKind.FieldDeclaration:                      anyNonTypeMembers = true;                      Syntax.InternalSyntax.SeparatedSyntaxList<Syntax.InternalSyntax.VariableDeclaratorSyntax> fieldDeclarators =                          ((Syntax.InternalSyntax.FieldDeclarationSyntax)member).Declaration.Variables;                      int numFieldDeclarators = fieldDeclarators.Count;                      for (int i = 0; i < numFieldDeclarators; i++)                      {                          set.Add(fieldDeclarators[i].Identifier.ValueText);                      }                      break;                    case SyntaxKind.EventFieldDeclaration:                      anyNonTypeMembers = true;                      Syntax.InternalSyntax.SeparatedSyntaxList<Syntax.InternalSyntax.VariableDeclaratorSyntax> eventDeclarators =                          ((Syntax.InternalSyntax.EventFieldDeclarationSyntax)member).Declaration.Variables;                      int numEventDeclarators = eventDeclarators.Count;                      for (int i = 0; i < numEventDeclarators; i++)                      {                          set.Add(eventDeclarators[i].Identifier.ValueText);                      }                      break;                    case SyntaxKind.MethodDeclaration:                      anyNonTypeMembers = true;                      // Member names are exposed via NamedTypeSymbol.MemberNames and are used primarily                      // as an acid test to determine whether a more in-depth search of a type is worthwhile.                      // We decided that it was reasonable to exclude explicit interface implementations                      // from the list of member names.                      var methodDecl = (Syntax.InternalSyntax.MethodDeclarationSyntax)member;                      if (methodDecl.ExplicitInterfaceSpecifier == null)                      {                          set.Add(methodDecl.Identifier.ValueText);                      }                      break;                    case SyntaxKind.PropertyDeclaration:                      anyNonTypeMembers = true;                      // Handle in the same way as explicit method implementations                      var propertyDecl = (Syntax.InternalSyntax.PropertyDeclarationSyntax)member;                      if (propertyDecl.ExplicitInterfaceSpecifier == null)                      {                          set.Add(propertyDecl.Identifier.ValueText);                      }                      break;                    case SyntaxKind.EventDeclaration:                      anyNonTypeMembers = true;                      // Handle in the same way as explicit method implementations                      var eventDecl = (Syntax.InternalSyntax.EventDeclarationSyntax)member;                      if (eventDecl.ExplicitInterfaceSpecifier == null)                      {                          set.Add(eventDecl.Identifier.ValueText);                      }                      break;                    case SyntaxKind.ConstructorDeclaration:                      anyNonTypeMembers = true;                      set.Add(((Syntax.InternalSyntax.ConstructorDeclarationSyntax)member).Modifiers.Any(SyntaxKind.StaticKeyword)                          ? WellKnownMemberNames.StaticConstructorName                          : WellKnownMemberNames.InstanceConstructorName);                      break;                    case SyntaxKind.DestructorDeclaration:                      anyNonTypeMembers = true;                      set.Add(WellKnownMemberNames.DestructorName);                      break;                    case SyntaxKind.IndexerDeclaration:                      anyNonTypeMembers = true;                      set.Add(WellKnownMemberNames.Indexer);                      break;                    case SyntaxKind.OperatorDeclaration:                      anyNonTypeMembers = true;                      var opDecl = (Syntax.InternalSyntax.OperatorDeclarationSyntax)member;                      var name = OperatorFacts.OperatorNameFromDeclaration(opDecl);                      set.Add(name);                      break;                    case SyntaxKind.ConversionOperatorDeclaration:                      anyNonTypeMembers = true;                      set.Add(((Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax)member).ImplicitOrExplicitKeyword.Kind == SyntaxKind.ImplicitKeyword                          ? WellKnownMemberNames.ImplicitConversionName                          : WellKnownMemberNames.ExplicitConversionName);                      break;                    case SyntaxKind.GlobalStatement:                      anyNonTypeMembers = true;                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,CheckCaptured,The following switch statement is missing a default case: switch (variable.Kind)              {                  case SymbolKind.Local:                      if (((LocalSymbol)variable).IsConst) break;                      goto case SymbolKind.RangeVariable;                  case SymbolKind.Parameter:                  case SymbolKind.RangeVariable:                      if (currentMethodOrLambda != variable.ContainingSymbol)                      {                          _capturedVariables.Add(variable);                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,CheckAssigned,The following switch statement is missing a default case: switch (expr.Kind)              {                  case BoundKind.Local:                      CheckAssigned(((BoundLocal)expr).LocalSymbol' node);                      break;                  case BoundKind.Parameter:                      CheckAssigned(((BoundParameter)expr).ParameterSymbol' node);                      break;                  case BoundKind.FieldAccess:                      var field = (BoundFieldAccess)expr;                      var symbol = field.FieldSymbol;                      if (!symbol.IsFixed && MayRequireTracking(field.ReceiverOpt' symbol))                      {                          CheckAssigned(expr' symbol' node);                      }                      break;                  case BoundKind.EventAccess:                      var @event = (BoundEventAccess)expr;                      FieldSymbol associatedField = @event.EventSymbol.AssociatedField;                      if ((object)associatedField != null && MayRequireTracking(@event.ReceiverOpt' associatedField))                      {                          CheckAssigned(@event' associatedField' node);                      }                      break;                  case BoundKind.ThisReference:                  case BoundKind.BaseReference:                      CheckAssigned(MethodThisParameter' node);                      break;                      //CheckAssigned(expr'               }
Missing Default,Microsoft.CodeAnalysis.CSharp,DataFlowPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\DataFlowPass.cs,MarkFieldsUsed,The following switch statement is missing a default case: switch (type.TypeKind)              {                  case TypeKind.Array:                      MarkFieldsUsed(((ArrayTypeSymbol)type).ElementType);                      return;                    case TypeKind.Class:                  case TypeKind.Struct:                      if (!type.IsFromCompilation(this.compilation))                      {                          return;                      }                        var namedType = (NamedTypeSymbol)type;                      var assembly = type.ContainingAssembly as SourceAssemblySymbol;                      if ((object)assembly == null)                      {                          return; // could be retargeting assembly                      }                        var seen = assembly.TypesReferencedInExternalMethods;                      if (seen.Add(type))                      {                          foreach (var symbol in namedType.GetMembersUnordered())                          {                              if (symbol.Kind != SymbolKind.Field)                              {                                  continue;                              }                                FieldSymbol field = (FieldSymbol)symbol;                              assembly.NoteFieldAccess(field' read: true' write: true);                              MarkFieldsUsed(field.Type);                          }                      }                      return;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,EmptyStructTypeCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\EmptyStructTypeCache.cs,GetActualInstanceField,The following switch statement is missing a default case: switch (member.Kind)                  {                      case SymbolKind.Field:                          var field = (FieldSymbol)member;                          return (field.IsFixed || ShouldIgnoreStructField(field' field.Type)) ? null : field.AsMember(type);                        case SymbolKind.Event:                          EventSymbol eventSymbol = (EventSymbol)member;                          return (!eventSymbol.HasAssociatedField || ShouldIgnoreStructField(eventSymbol' eventSymbol.Type)) ? null : eventSymbol.AssociatedField.AsMember(type);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,EmptyStructTypeCache,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\EmptyStructTypeCache.cs,IsAccessibleInAssembly,The following switch statement is missing a default case: switch (symbol.DeclaredAccessibility)                  {                      case Accessibility.Internal:                      case Accessibility.ProtectedAndInternal:                          if (!assembly.HasInternalAccessTo(symbol.ContainingAssembly)) return false;                          break;                        case Accessibility.Private:                          return false;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,ReadWriteWalker,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\ReadWriteWalker.cs,NoteReceiverReadOrWritten,The following switch statement is missing a default case: switch (receiver.Kind)              {                  case BoundKind.Local:                      if (RegionContains(receiverSyntax.Span))                      {                          readOrWritten.Add(((BoundLocal)receiver).LocalSymbol);                      }                      break;                  case BoundKind.ThisReference:                      if (RegionContains(receiverSyntax.Span))                      {                          readOrWritten.Add(this.MethodThisParameter);                      }                      break;                  case BoundKind.BaseReference:                      if (RegionContains(receiverSyntax.Span))                      {                          readOrWritten.Add(this.MethodThisParameter);                      }                      break;                  case BoundKind.Parameter:                      if (RegionContains(receiverSyntax.Span))                      {                          readOrWritten.Add(((BoundParameter)receiver).ParameterSymbol);                      }                      break;                  case BoundKind.RangeVariable:                      if (RegionContains(receiverSyntax.Span))                      {                          readOrWritten.Add(((BoundRangeVariable)receiver).RangeVariableSymbol);                      }                      break;                  case BoundKind.FieldAccess:                      if (receiver.Type.IsStructType() && receiverSyntax.Span.OverlapsWith(RegionSpan))                      {                          NoteReceiverReadOrWritten(receiver as BoundFieldAccess' readOrWritten);                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,RegionAnalysisContext,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\FlowAnalysis\RegionAnalysisContext.cs,RegionAnalysisContext,The following switch statement is missing a default case: switch (firstInRegion.Kind)                  {                      case BoundKind.NamespaceExpression:                      case BoundKind.TypeExpression:                            // Some bound nodes are still considered to be invalid for flow analysis                          this.Failed = true;                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,AwaitExpressionSpiller,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AwaitExpressionSpiller.cs,ReceiverSpillRefKind,The following switch statement is missing a default case: switch (receiver.Kind)                  {                      case BoundKind.Parameter:                      case BoundKind.Local:                      case BoundKind.ArrayAccess:                      case BoundKind.ThisReference:                      case BoundKind.BaseReference:                      case BoundKind.PointerIndirectionOperator:                      case BoundKind.RefValueOperator:                      case BoundKind.FieldAccess:                          return RefKind.Ref;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,GetLocalOrParameterSymbol,The following switch statement is missing a default case: switch (expr.Kind)                  {                      case BoundKind.Local:                          return ((BoundLocal)expr).LocalSymbol;                      case BoundKind.Parameter:                          return ((BoundParameter)expr).ParameterSymbol;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,FindSurprisingSignExtensionBits,The following switch statement is missing a default case: switch (toSize)                  {                      case 1: return unchecked((ulong)(byte)recursive);                      case 2: return unchecked((ulong)(ushort)recursive);                      case 4: return unchecked((ulong)(uint)recursive);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,DiagnosticsPass,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\DiagnosticsPass_ExpressionTrees.cs,CheckNullableNullBinOp,The following switch statement is missing a default case: switch (node.OperatorKind.Operator())              {                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                      // CS0472: The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'                      //                      // Produce the warning if one side is always null and the other is never null.                      // That is' we have something like "if (myInt == null)"                        string always = node.OperatorKind.Operator() == BinaryOperatorKind.NotEqual ? "true" : "false";                        // we use a separate warning code for cases newly detected in later versions of the compiler                      if (node.Right.IsLiteralNull() && node.Left.NullableAlwaysHasValue())                      {                          Error(ErrorCode.WRN_NubExprIsConstBool' node' always' node.Left.Type.GetNullableUnderlyingType()' node.Left.Type);                      }                      else if (node.Left.IsLiteralNull() && node.Right.NullableAlwaysHasValue())                      {                          Error(ErrorCode.WRN_NubExprIsConstBool' node' always' node.Right.Type.GetNullableUnderlyingType()' node.Right.Type);                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,LambdaRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.Analysis.cs,InLoopOrLambda,The following switch statement is missing a default case: switch (curSyntax.Kind())                  {                      case SyntaxKind.ForStatement:                      case SyntaxKind.ForEachStatement:                      case SyntaxKind.WhileStatement:                      case SyntaxKind.DoStatement:                      case SyntaxKind.SimpleLambdaExpression:                      case SyntaxKind.ParenthesizedLambdaExpression:                          return true;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,LambdaFrame,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaFrame.cs,IsStatementWithEmbeddedStatementBody,The following switch statement is missing a default case: switch (syntax)              {                  case SyntaxKind.IfStatement:                  case SyntaxKind.DoStatement:                  case SyntaxKind.WhileStatement:                  case SyntaxKind.ForEachStatement:                  case SyntaxKind.ForStatement:                  case SyntaxKind.UsingStatement:                  case SyntaxKind.FixedStatement:                  case SyntaxKind.LockStatement:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeBinaryOperator,The following switch statement is missing a default case: switch (operatorKind.Operator() | operatorKind.OperandTypes())                  {                      case BinaryOperatorKind.ObjectAndStringConcatenation:                      case BinaryOperatorKind.StringAndObjectConcatenation:                      case BinaryOperatorKind.StringConcatenation:                          return RewriteStringConcatenation(syntax' operatorKind' loweredLeft' loweredRight' type);                      case BinaryOperatorKind.DelegateCombination:                          return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__Combine);                      case BinaryOperatorKind.DelegateRemoval:                          return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__Remove);                      case BinaryOperatorKind.DelegateEqual:                          return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__op_Equality);                      case BinaryOperatorKind.DelegateNotEqual:                          return RewriteDelegateOperation(syntax' operatorKind' loweredLeft' loweredRight' type' SpecialMember.System_Delegate__op_Inequality);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,MakeNullCheck,The following switch statement is missing a default case: switch (operatorKind)                  {                      case BinaryOperatorKind.Equal:                          return MakeLiteral(syntax' ConstantValue.Create(rewrittenExpr.ConstantValue.IsNull' ConstantValueTypeDiscriminator.Boolean)' boolType);                      case BinaryOperatorKind.NotEqual:                          return MakeLiteral(syntax' ConstantValue.Create(!rewrittenExpr.ConstantValue.IsNull' ConstantValueTypeDiscriminator.Boolean)' boolType);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetCallerLocation,The following switch statement is missing a default case: switch (enableCallerInfo)              {                  case ThreeState.False:                      return null;                  case ThreeState.True:                      return new SourceLocation(syntax.GetFirstToken());              }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,IsFloatPointExpressionOfUnknownPrecision,The following switch statement is missing a default case: switch (rewrittenNode.Kind)              {                  // ECMA-335   I.12.1.3 Handling of floating-point data types.                  //    ... the value might be retained in the internal representation                  //   for future use' if it is reloaded from the storage location without having been modified ...                  //                  // Unfortunately' the above means that precision is not guranteed even when loading from storage.                  //                  //case BoundKind.FieldAccess:                  //case BoundKind.ArrayAccess:                  //  return true;                    case BoundKind.Sequence:                      var sequence = (BoundSequence)rewrittenNode;                      return IsFloatPointExpressionOfUnknownPrecision(sequence.Value);                    case BoundKind.Conversion:                      // lowered conversions have definite precision unless they are implicit identity casts                      var conversion = (BoundConversion)rewrittenNode;                      return conversion.ConversionKind == ConversionKind.Identity && !conversion.ExplicitCastInCode;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetIntPtrConversionMethod,The following switch statement is missing a default case: switch (s0Type)                  {                      case SpecialType.System_Byte:                      case SpecialType.System_SByte:                      case SpecialType.System_Int16:                      case SpecialType.System_UInt16:                      case SpecialType.System_Char:                      case SpecialType.System_Int32:                          return SpecialMember.System_IntPtr__op_Explicit_FromInt32;                      case SpecialType.System_UInt32:                      case SpecialType.System_UInt64:                      case SpecialType.System_Int64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          return SpecialMember.System_IntPtr__op_Explicit_FromInt64;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetIntPtrConversionMethod,The following switch statement is missing a default case: switch (s0Type)                  {                      case SpecialType.System_Byte:                      case SpecialType.System_UInt16:                      case SpecialType.System_Char:                      case SpecialType.System_UInt32:                          return SpecialMember.System_UIntPtr__op_Explicit_FromUInt32;                      case SpecialType.System_SByte:                      case SpecialType.System_Int16:                      case SpecialType.System_Int32:                      case SpecialType.System_UInt64:                      case SpecialType.System_Int64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          return SpecialMember.System_UIntPtr__op_Explicit_FromUInt64;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetIntPtrConversionMethod,The following switch statement is missing a default case: switch (t0Type)                  {                      case SpecialType.System_Byte:                      case SpecialType.System_SByte:                      case SpecialType.System_Int16:                      case SpecialType.System_UInt16:                      case SpecialType.System_Char:                      case SpecialType.System_UInt32:                      case SpecialType.System_Int32:                          return SpecialMember.System_IntPtr__op_Explicit_ToInt32;                      case SpecialType.System_UInt64:                      case SpecialType.System_Int64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          return SpecialMember.System_IntPtr__op_Explicit_ToInt64;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetIntPtrConversionMethod,The following switch statement is missing a default case: switch (t0Type)                  {                      case SpecialType.System_SByte:                      case SpecialType.System_Int16:                      case SpecialType.System_Int32:                      case SpecialType.System_Byte:                      case SpecialType.System_UInt16:                      case SpecialType.System_Char:                      case SpecialType.System_UInt32:                          return SpecialMember.System_UIntPtr__op_Explicit_ToUInt32;                      case SpecialType.System_UInt64:                      case SpecialType.System_Int64:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          return SpecialMember.System_UIntPtr__op_Explicit_ToUInt64;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitUnusedExpression,The following switch statement is missing a default case: switch (expression.Kind)              {                  case BoundKind.AssignmentOperator:                      // Avoid extra temporary by indicating the expression value is not used.                      return VisitAssignmentOperator((BoundAssignmentOperator)expression' used: false);                    case BoundKind.CompoundAssignmentOperator:                      return VisitCompoundAssignmentOperator((BoundCompoundAssignmentOperator)expression' used: false);                    case BoundKind.Call:                      if (_allowOmissionOfConditionalCalls)                      {                          var call = (BoundCall)expression;                          if (call.Method.CallsAreOmitted(call.SyntaxTree))                          {                              return null;                          }                      }                      break;                    case BoundKind.DynamicInvocation:                      // TODO (tomat): circumvents logic in VisitExpression...                      return VisitDynamicInvocation((BoundDynamicInvocation)expression' resultDiscarded: true);                    case BoundKind.ConditionalAccess:                      return RewriteConditionalAccess((BoundConditionalAccess)expression' used: false);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,FlattenConcatArg,The following switch statement is missing a default case: switch (lowered.Kind)              {                  case BoundKind.Call:                      var boundCall = (BoundCall)lowered;                        var method = boundCall.Method;                      if (method.IsStatic && method.ContainingType.SpecialType == SpecialType.System_String)                      {                          if ((object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatStringString) ||                              (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatStringStringString) ||                              (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatStringStringStringString) ||                              (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatObject) ||                              (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatObjectObject) ||                              (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatObjectObjectObject))                          {                              flattened.AddRange(boundCall.Arguments);                              return;                          }                            if ((object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatStringArray) ||                              (object)method == (object)_compilation.GetSpecialTypeMember(SpecialMember.System_String__ConcatObjectArray))                          {                              var args = boundCall.Arguments[0] as BoundArrayCreation;                              if (args != null)                              {                                  var initializer = args.InitializerOpt;                                  if (initializer != null)                                  {                                      flattened.AddRange(initializer.Initializers);                                      return;                                  }                              }                          }                      }                      break;                    case BoundKind.NullCoalescingOperator:                      var boundCoalesce = (BoundNullCoalescingOperator)lowered;                        if (boundCoalesce.LeftConversion.IsIdentity)                      {                          // The RHS may be a constant value with an identity conversion to string even                          // if it is not a string: in particular' the null literal behaves this way.                          // To be safe' check that the constant value is actually a string before                          // attempting to access its value as a string.                            var rightConstant = boundCoalesce.RightOperand.ConstantValue;                          if (rightConstant != null && rightConstant.IsString && rightConstant.StringValue.Length == 0)                          {                              flattened.Add(boundCoalesce.LeftOperand);                              return;                          }                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,VisitUnaryOperator,The following switch statement is missing a default case: switch (node.OperatorKind.Operator())              {                  case UnaryOperatorKind.PrefixDecrement:                  case UnaryOperatorKind.PrefixIncrement:                  case UnaryOperatorKind.PostfixDecrement:                  case UnaryOperatorKind.PostfixIncrement:                      Debug.Assert(false); // these should have been represented as a BoundIncrementOperator                      return base.VisitUnaryOperator(node);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,IsIndirectOrInstanceField,The following switch statement is missing a default case: switch (expression.Kind)              {                  case BoundKind.Local:                      return ((BoundLocal)expression).LocalSymbol.RefKind != RefKind.None;                    case BoundKind.Parameter:                      return ((BoundParameter)expression).ParameterSymbol.RefKind != RefKind.None;                    case BoundKind.FieldAccess:                      return !((BoundFieldAccess)expression).FieldSymbol.IsStatic;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,LocalRewriter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs,GetCorrespondingBinaryOperator,The following switch statement is missing a default case: switch (result)              {                  case BinaryOperatorKind.UInt:                  case BinaryOperatorKind.Int:                  case BinaryOperatorKind.ULong:                  case BinaryOperatorKind.Long:                  case BinaryOperatorKind.PointerAndInt:                      result |= (BinaryOperatorKind)unaryOperatorKind.OverflowChecks();                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,LoweredDynamicOperationFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LoweredDynamicOperationFactory.cs,GetReceiverRefKind,The following switch statement is missing a default case: switch (loweredReceiver.Kind)              {                  case BoundKind.Local:                  case BoundKind.Parameter:                  case BoundKind.ArrayAccess:                  case BoundKind.ThisReference:                  case BoundKind.PointerIndirectionOperator:                  case BoundKind.PointerElementAccess:                  case BoundKind.RefValueOperator:                      return RefKind.Ref;                    case BoundKind.BaseReference:                  // base dynamic dispatch is not supported' an error has already been reported                  case BoundKind.TypeExpression:                      throw ExceptionUtilities.UnexpectedValue(loweredReceiver.Kind);              }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\CharacterInfo.cs,IsLetterChar,The following switch statement is missing a default case: switch (cat)              {                  case UnicodeCategory.UppercaseLetter:                  case UnicodeCategory.LowercaseLetter:                  case UnicodeCategory.TitlecaseLetter:                  case UnicodeCategory.ModifierLetter:                  case UnicodeCategory.OtherLetter:                  case UnicodeCategory.LetterNumber:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\CharacterInfo.cs,IsCombiningChar,The following switch statement is missing a default case: switch (cat)              {                  case UnicodeCategory.NonSpacingMark:                  case UnicodeCategory.SpacingCombiningMark:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\CharacterInfo.cs,IsGlobalMemberDeclaration,The following switch statement is missing a default case: switch (kind)              {                  case SyntaxKind.GlobalStatement:                  case SyntaxKind.FieldDeclaration:                  case SyntaxKind.MethodDeclaration:                  case SyntaxKind.PropertyDeclaration:                  case SyntaxKind.EventDeclaration:                  case SyntaxKind.EventFieldDeclaration:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\CharacterInfo.cs,IsAttributeName,The following switch statement is missing a default case: switch (parent.Kind())              {                  case QualifiedName:                      var qn = (QualifiedNameSyntax)parent;                      return qn.Right == node ? IsAttributeName(parent) : false;                    case AliasQualifiedName:                      var an = (AliasQualifiedNameSyntax)parent;                      return an.Name == node ? IsAttributeName(parent) : false;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\CharacterInfo.cs,IsInTypeOnlyContext,The following switch statement is missing a default case: switch (parent.Kind())                  {                      case Attribute:                          return ((AttributeSyntax)parent).Name == node;                        case ArrayType:                          return ((ArrayTypeSyntax)parent).ElementType == node;                        case PointerType:                          return ((PointerTypeSyntax)parent).ElementType == node;                        case PredefinedType:                          return true;                        case NullableType:                          return ((NullableTypeSyntax)parent).ElementType == node;                        case TypeArgumentList:                          // all children of GenericNames are type arguments                          return true;                        case CastExpression:                          return ((CastExpressionSyntax)parent).Type == node;                        case ObjectCreationExpression:                          return ((ObjectCreationExpressionSyntax)parent).Type == node;                        case StackAllocArrayCreationExpression:                          return ((StackAllocArrayCreationExpressionSyntax)parent).Type == node;                        case FromClause:                          return ((FromClauseSyntax)parent).Type == node;                        case JoinClause:                          return ((JoinClauseSyntax)parent).Type == node;                        case VariableDeclaration:                          return ((VariableDeclarationSyntax)parent).Type == node;                        case ForEachStatement:                          return ((ForEachStatementSyntax)parent).Type == node;                        case CatchDeclaration:                          return ((CatchDeclarationSyntax)parent).Type == node;                        case AsExpression:                      case IsExpression:                          return ((BinaryExpressionSyntax)parent).Right == node;                        case TypeOfExpression:                          return ((TypeOfExpressionSyntax)parent).Type == node;                        case SizeOfExpression:                          return ((SizeOfExpressionSyntax)parent).Type == node;                        case DefaultExpression:                          return ((DefaultExpressionSyntax)parent).Type == node;                        case RefValueExpression:                          return ((RefValueExpressionSyntax)parent).Type == node;                        case Parameter:                          return ((ParameterSyntax)parent).Type == node;                        case TypeConstraint:                          return ((TypeConstraintSyntax)parent).Type == node;                        case MethodDeclaration:                          return ((MethodDeclarationSyntax)parent).ReturnType == node;                        case IndexerDeclaration:                          return ((IndexerDeclarationSyntax)parent).Type == node;                        case OperatorDeclaration:                          return ((OperatorDeclarationSyntax)parent).ReturnType == node;                        case ConversionOperatorDeclaration:                          return ((ConversionOperatorDeclarationSyntax)parent).Type == node;                        case PropertyDeclaration:                          return ((PropertyDeclarationSyntax)parent).Type == node;                        case DelegateDeclaration:                          return ((DelegateDeclarationSyntax)parent).ReturnType == node;                        case EventDeclaration:                          return ((EventDeclarationSyntax)parent).Type == node;                        case SimpleBaseType:                          return true;                        case CrefParameter:                          return true;                        case ConversionOperatorMemberCref:                          return ((ConversionOperatorMemberCrefSyntax)parent).Type == node;                        case ExplicitInterfaceSpecifier:                          // #13.4.1 An explicit member implementation is a method' property' event or indexer                          // declaration that references a fully qualified interface member name.                          // A ExplicitInterfaceSpecifier represents the left part (QN) of the member name' so it                          // should be treated like a QualifiedName.                          return ((ExplicitInterfaceSpecifierSyntax)parent).Name == node;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFacts,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\CharacterInfo.cs,IsLambdaBody,The following switch statement is missing a default case: switch (parent.Kind())              {                  case ParenthesizedLambdaExpression:                  case SimpleLambdaExpression:                  case AnonymousMethodExpression:                      return true;                    case FromClause:                      var fromClause = (FromClauseSyntax)parent;                      return fromClause.Expression == node && fromClause.Parent is QueryBodySyntax;                    case JoinClause:                      var joinClause = (JoinClauseSyntax)parent;                      return joinClause.LeftExpression == node || joinClause.RightExpression == node;                    case LetClause:                      var letClause = (LetClauseSyntax)parent;                      return letClause.Expression == node;                    case WhereClause:                      var whereClause = (WhereClauseSyntax)parent;                      return whereClause.Condition == node;                    case AscendingOrdering:                  case DescendingOrdering:                      var ordering = (OrderingSyntax)parent;                      return ordering.Expression == node;                    case SelectClause:                      var selectClause = (SelectClauseSyntax)parent;                      return selectClause.Expression == node;                    case GroupClause:                      var groupClause = (GroupClauseSyntax)parent;                      return groupClause.GroupExpression == node || groupClause.ByExpression == node;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,ObjectDisplay,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\ObjectDisplay.cs,FormatString,The following switch statement is missing a default case: switch (CharUnicodeInfo.GetUnicodeCategory(c))                              {                                  case UnicodeCategory.OtherNotAssigned:                                  case UnicodeCategory.ParagraphSeparator:                                  case UnicodeCategory.Control:                                      unicodeEscape = true;                                      break;                              }
Missing Default,Microsoft.CodeAnalysis.CSharp,ObjectDisplay,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\ObjectDisplay.cs,FormatString,The following switch statement is missing a default case: switch (quote)              {                  case '"': return String.Concat("\""' str' "\"");                  case '\'': return String.Concat("'"' str' "'");                  case '\0': return str;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,VisitParameter,The following switch statement is missing a default case: switch (symbol.RefKind)                      {                          case RefKind.Out:                              AddKeyword(SyntaxKind.OutKeyword);                              AddSpace();                              break;                          case RefKind.Ref:                              AddKeyword(SyntaxKind.RefKeyword);                              AddSpace();                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddTypeParameterVarianceIfRequired,The following switch statement is missing a default case: switch (symbol.Variance)                  {                      case VarianceKind.In:                          AddKeyword(SyntaxKind.InKeyword);                          AddSpace();                          break;                      case VarianceKind.Out:                          AddKeyword(SyntaxKind.OutKeyword);                          AddSpace();                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,SymbolDisplayVisitor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\SymbolDisplay\SymbolDisplayVisitor.cs,AddLiteralValue,The following switch statement is missing a default case: switch (type)              {                  case SpecialType.System_Boolean:                      kind = SymbolDisplayPartKind.Keyword;                      break;                    case SpecialType.System_String:                  case SpecialType.System_Char:                      kind = SymbolDisplayPartKind.StringLiteral;                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,Token,The following switch statement is missing a default case: switch (kind)              {                  case SyntaxKind.IdentifierToken:                      // Have a different representation.                      throw new ArgumentException(CSharpResources.UseVerbatimIdentifier' "kind");                  case SyntaxKind.CharacterLiteralToken:                      // Value should not have type string.                      throw new ArgumentException(CSharpResources.UseLiteralForTokens' "kind");                  case SyntaxKind.NumericLiteralToken:                      // Value should not have type string.                      throw new ArgumentException(CSharpResources.UseLiteralForNumeric' "kind");              }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,GetStandaloneType,The following switch statement is missing a default case: switch (parent.Kind())                      {                          case SyntaxKind.QualifiedName:                              var qualifiedName = (QualifiedNameSyntax)parent;                              if (qualifiedName.Right == node)                              {                                  return qualifiedName;                              }                                break;                          case SyntaxKind.AliasQualifiedName:                              var aliasQualifiedName = (AliasQualifiedNameSyntax)parent;                              if (aliasQualifiedName.Name == node)                              {                                  return aliasQualifiedName;                              }                                break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,GetStandaloneNode,The following switch statement is missing a default case: switch (parent.Kind())              {                  case SyntaxKind.QualifiedName:                      if (((QualifiedNameSyntax)parent).Right == node)                      {                          return parent;                      }                        break;                  case SyntaxKind.AliasQualifiedName:                      if (((AliasQualifiedNameSyntax)parent).Name == node)                      {                          return parent;                      }                        break;                  case SyntaxKind.SimpleMemberAccessExpression:                  case SyntaxKind.PointerMemberAccessExpression:                      if (((MemberAccessExpressionSyntax)parent).Name == node)                      {                          return parent;                      }                        break;                    case SyntaxKind.MemberBindingExpression:                      {                          if (((MemberBindingExpressionSyntax)parent).Name == node)                          {                              return parent;                          }                            break;                      }                    // Only care about name member crefs because the other cref members                  // are identifier by keywords' not syntax nodes.                  case SyntaxKind.NameMemberCref:                      if (((NameMemberCrefSyntax)parent).Name == node)                      {                          CSharpSyntaxNode grandparent = parent.Parent;                          return grandparent != null && grandparent.Kind() == SyntaxKind.QualifiedCref                              ? grandparent                              : parent;                      }                        break;                    case SyntaxKind.QualifiedCref:                      if (((QualifiedCrefSyntax)parent).Member == node)                      {                          return parent;                      }                        break;                    case SyntaxKind.ArrayCreationExpression:                      if (((ArrayCreationExpressionSyntax)parent).Type == node)                      {                          return parent;                      }                        break;                    case SyntaxKind.ObjectCreationExpression:                      if (node.Kind() == SyntaxKind.NullableType && ((ObjectCreationExpressionSyntax)parent).Type == node)                      {                          return parent;                      }                        break;                    case SyntaxKind.StackAllocArrayCreationExpression:                      if (((StackAllocArrayCreationExpressionSyntax)parent).Type == node)                      {                          return parent;                      }                        break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,GetNonGenericExpression,The following switch statement is missing a default case: switch (expression.Kind())                  {                      case SyntaxKind.SimpleMemberAccessExpression:                      case SyntaxKind.PointerMemberAccessExpression:                          var max = (MemberAccessExpressionSyntax)expression;                          if (max.Name.Kind() == SyntaxKind.GenericName)                          {                              var gn = (GenericNameSyntax)max.Name;                              return SyntaxFactory.BinaryExpression(expression.Kind()' max.Expression' max.OperatorToken' SyntaxFactory.IdentifierName(gn.Identifier));                          }                          break;                      case SyntaxKind.QualifiedName:                          var qn = (QualifiedNameSyntax)expression;                          if (qn.Right.Kind() == SyntaxKind.GenericName)                          {                              var gn = (GenericNameSyntax)qn.Right;                              return SyntaxFactory.QualifiedName(qn.Left' qn.DotToken' SyntaxFactory.IdentifierName(gn.Identifier));                          }                          break;                      case SyntaxKind.AliasQualifiedName:                          var an = (AliasQualifiedNameSyntax)expression;                          if (an.Name.Kind() == SyntaxKind.GenericName)                          {                              var gn = (GenericNameSyntax)an.Name;                              return SyntaxFactory.AliasQualifiedName(an.Alias' an.ColonColonToken' SyntaxFactory.IdentifierName(gn.Identifier));                          }                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,IsCompleteSubmission,The following switch statement is missing a default case: switch ((ErrorCode)error.Code)                  {                      case ErrorCode.ERR_OpenEndedComment:                      case ErrorCode.ERR_EndifDirectiveExpected:                      case ErrorCode.ERR_EndRegionDirectiveExpected:                          return false;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,SyntaxFactory,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\AnonymousMethodExpressionSyntax.cs,IsCompleteSubmission,The following switch statement is missing a default case: switch ((ErrorCode)error.Code)                  {                      // unterminated character or string literal:                      case ErrorCode.ERR_NewlineInConst:                        // unterminated verbatim string literal:                      case ErrorCode.ERR_UnterminatedStringLit:                        // unexpected token following a global statement:                      case ErrorCode.ERR_GlobalDefinitionOrStatementExpected:                      case ErrorCode.ERR_EOFExpected:                          return false;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,DigForLocal,The following switch statement is missing a default case: switch (value.Kind)              {                  case BoundKind.Local:                      var local = (BoundLocal)value;                      if (local.LocalSymbol.RefKind == RefKind.None)                      {                          return local;                      }                      break;                    case BoundKind.Sequence:                      return DigForLocal(((BoundSequence)value).Value);                    case BoundKind.FieldAccess:                      var fieldAccess = (BoundFieldAccess)value;                      if (!fieldAccess.FieldSymbol.IsStatic)                      {                          return DigForLocal(fieldAccess.ReceiverOpt);                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitConversionExpression,The following switch statement is missing a default case: switch (conversion.ConversionKind)              {                  case ConversionKind.MethodGroup:                      EmitMethodGroupConversion(conversion' used);                      return;                  case ConversionKind.NullToPointer:                      // The null pointer is represented as 0u.                      _builder.EmitIntConstant(0);                      _builder.EmitOpCode(ILOpCode.Conv_u);                      return;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,ConversionHasSideEffects,The following switch statement is missing a default case: switch (conversion.ConversionKind)              {                  case ConversionKind.Identity:                  // NOTE: even explicit float/double identity conversion does not have side                  // effects since it does not throw                  case ConversionKind.ImplicitNumeric:                  case ConversionKind.ImplicitEnumeration:                  // implicit ref cast does not throw ...                  case ConversionKind.ImplicitReference:                  case ConversionKind.Boxing:                      return false;                    // unchecked numeric conversion does not throw                   case ConversionKind.ExplicitNumeric:                      return conversion.Checked;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitIdentityConversion,The following switch statement is missing a default case: switch (conversion.Type.PrimitiveTypeCode)                  {                      case Microsoft.Cci.PrimitiveTypeCode.Float32:                      case Microsoft.Cci.PrimitiveTypeCode.Float64:                          // For explicitly-written "identity conversions" from float to float or                          // double to double' we require the generation of conv.r4 or conv.r8. The                          // runtime can use these instructions to truncate precision' and csc.exe                          // generates them. It's not ideal' we should consider the possibility of not                          // doing this or marking somewhere else that this is necessary.                            // Don't need to do this for constants' however.                          if (conversion.Operand.ConstantValue == null)                          {                              EmitNumericConversion(conversion);                          }                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,FieldLoadPrefersRef,The following switch statement is missing a default case: switch (receiver.Kind)              {                  case BoundKind.Parameter:                      // prefer ldarg over ldarga                      return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;                    case BoundKind.Local:                      // prefer ldloc over ldloca                      return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;                    case BoundKind.Sequence:                      return FieldLoadPrefersRef(((BoundSequence)receiver).Value);                    case BoundKind.FieldAccess:                      var fieldAccess = (BoundFieldAccess)receiver;                      if (fieldAccess.FieldSymbol.IsStatic)                      {                          return true;                      }                        if (DiagnosticsPass.IsNonAgileFieldAccess(fieldAccess' _module.Compilation))                      {                          return false;                      }                        return FieldLoadPrefersRef(fieldAccess.ReceiverOpt);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,FieldLoadMustUseRef,The following switch statement is missing a default case: switch (type.SpecialType)              {                  // case PT_BYTE:                  case SpecialType.System_Byte:                  // case PT_SHORT:                  case SpecialType.System_Int16:                  // case PT_INT:                  case SpecialType.System_Int32:                  // case PT_LONG:                  case SpecialType.System_Int64:                  // case PT_CHAR:                  case SpecialType.System_Char:                  // case PT_BOOL:                  case SpecialType.System_Boolean:                  // case PT_SBYTE:                  case SpecialType.System_SByte:                  // case PT_USHORT:                  case SpecialType.System_UInt16:                  // case PT_UINT:                  case SpecialType.System_UInt32:                  // case PT_ULONG:                  case SpecialType.System_UInt64:                  // case PT_INTPTR:                  case SpecialType.System_IntPtr:                  // case PT_UINTPTR:                  case SpecialType.System_UIntPtr:                  // case PT_FLOAT:                  case SpecialType.System_Single:                  // case PT_DOUBLE:                  case SpecialType.System_Double:                  // case PT_TYPEHANDLE:                  case SpecialType.System_RuntimeTypeHandle:                  // case PT_FIELDHANDLE:                  case SpecialType.System_RuntimeFieldHandle:                  // case PT_METHODHANDLE:                  case SpecialType.System_RuntimeMethodHandle:                  //case PT_ARGUMENTHANDLE:                  case SpecialType.System_RuntimeArgumentHandle:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,CanUseCallOnRefTypeReceiver,The following switch statement is missing a default case: switch (receiver.Kind)              {                  case BoundKind.ArrayCreation:                      return true;                    case BoundKind.ObjectCreationExpression:                      //NOTE: there are cases involving ProxyAttribute                      //where newobj may produce null                      return true;                    case BoundKind.Conversion:                      var conversion = (BoundConversion)receiver;                        switch (conversion.ConversionKind)                      {                          case ConversionKind.Boxing:                              //NOTE: boxing can produce null for Nullable' but any call through that                              //will result in null reference exceptions anyways.                              return true;                            case ConversionKind.MethodGroup:                          case ConversionKind.AnonymousFunction:                              return true;                            case ConversionKind.ExplicitReference:                          case ConversionKind.ImplicitReference:                              return CanUseCallOnRefTypeReceiver(conversion.Operand);                      }                      break;                    case BoundKind.ThisReference:                      //NOTE: these actually can be null if called from a different language                      //if that has already happen' we will just propagate the behavior.                      return true;                    case BoundKind.DelegateCreationExpression:                      return true;                    case BoundKind.Sequence:                      var seqValue = ((BoundSequence)(receiver)).Value;                      return CanUseCallOnRefTypeReceiver(seqValue);                    case BoundKind.AssignmentOperator:                      var rhs = ((BoundAssignmentOperator)receiver).Right;                      return CanUseCallOnRefTypeReceiver(rhs);                    case BoundKind.TypeOfOperator:                      return true;                    case BoundKind.FieldAccess:                      return ((BoundFieldAccess)receiver).FieldSymbol.IsCapturedFrame;                    case BoundKind.ConditionalReceiver:                      return true;                        //TODO: there could be more cases where we can be sure that receiver is not a null.              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,CanUseCallOnRefTypeReceiver,The following switch statement is missing a default case: switch (conversion.ConversionKind)                      {                          case ConversionKind.Boxing:                              //NOTE: boxing can produce null for Nullable' but any call through that                              //will result in null reference exceptions anyways.                              return true;                            case ConversionKind.MethodGroup:                          case ConversionKind.AnonymousFunction:                              return true;                            case ConversionKind.ExplicitReference:                          case ConversionKind.ImplicitReference:                              return CanUseCallOnRefTypeReceiver(conversion.Operand);                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,IsThisReceiver,The following switch statement is missing a default case: switch (receiver.Kind)              {                  case BoundKind.ThisReference:                      return true;                    case BoundKind.Sequence:                      var seqValue = ((BoundSequence)(receiver)).Value;                      return IsThisReceiver(seqValue);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitCallExpression,The following switch statement is missing a default case: switch (callKind)              {                  case CallKind.Call:                      _builder.EmitOpCode(ILOpCode.Call' stackBehavior);                      break;                    case CallKind.CallVirt:                      _builder.EmitOpCode(ILOpCode.Callvirt' stackBehavior);                      break;                    case CallKind.ConstrainedCallVirt:                      _builder.EmitOpCode(ILOpCode.Constrained);                      EmitSymbolToken(receiver.Type' receiver.Syntax);                      _builder.EmitOpCode(ILOpCode.Callvirt' stackBehavior);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,IsRef,The following switch statement is missing a default case: switch (receiver.Kind)              {                  case BoundKind.Local:                      return ((BoundLocal)receiver).LocalSymbol.RefKind != RefKind.None;                    case BoundKind.Parameter:                      return ((BoundParameter)receiver).ParameterSymbol.RefKind != RefKind.None;                    case BoundKind.Dup:                      return ((BoundDup)receiver).RefKind != RefKind.None;                    case BoundKind.Sequence:                      return IsRef(((BoundSequence)receiver).Value);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,TargetIsNotOnHeap,The following switch statement is missing a default case: switch (left.Kind)              {                  case BoundKind.Parameter:                      return ((BoundParameter)left).ParameterSymbol.RefKind == RefKind.None;                    case BoundKind.Local:                      // NOTE: stack locals are either homeless or refs' no need to special case them                      //       they will never be assigned in-place.                      return ((BoundLocal)left).LocalSymbol.RefKind == RefKind.None;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitAssignmentPreamble,The following switch statement is missing a default case: switch (assignmentTarget.Kind)              {                  case BoundKind.RefValueOperator:                      EmitRefValueAddress((BoundRefValueOperator)assignmentTarget);                      break;                    case BoundKind.FieldAccess:                      {                          var left = (BoundFieldAccess)assignmentTarget;                          if (!left.FieldSymbol.IsStatic)                          {                              var temp = EmitReceiverRef(left.ReceiverOpt);                              Debug.Assert(temp == null' "temp is unexpected when assigning to a field");                              lhsUsesStack = true;                          }                      }                      break;                    case BoundKind.Parameter:                      {                          var left = (BoundParameter)assignmentTarget;                          if (left.ParameterSymbol.RefKind != RefKind.None)                          {                              _builder.EmitLoadArgumentOpcode(ParameterSlot(left));                              lhsUsesStack = true;                          }                      }                      break;                    case BoundKind.Local:                      {                          var left = (BoundLocal)assignmentTarget;                            // Again' consider our earlier case:                          //                          // ref int addr = ref N().s;                          // int sum = addr + 10;                           // addr = sum;                          //                          // There are three different ways we could be assigning to a local.                          //                          // In the first case' we want to simply call N()' take the address                          // of s' and then store that address in addr.                          //                          // In the second case again we simply want to compute the sum and                          // store the result in sum.                          //                          // In the third case however we want to first load the contents of                          // addr -- the address of field s -- then put the sum on the stack'                          // and then do an indirect store. In that case we need to have the                          // contents of addr on the stack.                            if (left.LocalSymbol.RefKind != RefKind.None && assignmentOperator.RefKind == RefKind.None)                          {                              if (!IsStackLocal(left.LocalSymbol))                              {                                  LocalDefinition localDefinition = GetLocal(left);                                  _builder.EmitLocalLoad(localDefinition);                              }                              else                              {                                  // this is a case of indirect assignment to a stack temp.                                  // currently byref temp can only be a stack local in scenarios where                                   // there is only one assignment and it is the last one.                                   // I do not yet know how to support cases where we assign more than once.                                   // That where Dup of LHS would be needed' but as a general scenario                                   // it is not always possible to handle. Fortunately all the cases where we                                  // indirectly assign to a byref temp come from rewriter and all                                  // they all are write-once cases.                                  //                                  // For now analyzer asserts that indirect writes are final reads of                                   // a ref local. And we never need a dup here.                                    // builder.EmitOpCode(ILOpCode.Dup);                              }                                lhsUsesStack = true;                          }                      }                      break;                    case BoundKind.ArrayAccess:                      {                          var left = (BoundArrayAccess)assignmentTarget;                          EmitExpression(left.Expression' used: true);                          EmitArrayIndices(left.Indices);                          lhsUsesStack = true;                      }                      break;                    case BoundKind.ThisReference:                      {                          var left = (BoundThisReference)assignmentTarget;                            var temp = EmitAddress(left' AddressKind.Writeable);                          Debug.Assert(temp == null' "taking ref of this should not create a temp");                            lhsUsesStack = true;                      }                      break;                    case BoundKind.Dup:                      {                          var left = (BoundDup)assignmentTarget;                            var temp = EmitAddress(left' AddressKind.Writeable);                          Debug.Assert(temp == null' "taking ref of Dup should not create a temp");                            lhsUsesStack = true;                      }                      break;                    case BoundKind.PointerIndirectionOperator:                      {                          var left = (BoundPointerIndirectionOperator)assignmentTarget;                            EmitExpression(left.Operand' used: true);                            lhsUsesStack = true;                      }                      break;                    case BoundKind.Sequence:                      {                          var sequence = (BoundSequence)assignmentTarget;                            DefineLocals(sequence);                          EmitSideEffects(sequence);                            BoundLocal referencedLocal = DigForLocal(sequence.Value);                          LocalSymbol doNotRelease = null;                          if (referencedLocal != null)                          {                              doNotRelease = referencedLocal.LocalSymbol;                          }                            lhsUsesStack = EmitAssignmentPreamble(assignmentOperator.Update(sequence.Value' assignmentOperator.Right' assignmentOperator.RefKind' assignmentOperator.Type));                            FreeLocals(sequence);                          Debug.Assert(!sequence.Locals.Any(l => l == doNotRelease));                      }                      break;                    case BoundKind.PropertyAccess:                  case BoundKind.IndexerAccess:                  // Property access should have been rewritten.                  case BoundKind.PreviousSubmissionReference:                      // Script references are lowered to a this reference and a field access.                      throw ExceptionUtilities.UnexpectedValue(assignmentTarget.Kind);                    case BoundKind.PseudoVariable:                      EmitPseudoVariableAddress((BoundPseudoVariable)assignmentTarget);                      lhsUsesStack = true;                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,StackMergeType,The following switch statement is missing a default case: switch (expr.Kind)              {                  case BoundKind.Conversion:                      var conversion = (BoundConversion)expr;                      var conversionKind = conversion.ConversionKind;                      if (conversionKind.IsImplicitConversion() &&                          conversionKind != ConversionKind.MethodGroup &&                          conversionKind != ConversionKind.NullLiteral)                      {                          return StackMergeType(conversion.Operand);                      }                      break;                    case BoundKind.AssignmentOperator:                      var assignment = (BoundAssignmentOperator)expr;                      return StackMergeType(assignment.Right);                    case BoundKind.Sequence:                      var sequence = (BoundSequence)expr;                      return StackMergeType(sequence.Value);                    case BoundKind.Local:                      var local = (BoundLocal)expr;                      if (this.IsStackLocal(local.LocalSymbol))                      {                          // stack value' we cannot be sure what it is                          return null;                      }                      break;                    case BoundKind.Dup:                      // stack value' we cannot be sure what it is                      return null;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitConversionToEnumUnderlyingType,The following switch statement is missing a default case: switch (type)              {                  case SpecialType.System_Byte:                      _builder.EmitNumericConversion(Microsoft.Cci.PrimitiveTypeCode.Int32' Microsoft.Cci.PrimitiveTypeCode.UInt8' @checked);                      break;                  case SpecialType.System_SByte:                      _builder.EmitNumericConversion(Microsoft.Cci.PrimitiveTypeCode.Int32' Microsoft.Cci.PrimitiveTypeCode.Int8' @checked);                      break;                  case SpecialType.System_Int16:                      _builder.EmitNumericConversion(Microsoft.Cci.PrimitiveTypeCode.Int32' Microsoft.Cci.PrimitiveTypeCode.Int16' @checked);                      break;                  case SpecialType.System_UInt16:                      _builder.EmitNumericConversion(Microsoft.Cci.PrimitiveTypeCode.Int32' Microsoft.Cci.PrimitiveTypeCode.UInt16' @checked);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,IsUnsigned,The following switch statement is missing a default case: switch (type)              {                  case SpecialType.System_Byte:                  case SpecialType.System_UInt16:                  case SpecialType.System_UInt32:                  case SpecialType.System_UInt64:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,IsConditional,The following switch statement is missing a default case: switch (opKind.OperatorWithLogical())              {                  case BinaryOperatorKind.LogicalAnd:                  case BinaryOperatorKind.LogicalOr:                  case BinaryOperatorKind.Equal:                  case BinaryOperatorKind.NotEqual:                  case BinaryOperatorKind.LessThan:                  case BinaryOperatorKind.LessThanOrEqual:                  case BinaryOperatorKind.GreaterThan:                  case BinaryOperatorKind.GreaterThanOrEqual:                      return true;                    case BinaryOperatorKind.And:                  case BinaryOperatorKind.Or:                  case BinaryOperatorKind.Xor:                      return opKind.OperandTypes() == BinaryOperatorKind.Bool;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,CodeGenerator,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs,EmitCondBranch,The following switch statement is missing a default case: switch (binOp.OperatorKind.OperatorWithLogical())                      {                          case BinaryOperatorKind.LogicalOr:                              testBothArgs = !testBothArgs;                              // Fall through                              goto case BinaryOperatorKind.LogicalAnd;                            case BinaryOperatorKind.LogicalAnd:                              if (testBothArgs)                              {                                  // gotoif(a != sense) fallThrough                                  // gotoif(b == sense) dest                                  // fallThrough:                                    object fallThrough = null;                                    EmitCondBranch(binOp.Left' ref fallThrough' !sense);                                  EmitCondBranch(binOp.Right' ref dest' sense);                                    if (fallThrough != null)                                  {                                      _builder.MarkLabel(fallThrough);                                  }                              }                              else                              {                                  // gotoif(a == sense) labDest                                  // gotoif(b == sense) labDest                                    EmitCondBranch(binOp.Left' ref dest' sense);                                  condition = binOp.Right;                                  goto oneMoreTime;                              }                              return;                            case BinaryOperatorKind.Equal:                          case BinaryOperatorKind.NotEqual:                              var reduced = TryReduce(binOp' ref sense);                              if (reduced != null)                              {                                  condition = reduced;                                  goto oneMoreTime;                              }                              // Fall through                              goto case BinaryOperatorKind.LessThan;                            case BinaryOperatorKind.LessThan:                          case BinaryOperatorKind.LessThanOrEqual:                          case BinaryOperatorKind.GreaterThan:                          case BinaryOperatorKind.GreaterThanOrEqual:                              EmitExpression(binOp.Left' true);                              EmitExpression(binOp.Right' true);                              ILOpCode revOpCode;                              ilcode = CodeForJump(binOp' sense' out revOpCode);                              dest = dest ?? new object();                              _builder.EmitBranch(ilcode' dest' revOpCode);                              return;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,LhsUsesStackWhenAssignedTo,The following switch statement is missing a default case: switch (node.Kind)              {                  case BoundKind.Parameter:                  case BoundKind.Local:                      return false;                    case BoundKind.FieldAccess:                      return !((BoundFieldAccess)node).FieldSymbol.IsStatic;                    case BoundKind.Sequence:                      return LhsUsesStackWhenAssignedTo(((BoundSequence)node).Value' context);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,VisitLocal,The following switch statement is missing a default case: switch (_context)                  {                      case ExprContext.Address:                          if (node.LocalSymbol.RefKind != RefKind.None)                          {                              RecordVarRead(node.LocalSymbol);                          }                          else                          {                              RecordVarRef(node.LocalSymbol);                          }                          break;                        case ExprContext.AssignmentTarget:                          Debug.Assert(_assignmentLocal == null);                            // actual assignment will happen later' after Right is evaluated                          // just remember what we are assigning to.                          _assignmentLocal = node;                            // whatever is available as lastExpression is still available                           // (adjust for visit of this node)                          _lastExpressionCnt++;                            break;                        case ExprContext.Sideeffects:                          break;                        case ExprContext.Value:                      case ExprContext.Box:                          RecordVarRead(node.LocalSymbol);                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGen,StackOptimizerPass1,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs,IsIndirectAssignment,The following switch statement is missing a default case: switch (lhs.Kind)              {                  case BoundKind.Parameter:                      if (((BoundParameter)lhs).ParameterSymbol.RefKind != RefKind.None)                      {                          bool isIndirect = node.RefKind == RefKind.None;                          Debug.Assert(isIndirect' "direct assignment to a ref/out parameter is highly suspicious");                          return isIndirect;                      }                        break;                    case BoundKind.Local:                      if (((BoundLocal)lhs).LocalSymbol.RefKind != RefKind.None)                      {                          bool isIndirect = node.RefKind == RefKind.None;                          return isIndirect;                      }                        break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,CSharpAttributeData,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\AttributeDataAdapter.cs,ShouldEmitAttribute,The following switch statement is missing a default case: switch (target.Kind)              {                  case SymbolKind.Assembly:                      if ((!emittingAssemblyAttributesInNetModule &&                              (IsTargetAttribute(target' AttributeDescription.AssemblyCultureAttribute) ||                               IsTargetAttribute(target' AttributeDescription.AssemblyVersionAttribute) ||                               IsTargetAttribute(target' AttributeDescription.AssemblyFlagsAttribute) ||                               IsTargetAttribute(target' AttributeDescription.AssemblyAlgorithmIdAttribute))) ||                          IsTargetAttribute(target' AttributeDescription.TypeForwardedToAttribute) ||                          IsSecurityAttribute(target.DeclaringCompilation))                      {                          return false;                      }                        break;                    case SymbolKind.Event:                      if (IsTargetAttribute(target' AttributeDescription.SpecialNameAttribute))                      {                          return false;                      }                        break;                    case SymbolKind.Field:                      if (IsTargetAttribute(target' AttributeDescription.SpecialNameAttribute) ||                          IsTargetAttribute(target' AttributeDescription.NonSerializedAttribute) ||                          IsTargetAttribute(target' AttributeDescription.FieldOffsetAttribute) ||                          IsTargetAttribute(target' AttributeDescription.MarshalAsAttribute))                      {                          return false;                      }                        break;                    case SymbolKind.Method:                      if (isReturnType)                      {                          if (IsTargetAttribute(target' AttributeDescription.MarshalAsAttribute))                          {                              return false;                          }                      }                      else                      {                          if (IsTargetAttribute(target' AttributeDescription.SpecialNameAttribute) ||                              IsTargetAttribute(target' AttributeDescription.MethodImplAttribute) ||                              IsTargetAttribute(target' AttributeDescription.DllImportAttribute) ||                              IsTargetAttribute(target' AttributeDescription.PreserveSigAttribute) ||                              IsTargetAttribute(target' AttributeDescription.DynamicSecurityMethodAttribute) ||                              IsSecurityAttribute(target.DeclaringCompilation))                          {                              return false;                          }                      }                        break;                    case SymbolKind.NetModule:                      // Note that DefaultCharSetAttribute is emitted to metadata' although it's also decoded and used when emitting P/Invoke                      break;                    case SymbolKind.NamedType:                      if (IsTargetAttribute(target' AttributeDescription.SpecialNameAttribute) ||                          IsTargetAttribute(target' AttributeDescription.ComImportAttribute) ||                          IsTargetAttribute(target' AttributeDescription.SerializableAttribute) ||                          IsTargetAttribute(target' AttributeDescription.StructLayoutAttribute) ||                          IsTargetAttribute(target' AttributeDescription.WindowsRuntimeImportAttribute) ||                          IsSecurityAttribute(target.DeclaringCompilation))                      {                          return false;                      }                        break;                    case SymbolKind.Parameter:                      if (IsTargetAttribute(target' AttributeDescription.OptionalAttribute) ||                          IsTargetAttribute(target' AttributeDescription.DefaultParameterValueAttribute) ||                          IsTargetAttribute(target' AttributeDescription.InAttribute) ||                          IsTargetAttribute(target' AttributeDescription.OutAttribute) ||                          IsTargetAttribute(target' AttributeDescription.MarshalAsAttribute))                      {                          return false;                      }                        break;                    case SymbolKind.Property:                      if (IsTargetAttribute(target' AttributeDescription.IndexerNameAttribute) ||                          IsTargetAttribute(target' AttributeDescription.SpecialNameAttribute))                      {                          return false;                      }                        break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,NamespaceSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\NamespaceSymbolAdapter.cs,GetNestedNamespace,The following switch statement is missing a default case: switch (name.Kind())              {                  case SyntaxKind.GenericName: // DeclarationTreeBuilder.VisitNamespace uses the PlainName' even for generic names                  case SyntaxKind.IdentifierName:                      return this.GetNestedNamespace(((SimpleNameSyntax)name).Identifier.ValueText);                    case SyntaxKind.QualifiedName:                      var qn = (QualifiedNameSyntax)name;                      var leftNs = this.GetNestedNamespace(qn.Left);                      if ((object)leftNs != null)                      {                          return leftNs.GetNestedNamespace(qn.Right);                      }                        break;                    case SyntaxKind.AliasQualifiedName:                      // This is an error scenario' but we should still handle it.                      // We recover in the same way as DeclarationTreeBuilder.VisitNamespaceDeclaration.                      return this.GetNestedNamespace(name.GetUnqualifiedName().Identifier.ValueText);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\TypeParameterSymbolAdapter.cs,GetConstraints,The following switch statement is missing a default case: switch (type.SpecialType)                  {                      case SpecialType.System_Object:                          // Avoid emitting unnecessary object constraint.                          continue;                      case SpecialType.System_ValueType:                          seenValueType = true;                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\TypeParameterSymbolAdapter.cs,ConstraintImpliesReferenceType,The following switch statement is missing a default case: switch (constraint.TypeKind)                  {                      case TypeKind.Interface:                          return false; // can be satisfied by valuetypes                      case TypeKind.Error:                          return false;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeParameterSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\TypeParameterSymbolAdapter.cs,ConstraintImpliesReferenceType,The following switch statement is missing a default case: switch (constraint.SpecialType)                  {                      case SpecialType.System_Object:                      case SpecialType.System_ValueType:                      case SpecialType.System_Enum:                          return false; // can be satisfied by valuetypes                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,AnonymousTypeTemplateSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\AnonymousTypes\SynthesizedSymbols\AnonymousType.TemplateSymbol.cs,GetFieldsToEmit,The following switch statement is missing a default case: switch (m.Kind)                      {                          case SymbolKind.Field:                              yield return (FieldSymbol)m;                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,BaseTypeAnalysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\BaseTypeAnalysis.cs,IsManagedType,The following switch statement is missing a default case: switch (IsManagedTypeHelper(type))              {                  case ThreeState.True:                      return true;                  case ThreeState.False:                      return false;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,BaseTypeAnalysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\BaseTypeAnalysis.cs,DependsOnDefinitelyManagedType,The following switch statement is missing a default case: switch (member.Kind)                      {                          case SymbolKind.Field:                              field = (FieldSymbol)member;                              Debug.Assert(ReferenceEquals(field.AssociatedSymbol as EventSymbol' null)'                                  "Didn't expect to find a field-like event backing field in the member list.");                              break;                          case SymbolKind.Event:                              field = ((EventSymbol)member).AssociatedField;                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,BaseTypeAnalysis,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\BaseTypeAnalysis.cs,DependsOnDefinitelyManagedType,The following switch statement is missing a default case: switch (IsManagedTypeHelper(fieldNamedType))                          {                              case ThreeState.True:                                  return true;                              case ThreeState.False:                                  continue;                              case ThreeState.Unknown:                                  if (DependsOnDefinitelyManagedType(fieldNamedType' partialClosure))                                  {                                      return true;                                  }                                  continue;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSymbolExtensions.cs,ContainingNamespaceOrType,The following switch statement is missing a default case: switch (containingSymbol.Kind)                  {                      case SymbolKind.Namespace:                      case SymbolKind.NamedType:                      case SymbolKind.ErrorType:                          return (NamespaceOrTypeSymbol)containingSymbol;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\MemberSymbolExtensions.cs,GetArity,The following switch statement is missing a default case: switch (symbol.Kind)                  {                      case SymbolKind.NamedType:                          return ((NamedTypeSymbol)symbol).Arity;                      case SymbolKind.Method:                          return ((MethodSymbol)symbol).Arity;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,ParameterHelpers,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\ParameterHelpers.cs,GetModifiers,The following switch statement is missing a default case: switch (modifier.Kind())                  {                      case SyntaxKind.OutKeyword:                          outKeyword = modifier;                          if (refKind == RefKind.None)                          {                              refKind = RefKind.Out;                          }                          break;                      case SyntaxKind.RefKeyword:                          refKeyword = modifier;                          if (refKind == RefKind.None)                          {                              refKind = RefKind.Ref;                          }                          break;                      case SyntaxKind.ParamsKeyword:                          paramsKeyword = modifier;                          break;                      case SyntaxKind.ThisKeyword:                          thisKeyword = modifier;                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceAssemblySymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceAssemblySymbol.cs,DecodeWellKnownAttribute,The following switch statement is missing a default case: switch (namedArg.Key)                      {                          case "WrapNonExceptionThrows":                              wrapNonExceptionThrows = namedArg.Value.DecodeValue<bool>(SpecialType.System_Boolean);                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceCustomEventSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceCustomEventSymbol.cs,SourceCustomEventSymbol,The following switch statement is missing a default case: switch (accessor.Kind())                  {                      case SyntaxKind.AddAccessorDeclaration:                          if (addSyntax == null || addSyntax.Keyword.Span.IsEmpty)                          {                              addSyntax = accessor;                          }                          break;                      case SyntaxKind.RemoveAccessorDeclaration:                          if (removeSyntax == null || removeSyntax.Keyword.Span.IsEmpty)                          {                              removeSyntax = accessor;                          }                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MakeModifiers,The following switch statement is missing a default case: switch (typeKind)              {                  case TypeKind.Class:                  case TypeKind.Submission:                      // static' sealed' and abstract allowed if a class                      allowedModifiers |= DeclarationModifiers.Static | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract | DeclarationModifiers.Unsafe;                      break;                  case TypeKind.Struct:                  case TypeKind.Interface:                  case TypeKind.Delegate:                      allowedModifiers |= DeclarationModifiers.Unsafe;                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MakeModifiers,The following switch statement is missing a default case: switch (typeKind)              {                  case TypeKind.Interface:                      mods |= DeclarationModifiers.Abstract;                      break;                  case TypeKind.Struct:                  case TypeKind.Enum:                      mods |= DeclarationModifiers.Sealed;                      break;                  case TypeKind.Delegate:                      mods |= DeclarationModifiers.Sealed;                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,MakeAndCheckTypeModifiers,The following switch statement is missing a default case: switch (self.ContainingSymbol.Kind)                      {                          case SymbolKind.Namespace:                              for (var i = 1; i < partCount; i++)                              {                                  diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS' declaration.Declarations[i].NameLocation' self.Name' self.ContainingSymbol);                                  modifierErrors = true;                              }                              break;                            case SymbolKind.NamedType:                              for (var i = 1; i < partCount; i++)                              {                                  if (ContainingType.Locations.Length == 1 || ContainingType.IsPartial())                                      diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass' declaration.Declarations[i].NameLocation' self.ContainingSymbol' self.Name);                                  modifierErrors = true;                              }                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,EffectiveAccessibility,The following switch statement is missing a default case: switch (container.DeclaredAccessibility)                  {                      case Accessibility.Private:                          return Accessibility.Private;                      case Accessibility.Internal:                          result = Accessibility.Internal;                          continue;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMemberNameDistinctFromType,The following switch statement is missing a default case: switch (this.TypeKind)              {                  case TypeKind.Class:                  case TypeKind.Struct:                      if (member.Name == this.Name)                      {                          diagnostics.Add(ErrorCode.ERR_MemberNameSameAsType' member.Locations[0]' this.Name);                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,GetFieldsToEmit,The following switch statement is missing a default case: switch (m.Kind)                  {                      case SymbolKind.Field:                          yield return (FieldSymbol)m;                          break;                      case SymbolKind.Event:                          FieldSymbol associatedField = ((EventSymbol)m).AssociatedField;                          if ((object)associatedField != null)                          {                              yield return associatedField;                          }                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckAccessorNameConflicts,The following switch statement is missing a default case: switch (symbol.Kind)                  {                      case SymbolKind.Property:                          {                              var propertySymbol = (PropertySymbol)symbol;                              this.CheckForMemberConflictWithPropertyAccessor(propertySymbol' getNotSet: true' diagnostics: diagnostics);                              this.CheckForMemberConflictWithPropertyAccessor(propertySymbol' getNotSet: false' diagnostics: diagnostics);                              break;                          }                      case SymbolKind.Event:                          {                              var eventSymbol = (EventSymbol)symbol;                              this.CheckForMemberConflictWithEventAccessor(eventSymbol' isAdder: true' diagnostics: diagnostics);                              this.CheckForMemberConflictWithEventAccessor(eventSymbol' isAdder: false' diagnostics: diagnostics);                              break;                          }                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,AddSynthesizedConstructorsIfNecessary,The following switch statement is missing a default case: switch (method.MethodKind)                      {                          case MethodKind.Constructor:                              hasInstanceConstructor = true;                              hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;                              break;                            case MethodKind.StaticConstructor:                              hasStaticConstructor = true;                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMemberContainerTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs,CheckMembersAgainstBaseType,The following switch statement is missing a default case: switch (member.Kind)                  {                      case SymbolKind.Method:                          var method = (MethodSymbol)member;                          if (MethodSymbol.CanOverrideOrHide(method.MethodKind) && !method.IsAccessor())                          {                              if (member.IsOverride)                              {                                  CheckOverrideMember(method' method.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                              }                              else                              {                                  // synthesized constructors are the exception' but they should have been weeded out by the caller                                  var isNew = ((SourceMethodSymbol)method).IsNew;                                  CheckNonOverrideMember(method' isNew' method.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                              }                          }                          else if (method.MethodKind == MethodKind.Destructor)                          {                              // NOTE: Normal finalize methods CanOverrideOrHide and will go through the normal code path.                                // First is fine' since there should only be one' since there are no parameters.                              MethodSymbol overridden = method.GetFirstRuntimeOverriddenMethodIgnoringNewSlot(ignoreInterfaceImplementationChanges: true);                                // NOTE: Dev11 doesn't expose symbols' so it can treat destructors as override and let them go through the normal                              // checks.  Roslyn can't' since the language says they are not virtual/override and that's what we need to expose                              // in the symbol model.  Having said that' Dev11 doesn't seem to produce override errors other than this one                              // (see SymbolPreparer::prepareOperator).                              if ((object)overridden != null && overridden.IsMetadataFinal)                              {                                  diagnostics.Add(ErrorCode.ERR_CantOverrideSealed' method.Locations[0]' method' overridden);                              }                          }                          break;                      case SymbolKind.Property:                          var property = (PropertySymbol)member;                          var getMethod = property.GetMethod;                          var setMethod = property.SetMethod;                            // Handle the accessors here' instead of in the loop' so that we can ensure that                          // they're checked *after* the corresponding property.                          if (member.IsOverride)                          {                              CheckOverrideMember(property' property.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                if (!suppressAccessors)                              {                                  if ((object)getMethod != null)                                  {                                      CheckOverrideMember(getMethod' getMethod.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                  }                                  if ((object)setMethod != null)                                  {                                      CheckOverrideMember(setMethod' setMethod.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                  }                              }                          }                          else                          {                              var isNewProperty = ((SourcePropertySymbol)property).IsNew;                              CheckNonOverrideMember(property' isNewProperty' property.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                if (!suppressAccessors)                              {                                  if ((object)getMethod != null)                                  {                                      CheckNonOverrideMember(getMethod' isNewProperty' getMethod.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                  }                                  if ((object)setMethod != null)                                  {                                      CheckNonOverrideMember(setMethod' isNewProperty' setMethod.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                  }                              }                          }                          break;                      case SymbolKind.Event:                          var @event = (EventSymbol)member;                          var addMethod = @event.AddMethod;                          var removeMethod = @event.RemoveMethod;                            // Handle the accessors here' instead of in the loop' so that we can ensure that                          // they're checked *after* the corresponding event.                          if (member.IsOverride)                          {                              CheckOverrideMember(@event' @event.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                if (!suppressAccessors)                              {                                  if ((object)addMethod != null)                                  {                                      CheckOverrideMember(addMethod' addMethod.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                  }                                  if ((object)removeMethod != null)                                  {                                      CheckOverrideMember(removeMethod' removeMethod.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                  }                              }                          }                          else                          {                              var isNewEvent = ((SourceEventSymbol)@event).IsNew;                              CheckNonOverrideMember(@event' isNewEvent' @event.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                if (!suppressAccessors)                              {                                  if ((object)addMethod != null)                                  {                                      CheckNonOverrideMember(addMethod' isNewEvent' addMethod.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                  }                                  if ((object)removeMethod != null)                                  {                                      CheckNonOverrideMember(removeMethod' isNewEvent' removeMethod.OverriddenOrHiddenMembers' diagnostics' out suppressAccessors);                                  }                              }                          }                          break;                      case SymbolKind.Field:                          var sourceField = member as SourceFieldSymbol;                          var isNewField = (object)sourceField != null && sourceField.IsNew;                            // We don't want to report diagnostics for field-like event backing fields (redundant)'                          // but that shouldn't be an issue since they shouldn't be in the member list.                          Debug.Assert((object)sourceField == null || (object)sourceField.AssociatedSymbol == null ||                              sourceField.AssociatedSymbol.Kind != SymbolKind.Event);                            CheckNewModifier(member' isNewField' diagnostics);                          break;                      case SymbolKind.NamedType:                          CheckNewModifier(member' ((SourceMemberContainerTypeSymbol)member).IsNew' diagnostics);                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceMethodSymbol.cs,DecodeDllImportAttribute,The following switch statement is missing a default case: switch (namedArg.Key)                  {                      case "EntryPoint":                          importName = namedArg.Value.Value as string;                          if (!MetadataHelpers.IsValidMetadataIdentifier(importName))                          {                              // Dev10 reports CS0647: "Error emitting attribute ..."                              arguments.Diagnostics.Add(ErrorCode.ERR_InvalidNamedArgument' arguments.AttributeSyntaxOpt.ArgumentList.Arguments[position].Location' namedArg.Key);                              hasErrors = true;                              importName = null;                          }                            break;                        case "CharSet":                          // invalid values will be ignored                          charSet = namedArg.Value.DecodeValue<CharSet>(SpecialType.System_Enum);                          break;                        case "SetLastError":                          // invalid values will be ignored                          setLastError = namedArg.Value.DecodeValue<bool>(SpecialType.System_Boolean);                          break;                        case "ExactSpelling":                          // invalid values will be ignored                          exactSpelling = namedArg.Value.DecodeValue<bool>(SpecialType.System_Boolean);                          break;                        case "PreserveSig":                          preserveSig = namedArg.Value.DecodeValue<bool>(SpecialType.System_Boolean);                          break;                        case "CallingConvention":                          // invalid values will be ignored                          callingConvention = namedArg.Value.DecodeValue<CallingConvention>(SpecialType.System_Enum);                          break;                        case "BestFitMapping":                          bestFitMapping = namedArg.Value.DecodeValue<bool>(SpecialType.System_Boolean);                          break;                        case "ThrowOnUnmappableChar":                          throwOnUnmappable = namedArg.Value.DecodeValue<bool>(SpecialType.System_Boolean);                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceModuleSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceModuleSymbol.cs,NamespaceContainsExplicitDefinitionOfNoPiaLocalTypes,The following switch statement is missing a default case: switch (s.Kind)                  {                      case SymbolKind.Namespace:                          if (NamespaceContainsExplicitDefinitionOfNoPiaLocalTypes((NamespaceSymbol)s))                          {                              return true;                          }                            break;                        case SymbolKind.NamedType:                          if (((NamedTypeSymbol)s).IsExplicitDefinitionOfNoPiaLocalType)                          {                              return true;                          }                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,HasInstanceFields,The following switch statement is missing a default case: switch (m.Kind)                      {                          case SymbolKind.Field:                              return true;                            case SymbolKind.Event:                              if (((EventSymbol)m).AssociatedField != null)                              {                                  return true;                              }                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourceNamedTypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourceNamedTypeSymbol.cs,IsRestrictedBaseType,The following switch statement is missing a default case: switch (specialType)              {                  case SpecialType.System_Array:                  case SpecialType.System_Enum:                  case SpecialType.System_Delegate:                  case SpecialType.System_MulticastDelegate:                  case SpecialType.System_ValueType:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SourcePropertyAccessorSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Source\SourcePropertyAccessorSymbol.cs,GetAttributeDeclarations,The following switch statement is missing a default case: switch (syntax.Kind())              {                  case SyntaxKind.GetAccessorDeclaration:                  case SyntaxKind.SetAccessorDeclaration:                      return OneOrMany.Create(((AccessorDeclarationSyntax)syntax).AttributeLists);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,SynthesizedContainer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Synthesized\SynthesizedContainer.cs,GetFieldsToEmit,The following switch statement is missing a default case: switch (m.Kind)                  {                      case SymbolKind.Field:                          yield return (FieldSymbol)m;                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbol.cs,ComputeAbstractMembers,The following switch statement is missing a default case: switch (member.Kind)                  {                      case SymbolKind.Method:                          {                              overriddenMember = ((MethodSymbol)member).OverriddenMethod;                              break;                          }                      case SymbolKind.Property:                          {                              overriddenMember = ((PropertySymbol)member).OverriddenProperty;                              break;                          }                      case SymbolKind.Event:                          {                              overriddenMember = ((EventSymbol)member).OverriddenEvent;                              break;                          }                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,GetDefaultValue,The following switch statement is missing a default case: switch (type.SpecialType)                  {                      case SpecialType.System_SByte:                      case SpecialType.System_Byte:                      case SpecialType.System_Int16:                      case SpecialType.System_UInt16:                      case SpecialType.System_Int32:                      case SpecialType.System_UInt32:                      case SpecialType.System_Int64:                      case SpecialType.System_UInt64:                      case SpecialType.System_Char:                      case SpecialType.System_Boolean:                      case SpecialType.System_Single:                      case SpecialType.System_Double:                      case SpecialType.System_Decimal:                          return ConstantValue.Default(type.SpecialType);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,VisitType,The following switch statement is missing a default case: switch (current.TypeKind)                  {                      case TypeKind.Class:                      case TypeKind.Struct:                      case TypeKind.Interface:                      case TypeKind.Enum:                      case TypeKind.Delegate:                          {                              var containingType = current.ContainingType;                              if ((object)containingType != null)                              {                                  isNestedNamedType = true;                                  var result = containingType.VisitType(predicate' arg);                                  if ((object)result != null)                                  {                                      return result;                                  }                              }                          }                          break;                        case TypeKind.Submission:                          Debug.Assert((object)current.ContainingType == null);                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,IsAsRestrictive,The following switch statement is missing a default case: switch (acc2)                              {                                  case Accessibility.Private:                                      // if s2 is private and within a subclass of s1's parent'                                      // or withing the same assembly as s1                                      // then this is at least as restrictive as s1's internal protected.                                      if (s2.ContainingAssembly.HasInternalAccessTo(s1.ContainingAssembly))                                      {                                          return true;                                      }                                        for (var parent2 = s2.ContainingType; (object)parent2 != null; parent2 = parent2.ContainingType)                                      {                                          if (parent1.IsAccessibleViaInheritance(parent2' ref useSiteDiagnostics))                                          {                                              return true;                                          }                                      }                                        break;                                    case Accessibility.Internal:                                      // If s2 is in the same assembly as s1' then this is more restrictive                                      // than s1's internal protected.                                      if (s2.ContainingAssembly.HasInternalAccessTo(s1.ContainingAssembly))                                      {                                          return true;                                      }                                        break;                                    case Accessibility.Protected:                                      // if s2 is protected' and it's parent is a subclass (or the same as) s1's parent                                      // then this is at least as restrictive as s1's internal protected                                      if (parent1.IsAccessibleViaInheritance(s2.ContainingType' ref useSiteDiagnostics))                                      {                                          return true;                                      }                                        break;                                    case Accessibility.ProtectedOrInternal:                                      // if s2 is internal protected' and it's parent is a subclass (or the same as) s1's parent                                      // and its in the same assembly as s1' then this is at least as restrictive as s1's protected                                      if (s2.ContainingAssembly.HasInternalAccessTo(s1.ContainingAssembly) &&                                          parent1.IsAccessibleViaInheritance(s2.ContainingType' ref useSiteDiagnostics))                                      {                                          return true;                                      }                                        break;                              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,IsValidSwitchGoverningType,The following switch statement is missing a default case: switch (type.SpecialType)              {                  case SpecialType.System_SByte:                  case SpecialType.System_Byte:                  case SpecialType.System_Int16:                  case SpecialType.System_UInt16:                  case SpecialType.System_Int32:                  case SpecialType.System_UInt32:                  case SpecialType.System_Int64:                  case SpecialType.System_UInt64:                  case SpecialType.System_Char:                  case SpecialType.System_String:                      return true;                    case SpecialType.System_Boolean:                      // User-defined implicit conversion with target type as bool type is not valid.                      return !isTargetTypeOfUserDefinedOp;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,IsRestrictedType,The following switch statement is missing a default case: switch (type.SpecialType)              {                  case SpecialType.System_TypedReference:                  case SpecialType.System_ArgIterator:                  case SpecialType.System_RuntimeArgumentHandle:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,IsValidVolatileFieldType,The following switch statement is missing a default case: switch (type.TypeKind)              {                  case TypeKind.Struct:                      return type.SpecialType.IsValidVolatileFieldType();                    case TypeKind.Array:                  case TypeKind.Class:                  case TypeKind.Delegate:                  case TypeKind.Dynamic:                  case TypeKind.Error:                  case TypeKind.Interface:                  case TypeKind.Pointer:                      return true;                    case TypeKind.Enum:                      return ((NamedTypeSymbol)type).EnumUnderlyingType.SpecialType.IsValidVolatileFieldType();                    case TypeKind.TypeParameter:                      return type.IsReferenceType;                    case TypeKind.Submission:                      throw ExceptionUtilities.UnexpectedValue(type.TypeKind);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,CustomModifierCount,The following switch statement is missing a default case: switch (type.Kind)              {                  case SymbolKind.ArrayType:                      {                          var array = (ArrayTypeSymbol)type;                          return array.CustomModifiers.Length + array.ElementType.CustomModifierCount();                      }                  case SymbolKind.PointerType:                      {                          var pointer = (PointerTypeSymbol)type;                          return pointer.CustomModifiers.Length + pointer.PointedAtType.CustomModifierCount();                      }                  case SymbolKind.ErrorType:                  case SymbolKind.NamedType:                      {                          bool isDefinition = type.IsDefinition;                            if (!isDefinition)                          {                              var namedType = (NamedTypeSymbol)type;                              int count = 0;                                while ((object)namedType != null)                              {                                  ImmutableArray<TypeSymbol> typeArgs = namedType.TypeArgumentsNoUseSiteDiagnostics;                                    foreach (TypeSymbol typeArg in typeArgs)                                  {                                      count += typeArg.CustomModifierCount();                                  }                                    namedType = namedType.ContainingType;                              }                                return count;                          }                          break;                      }              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,TypeSymbolExtensions,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\TypeSymbolExtensions.cs,HasCustomModifiers,The following switch statement is missing a default case: switch (type.Kind)              {                  case SymbolKind.ArrayType:                      {                          var array = (ArrayTypeSymbol)type;                          return array.CustomModifiers.Any() || array.ElementType.HasCustomModifiers();                      }                  case SymbolKind.PointerType:                      {                          var pointer = (PointerTypeSymbol)type;                          return pointer.CustomModifiers.Any() || pointer.PointedAtType.HasCustomModifiers();                      }                  case SymbolKind.ErrorType:                  case SymbolKind.NamedType:                      {                          bool isDefinition = type.IsDefinition;                            if (!isDefinition)                          {                              var namedType = (NamedTypeSymbol)type;                              while ((object)namedType != null)                              {                                  ImmutableArray<TypeSymbol> typeArgs = namedType.TypeArgumentsNoUseSiteDiagnostics;                                    foreach (TypeSymbol typeArg in typeArgs)                                  {                                      if (typeArg.HasCustomModifiers())                                      {                                          return true;                                      }                                  }                                    namedType = namedType.ContainingType;                              }                          }                          break;                      }              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols,VarianceSafety,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\VarianceSafety.cs,CheckInterfaceVarianceSafety,The following switch statement is missing a default case: switch (member.Kind)                  {                      case SymbolKind.Method:                          if (!member.IsAccessor())                          {                              CheckMethodVarianceSafety((MethodSymbol)member' diagnostics);                          }                          break;                      case SymbolKind.Property:                          CheckPropertyVarianceSafety((PropertySymbol)member' diagnostics);                          break;                      case SymbolKind.Event:                          CheckEventVarianceSafety((EventSymbol)member' diagnostics);                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Emit,CSharpDefinitionMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\EditAndContinue\CSharpDefinitionMap.cs,GetStateMachineFieldMapFromMetadata,The following switch statement is missing a default case: switch (GeneratedNames.GetKind(name))                      {                          case GeneratedNameKind.AwaiterField:                              if (GeneratedNames.TryParseSlotIndex(name' out slotIndex))                              {                                  var field = (IFieldSymbol)member;                                    // correct metadata won't contain duplicates' but malformed might' ignore the duplicate:                                  awaiters[(Cci.ITypeReference)field.Type] = slotIndex;                                    if (slotIndex > maxAwaiterSlotIndex)                                  {                                      maxAwaiterSlotIndex = slotIndex;                                  }                              }                                break;                            case GeneratedNameKind.HoistedLocalField:                          case GeneratedNameKind.HoistedSynthesizedLocalField:                              if (GeneratedNames.TryParseSlotIndex(name' out slotIndex))                              {                                  var field = (IFieldSymbol)member;                                  if (slotIndex >= localSlotDebugInfo.Length)                                  {                                      // invalid or missing metadata                                      continue;                                  }                                    var key = new EncHoistedLocalInfo(localSlotDebugInfo[slotIndex]' (Cci.ITypeReference)field.Type);                                    // correct metadata won't contain duplicate ids' but malformed might' ignore the duplicate:                                  hoistedLocals[key] = slotIndex;                              }                                break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Emit,PEModuleBuilder,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\Model\PEModuleBuilder.cs,Translate,The following switch statement is missing a default case: switch (typeSymbol.Kind)              {                  case SymbolKind.DynamicType:                      return Translate((DynamicTypeSymbol)typeSymbol' syntaxNodeOpt' diagnostics);                    case SymbolKind.ArrayType:                      return Translate((ArrayTypeSymbol)typeSymbol);                    case SymbolKind.ErrorType:                  case SymbolKind.NamedType:                      return Translate((NamedTypeSymbol)typeSymbol' syntaxNodeOpt' diagnostics);                    case SymbolKind.PointerType:                      return Translate((PointerTypeSymbol)typeSymbol);                    case SymbolKind.TypeParameter:                      return Translate((TypeParameterSymbol)typeSymbol);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Emit.NoPia,EmbeddedType,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Emitter\NoPia\EmbeddedType.cs,EmbedDefaultMembers,The following switch statement is missing a default case: switch (s.Kind)                  {                      case SymbolKind.Field:                          TypeManager.EmbedField(this' (FieldSymbol)s' syntaxNodeOpt' diagnostics);                          break;                      case SymbolKind.Method:                          TypeManager.EmbedMethod(this' (MethodSymbol)s' syntaxNodeOpt' diagnostics);                          break;                      case SymbolKind.Property:                          TypeManager.EmbedProperty(this' (PropertySymbol)s' syntaxNodeOpt' diagnostics);                          break;                      case SymbolKind.Event:                          TypeManager.EmbedEvent(this' (EventSymbol)s' syntaxNodeOpt' diagnostics' isUsedForComAwareEventBinding: false);                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DirectiveParser.cs,Evaluate,The following switch statement is missing a default case: switch (expr.Kind)              {                  case SyntaxKind.ParenthesizedExpression:                      return Evaluate(((ParenthesizedExpressionSyntax)expr).Expression);                  case SyntaxKind.TrueLiteralExpression:                  case SyntaxKind.FalseLiteralExpression:                      return ((LiteralExpressionSyntax)expr).Token.Value;                  case SyntaxKind.LogicalAndExpression:                  case SyntaxKind.BitwiseAndExpression:                      return EvaluateBool(((BinaryExpressionSyntax)expr).Left) && EvaluateBool(((BinaryExpressionSyntax)expr).Right);                  case SyntaxKind.LogicalOrExpression:                  case SyntaxKind.BitwiseOrExpression:                      return EvaluateBool(((BinaryExpressionSyntax)expr).Left) || EvaluateBool(((BinaryExpressionSyntax)expr).Right);                  case SyntaxKind.EqualsExpression:                      return object.Equals(Evaluate(((BinaryExpressionSyntax)expr).Left)' Evaluate(((BinaryExpressionSyntax)expr).Right));                  case SyntaxKind.NotEqualsExpression:                      return !object.Equals(Evaluate(((BinaryExpressionSyntax)expr).Left)' Evaluate(((BinaryExpressionSyntax)expr).Right));                  case SyntaxKind.LogicalNotExpression:                      return !EvaluateBool(((PrefixUnaryExpressionSyntax)expr).Operand);                  case SyntaxKind.IdentifierName:                      // For backwards compatibility' we want to evaluate any unicode escape sequences in                      // the identifier name and then check again for boolean literals.  (This actually                      // seems like a bug that we're retaining for back-compat' because section 2.4.1 of                      // the spec says that escape sequences can only appear in identifiers' character                      // literals' and regular string literals - not boolean literals.  In (non-directive)                      // C#' tru\u0065 is equivalent to the identifier @true' not the boolean literal true.)                      string id = ((IdentifierNameSyntax)expr).Identifier.ValueText;                      bool constantValue;                      if (bool.TryParse(id' out constantValue))                      {                          return constantValue;                      }                      return IsDefined(id);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveStack,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Directives.cs,IsDefined,The following switch statement is missing a default case: switch (current.Head.Kind)                  {                      case SyntaxKind.DefineDirectiveTrivia:                          if (current.Head.GetIdentifier() == id)                          {                              return DefineState.Defined;                          }                            break;                      case SyntaxKind.UndefDirectiveTrivia:                          if (current.Head.GetIdentifier() == id)                          {                              return DefineState.Undefined;                          }                            break;                        case SyntaxKind.ElifDirectiveTrivia:                      case SyntaxKind.ElseDirectiveTrivia:                          // Skip directives from previous branches of the same #if.                          do                          {                              current = current.Tail;                                if (current == null || !current.Any())                              {                                  return DefineState.Unspecified;                              }                          }                          while (current.Head.Kind != SyntaxKind.IfDirectiveTrivia);                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveStack,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Directives.cs,GetPreviousIf,The following switch statement is missing a default case: switch (current.Head.Kind)                  {                      case SyntaxKind.IfDirectiveTrivia:                          return current;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveStack,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Directives.cs,GetPreviousIfElifElseOrRegion,The following switch statement is missing a default case: switch (current.Head.Kind)                  {                      case SyntaxKind.IfDirectiveTrivia:                      case SyntaxKind.ElifDirectiveTrivia:                      case SyntaxKind.ElseDirectiveTrivia:                      case SyntaxKind.RegionDirectiveTrivia:                          return current;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DirectiveStack,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Directives.cs,SkipInsignificantDirectives,The following switch statement is missing a default case: switch (directives.Head.Kind)                  {                      case SyntaxKind.IfDirectiveTrivia:                      case SyntaxKind.ElifDirectiveTrivia:                      case SyntaxKind.ElseDirectiveTrivia:                      case SyntaxKind.EndIfDirectiveTrivia:                      case SyntaxKind.DefineDirectiveTrivia:                      case SyntaxKind.UndefDirectiveTrivia:                      case SyntaxKind.RegionDirectiveTrivia:                      case SyntaxKind.EndRegionDirectiveTrivia:                          return directives;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentParser.cs,ParseCrefParameter,The following switch statement is missing a default case: switch (CurrentToken.Kind)              {                  case SyntaxKind.RefKeyword:                  case SyntaxKind.OutKeyword:                      refOrOutOpt = EatToken();                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following switch statement is missing a default case: switch (text.Length)              {                  case 3:                      if (text == DocumentationCommentXmlNames.SeeElementName)                      {                          return s_seeToken;                      }                      break;                    case 4:                      switch (text)                      {                          case DocumentationCommentXmlNames.CodeElementName:                              return s_codeToken;                            case DocumentationCommentXmlNames.ListElementName:                              return s_listToken;                      }                      break;                    case 5:                      switch (text)                      {                          case DocumentationCommentXmlNames.ParameterElementName:                              return s_paramToken;                            case DocumentationCommentXmlNames.ValueElementName:                              return s_valueToken;                      }                      break;                    case 7:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExampleElementName:                              return s_exampleToken;                            case DocumentationCommentXmlNames.IncludeElementName:                              return s_includeToken;                            case DocumentationCommentXmlNames.RemarksElementName:                              return s_remarksToken;                            case DocumentationCommentXmlNames.SeeAlsoElementName:                              return s_seealsoToken;                            case DocumentationCommentXmlNames.SummaryElementName:                              return s_summaryToken;                      }                      break;                    case 9:                      switch (text)                      {                          case DocumentationCommentXmlNames.ExceptionElementName:                              return s_exceptionToken;                            case DocumentationCommentXmlNames.TypeParameterElementName:                              return s_typeparamToken;                      }                      break;                    case 10:                      if (text == DocumentationCommentXmlNames.PermissionElementName)                      {                          return s_permissionToken;                      }                      break;                    case 12:                      if (text == DocumentationCommentXmlNames.TypeParameterElementName)                      {                          return s_typeparamrefToken;                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following switch statement is missing a default case: switch (text)                      {                          case DocumentationCommentXmlNames.CodeElementName:                              return s_codeToken;                            case DocumentationCommentXmlNames.ListElementName:                              return s_listToken;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following switch statement is missing a default case: switch (text)                      {                          case DocumentationCommentXmlNames.ParameterElementName:                              return s_paramToken;                            case DocumentationCommentXmlNames.ValueElementName:                              return s_valueToken;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following switch statement is missing a default case: switch (text)                      {                          case DocumentationCommentXmlNames.ExampleElementName:                              return s_exampleToken;                            case DocumentationCommentXmlNames.IncludeElementName:                              return s_includeToken;                            case DocumentationCommentXmlNames.RemarksElementName:                              return s_remarksToken;                            case DocumentationCommentXmlNames.SeeAlsoElementName:                              return s_seealsoToken;                            case DocumentationCommentXmlNames.SummaryElementName:                              return s_summaryToken;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlElementTag,The following switch statement is missing a default case: switch (text)                      {                          case DocumentationCommentXmlNames.ExceptionElementName:                              return s_exceptionToken;                            case DocumentationCommentXmlNames.TypeParameterElementName:                              return s_typeparamToken;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,DocumentationCommentXmlTokens,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\DocumentationCommentXmlTokens.cs,LookupXmlAttribute,The following switch statement is missing a default case: switch (text)              {                  case DocumentationCommentXmlNames.CrefAttributeName:                      return s_crefToken;                    case DocumentationCommentXmlNames.FileAttributeName:                      return s_fileToken;                    case DocumentationCommentXmlNames.NameAttributeName:                      return s_nameToken;                    case DocumentationCommentXmlNames.PathAttributeName:                      return s_pathToken;                    case DocumentationCommentXmlNames.TypeAttributeName:                      return s_typeToken;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsTerminator,The following switch statement is missing a default case: switch (isolated)                      {                          case TerminatorState.IsNamespaceMemberStartOrStop:                              if (this.IsNamespaceMemberStartOrStop())                              {                                  return true;                              }                                break;                          case TerminatorState.IsAttributeDeclarationTerminator:                              if (this.IsAttributeDeclarationTerminator())                              {                                  return true;                              }                                break;                          case TerminatorState.IsPossibleAggregateClauseStartOrStop:                              if (this.IsPossibleAggregateClauseStartOrStop())                              {                                  return true;                              }                                break;                          case TerminatorState.IsPossibleMemberStartOrStop:                              if (this.IsPossibleMemberStartOrStop())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfReturnType:                              if (this.IsEndOfReturnType())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfParameterList:                              if (this.IsEndOfParameterList())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfFieldDeclaration:                              if (this.IsEndOfFieldDeclaration())                              {                                  return true;                              }                                break;                          case TerminatorState.IsPossibleEndOfVariableDeclaration:                              if (this.IsPossibleEndOfVariableDeclaration())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfTypeArgumentList:                              if (this.IsEndOfTypeArgumentList())                              {                                  return true;                              }                                break;                          case TerminatorState.IsPossibleStatementStartOrStop:                              if (this.IsPossibleStatementStartOrStop())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfFixedStatement:                              if (this.IsEndOfFixedStatement())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfTryBlock:                              if (this.IsEndOfTryBlock())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfCatchClause:                              if (this.IsEndOfCatchClause())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfilterClause:                              if (this.IsEndOfFilterClause())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfCatchBlock:                              if (this.IsEndOfCatchBlock())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfDoWhileExpression:                              if (this.IsEndOfDoWhileExpression())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfForStatementArgument:                              if (this.IsEndOfForStatementArgument())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfDeclarationClause:                              if (this.IsEndOfDeclarationClause())                              {                                  return true;                              }                                break;                          case TerminatorState.IsEndOfArgumentList:                              if (this.IsEndOfArgumentList())                              {                                  return true;                              }                                break;                          case TerminatorState.IsSwitchSectionStart:                              if (this.IsPossibleSwitchSection())                              {                                  return true;                              }                                break;                            case TerminatorState.IsEndOfTypeParameterList:                              if (this.IsEndOfTypeParameterList())                              {                                  return true;                              }                                break;                            case TerminatorState.IsEndOfMethodSignature:                              if (this.IsEndOfMethodSignature())                              {                                  return true;                              }                                break;                            case TerminatorState.IsEndOfNameInExplicitInterface:                              if (this.IsEndOfNameInExplicitInterface())                              {                                  return true;                              }                                break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ContainsAlias,The following switch statement is missing a default case: switch (name.Kind)              {                  case SyntaxKind.GenericName:                      return false;                  case SyntaxKind.AliasQualifiedName:                      return true;                  case SyntaxKind.QualifiedName:                      var qualifedName = (QualifiedNameSyntax)name;                      return ContainsAlias(qualifedName.Left);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ContainsGeneric,The following switch statement is missing a default case: switch (name.Kind)              {                  case SyntaxKind.GenericName:                      return true;                  case SyntaxKind.AliasQualifiedName:                      return ContainsGeneric(((AliasQualifiedNameSyntax)name).Name);                  case SyntaxKind.QualifiedName:                      var qualifedName = (QualifiedNameSyntax)name;                      return ContainsGeneric(qualifedName.Left) || ContainsGeneric(qualifedName.Right);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAttributeArgument,The following switch statement is missing a default case: switch (nextTokenKind)                  {                      case SyntaxKind.EqualsToken:                          {                              var name = this.ParseIdentifierToken();                              var equals = this.EatToken(SyntaxKind.EqualsToken);                              nameEquals = _syntaxFactory.NameEquals(_syntaxFactory.IdentifierName(name)' equals);                              shouldHaveName = true;                          }                            break;                      case SyntaxKind.ColonToken:                          {                              var name = this.ParseIdentifierName();                              var colonToken = this.EatToken(SyntaxKind.ColonToken);                              nameColon = _syntaxFactory.NameColon(name' colonToken);                              nameColon = CheckFeatureAvailability(nameColon' MessageID.IDS_FeatureNamedArgument);                          }                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetModifier,The following switch statement is missing a default case: switch (token.ContextualKind)                      {                          case SyntaxKind.PartialKeyword:                              return SyntaxModifier.Partial;                          case SyntaxKind.AsyncKeyword:                              return SyntaxModifier.Async;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPartialType,The following switch statement is missing a default case: switch (this.PeekToken(1).Kind)              {                  case SyntaxKind.StructKeyword:                  case SyntaxKind.ClassKeyword:                  case SyntaxKind.InterfaceKeyword:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,CanReuseTypeDeclaration,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.ClassDeclaration:                      case SyntaxKind.StructDeclaration:                      case SyntaxKind.InterfaceDeclaration:                      case SyntaxKind.EnumDeclaration:                      case SyntaxKind.DelegateDeclaration:                          return true;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,CanReuseMemberDeclaration,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.ClassDeclaration:                      case SyntaxKind.StructDeclaration:                      case SyntaxKind.InterfaceDeclaration:                      case SyntaxKind.EnumDeclaration:                      case SyntaxKind.DelegateDeclaration:                      case SyntaxKind.FieldDeclaration:                      case SyntaxKind.EventFieldDeclaration:                      case SyntaxKind.PropertyDeclaration:                      case SyntaxKind.EventDeclaration:                      case SyntaxKind.IndexerDeclaration:                      case SyntaxKind.OperatorDeclaration:                      case SyntaxKind.ConversionOperatorDeclaration:                          return true;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,CanReuseMemberDeclaration,The following switch statement is missing a default case: switch (member.Kind())                      {                          case SyntaxKind.MethodDeclaration:                              // can reuse a method as long as it *doesn't* match the type name.                              //                              // TODO(cyrusn): Relax this in the case of generic methods?                              var methodDeclaration = (CSharp.Syntax.MethodDeclarationSyntax)member;                              return methodDeclaration.Identifier.ValueText != typeName;                            case SyntaxKind.ConstructorDeclaration: // fall through                          case SyntaxKind.DestructorDeclaration:                              // can reuse constructors or destructors if the name and type name still                              // match.                              return originalTypeDeclaration.Identifier.ValueText == typeName;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The following switch statement is missing a default case: switch (this.CurrentToken.Kind)                      {                          case SyntaxKind.UnsafeKeyword:                              if (this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)                              {                                  return _syntaxFactory.GlobalStatement(ParseUnsafeStatement());                              }                              break;                            case SyntaxKind.FixedKeyword:                              if (this.PeekToken(1).Kind == SyntaxKind.OpenParenToken)                              {                                  return _syntaxFactory.GlobalStatement(ParseFixedStatement());                              }                              break;                            case SyntaxKind.DelegateKeyword:                              switch (this.PeekToken(1).Kind)                              {                                  case SyntaxKind.OpenParenToken:                                  case SyntaxKind.OpenBraceToken:                                      return _syntaxFactory.GlobalStatement(ParseExpressionStatement());                              }                              break;                            case SyntaxKind.NewKeyword:                              if (IsPossibleNewExpression())                              {                                  return _syntaxFactory.GlobalStatement(ParseExpressionStatement());                              }                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseMemberDeclarationOrStatement,The following switch statement is missing a default case: switch (this.PeekToken(1).Kind)                              {                                  case SyntaxKind.OpenParenToken:                                  case SyntaxKind.OpenBraceToken:                                      return _syntaxFactory.GlobalStatement(ParseExpressionStatement());                              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseAccessorDeclaration,The following switch statement is missing a default case: switch (accessorName.ContextualKind)                      {                          case SyntaxKind.GetKeyword:                          case SyntaxKind.SetKeyword:                          case SyntaxKind.AddKeyword:                          case SyntaxKind.RemoveKeyword:                              accessorName = ConvertToKeyword(accessorName);                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,CanReuseAccessorDeclaration,The following switch statement is missing a default case: switch (this.CurrentNodeKind)              {                  case SyntaxKind.AddAccessorDeclaration:                  case SyntaxKind.RemoveAccessorDeclaration:                      if (isEvent && parent != null && parent.Kind() == SyntaxKind.EventDeclaration)                      {                          return true;                      }                        break;                  case SyntaxKind.GetAccessorDeclaration:                  case SyntaxKind.SetAccessorDeclaration:                      if (!isEvent && parent != null && parent.Kind() == SyntaxKind.PropertyDeclaration)                      {                          return true;                      }                        break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,GetOriginalModifiers,The following switch statement is missing a default case: switch (decl.Kind())                  {                      case SyntaxKind.FieldDeclaration:                          return ((CSharp.Syntax.FieldDeclarationSyntax)decl).Modifiers;                      case SyntaxKind.MethodDeclaration:                          return ((CSharp.Syntax.MethodDeclarationSyntax)decl).Modifiers;                      case SyntaxKind.ConstructorDeclaration:                          return ((CSharp.Syntax.ConstructorDeclarationSyntax)decl).Modifiers;                      case SyntaxKind.DestructorDeclaration:                          return ((CSharp.Syntax.DestructorDeclarationSyntax)decl).Modifiers;                      case SyntaxKind.PropertyDeclaration:                          return ((CSharp.Syntax.PropertyDeclarationSyntax)decl).Modifiers;                      case SyntaxKind.EventFieldDeclaration:                          return ((CSharp.Syntax.EventFieldDeclarationSyntax)decl).Modifiers;                      case SyntaxKind.AddAccessorDeclaration:                      case SyntaxKind.RemoveAccessorDeclaration:                      case SyntaxKind.GetAccessorDeclaration:                      case SyntaxKind.SetAccessorDeclaration:                          return ((CSharp.Syntax.AccessorDeclarationSyntax)decl).Modifiers;                      case SyntaxKind.ClassDeclaration:                      case SyntaxKind.StructDeclaration:                      case SyntaxKind.InterfaceDeclaration:                          return ((CSharp.Syntax.TypeDeclarationSyntax)decl).Modifiers;                      case SyntaxKind.DelegateDeclaration:                          return ((CSharp.Syntax.DelegateDeclarationSyntax)decl).Modifiers;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ScanPossibleTypeArgumentList,The following switch statement is missing a default case: switch (this.ScanType(out lastTokenOfList))                      {                          case ScanTypeFlags.NotType:                              lastTokenOfList = null;                              return ScanTypeFlags.NotType;                            case ScanTypeFlags.MustBeType:                          case ScanTypeFlags.GenericTypeOrMethod:                              result = ScanTypeFlags.GenericTypeOrMethod;                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsPossibleNewExpression,The following switch statement is missing a default case: switch (nextToken.Kind)              {                  case SyntaxKind.OpenBraceToken:                  case SyntaxKind.OpenBracketToken:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsAwaitExpression,The following switch statement is missing a default case: switch (this.PeekToken(1).Kind)                  {                      case SyntaxKind.IdentifierToken:                        // Keywords                      case SyntaxKind.NewKeyword:                      case SyntaxKind.ThisKeyword:                      case SyntaxKind.BaseKeyword:                      case SyntaxKind.DelegateKeyword:                      case SyntaxKind.TypeOfKeyword:                      case SyntaxKind.CheckedKeyword:                      case SyntaxKind.UncheckedKeyword:                      case SyntaxKind.DefaultKeyword:                        // Literals                      case SyntaxKind.TrueKeyword:                      case SyntaxKind.FalseKeyword:                      case SyntaxKind.StringLiteralToken:                      case SyntaxKind.InterpolatedStringStartToken:                      case SyntaxKind.InterpolatedStringToken:                      case SyntaxKind.NumericLiteralToken:                      case SyntaxKind.NullKeyword:                      case SyntaxKind.CharacterLiteralToken:                          return true;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseConsequenceSyntax,The following switch statement is missing a default case: switch (tk)              {                  case SyntaxKind.DotToken:                      expr = _syntaxFactory.MemberBindingExpression(this.EatToken()' this.ParseSimpleName(NameOptions.InExpression));                      break;                    case SyntaxKind.OpenBracketToken:                      expr = _syntaxFactory.ElementBindingExpression(this.ParseBracketedArgumentList());                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,IsTokenQueryContextualKeyword,The following switch statement is missing a default case: switch (token.ContextualKind)              {                  case SyntaxKind.OnKeyword:                  case SyntaxKind.EqualsKeyword:                  case SyntaxKind.AscendingKeyword:                  case SyntaxKind.DescendingKeyword:                  case SyntaxKind.ByKeyword:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,LanguageParser,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs,ParseQueryBody,The following switch statement is missing a default case: switch (this.CurrentToken.ContextualKind)                      {                          case SyntaxKind.FromKeyword:                              var fc = this.ParseFromClause();                              clauses.Add(fc);                              continue;                          case SyntaxKind.JoinKeyword:                              clauses.Add(this.ParseJoinClause());                              continue;                          case SyntaxKind.LetKeyword:                              clauses.Add(this.ParseLetClause());                              continue;                          case SyntaxKind.WhereKeyword:                              clauses.Add(this.ParseWhereClause());                              continue;                          case SyntaxKind.OrderByKeyword:                              clauses.Add(this.ParseOrderByClause());                              continue;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,Lex,The following switch statement is missing a default case: switch (_mode)              {                  case LexerMode.Syntax:                  case LexerMode.DebuggerSyntax:                      return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();                  case LexerMode.Directive:                      return this.LexDirectiveToken();              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,Lex,The following switch statement is missing a default case: switch (ModeOf(_mode))              {                  case LexerMode.XmlDocComment:                      return this.LexXmlToken();                  case LexerMode.XmlElementTag:                      return this.LexXmlElementTagToken();                  case LexerMode.XmlAttributeTextQuote:                  case LexerMode.XmlAttributeTextDoubleQuote:                      return this.LexXmlAttributeTextToken();                  case LexerMode.XmlCDataSectionText:                      return this.LexXmlCDataSectionTextToken();                  case LexerMode.XmlCommentText:                      return this.LexXmlCommentTextToken();                  case LexerMode.XmlProcessingInstructionText:                      return this.LexXmlProcessingInstructionTextToken();                  case LexerMode.XmlCrefQuote:                  case LexerMode.XmlCrefDoubleQuote:                      return this.LexXmlCrefOrNameToken();                  case LexerMode.XmlNameQuote:                  case LexerMode.XmlNameDoubleQuote:                      // Same lexing as a cref attribute' just treat the identifiers a little differently.                      return this.LexXmlCrefOrNameToken();                  case LexerMode.XmlCharacter:                      return this.LexXmlCharacter();              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,Lexer,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\Lexer.cs,ScanXmlCrefToken,The following switch statement is missing a default case: switch (consumedChar)              {                  //// Single-Character Punctuation/Operators ////                  case '(':                      info.Kind = SyntaxKind.OpenParenToken;                      break;                  case ')':                      info.Kind = SyntaxKind.CloseParenToken;                      break;                  case '[':                      info.Kind = SyntaxKind.OpenBracketToken;                      break;                  case ']':                      info.Kind = SyntaxKind.CloseBracketToken;                      break;                  case ''':                      info.Kind = SyntaxKind.CommaToken;                      break;                  case '.':                      info.Kind = SyntaxKind.DotToken;                      break;                  case '?':                      info.Kind = SyntaxKind.QuestionToken;                      break;                  case '&':                      info.Kind = SyntaxKind.AmpersandToken;                      break;                  case '*':                      info.Kind = SyntaxKind.AsteriskToken;                      break;                  case '|':                      info.Kind = SyntaxKind.BarToken;                      break;                  case '^':                      info.Kind = SyntaxKind.CaretToken;                      break;                  case '%':                      info.Kind = SyntaxKind.PercentToken;                      break;                  case '/':                      info.Kind = SyntaxKind.SlashToken;                      break;                  case '~':                      info.Kind = SyntaxKind.TildeToken;                      break;                    // NOTE: Special case - convert curly brackets into angle brackets.                  case '{':                      info.Kind = SyntaxKind.LessThanToken;                      break;                  case '}':                      info.Kind = SyntaxKind.GreaterThanToken;                      break;                    //// Multi-Character Punctuation/Operators ////                  case ':':                      if (AdvanceIfMatches(':')) info.Kind = SyntaxKind.ColonColonToken;                      else info.Kind = SyntaxKind.ColonToken;                      break;                  case '=':                      if (AdvanceIfMatches('=')) info.Kind = SyntaxKind.EqualsEqualsToken;                      else info.Kind = SyntaxKind.EqualsToken;                      break;                  case '!':                      if (AdvanceIfMatches('=')) info.Kind = SyntaxKind.ExclamationEqualsToken;                      else info.Kind = SyntaxKind.ExclamationToken;                      break;                  case '>':                      if (AdvanceIfMatches('=')) info.Kind = SyntaxKind.GreaterThanEqualsToken;                      // GreaterThanGreaterThanToken is synthesized in the parser since it is ambiguous (with closing nested type parameter lists)                      // else if (AdvanceIfMatches('>')) info.Kind = SyntaxKind.GreaterThanGreaterThanToken;                      else info.Kind = SyntaxKind.GreaterThanToken;                      break;                  case '<':                      if (AdvanceIfMatches('=')) info.Kind = SyntaxKind.LessThanEqualsToken;                      else if (AdvanceIfMatches('<')) info.Kind = SyntaxKind.LessThanLessThanToken;                      else info.Kind = SyntaxKind.LessThanToken;                      break;                  case '+':                      if (AdvanceIfMatches('+')) info.Kind = SyntaxKind.PlusPlusToken;                      else info.Kind = SyntaxKind.PlusToken;                      break;                  case '-':                      if (AdvanceIfMatches('-')) info.Kind = SyntaxKind.MinusMinusToken;                      else info.Kind = SyntaxKind.MinusToken;                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,TryScanXmlEntity,The following switch statement is missing a default case: switch (this.PeekChar())              {                  case 'l':                      if (AdvanceIfMatches("lt;"))                      {                          ch = '<';                          return true;                      }                      break;                  case 'g':                      if (AdvanceIfMatches("gt;"))                      {                          ch = '>';                          return true;                      }                      break;                  case 'a':                      if (AdvanceIfMatches("amp;"))                      {                          ch = '&';                          return true;                      }                      else if (AdvanceIfMatches("apos;"))                      {                          ch = '\'';                          return true;                      }                      break;                  case 'q':                      if (AdvanceIfMatches("quot;"))                      {                          ch = '"';                          return true;                      }                      break;                  case '#':                      {                          this.AdvanceChar(); //#                            uint uintChar = 0;                            if (AdvanceIfMatches("x"))                          {                              char digit;                              while (SyntaxFacts.IsHexDigit(digit = this.PeekChar()))                              {                                  this.AdvanceChar();                                    // disallow overflow                                  if (uintChar <= 0x7FFFFFF)                                  {                                      uintChar = (uintChar << 4) + (uint)SyntaxFacts.HexValue(digit);                                  }                                  else                                  {                                      return false;                                  }                              }                          }                          else                          {                              char digit;                              while (SyntaxFacts.IsDecDigit(digit = this.PeekChar()))                              {                                  this.AdvanceChar();                                    // disallow overflow                                  if (uintChar <= 0x7FFFFFF)                                  {                                      uintChar = (uintChar << 3) + (uintChar << 1) + (uint)SyntaxFacts.DecValue(digit);                                  }                                  else                                  {                                      return false;                                  }                              }                          }                            if (AdvanceIfMatches(";"))                          {                              ch = GetCharsFromUtf32(uintChar' out surrogate);                              return true;                          }                            break;                      }              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax,SlidingTextWindow,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Parser\SlidingTextWindow.cs,GetText,The following switch statement is missing a default case: switch (length)              {                  case 0:                      return string.Empty;                    case 1:                      if (_characterWindow[offset] == ' ')                      {                          return " ";                      }                      break;                    case 2:                      char firstChar = _characterWindow[offset];                      if (firstChar == '\r' && _characterWindow[offset + 1] == '\n')                      {                          return "\r\n";                      }                      if (firstChar == '/' && _characterWindow[offset + 1] == '/')                      {                          return "//";                      }                      break;                    case 3:                      if (_characterWindow[offset] == '/' && _characterWindow[offset + 1] == '/' && _characterWindow[offset + 2] == ' ')                      {                          return "// ";                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE,PEMethodSymbol,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Symbols\Metadata\PE\PEMethodSymbol.cs,ComputeMethodKind,The following switch statement is missing a default case: switch (_name)                      {                          case WellKnownMemberNames.AdditionOperatorName:                          case WellKnownMemberNames.BitwiseAndOperatorName:                          case WellKnownMemberNames.BitwiseOrOperatorName:                          case WellKnownMemberNames.DivisionOperatorName:                          case WellKnownMemberNames.EqualityOperatorName:                          case WellKnownMemberNames.ExclusiveOrOperatorName:                          case WellKnownMemberNames.GreaterThanOperatorName:                          case WellKnownMemberNames.GreaterThanOrEqualOperatorName:                          case WellKnownMemberNames.InequalityOperatorName:                          case WellKnownMemberNames.LeftShiftOperatorName:                          case WellKnownMemberNames.LessThanOperatorName:                          case WellKnownMemberNames.LessThanOrEqualOperatorName:                          case WellKnownMemberNames.ModulusOperatorName:                          case WellKnownMemberNames.MultiplyOperatorName:                          case WellKnownMemberNames.RightShiftOperatorName:                          case WellKnownMemberNames.SubtractionOperatorName:                              return IsValidUserDefinedOperatorSignature(2) ? MethodKind.UserDefinedOperator : MethodKind.Ordinary;                          case WellKnownMemberNames.DecrementOperatorName:                          case WellKnownMemberNames.FalseOperatorName:                          case WellKnownMemberNames.IncrementOperatorName:                          case WellKnownMemberNames.LogicalNotOperatorName:                          case WellKnownMemberNames.OnesComplementOperatorName:                          case WellKnownMemberNames.TrueOperatorName:                          case WellKnownMemberNames.UnaryNegationOperatorName:                          case WellKnownMemberNames.UnaryPlusOperatorName:                              return IsValidUserDefinedOperatorSignature(1) ? MethodKind.UserDefinedOperator : MethodKind.Ordinary;                          case WellKnownMemberNames.ImplicitConversionName:                          case WellKnownMemberNames.ExplicitConversionName:                              return IsValidUserDefinedOperatorSignature(1) ? MethodKind.Conversion : MethodKind.Ordinary;                              // UNDONE: Non-C#-supported overloaded operator case WellKnownMemberNames.ConcatenateOperatorName:                              // UNDONE: Non-C#-supported overloaded operator case WellKnownMemberNames.ExponentOperatorName:                              // UNDONE: Non-C#-supported overloaded operator case WellKnownMemberNames.IntegerDivisionOperatorName:                              // UNDONE: Non-C#-supported overloaded operator case WellKnownMemberNames.LikeOperatorName:                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,CSharpLineDirectiveMap,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\CSharpLineDirectiveMap.cs,GetEntry,The following switch statement is missing a default case: switch (lineToken.Kind())                  {                      case SyntaxKind.HiddenKeyword:                          state = PositionState.Hidden;                          break;                        case SyntaxKind.DefaultKeyword:                          mappedLine = unmappedLine;                          mappedPathOpt = null;                          state = PositionState.Unmapped;                          break;                        case SyntaxKind.NumericLiteralToken:                          // skip both the mapped line and the filename if the line number is not valid                          if (!lineToken.ContainsDiagnostics)                          {                              object value = lineToken.Value;                              if (value is int)                              {                                  // convert one-based line number into zero-based line number                                  mappedLine = ((int)value) - 1;                              }                                if (directive.File.Kind() == SyntaxKind.StringLiteralToken)                              {                                  mappedPathOpt = (string)directive.File.Value;                              }                                state = PositionState.Remapped;                          }                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,DirectiveTriviaSyntax,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\DirectiveTriviaSyntax.cs,GetNextRelatedDirective,The following switch statement is missing a default case: switch (d.Kind())              {                  case SyntaxKind.IfDirectiveTrivia:                      while (d != null)                      {                          switch (d.Kind())                          {                              case SyntaxKind.ElifDirectiveTrivia:                              case SyntaxKind.ElseDirectiveTrivia:                              case SyntaxKind.EndIfDirectiveTrivia:                                  return d;                          }                            d = d.GetNextPossiblyRelatedDirective();                      }                        break;                  case SyntaxKind.ElifDirectiveTrivia:                      while (d != null)                      {                          switch (d.Kind())                          {                              case SyntaxKind.ElseDirectiveTrivia:                              case SyntaxKind.EndIfDirectiveTrivia:                                  return d;                          }                            d = d.GetNextPossiblyRelatedDirective();                      }                        break;                  case SyntaxKind.ElseDirectiveTrivia:                      while (d != null)                      {                          if (d.Kind() == SyntaxKind.EndIfDirectiveTrivia)                          {                              return d;                          }                            d = d.GetNextPossiblyRelatedDirective();                      }                        break;                  case SyntaxKind.RegionDirectiveTrivia:                      while (d != null)                      {                          if (d.Kind() == SyntaxKind.EndRegionDirectiveTrivia)                          {                              return d;                          }                            d = d.GetNextPossiblyRelatedDirective();                      }                        break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,DirectiveTriviaSyntax,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\DirectiveTriviaSyntax.cs,GetNextRelatedDirective,The following switch statement is missing a default case: switch (d.Kind())                          {                              case SyntaxKind.ElifDirectiveTrivia:                              case SyntaxKind.ElseDirectiveTrivia:                              case SyntaxKind.EndIfDirectiveTrivia:                                  return d;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,DirectiveTriviaSyntax,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\DirectiveTriviaSyntax.cs,GetNextRelatedDirective,The following switch statement is missing a default case: switch (d.Kind())                          {                              case SyntaxKind.ElseDirectiveTrivia:                              case SyntaxKind.EndIfDirectiveTrivia:                                  return d;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,DirectiveTriviaSyntax,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\DirectiveTriviaSyntax.cs,GetNextPossiblyRelatedDirective,The following switch statement is missing a default case: switch (d.Kind())                      {                          case SyntaxKind.IfDirectiveTrivia:                              while (d != null && d.Kind() != SyntaxKind.EndIfDirectiveTrivia)                              {                                  d = d.GetNextRelatedDirective();                              }                                continue;                          case SyntaxKind.RegionDirectiveTrivia:                              while (d != null && d.Kind() != SyntaxKind.EndRegionDirectiveTrivia)                              {                                  d = d.GetNextRelatedDirective();                              }                                continue;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,DirectiveTriviaSyntax,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\DirectiveTriviaSyntax.cs,GetPreviousRelatedDirective,The following switch statement is missing a default case: switch (d.Kind())              {                  case SyntaxKind.EndIfDirectiveTrivia:                      while (d != null)                      {                          switch (d.Kind())                          {                              case SyntaxKind.IfDirectiveTrivia:                              case SyntaxKind.ElifDirectiveTrivia:                              case SyntaxKind.ElseDirectiveTrivia:                                  return d;                          }                            d = d.GetPreviousPossiblyRelatedDirective();                      }                        break;                  case SyntaxKind.ElifDirectiveTrivia:                      while (d != null)                      {                          if (d.Kind() == SyntaxKind.IfDirectiveTrivia)                          {                              return d;                          }                            d = d.GetPreviousPossiblyRelatedDirective();                      }                        break;                  case SyntaxKind.ElseDirectiveTrivia:                      while (d != null)                      {                          switch (d.Kind())                          {                              case SyntaxKind.IfDirectiveTrivia:                              case SyntaxKind.ElifDirectiveTrivia:                                  return d;                          }                            d = d.GetPreviousPossiblyRelatedDirective();                      }                        break;                  case SyntaxKind.EndRegionDirectiveTrivia:                      while (d != null)                      {                          if (d.Kind() == SyntaxKind.RegionDirectiveTrivia)                          {                              return d;                          }                            d = d.GetPreviousPossiblyRelatedDirective();                      }                        break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,DirectiveTriviaSyntax,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\DirectiveTriviaSyntax.cs,GetPreviousRelatedDirective,The following switch statement is missing a default case: switch (d.Kind())                          {                              case SyntaxKind.IfDirectiveTrivia:                              case SyntaxKind.ElifDirectiveTrivia:                              case SyntaxKind.ElseDirectiveTrivia:                                  return d;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,DirectiveTriviaSyntax,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\DirectiveTriviaSyntax.cs,GetPreviousRelatedDirective,The following switch statement is missing a default case: switch (d.Kind())                          {                              case SyntaxKind.IfDirectiveTrivia:                              case SyntaxKind.ElifDirectiveTrivia:                                  return d;                          }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,DirectiveTriviaSyntax,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\DirectiveTriviaSyntax.cs,GetPreviousPossiblyRelatedDirective,The following switch statement is missing a default case: switch (d.Kind())                      {                          case SyntaxKind.EndIfDirectiveTrivia:                              while (d != null && d.Kind() != SyntaxKind.IfDirectiveTrivia)                              {                                  d = d.GetPreviousRelatedDirective();                              }                                continue;                          case SyntaxKind.EndRegionDirectiveTrivia:                              while (d != null && d.Kind() != SyntaxKind.RegionDirectiveTrivia)                              {                                  d = d.GetPreviousRelatedDirective();                              }                                continue;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,NameSyntax,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\NameSyntax.cs,GetAliasQualifierOpt,The following switch statement is missing a default case: switch (name.Kind())                  {                      case SyntaxKind.QualifiedName:                          name = ((QualifiedNameSyntax)name).Left;                          continue;                      case SyntaxKind.AliasQualifiedName:                          return ((AliasQualifiedNameSyntax)name).Alias.Identifier.ValueText;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxEquivalence,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxEquivalence.cs,AreTokensEquivalent,The following switch statement is missing a default case: switch ((SyntaxKind)before.RawKind)              {                  case SyntaxKind.IdentifierToken:                      return ((Green.SyntaxToken)before).ValueText == ((Green.SyntaxToken)after).ValueText;                    case SyntaxKind.NumericLiteralToken:                  case SyntaxKind.CharacterLiteralToken:                  case SyntaxKind.StringLiteralToken:                      return ((Green.SyntaxToken)before).Text == ((Green.SyntaxToken)after).Text;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,LineBreaksAfter,The following switch statement is missing a default case: switch (currentToken.Kind())              {                  case SyntaxKind.None:                      return 0;                  case SyntaxKind.OpenBraceToken:                  case SyntaxKind.FinallyKeyword:                      return 1;                  case SyntaxKind.CloseBraceToken:                      return LineBreaksAfterCloseBrace(nextToken);                    case SyntaxKind.CloseParenToken:                      return (((currentToken.Parent is StatementSyntax) && nextToken.Parent != currentToken.Parent)                          || nextToken.Kind() == SyntaxKind.OpenBraceToken) ? 1 : 0;                  case SyntaxKind.CloseBracketToken:                      if (currentToken.Parent is AttributeListSyntax)                      {                          return 1;                      }                        break;                  case SyntaxKind.SemicolonToken:                      return LineBreaksAfterSemicolon(currentToken' nextToken);                    case SyntaxKind.CommaToken:                      return currentToken.Parent is EnumDeclarationSyntax ? 1 : 0;                  case SyntaxKind.ElseKeyword:                      return nextToken.Kind() != SyntaxKind.IfKeyword ? 1 : 0;                  case SyntaxKind.ColonToken:                      if (currentToken.Parent is LabeledStatementSyntax || currentToken.Parent is SwitchLabelSyntax)                      {                          return 1;                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,SyntaxFormatter,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxFormatter.cs,LineBreaksAfter,The following switch statement is missing a default case: switch (nextToken.Kind())              {                  case SyntaxKind.OpenBraceToken:                  case SyntaxKind.CloseBraceToken:                  case SyntaxKind.ElseKeyword:                  case SyntaxKind.FinallyKeyword:                      return 1;                  case SyntaxKind.OpenBracketToken:                      return nextToken.Parent is AttributeListSyntax ? 1 : 0;                  case SyntaxKind.WhereKeyword:                      return currentToken.Parent is TypeParameterListSyntax ? 1 : 0;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,NodeListEditor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxReplacer.cs,VisitList,The following switch statement is missing a default case: switch (this.editKind)                          {                              case ListEditKind.Replace:                                  return list.ReplaceRange((TNode)_originalNode' _newNodes.Cast<TNode>());                                case ListEditKind.InsertAfter:                                  return list.InsertRange(index + 1' _newNodes.Cast<TNode>());                                case ListEditKind.InsertBefore:                                  return list.InsertRange(index' _newNodes.Cast<TNode>());                          }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,NodeListEditor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxReplacer.cs,VisitList,The following switch statement is missing a default case: switch (this.editKind)                          {                              case ListEditKind.Replace:                                  return list.ReplaceRange((TNode)_originalNode' _newNodes.Cast<TNode>());                                case ListEditKind.InsertAfter:                                  return list.InsertRange(index + 1' _newNodes.Cast<TNode>());                                case ListEditKind.InsertBefore:                                  return list.InsertRange(index' _newNodes.Cast<TNode>());                          }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,TokenListEditor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxReplacer.cs,VisitList,The following switch statement is missing a default case: switch (this.editKind)                      {                          case ListEditKind.Replace:                              return list.ReplaceRange(_originalToken' _newTokens);                            case ListEditKind.InsertAfter:                              return list.InsertRange(index + 1' _newTokens);                            case ListEditKind.InsertBefore:                              return list.InsertRange(index' _newTokens);                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Syntax,TriviaListEditor,C:\repos\mono_roslyn\src\Compilers\CSharp\Portable\Syntax\SyntaxReplacer.cs,VisitList,The following switch statement is missing a default case: switch (this.editKind)                      {                          case ListEditKind.Replace:                              return list.ReplaceRange(_originalTrivia' _newTrivia);                            case ListEditKind.InsertAfter:                              return list.InsertRange(index + 1' _newTrivia);                            case ListEditKind.InsertBefore:                              return list.InsertRange(index' _newTrivia);                      }
