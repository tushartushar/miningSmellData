Implementation smell,Namespace,Class,File,Method,Description
Long Method,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithHasErrors,The method has 117 lines of code.
Long Method,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteVisitor,The method has 151 lines of code.
Long Method,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteTreeDumperNodeProducer,The method has 115 lines of code.
Long Method,BoundTreeGenerator,Extensions,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,IsVBKeyword,The method has 160 lines of code.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithHasErrors,The length of the statement  "                        IEnumerable<string> fields = isPublic ? new[] { "CSharpSyntaxNode syntax" } : new[] { "BoundKind kind"' "CSharpSyntaxNode syntax" }; " is 132.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithHasErrors,The length of the statement  "                                WriteLine("this._{0} = {1};"' field.Name' FieldNullHandling(node' field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name)); " is 137.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithHasErrors,The length of the statement  "                                WriteLine("this.{0} = {1};"' field.Name' FieldNullHandling(node' field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name)); " is 136.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithHasErrors,The length of the statement  "                        IEnumerable<string> fields = isPublic ? new[] { "syntax As VisualBasicSyntaxNode" } : new[] { "kind As BoundKind"' "syntax as VisualBasicSyntaxNode" }; " is 151.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithHasErrors,The length of the statement  "                                Write("{0}' "' FieldNullHandling(node' baseField.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(baseField.Name)); " is 121.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithHasErrors,The length of the statement  "                                Write("{0}' "' FieldNullHandling(node' baseField.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(baseField.Name)); " is 121.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithHasErrors,The length of the statement  "                            WriteLine("Me._{0} = {1}"' field.Name' FieldNullHandling(node' field.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(field.Name)); " is 137.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithoutHasErrors,The length of the statement  "                        IEnumerable<string> fields = isPublic ? new[] { "CSharpSyntaxNode syntax" } : new[] { "BoundKind kind"' "CSharpSyntaxNode syntax" }; " is 132.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithoutHasErrors,The length of the statement  "                                WriteLine("this._{0} = {1};"' field.Name' FieldNullHandling(node' field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name)); " is 137.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithoutHasErrors,The length of the statement  "                                WriteLine("this.{0} = {1};"' field.Name' FieldNullHandling(node' field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name)); " is 136.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithoutHasErrors,The length of the statement  "                        IEnumerable<string> fields = isPublic ? new[] { "syntax As VisualBasicSyntaxNode" } : new[] { "kind As BoundKind"' "syntax as VisualBasicSyntaxNode" }; " is 151.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithoutHasErrors,The length of the statement  "                                Write("' {0}"' FieldNullHandling(node' baseField.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(baseField.Name)); " is 121.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithoutHasErrors,The length of the statement  "                                Write("' {0}"' FieldNullHandling(node' baseField.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(baseField.Name)); " is 121.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteConstructorWithoutHasErrors,The length of the statement  "                            WriteLine("Me._{0} = {1}"' field.Name' FieldNullHandling(node' field.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(field.Name)); " is 137.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteNullChecks,The length of the statement  "            IEnumerable<Field> nullCheckFields = AllFields(node).Where(f => FieldNullHandling(node' f.Name) == NullHandling.Disallow); " is 122.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteNullChecks,The length of the statement  "                                WriteLine("Debug.Assert(!{0}.IsDefault' \"Field '{0}' cannot be null (use Null=\\\"allow\\\" in BoundNodes.xml to remove this check)\");"' ToCamelCase(field.Name)); " is 164.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteNullChecks,The length of the statement  "                                WriteLine("Debug.Assert({0} != null' \"Field '{0}' cannot be null (use Null=\\\"allow\\\" in BoundNodes.xml to remove this check)\");"' ToCamelCase(field.Name)); " is 161.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteNullChecks,The length of the statement  "                                WriteLine("Debug.Assert(Not ({0}.IsDefault)' \"Field '{0}' cannot be null (use Null=\"\"allow\"\" in BoundNodes.xml to remove this check)\")"' ToCamelCase(field.Name)); " is 168.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteNullChecks,The length of the statement  "                                WriteLine("Debug.Assert({0} IsNot Nothing' \"Field '{0}' cannot be null (use Null=\"\"allow\"\" in BoundNodes.xml to remove this check)\")"' ToCamelCase(field.Name)); " is 166.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteField,The length of the statement  "                        WriteLine("public override {0}{1} {2} {{ get {{ return _{2};}} }}"' (IsNew(field) ? "new " : "")' field.Type' field.Name); " is 122.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteField,The length of the statement  "                    WriteLine("Public {0}ReadOnly Property {2} As {1}"' (IsNew(field) ? "Shadows " : IsPropertyOverrides(field) ? "Overrides " : "")' field.Type' field.Name); " is 154.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteUpdateMethod,The length of the statement  "                            var fields = new[] { "this.Syntax" }.Concat(AllSpecifiableFields(node).Select(f => ToCamelCase(f.Name))).Concat(new[] { "this.HasErrors" }); " is 140.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteUpdateMethod,The length of the statement  "                            var fields = new[] { "Me.Syntax" }.Concat(AllSpecifiableFields(node).Select(f => ToCamelCase(f.Name))).Concat(new[] { "Me.HasErrors" }); " is 136.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteTreeDumperNodeProducer,The length of the statement  "                                    Write("new TreeDumperNode(\"{0}\"' null' new TreeDumperNode[] {{ Visit(node.{1}' null) }})"' ToCamelCase(field.Name)' field.Name); " is 130.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteTreeDumperNodeProducer,The length of the statement  "                                        Write("new TreeDumperNode(\"{0}\"' null' node.{1}.IsDefault ? SpecializedCollections.EmptyArray<TreeDumperNode>() : from x in node.{1} select Visit(x' null))"' ToCamelCase(field.Name)' field.Name); " is 197.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteTreeDumperNodeProducer,The length of the statement  "                                        Write("new TreeDumperNode(\"{0}\"' null' from x in node.{1} select Visit(x' null))"' ToCamelCase(field.Name)' field.Name); " is 122.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteTreeDumperNodeProducer,The length of the statement  "                        WriteLine("Public Overrides Function Visit{0}(node As {1}' arg As Object) As TreeDumperNode"' StripBound(node.Name)' node.Name); " is 128.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteTreeDumperNodeProducer,The length of the statement  "                                    Write("New TreeDumperNode(\"{0}\"' Nothing' new TreeDumperNode() {{ Visit(node.{1}' Nothing) }})"' ToCamelCase(field.Name)' field.Name); " is 136.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteTreeDumperNodeProducer,The length of the statement  "                                    Write("New TreeDumperNode(\"{0}\"' Nothing' From x In node.{1} Select Visit(x' Nothing))"' ToCamelCase(field.Name)' field.Name); " is 128.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteRewriter,The length of the statement  "                                WriteLine("{3} {0} = ({3})this.Visit{2}(node.{1});"' ToCamelCase(field.Name)' field.Name' IsNodeList(field.Type) ? "List" : ""' field.Type); " is 140.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteRewriter,The length of the statement  "                                ParenList(AllSpecifiableFields(node)' field => IsDerivedOrListOfDerived("BoundNode"' field.Type) || field.Type == "TypeSymbol" ? ToCamelCase(field.Name) : string.Format("node.{0}"' field.Name)); " is 194.
Long Statement,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteRewriter,The length of the statement  "                                ParenList(AllSpecifiableFields(node)' field => IsDerivedOrListOfDerived("BoundNode"' field.Type) || field.Type == "TypeSymbol" ? ToCamelCase(field.Name) : string.Format("node.{0}"' field.Name)); " is 194.
Long Statement,BoundTreeGenerator,Program,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\Program.cs,Main,The length of the statement  "                Console.WriteLine("Usage: \"{0} <language> <input> <output>\"' where <language> is \"VB\" or \"CSharp\""' Path.GetFileNameWithoutExtension(Environment.GetCommandLineArgs()[0])); " is 177.
Magic Number,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,Write,The following statement contains a magic number: if (_needsIndent)              {                  _writer.Write(new string(' '' _indent * 4));                  _needsIndent = false;              }
Magic Number,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,StripBound,The following statement contains a magic number: if (name.StartsWith("Bound"))              {                  name = name.Substring(5);              }
Magic Number,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,GetElementType,The following statement contains a magic number: switch (_targetLang)              {                  case TargetLanguage.CSharp:                      {                          if (!typeName.Contains("<"))                              return string.Empty;                          int iStart = typeName.IndexOf('<');                          int iEnd = typeName.IndexOf('>'' iStart + 1);                          if (iEnd < iStart)                              return string.Empty;                          var sub = typeName.Substring(iStart + 1' iEnd - iStart - 1);                          return sub;                      }                    case TargetLanguage.VB:                      {                          int iStart = typeName.IndexOf("(Of"' StringComparison.OrdinalIgnoreCase);                            if (iStart == -1)                              return string.Empty;                            int iEnd = typeName.IndexOf(')'' iStart + 3);                          if (iEnd < iStart)                              return string.Empty;                          var sub = typeName.Substring(iStart + 3' iEnd - iStart - 3).Trim();                          return sub;                      }                    default:                      throw new ApplicationException("Unexpected target language");              }
Magic Number,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,GetElementType,The following statement contains a magic number: switch (_targetLang)              {                  case TargetLanguage.CSharp:                      {                          if (!typeName.Contains("<"))                              return string.Empty;                          int iStart = typeName.IndexOf('<');                          int iEnd = typeName.IndexOf('>'' iStart + 1);                          if (iEnd < iStart)                              return string.Empty;                          var sub = typeName.Substring(iStart + 1' iEnd - iStart - 1);                          return sub;                      }                    case TargetLanguage.VB:                      {                          int iStart = typeName.IndexOf("(Of"' StringComparison.OrdinalIgnoreCase);                            if (iStart == -1)                              return string.Empty;                            int iEnd = typeName.IndexOf(')'' iStart + 3);                          if (iEnd < iStart)                              return string.Empty;                          var sub = typeName.Substring(iStart + 3' iEnd - iStart - 3).Trim();                          return sub;                      }                    default:                      throw new ApplicationException("Unexpected target language");              }
Magic Number,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,GetElementType,The following statement contains a magic number: switch (_targetLang)              {                  case TargetLanguage.CSharp:                      {                          if (!typeName.Contains("<"))                              return string.Empty;                          int iStart = typeName.IndexOf('<');                          int iEnd = typeName.IndexOf('>'' iStart + 1);                          if (iEnd < iStart)                              return string.Empty;                          var sub = typeName.Substring(iStart + 1' iEnd - iStart - 1);                          return sub;                      }                    case TargetLanguage.VB:                      {                          int iStart = typeName.IndexOf("(Of"' StringComparison.OrdinalIgnoreCase);                            if (iStart == -1)                              return string.Empty;                            int iEnd = typeName.IndexOf(')'' iStart + 3);                          if (iEnd < iStart)                              return string.Empty;                          var sub = typeName.Substring(iStart + 3' iEnd - iStart - 3).Trim();                          return sub;                      }                    default:                      throw new ApplicationException("Unexpected target language");              }
Magic Number,BoundTreeGenerator,Program,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\Program.cs,Main,The following statement contains a magic number: if (nonSwitches.Length != 3)              {                  Console.WriteLine("Usage: \"{0} <language> <input> <output>\"' where <language> is \"VB\" or \"CSharp\""' Path.GetFileNameWithoutExtension(Environment.GetCommandLineArgs()[0]));                  return;              }
Magic Number,BoundTreeGenerator,Program,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\Program.cs,Main,The following statement contains a magic number: outfilename = args[2];
Missing Default,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,InitializeValueTypes,The following switch statement is missing a default case: switch (_targetLang)              {                  case TargetLanguage.CSharp:                      _valueTypes.Add("bool"' true);                      _valueTypes.Add("int"' true);                      _valueTypes.Add("uint"' true);                      _valueTypes.Add("short"' true);                      _valueTypes.Add("ushort"' true);                      _valueTypes.Add("long"' true);                      _valueTypes.Add("ulong"' true);                      _valueTypes.Add("byte"' true);                      _valueTypes.Add("sbyte"' true);                      _valueTypes.Add("char"' true);                      _valueTypes.Add("Boolean"' true);                      break;                    case TargetLanguage.VB:                      _valueTypes.Add("Boolean"' true);                      _valueTypes.Add("Integer"' true);                      _valueTypes.Add("UInteger"' true);                      _valueTypes.Add("Short"' true);                      _valueTypes.Add("UShort"' true);                      _valueTypes.Add("Long"' true);                      _valueTypes.Add("ULong"' true);                      _valueTypes.Add("Byte"' true);                      _valueTypes.Add("SByte"' true);                      _valueTypes.Add("Char"' true);                      break;              }
Missing Default,BoundTreeGenerator,BoundNodeClassWriter,C:\repos\mono_roslyn\src\Tools\Source\CompilerGeneratorTools\Source\BoundTreeGenerator\BoundNodeClassWriter.cs,WriteNullChecks,The following switch statement is missing a default case: switch (_targetLang)                      {                          case TargetLanguage.CSharp:                              if (isROArray)                                  WriteLine("Debug.Assert(!{0}.IsDefault' \"Field '{0}' cannot be null (use Null=\\\"allow\\\" in BoundNodes.xml to remove this check)\");"' ToCamelCase(field.Name));                              else                                  WriteLine("Debug.Assert({0} != null' \"Field '{0}' cannot be null (use Null=\\\"allow\\\" in BoundNodes.xml to remove this check)\");"' ToCamelCase(field.Name));                              break;                            case TargetLanguage.VB:                              if (isROArray)                                  WriteLine("Debug.Assert(Not ({0}.IsDefault)' \"Field '{0}' cannot be null (use Null=\"\"allow\"\" in BoundNodes.xml to remove this check)\")"' ToCamelCase(field.Name));                              else                                  WriteLine("Debug.Assert({0} IsNot Nothing' \"Field '{0}' cannot be null (use Null=\"\"allow\"\" in BoundNodes.xml to remove this check)\")"' ToCamelCase(field.Name));                              break;                      }
