Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,UpdateDeclarationType,The method has 104 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetDeclarationKind,The method has 126 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,TryGetDeclaredSymbolInfo,The method has 110 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInBinaryOrAssignmentExpression,The method has 101 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInInitializerExpression,The method has 119 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,TryCreateSpanForNode,The method has 124 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,TryCreateSpanForStatement,The method has 165 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The method has 201 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanReplaceWithLValue,The method has 127 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The method has 279 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,GetOperatorPrecedence,The method has 105 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Extensions,CommonSemanticModelExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ISemanticModelExtensions.cs,DetermineAccessibilityConstraint,The method has 100 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Extensions,ParenthesizedExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ParenthesizedExpressionSyntaxExtensions.cs,CanRemoveParentheses,The method has 101 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTokenExtensions.cs,IsBeginningOfStatementContext,The method has 110 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsTypeDeclarationContext,The method has 138 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsExpressionContext,The method has 460 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The method has 176 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The method has 214 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustNewLinesOperation,The method has 121 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The method has 190 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputeDeclarationConflictsAsync,The method has 117 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitSimpleName,The method has 231 lines of code.
Long Method,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsForNodeLanguageSpecific,The method has 130 lines of code.
Complex Method,Microsoft.CodeAnalysis.CSharp.Classification,Worker,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Worker.cs,ClassifyPreprocessorDirective,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CodeAnalysis.CSharp.Classification.Classifiers,NameSyntaxClassifier,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Classifiers\NameSyntaxClassifier.cs,TryClassifySymbol,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Classification.Classifiers,NameSyntaxClassifier,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Classifiers\NameSyntaxClassifier.cs,TryGetSymbol,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationHelpers.cs,GetInsertionIndex,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationHelpers.cs,GetDestination,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddMethod,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddProperty,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,UpdateDeclarationType,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpDeclarationComparer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpDeclarationComparer.cs,Compare,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpDeclarationComparer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpDeclarationComparer.cs,GetAccessibilityPrecedence,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetAttributeLists,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithAttributeLists,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,Flatten,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,InsertMembers,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetAllowedModifiers,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetModifierTokens,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,SetModifierTokens,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsModifierList,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetAccessibilityAndModifiers,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetDeclarationKind,Cyclomatic complexity of the method is 35
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetName,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithNameInternal,Cyclomatic complexity of the method is 25
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetType,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithTypeInternal,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetParameterList,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithParameterList,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetEqualsValue,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithEqualsValue,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetStatements,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithStatements,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AreSimilarExceptForSubDeclarations,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,RemoveNodeInternal,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,TypeExpression,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,EnumMemberGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\EnumMemberGenerator.cs,CreateEnumMemberValue,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateNonEnumValueExpression,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,DetermineSuffix,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,MethodGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\MethodGenerator.cs,GenerateModifiers,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp.CodeGeneration,PropertyGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\PropertyGenerator.cs,GenerateModifiers,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,GetPredefinedType,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,GetPredefinedOperator,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,TryGetDeclaredSymbolInfo,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,ExpandTypeName,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,GetNodeName,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,GetBindableParent,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInArgument,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInBinaryOrAssignmentExpression,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInInitializerExpression,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeForReturnStatement,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ArgumentSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ArgumentSyntaxExtensions.cs,DetermineParameter,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,TryCreateSpanForNode,Cyclomatic complexity of the method is 34
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,TryCreateSpanForStatement,Cyclomatic complexity of the method is 26
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,TryCreateSpanForVariableDeclaration,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,IsBreakableExpression,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,GetOuterCastType,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,CastPassedToParamsArrayDefinitelyCantBeRemoved,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,Cyclomatic complexity of the method is 30
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,CrefSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CrefSyntaxExtensions.cs,TryReduceOrSimplifyExplicitName,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,DirectiveWalker,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\DirectiveSyntaxExtensions.DirectiveWalker.cs,VisitToken,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanReplaceWithLValue,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReplaceWithAlias,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,Cyclomatic complexity of the method is 44
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TrySimplifyMemberAccessOrQualifiedName,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanReplaceWithReducedName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsReplacableByVar,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,GetPredefinedKeywordKind,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,GetOperatorPrecedence,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,CommonSemanticModelExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ISemanticModelExtensions.cs,DetermineAccessibilityConstraint,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,TypeSyntaxGeneratorVisitor,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ITypeSymbolExtensions.TypeSyntaxGeneratorVisitor.cs,CreateSimpleTypeSyntax,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,TypeSyntaxGeneratorVisitor,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ITypeSymbolExtensions.TypeSyntaxGeneratorVisitor.cs,VisitNamedType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,GetAttributes,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,GetNameToken,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,WithAttributeLists,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,GetMemberType,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ParenthesizedExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ParenthesizedExpressionSyntaxExtensions.cs,CanRemoveParentheses,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ParenthesizedExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ParenthesizedExpressionSyntaxExtensions.cs,RemovalChangesAssociation,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,ParenthesizedExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ParenthesizedExpressionSyntaxExtensions.cs,RemovalMayIntroduceCommaListAmbiguity,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,ContainsInterleavedDirective,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,GetBraces,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,GetModifiers,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,WithModifiers,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,GetBodies,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,IsInInactiveRegion,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,IsInPartiallyWrittenGeneric,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTriviaExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTriviaExtensions.cs,GetCommentText,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTokenExtensions.cs,IsBeginningOfStatementContext,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTokenExtensions.cs,IsBeginningOfGlobalStatementContext,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTokenExtensions.cs,IsSwitchLabelContext,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsMemberDeclarationContext,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsMemberDeclarationContext,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsTypeDeclarationContext,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsTypeDeclarationContext,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsGenericTypeArgumentContext,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsParameterModifierContext,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsConstantExpressionContext,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsExpressionContext,Cyclomatic complexity of the method is 73
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsNameOfContext,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsIsOrAsContext,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpTriviaFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\CSharpTriviaFormatter.cs,GetLineColumnRuleBetween,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,Analyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.Analyzer.cs,Analyze,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,FormattingHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\FormattingHelpers.cs,IsParenInArgumentList,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,FormattingHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\FormattingHelpers.cs,IsCloseParenInStatement,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,AnchorIndentationFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\AnchorIndentationFormattingRule.cs,AddAnchorIndentationOperations,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,GetAdjustNewLinesOperation,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,GetAdjustNewLinesOperationBetweenMembers,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,LineBreaksAfter,Cyclomatic complexity of the method is 23
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddAlignmentBlockOperation,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddEmbeddedStatementsIndentationOperation,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustSpacesOperation,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,Cyclomatic complexity of the method is 27
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,Cyclomatic complexity of the method is 40
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddSpecificNodesSuppressOperations,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustNewLinesOperation,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,AddSpecificNodesSuppressOperations,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,RemoveSuppressOperationForStatementMethodDeclaration,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetSymbolsOffOfBoundExpression,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputeDeclarationConflictsAsync,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputePossibleImplicitUsageConflicts,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,TryAddPossibleNameConflicts,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameAndAnnotateAsync,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,GetAnnotationForInvocationExpression,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameToken,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameWithinToken,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpEscapingReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpEscapingReducer.cs,SimplifyIdentifierToken,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpExtensionMethodReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpExtensionMethodReducer.cs,TryReduceExtensionMethod,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitSimpleName,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,TypeArgumentsInAllContainingSymbol,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,FullyQualifyIdentifierName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FindAppropriateRangeWorker,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FindAppropriateRangeForSemicolon,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FindAppropriateRangeForCloseBrace,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CodeAnalysis.CSharp.Utilities,NameSyntaxComparer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\NameSyntaxComparer.cs,Compare,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,CreateSpeculativeSemanticModelForNode,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsOfUnchangedLambda,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsForNodeLanguageSpecific,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.CodeAnalysis.CSharp.Utilities,UsingsAndExternAliasesDirectiveComparer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\UsingsAndExternAliasesDirectiveComparer.cs,Compare,Cyclomatic complexity of the method is 13
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CaseCorrection,CSharpCaseCorrectionService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CaseCorrection\CSharpCaseCorrectionService.cs,AddReplacements,The method has 6 parameters. Parameters: semanticModel' root' spans' workspace' replacements' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Classification.Classifiers,NameSyntaxClassifier,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Classifiers\NameSyntaxClassifier.cs,TryClassifySymbol,The method has 5 parameters. Parameters: name' symbolInfo' semanticModel' cancellationToken' result
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Classification.Classifiers,NameSyntaxClassifier,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Classifiers\NameSyntaxClassifier.cs,TryClassifyAmbiguousSymbol,The method has 5 parameters. Parameters: name' symbolInfo' semanticModel' cancellationToken' result
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Classification.Classifiers,NameSyntaxClassifier,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Classifiers\NameSyntaxClassifier.cs,TryClassifySymbol,The method has 5 parameters. Parameters: name' symbol' semanticModel' cancellationToken' classifiedSpan
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationHelpers.cs,Insert,The method has 6 parameters. Parameters: declarationList' declaration' options' availableIndices' after' before
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationHelpers.cs,GetInsertionIndex,The method has 6 parameters. Parameters: declarationList' declaration' options' availableIndices' after' before
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddAttributes,The method has 5 parameters. Parameters: destination' attributes' target' options' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttributeFromAttributeLists,The method has 5 parameters. Parameters: attributeLists' attributeToRemove' options' positionOfRemovedNode' triviaOfRemovedNode
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpDeclarationComparer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpDeclarationComparer.cs,EqualAccessibility,The method has 5 parameters. Parameters: x' xModifiers' y' yModifiers' comparisonResult
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,FieldDeclaration,The method has 5 parameters. Parameters: name' type' accessibility' modifiers' initializer
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,MethodDeclaration,The method has 7 parameters. Parameters: name' parameters' typeParameters' returnType' accessibility' modifiers' statements
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,ConstructorDeclaration,The method has 6 parameters. Parameters: name' parameters' accessibility' modifiers' baseConstructorArguments' statements
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,PropertyDeclaration,The method has 6 parameters. Parameters: name' type' accessibility' modifiers' getAccessorStatements' setAccessorStatements
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,IndexerDeclaration,The method has 6 parameters. Parameters: parameters' type' accessibility' modifiers' getAccessorStatements' setAccessorStatements
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,CustomEventDeclaration,The method has 7 parameters. Parameters: name' type' accessibility' modifiers' parameters' addAccessorStatements' removeAccessorStatements
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,ClassDeclaration,The method has 7 parameters. Parameters: name' typeParameters' accessibility' modifiers' baseType' interfaceTypes' members
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,StructDeclaration,The method has 6 parameters. Parameters: name' typeParameters' accessibility' modifiers' interfaceTypes' members
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,InterfaceDeclaration,The method has 5 parameters. Parameters: name' typeParameters' accessibility' interfaceTypes' members
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,DelegateDeclaration,The method has 6 parameters. Parameters: name' parameters' typeParameters' returnType' accessibility' modifiers
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,EventGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\EventGenerator.cs,GenerateAccessorDeclaration,The method has 5 parameters. Parameters: event' accessor' kind' destination' options
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateLiteralExpression,The method has 6 parameters. Parameters: type' value' constants' formatString' canUseFieldReference' tokenFactory
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamedTypeGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamedTypeGenerator.cs,AddNamedTypeTo,The method has 5 parameters. Parameters: service' destination' namedType' options' availableIndices
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamedTypeGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamedTypeGenerator.cs,AddNamedTypeTo,The method has 5 parameters. Parameters: service' destination' namedType' options' availableIndices
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamedTypeGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamedTypeGenerator.cs,AddNamedTypeTo,The method has 5 parameters. Parameters: service' destination' namedType' options' availableIndices
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamedTypeGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamedTypeGenerator.cs,UpdateNamedTypeDeclaration,The method has 5 parameters. Parameters: service' declaration' newMembers' options' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamespaceGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamespaceGenerator.cs,AddNamespaceTo,The method has 5 parameters. Parameters: service' destination' namespace' options' availableIndices
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamespaceGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamespaceGenerator.cs,AddNamespaceTo,The method has 5 parameters. Parameters: service' destination' namespace' options' availableIndices
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamespaceGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamespaceGenerator.cs,UpdateCompilationUnitOrNamespaceDeclaration,The method has 5 parameters. Parameters: service' declaration' newMembers' options' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ParameterGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ParameterGenerator.cs,GetParameter,The method has 5 parameters. Parameters: p' options' isExplicit' isFirstParam' seenOptional
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,PropertyGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\PropertyGenerator.cs,GenerateAccessorDeclaration,The method has 5 parameters. Parameters: property' accessor' kind' destination' options
Long Parameter List,Microsoft.CodeAnalysis.CSharp.CodeGeneration,PropertyGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\PropertyGenerator.cs,GenerateAccessorDeclaration,The method has 5 parameters. Parameters: property' accessor' kind' hasBody' options
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,FindTokenOnLeftOfPosition,The method has 5 parameters. Parameters: node' position' includeSkipped' includeDirectives' includeDocumentationComments
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,FindTokenOnRightOfPosition,The method has 5 parameters. Parameters: node' position' includeSkipped' includeDirectives' includeDocumentationComments
Long Parameter List,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxTreeFactoryService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxTreeFactory.PathSyntaxReference.cs,CreateRecoverableTree,The method has 5 parameters. Parameters: cacheKey' filePath' optionsOpt' text' root
Long Parameter List,Microsoft.CodeAnalysis.CSharp,RecoverableSyntaxTree,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxTreeFactoryService.RecoverableSyntaxTree.cs,CreateRecoverableTree,The method has 6 parameters. Parameters: service' cacheKey' filePath' options' text' root
Long Parameter List,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInBinaryOrAssignmentExpression,The method has 6 parameters. Parameters: binop' operatorToken' left' right' expressionOpt' previousToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,CompilationUnitSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CompilationUnitSyntaxExtensions.cs,AddUsingDirective,The method has 5 parameters. Parameters: root' usingDirective' contextNode' placeSystemNamespaceFirst' annotations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,CompilationUnitSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CompilationUnitSyntaxExtensions.cs,AddUsingDirectives,The method has 5 parameters. Parameters: root' usingDirectives' contextNode' placeSystemNamespaceFirst' annotations
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,CrefSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CrefSyntaxExtensions.cs,TryReduceOrSimplifyExplicitName,The method has 6 parameters. Parameters: crefSyntax' semanticModel' replacementNode' issueSpan' optionSet' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CastIfPossible,The method has 5 parameters. Parameters: expression' targetType' position' semanticModel' wasCastAdded
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduceOrSimplifyExplicitName,The method has 6 parameters. Parameters: expression' semanticModel' replacementNode' issueSpan' optionSet' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduceExplicitName,The method has 6 parameters. Parameters: expression' semanticModel' replacementNode' issueSpan' optionSet' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The method has 6 parameters. Parameters: memberAccess' semanticModel' replacementNode' issueSpan' optionSet' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReplaceWithAlias,The method has 5 parameters. Parameters: node' semanticModel' preferAliasToQualifiedName' cancellationToken' aliasReplacement
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The method has 6 parameters. Parameters: name' semanticModel' replacementNode' issueSpan' optionSet' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanReplaceWithPredefinedTypeKeywordInContext,The method has 6 parameters. Parameters: name' semanticModel' replacementNode' issueSpan' keywordKind' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduceAttributeSuffix,The method has 6 parameters. Parameters: name' identifierToken' semanticModel' replacementNode' issueSpan' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TrySimplify,The method has 5 parameters. Parameters: expression' semanticModel' optionSet' replacementNode' issueSpan
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TrySimplifyMemberAccessOrQualifiedName,The method has 6 parameters. Parameters: left' right' semanticModel' optionSet' replacementNode' issueSpan
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsReplacableByVar,The method has 6 parameters. Parameters: simpleName' semanticModel' replacementNode' issueSpan' optionSet' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,EqualsValueClauseNotSuitableForVar,The method has 5 parameters. Parameters: identifier' simpleName' equalsValueClause' semanticModel' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,IsKind,The method has 5 parameters. Parameters: node' kind1' kind2' kind3' kind4
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,IsKind,The method has 6 parameters. Parameters: node' kind1' kind2' kind3' kind4' kind5
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,FindTokenOnRightOfPosition,The method has 5 parameters. Parameters: root' position' includeSkipped' includeDirectives' includeDocumentationComments
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,FindTokenOnLeftOfPosition,The method has 5 parameters. Parameters: root' position' includeSkipped' includeDirectives' includeDocumentationComments
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTokenExtensions.cs,GetNextTokenOrEndOfFile,The method has 5 parameters. Parameters: token' includeZeroWidth' includeSkipped' includeDirectives' includeDocumentationComments
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,FindTokenOnRightOfPosition,The method has 6 parameters. Parameters: syntaxTree' position' cancellationToken' includeSkipped' includeDirectives' includeDocumentationComments
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,FindTokenOnLeftOfPosition,The method has 6 parameters. Parameters: syntaxTree' position' cancellationToken' includeSkipped' includeDirectives' includeDocumentationComments
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,IsInPartiallyWrittenGeneric,The method has 5 parameters. Parameters: syntaxTree' position' cancellationToken' genericIdentifier' lessThanToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The method has 47 parameters. Parameters: workspace' semanticModel' position' leftToken' targetToken' containingTypeDeclaration' containingTypeOrEnumDeclaration' isInNonUserCode' isPreProcessorDirectiveContext' isPreProcessorKeywordContext' isPreProcessorExpressionContext' isTypeContext' isNamespaceContext' isStatementContext' isGlobalStatementContext' isAnyExpressionContext' isNonAttributeExpressionContext' isConstantExpressionContext' isAttributeNameContext' isEnumTypeMemberAccessContext' isNameOfContext' isInQuery' isInImportsDirective' isLabelContext' isTypeArgumentOfConstraintContext' isNamespaceDeclarationNameContext' isRightOfDotOrArrowOrColonColon' isIsOrAsContext' isObjectCreationTypeContext' isDefiniteCastTypeContext' isGenericTypeArgumentContext' isEnumBaseListContext' isIsOrAsTypeContext' isLocalVariableDeclarationContext' isDeclarationExpressionContext' isFixedVariableDeclarationContext' isParameterTypeContext' isPossibleLambdaOrAnonymousMethodParameterTypeContext' isImplicitOrExplicitOperatorTypeContext' isPrimaryFunctionExpressionContext' isDelegateReturnTypeContext' isTypeOfExpressionContext' precedingModifiers' isInstanceContext' isCrefContext' isCatchFilterContext' isDestructorTypeContext
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsMemberDeclarationContext,The method has 7 parameters. Parameters: syntaxTree' position' contextOpt' validModifiers' validTypeDeclarations' canBePartial' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsTypeDeclarationContext,The method has 7 parameters. Parameters: syntaxTree' position' contextOpt' validModifiers' validTypeDeclarations' canBePartial' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsGenericTypeArgumentContext,The method has 5 parameters. Parameters: syntaxTree' position' tokenOnLeftOfPosition' cancellationToken' semanticModelOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsParameterModifierContext,The method has 5 parameters. Parameters: syntaxTree' position' tokenOnLeftOfPosition' cancellationToken' allowableIndex
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsValidContextForFromClause,The method has 5 parameters. Parameters: syntaxTree' position' tokenOnLeftOfPosition' cancellationToken' semanticModelOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsExpressionContext,The method has 6 parameters. Parameters: syntaxTree' position' tokenOnLeftOfPosition' attributes' cancellationToken' semanticModelOpt
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpSyntaxFormattingService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpSyntaxFormattingService.cs,Format,The method has 6 parameters. Parameters: node' optionSet' formattingRules' token1' token2' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormatEngine,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\CSharpFormatEngine.cs,CSharpFormatEngine,The method has 5 parameters. Parameters: node' optionSet' formattingRules' token1' token2
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpStructuredTriviaFormatEngine,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\CSharpStructuredTriviaFormatEngine.cs,Format,The method has 5 parameters. Parameters: trivia' initialColumn' optionSet' formattingRules' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpStructuredTriviaFormatEngine,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\CSharpStructuredTriviaFormatEngine.cs,CSharpStructuredTriviaFormatEngine,The method has 6 parameters. Parameters: trivia' initialColumn' optionSet' formattingRules' token1' token2
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpTriviaFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\CSharpTriviaFormatter.cs,CSharpTriviaFormatter,The method has 7 parameters. Parameters: context' formattingRules' token1' token2' originalString' lineBreaks' spaces
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,ComplexTrivia,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.ComplexTrivia.cs,Format,The method has 5 parameters. Parameters: context' formattingRules' lines' spaces' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,ComplexTrivia,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.ComplexTrivia.cs,Format,The method has 5 parameters. Parameters: context' formattingRules' formattingResultApplier' cancellationToken' tokenPairIndex
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,FormattedComplexTrivia,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.FormattedComplexTrivia.cs,FormattedComplexTrivia,The method has 8 parameters. Parameters: context' formattingRules' token1' token2' lineBreaks' spaces' originalString' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,FormattedComplexTrivia,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.FormattedComplexTrivia.cs,WithLine,The method has 5 parameters. Parameters: line' indentation' context' formattingRules' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,FormattedComplexTrivia,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.FormattedComplexTrivia.cs,Format,The method has 5 parameters. Parameters: context' formattingRules' formattingResultApplier' cancellationToken' tokenPairIndex
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,ModifiedComplexTrivia,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.ModifiedComplexTrivia.cs,WithLine,The method has 5 parameters. Parameters: line' indentation' context' formattingRules' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,ModifiedComplexTrivia,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.ModifiedComplexTrivia.cs,Format,The method has 5 parameters. Parameters: context' formattingRules' formattingResultApplier' cancellationToken' tokenPairIndex
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,AddUnindentBlockOperation,The method has 5 parameters. Parameters: list' startToken' endToken' textSpan' option
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,AddUnindentBlockOperation,The method has 5 parameters. Parameters: list' startToken' endToken' includeTriviaAtEnd' option
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,AddIndentBlockOperation,The method has 5 parameters. Parameters: list' startToken' endToken' textSpan' option
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,AddIndentBlockOperation,The method has 5 parameters. Parameters: list' baseToken' startToken' endToken' option
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,SetAlignmentBlockOperation,The method has 5 parameters. Parameters: list' baseToken' startToken' endToken' option
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Formatting,DocumentationCommentExteriorCommentRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\CSharpTriviaFormatter.DocumentationCommentExteriorCommentRewriter.cs,DocumentationCommentExteriorCommentRewriter,The method has 5 parameters. Parameters: forceIndentation' indentation' indentationDelta' optionSet' visitStructuredTrivia
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetRecommendedSymbolsAtPositionWorker,The method has 5 parameters. Parameters: workspace' semanticModel' position' options' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetSymbolsOffOfBoundExpression,The method has 6 parameters. Parameters: context' originalExpression' expression' leftHandBinding' container' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputeDeclarationConflictsAsync,The method has 8 parameters. Parameters: replacementText' renamedSymbol' renameSymbol' referencedSymbols' baseSolution' newSolution' reverseMappedLocations' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputePossibleImplicitUsageConflicts,The method has 5 parameters. Parameters: renamedSymbol' semanticModel' originalDeclarationLocation' newDeclarationLocationStartingPosition' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,Expand,The method has 6 parameters. Parameters: node' semanticModel' annotationForReplacedAliasIdentifier' expandInsideNode' expandParameter' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,Expander,The method has 5 parameters. Parameters: semanticModel' expandInsideNode' expandParameter' cancellationToken' annotationForReplacedAliasIdentifier
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,FullyQualifyIdentifierName,The method has 6 parameters. Parameters: symbol' rewrittenNode' originalNode' replaceNode' isInsideCref' omitLeftHandSide
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,SpeculationAnalyzer,The method has 6 parameters. Parameters: expression' newExpression' semanticModel' cancellationToken' skipVerificationForReplacedNode' failOnOverloadResolutionFailuresInOriginalCode
Long Parameter List,Microsoft.CodeAnalysis.CSharp.Utilities,UsingsAndExternAliasesOrganizer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\UsingsAndExternAliasesOrganizer.cs,Organize,The method has 5 parameters. Parameters: externAliasList' usingList' placeSystemNamespaceFirst' organizedExternAliasList' organizedUsingList
Long Identifier,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,UpdateDeclarationType,The length of the parameter conversionOperatorDeclarationSyntax is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp.CodeGeneration,UsingDirectivesAdder,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\UsingDirectivesAdder.cs,AddAsync,The length of the parameter importsContainerToMissingNamespaces is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The length of the parameter replacementNodeWithoutAttributeSuffix is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The length of the parameter issueSpanWithoutAttributeSuffix is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TrySimplifyMemberAccessOrQualifiedName,The length of the parameter enclosingTypeParametersInsideOut is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,HidingTypeParameterSymbolExists,The length of the parameter enclosingTypeParametersInsideOut is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,GetBraces,The length of the parameter anonymousObjectCreationExpression is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter containingTypeOrEnumDeclaration is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isPreProcessorDirectiveContext is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isPreProcessorExpressionContext is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isNonAttributeExpressionContext is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isTypeArgumentOfConstraintContext is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isNamespaceDeclarationNameContext is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isRightOfDotOrArrowOrColonColon is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isLocalVariableDeclarationContext is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isDeclarationExpressionContext is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isFixedVariableDeclarationContext is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isPossibleLambdaOrAnonymousMethodParameterTypeContext is 53.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isImplicitOrExplicitOperatorTypeContext is 39.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CSharpSyntaxContext,The length of the parameter isPrimaryFunctionExpressionContext is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CreateContext,The length of the parameter preProcessorTokenOnLeftOfPosition is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CreateContext,The length of the parameter isPreProcessorDirectiveContext is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CreateContext,The length of the parameter isPreProcessorExpressionContext is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CreateContext,The length of the parameter isNonAttributeExpressionContext is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CreateContext,The length of the parameter containingTypeOrEnumDeclaration is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,,The length of the parameter ContainingTypeOrEnumDeclaration is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,,The length of the parameter IsPreProcessorExpressionContext is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,,The length of the parameter IsNonAttributeExpressionContext is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,,The length of the parameter IsTypeArgumentOfConstraintContext is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,,The length of the parameter IsNamespaceDeclarationNameContext is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,,The length of the parameter IsLocalVariableDeclarationContext is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,,The length of the parameter IsDeclarationExpressionContext is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,,The length of the parameter IsFixedVariableDeclarationContext is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,,The length of the parameter IsPossibleLambdaOrAnonymousMethodParameterTypeContext is 53.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,,The length of the parameter IsImplicitOrExplicitOperatorTypeContext is 39.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,,The length of the parameter IsPrimaryFunctionExpressionContext is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsPreProcessorDirectiveContext,The length of the parameter preProcessorTokenOnLeftOfPosition is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsPreProcessorKeywordContext,The length of the parameter preProcessorTokenOnLeftOfPosition is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpacingAfterMethodDeclarationName is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpaceWithinMethodDeclarationParenthesis is 39.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpaceBetweenEmptyMethodDeclarationParentheses is 45.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpaceWithinMethodCallParentheses is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpaceBetweenEmptyMethodCallParentheses is 38.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpaceAfterControlFlowStatementKeyword is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpaceWithinExpressionParentheses is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpacesIgnoreAroundVariableDeclaration is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpaceBetweenEmptySquareBrackets is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpaceAfterColonInBaseTypeDeclaration is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpaceAfterSemicolonsInForStatement is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpaceBeforeColonInBaseTypeDeclaration is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter SpaceBeforeSemicolonsInForStatement is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter WrappingKeepStatementsOnSingleLine is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter NewLinesForBracesInAnonymousMethods is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter NewLinesForBracesInControlBlocks is 32.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter NewLinesForBracesInAnonymousTypes is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter NewLinesForBracesInObjectCollectionArrayInitializers is 52.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter NewLinesForBracesInLambdaExpressionBody is 39.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\CSharpFormattingOptions.cs,,The length of the parameter NewLineForMembersInAnonymousTypes is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpTriviaFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\CSharpTriviaFormatter.cs,FormatDocumentComment,The length of the parameter singleLineDocumentationCommentExteriorCommentRewriter is 53.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpTriviaFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\CSharpTriviaFormatter.cs,FormatDocumentComment,The length of the parameter multiLineDocumentationCommentExteriorCommentRewriter is 52.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Formatting,CodeShapeAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.CodeShapeAnalyzer.cs,,The length of the parameter _touchedNoisyCharacterOnCurrentLine is 35.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputeImplicitReferenceConflicts,The length of the parameter implicitReferencesMightConflict is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputePossibleImplicitUsageConflicts,The length of the parameter newDeclarationLocationStartingPosition is 38.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameAndAnnotateAsync,The length of the parameter isNamespaceDeclarationReference is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,,The length of the parameter _renameRenamableSymbolDeclaration is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,,The length of the parameter _invocationExpressionsNeedingConflictChecks is 43.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,,The length of the parameter _skipRenameForComplexification is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,,The length of the parameter _isProcessingComplexifiedSpans is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpExtensionMethodReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpExtensionMethodReducer.cs,TryReduceExtensionMethod,The length of the parameter invocationExpressionNodeExpression is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,Expand,The length of the parameter annotationForReplacedAliasIdentifier is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,Expand,The length of the parameter rewrittenTokenWithElasticTrivia is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,AppendElasticTriviaIfNecessary,The length of the parameter rewrittenTokenWithLeadingElasticTrivia is 38.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,GetNodesAndTokensToReduce,The length of the parameter isNodeOrTokenOutsideSimplifySpans is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,Expander,The length of the parameter annotationForReplacedAliasIdentifier is 36.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,IsTypeArgumentDefinedRecursive,The length of the parameter typeArgumentsInOriginalDefinition is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,,The length of the parameter s_typeNameFormatWithoutGenerics is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,,The length of the parameter _annotationForReplacedAliasIdentifier is 37.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,NodesAndTokensToReduceComputer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.NodesAndTokensToReduceComputer.cs,Compute,The length of the parameter isNodeOrTokenOutsideSimplifySpans is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,NodesAndTokensToReduceComputer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.NodesAndTokensToReduceComputer.cs,NodesAndTokensToReduceComputer,The length of the parameter isNodeOrTokenOutsideSimplifySpans is 33.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Simplification,NodesAndTokensToReduceComputer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.NodesAndTokensToReduceComputer.cs,,The length of the parameter _isNodeOrTokenOutsideSimplifySpans is 34.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,SpeculationAnalyzer,The length of the parameter skipVerificationForReplacedNode is 31.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,SpeculationAnalyzer,The length of the parameter failOnOverloadResolutionFailuresInOriginalCode is 46.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsForNodeLanguageSpecific,The length of the parameter originalOtherPartOfConditional is 30.
Long Identifier,Microsoft.CodeAnalysis.CSharp.Utilities,SyntaxKindSet,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SyntaxKindSet.cs,,The length of the parameter ClassInterfaceStructTypeDeclarations is 36.
Long Statement,Microsoft.CodeAnalysis.CSharp.Classification,ClassificationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\ClassificationHelpers.cs,GetClassificationForIdentifer,The length of the statement  "            else if (token.Parent.IsKind(SyntaxKind.DelegateDeclaration) && ((DelegateDeclarationSyntax)token.Parent).Identifier == token) " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Classification.Classifiers,NameSyntaxClassifier,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Classifiers\NameSyntaxClassifier.cs,TryClassifyNameOfIdentifier,The length of the statement  "                result = SpecializedCollections.SingletonEnumerable(new ClassifiedSpan(identifierName.Identifier.Span' ClassificationTypeNames.Keyword)); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationHelpers.cs,AreBracesMissing,The length of the statement  "            return declaration.ChildTokens().Where(t => t.IsKind(SyntaxKind.OpenBraceToken' SyntaxKind.CloseBraceToken) && t.IsMissing).Any(); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,AttributeGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\AttributeGenerator.cs,GenerateAttributeLists,The length of the statement  "                var attributeNodes = attributes.OrderBy(a => a.AttributeClass.Name).Select((a) => GenerateAttribute(a' options)).WhereNotNull().ToList(); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,AttributeGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\AttributeGenerator.cs,GenerateAttributeLists,The length of the statement  "                var attributeDeclarations = attributes.OrderBy(a => a.AttributeClass.Name).Select(a => GenerateAttributeDeclaration(a' target' options)).WhereNotNull().ToList(); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ConstructorGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ConstructorGenerator.cs,GenerateConstructorInitializer,The length of the statement  "            var arguments = CodeGenerationConstructorInfo.GetThisConstructorArgumentsOpt(constructor) ?? CodeGenerationConstructorInfo.GetBaseConstructorArgumentsOpt(constructor); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddEvent,The length of the statement  "            return Cast<TDeclarationNode>(EventGenerator.AddEventTo(Cast<TypeDeclarationSyntax>(destination)' @event' options' availableIndices)); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddField,The length of the statement  "                return Cast<TDeclarationNode>(EnumMemberGenerator.AddEnumMemberTo(Cast<EnumDeclarationSyntax>(destination)' field' options)); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddField,The length of the statement  "                return Cast<TDeclarationNode>(FieldGenerator.AddFieldTo(Cast<TypeDeclarationSyntax>(destination)' field' options' availableIndices)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddField,The length of the statement  "                return Cast<TDeclarationNode>(FieldGenerator.AddFieldTo(Cast<CompilationUnitSyntax>(destination)' field' options' availableIndices)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddMethod,The length of the statement  "                    return Cast<TDeclarationNode>(ConstructorGenerator.AddConstructorTo(typeDeclaration' method' options' availableIndices)); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddProperty,The length of the statement  "                return Cast<TDeclarationNode>(PropertyGenerator.AddPropertyTo(Cast<TypeDeclarationSyntax>(destination)' property' options' availableIndices)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddProperty,The length of the statement  "                return Cast<TDeclarationNode>(PropertyGenerator.AddPropertyTo(Cast<CompilationUnitSyntax>(destination)' property' options' availableIndices)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddNamedType,The length of the statement  "                return Cast<TDeclarationNode>(NamedTypeGenerator.AddNamedTypeTo(this' Cast<TypeDeclarationSyntax>(destination)' namedType' options' availableIndices)); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddNamedType,The length of the statement  "                return Cast<TDeclarationNode>(NamedTypeGenerator.AddNamedTypeTo(this' Cast<NamespaceDeclarationSyntax>(destination)' namedType' options' availableIndices)); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddNamedType,The length of the statement  "                return Cast<TDeclarationNode>(NamedTypeGenerator.AddNamedTypeTo(this' Cast<CompilationUnitSyntax>(destination)' namedType' options' availableIndices)); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddNamespace,The length of the statement  "                return Cast<TDeclarationNode>(NamespaceGenerator.AddNamespaceTo(this' Cast<CompilationUnitSyntax>(destination)' @namespace' options' availableIndices)); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddNamespace,The length of the statement  "                return Cast<TDeclarationNode>(NamespaceGenerator.AddNamespaceTo(this' Cast<NamespaceDeclarationSyntax>(destination)' @namespace' options' availableIndices)); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddParameters,The length of the statement  "                var parameterSyntax = ParameterGenerator.GetParameter(parameter' options' isExplicit: false' isFirstParam: isFirstParam' seenOptional: seenOptional); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddParameters,The length of the statement  "            var finalParameterList = currentParameterList.WithParameters(SyntaxFactory.SeparatedList<ParameterSyntax>(parameterNodesAndTokens)); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddAttributes,The length of the statement  "            var attributeSyntaxList = AttributeGenerator.GenerateAttributeLists(attributes.ToImmutableArray()' options' target).ToArray(); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddMembers,The length of the statement  "            CheckDeclarationNode<EnumDeclarationSyntax' TypeDeclarationSyntax' NamespaceDeclarationSyntax' CompilationUnitSyntax>(destination); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttribute,The length of the statement  "                var newAttributeLists = RemoveAttributeFromAttributeLists(member.GetAttributes()' attributeToRemove' options' out positionOfRemovedNode' out triviaOfRemovedNode); " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttribute,The length of the statement  "                return Cast<TDeclarationNode>(AppendTriviaAtPosition(newMember' positionOfRemovedNode - destination.FullSpan.Start' triviaOfRemovedNode)); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttribute,The length of the statement  "                var newAttributeLists = RemoveAttributeFromAttributeLists(accessor.AttributeLists' attributeToRemove' options' out positionOfRemovedNode' out triviaOfRemovedNode); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttribute,The length of the statement  "                return Cast<TDeclarationNode>(AppendTriviaAtPosition(newAccessor' positionOfRemovedNode - destination.FullSpan.Start' triviaOfRemovedNode)); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttribute,The length of the statement  "                var newAttributeLists = RemoveAttributeFromAttributeLists(compilationUnit.AttributeLists' attributeToRemove' options' out positionOfRemovedNode' out triviaOfRemovedNode); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttribute,The length of the statement  "                return Cast<TDeclarationNode>(AppendTriviaAtPosition(newCompilationUnit' positionOfRemovedNode - destination.FullSpan.Start' triviaOfRemovedNode)); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttribute,The length of the statement  "                var newAttributeLists = RemoveAttributeFromAttributeLists(parameter.AttributeLists' attributeToRemove' options' out positionOfRemovedNode' out triviaOfRemovedNode); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttribute,The length of the statement  "                return Cast<TDeclarationNode>(AppendTriviaAtPosition(newParameter' positionOfRemovedNode - destination.FullSpan.Start' triviaOfRemovedNode)); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttribute,The length of the statement  "                var newAttributeLists = RemoveAttributeFromAttributeLists(typeParameter.AttributeLists' attributeToRemove' options' out positionOfRemovedNode' out triviaOfRemovedNode); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttribute,The length of the statement  "                return Cast<TDeclarationNode>(AppendTriviaAtPosition(newTypeParameter' positionOfRemovedNode - destination.FullSpan.Start' triviaOfRemovedNode)); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttributeFromAttributeLists,The length of the statement  "                        ComputePositionAndTriviaForRemoveAttributeList(attributeList' (SyntaxTrivia t) => t.IsKind(SyntaxKind.EndOfLineTrivia)' out positionOfRemovedNode' out trivia); " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,RemoveAttributeFromAttributeLists,The length of the statement  "                        ComputePositionAndTriviaForRemoveAttributeFromAttributeList(attributeToRemove' (SyntaxToken t) => t.IsKind(SyntaxKind.CommaToken)' out positionOfRemovedNode' out trivia); " is 170.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,AddStatementsWorker,The length of the statement  "                    var newContainingStatement = containingStatement.GetNodeWithoutLeadingBannerAndPreprocessorDirectives(out strippedTrivia); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,UpdateDeclarationModifiers,The length of the statement  "                return Cast<TDeclarationNode>(propertyDeclaration.WithModifiers(computeNewModifiersList(propertyDeclaration.Modifiers))); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,UpdateDeclarationModifiers,The length of the statement  "            Func<SyntaxTokenList' SyntaxTokenList> computeNewModifiersList = (SyntaxTokenList modifiersList) => newModifiers.ToSyntaxTokenList(); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,UpdateDeclarationAccessibility,The length of the statement  "            Func<SyntaxTokenList' SyntaxTokenList> computeNewModifiersList = (SyntaxTokenList modifiersList) => UpdateDeclarationAccessibility(modifiersList' newAccesibility' options); " is 172.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,UpdateDeclarationAccessibility,The length of the statement  "            CSharpCodeGenerationHelpers.AddAccessibilityModifiers(newAccesibility' newModifierTokens' options' Accessibility.NotApplicable); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,UpdateDeclarationAccessibility,The length of the statement  "            return GetUpdatedDeclarationAccessibilityModifiers(newModifierTokens' modifiersList' (SyntaxToken modifier) => SyntaxFacts.IsAccessibilityModifier(modifier.Kind())) " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,UpdateDeclarationMembers,The length of the statement  "                return Cast<TDeclarationNode>(NamedTypeGenerator.UpdateNamedTypeDeclaration(this' memberDeclaration' newMembers' options' cancellationToken)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,UpdateDeclarationMembers,The length of the statement  "                        return Cast<TDeclarationNode>(NamespaceGenerator.UpdateCompilationUnitOrNamespaceDeclaration(this' syntaxNode' newMembers' options' cancellationToken)); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,MethodDeclaration,The length of the statement  "                returnType != null ? (TypeSyntax)returnType : SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword))' " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,ConstructorDeclaration,The length of the statement  "                baseConstructorArguments != null ? SyntaxFactory.ConstructorInitializer(SyntaxKind.BaseConstructorInitializer' SyntaxFactory.ArgumentList(SyntaxFactory.SeparatedList(baseConstructorArguments.Select(AsArgument)))) : null' " is 220.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithoutBodies,The length of the statement  "                    return (method.Body != null) ? method.WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)).WithBody(null) : method; " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithoutBody,The length of the statement  "            return (accessor.Body != null) ? accessor.WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)).WithBody(null) : accessor; " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,StructDeclaration,The length of the statement  "            var itypes = interfaceTypes != null ? interfaceTypes.Select(i => (BaseTypeSyntax)SyntaxFactory.SimpleBaseType((TypeSyntax)i)).ToList() : null; " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,InterfaceDeclaration,The length of the statement  "            var itypes = interfaceTypes != null ? interfaceTypes.Select(i => (BaseTypeSyntax)SyntaxFactory.SimpleBaseType((TypeSyntax)i)).ToList() : null; " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsInterfaceMember,The length of the statement  "                        var ep = this.CustomEventDeclaration(this.GetName(ef)' this.GetType(ef)' acc' modifiers' parameters: null' addAccessorStatements: null' removeAccessorStatements: null); " is 168.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsInterfaceMember,The length of the statement  "                            this.PropertyDeclaration(this.GetName(f)' this.GetType(f)' acc' modifiers' getAccessorStatements: null' setAccessorStatements: null)); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsEnumMembers,The length of the statement  "            return members != null ? SyntaxFactory.SeparatedList(members.Select(AsEnumMember)) : default(SeparatedSyntaxList<EnumMemberDeclarationSyntax>); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,DelegateDeclaration,The length of the statement  "                returnType != null ? (TypeSyntax)returnType : SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword))' " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AttributeArgument,The length of the statement  "                ? SyntaxFactory.AttributeArgument(SyntaxFactory.NameEquals(name.ToIdentifierName())' default(NameColonSyntax)' (ExpressionSyntax)expression) " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetAttributes,The length of the statement  "                var tmp = this.Flatten(GetAttributeLists(declaration).Where(al => !IsReturnAttribute(al)).ToImmutableReadOnlyListOrEmpty()); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetReturnAttributes,The length of the statement  "                var tmp = this.Flatten(GetAttributeLists(declaration).Where(al => IsReturnAttribute(al)).ToImmutableReadOnlyListOrEmpty()); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsReturnAttributes,The length of the statement  "                .Select(list => list.WithTarget(SyntaxFactory.AttributeTargetSpecifier(SyntaxFactory.Token(SyntaxKind.ReturnKeyword)))); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsAssemblyAttributes,The length of the statement  "                    attributes.Select(list => list.WithTarget(SyntaxFactory.AttributeTargetSpecifier(SyntaxFactory.Token(SyntaxKind.AssemblyKeyword))))); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,InsertAttributeArgumentsInternal,The length of the statement  "                return this.WithAttributeArgumentList(declaration' existingArgumentList.WithArguments(existingArgumentList.Arguments.InsertRange(index' newArgumentList.Arguments))); " is 165.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,Merge,The length of the statement  "            return SyntaxFactory.TokenList(newList.Select(token => original.Any(token.Kind()) ? original.First(tk => tk.IsKind(token.Kind())) : token)); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsTypeParameterList,The length of the statement  "                ? SyntaxFactory.TypeParameterList(SyntaxFactory.SeparatedList(typeParameterNames.Select(name => SyntaxFactory.TypeParameter(name)))) " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithTypeConstraints,The length of the statement  "                ? SyntaxFactory.SeparatedList<TypeParameterConstraintSyntax>(types.Select(t => SyntaxFactory.TypeConstraint((TypeSyntax)t))) " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithTypeConstraints,The length of the statement  "                constraints = constraints.Insert(0' SyntaxFactory.ClassOrStructConstraint(isReferenceType ? SyntaxKind.ClassConstraint : SyntaxKind.StructConstraint)); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithTypeInternal,The length of the statement  "                    return ((FieldDeclarationSyntax)declaration).WithDeclaration(((FieldDeclarationSyntax)declaration).Declaration.WithType((TypeSyntax)type)); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithTypeInternal,The length of the statement  "                    return ((EventFieldDeclarationSyntax)declaration).WithDeclaration(((EventFieldDeclarationSyntax)declaration).Declaration.WithType((TypeSyntax)type)); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithTypeInternal,The length of the statement  "                    return ((LocalDeclarationStatementSyntax)declaration).WithDeclaration(((LocalDeclarationStatementSyntax)declaration).Declaration.WithType((TypeSyntax)type)); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetParameterList,The length of the statement  "                    return SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(((SimpleLambdaExpressionSyntax)declaration).Parameter)); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetGetAccessorStatements,The length of the statement  "                    return ((PropertyDeclarationSyntax)declaration).AccessorList.Accessors.FirstOrDefault(a => a.IsKind(SyntaxKind.GetAccessorDeclaration))?.Body?.Statements; " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetGetAccessorStatements,The length of the statement  "                    return ((IndexerDeclarationSyntax)declaration).AccessorList.Accessors.FirstOrDefault(a => a.IsKind(SyntaxKind.GetAccessorDeclaration))?.Body?.Statements; " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetSetAccessorStatements,The length of the statement  "                    return ((PropertyDeclarationSyntax)declaration).AccessorList.Accessors.FirstOrDefault(a => a.IsKind(SyntaxKind.SetAccessorDeclaration))?.Body?.Statements; " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetSetAccessorStatements,The length of the statement  "                    return ((IndexerDeclarationSyntax)declaration).AccessorList.Accessors.FirstOrDefault(a => a.IsKind(SyntaxKind.SetAccessorDeclaration))?.Body?.Statements; " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AddBaseType,The length of the statement  "                : SyntaxFactory.BaseList(SyntaxFactory.SingletonSeparatedList<BaseTypeSyntax>(SyntaxFactory.SimpleBaseType((TypeSyntax)baseType))); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AddInterfaceType,The length of the statement  "                ? baseList.WithTypes(baseList.Types.Insert(baseList.Types.Count' SyntaxFactory.SimpleBaseType((TypeSyntax)interfaceType))) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AddInterfaceType,The length of the statement  "                : SyntaxFactory.BaseList(SyntaxFactory.SingletonSeparatedList<BaseTypeSyntax>(SyntaxFactory.SimpleBaseType((TypeSyntax)interfaceType))); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,SplitAndReplace,The length of the statement  "                    newNodes.Add(this.WithSubDeclarationsRemoved(multiPartDeclaration' index' count - index).WithTrailingTrivia(SyntaxFactory.ElasticSpace)); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,SplitAndReplace,The length of the statement  "                    newNodes.Add(this.WithSubDeclarationsRemoved(multiPartDeclaration' 0' index + 1).WithLeadingTrivia(SyntaxFactory.ElasticSpace)); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,InsertNodesBefore,The length of the statement  "            return Isolate(root.TrackNodes(declaration)' r => InsertNodesBeforeInternal(r' r.GetCurrentNode(declaration)' newDeclarations)); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,InsertNodesAfter,The length of the statement  "            return Isolate(root.TrackNodes(declaration)' r => InsertNodesAfterInternal(r' r.GetCurrentNode(declaration)' newDeclarations)); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,SplitAndInsert,The length of the statement  "            newNodes.Add(this.WithSubDeclarationsRemoved(multiPartDeclaration' index' count - index).WithTrailingTrivia(SyntaxFactory.ElasticSpace)); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,SplitAndInsert,The length of the statement  "            newNodes.Add(this.WithSubDeclarationsRemoved(multiPartDeclaration' 0' index).WithLeadingTrivia(SyntaxFactory.ElasticSpace)); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,IfStatement,The length of the statement  "                        falseArray.Count == 1 && falseArray[0] is IfStatementSyntax ? (StatementSyntax)falseArray[0] : CreateBlock(falseArray))); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,InvocationExpression,The length of the statement  "            return SyntaxFactory.InvocationExpression(ParenthesizeLeft((ExpressionSyntax)expression)' CreateArgumentList(arguments)); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,ElementAccessExpression,The length of the statement  "            return SyntaxFactory.ElementAccessExpression(ParenthesizeLeft((ExpressionSyntax)expression)' SyntaxFactory.BracketedArgumentList(CreateArguments(arguments))); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AssignmentStatement,The length of the statement  "            return SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression' (ExpressionSyntax)left' Parenthesize(right)); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithTypeArguments,The length of the statement  "                    return SyntaxFactory.GenericName(sname.Identifier' SyntaxFactory.TypeArgumentList(SyntaxFactory.SeparatedList(typeArguments.Cast<TypeSyntax>()))); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithTypeArguments,The length of the statement  "                    return SyntaxFactory.MemberAccessExpression(expression.Kind()' sma.Expression' (SimpleNameSyntax)WithTypeArguments(sma.Name' typeArguments)); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,TryCatchStatement,The length of the statement  "                catchClauses != null ? SyntaxFactory.List(catchClauses.Cast<CatchClauseSyntax>()) : default(SyntaxList<CatchClauseSyntax>)' " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,DefaultSwitchSection,The length of the statement  "            return SyntaxFactory.SwitchSection(SyntaxFactory.SingletonList(SyntaxFactory.DefaultSwitchLabel() as SwitchLabelSyntax)' AsStatementList(statements)); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,EnumMemberGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\EnumMemberGenerator.cs,CreateEnumMemberValue,The length of the statement  "                                        SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression' SyntaxFactory.Literal(shiftValue.ToString()' shiftValue))); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,EventGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\EventGenerator.cs,GenerateEventDeclaration,The length of the statement  "            var declaration = !options.GenerateMethodBodies || @event.IsAbstract || @event.AddMethod == null || @event.RemoveMethod == null " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateNonEnumValueExpression,The length of the statement  "                return GenerateLiteralExpression(type' (sbyte)value' LiteralSpecialValues.SByteSpecialValues' null' canUseFieldReference' (s' v) => SyntaxFactory.Literal(s' v)); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateNonEnumValueExpression,The length of the statement  "                return GenerateLiteralExpression(type' (short)value' LiteralSpecialValues.Int16SpecialValues' null' canUseFieldReference' (s' v) => SyntaxFactory.Literal(s' v)); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateNonEnumValueExpression,The length of the statement  "                return GenerateLiteralExpression(type' (int)value' LiteralSpecialValues.Int32SpecialValues' null' canUseFieldReference' SyntaxFactory.Literal); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateNonEnumValueExpression,The length of the statement  "                return GenerateLiteralExpression(type' (long)value' LiteralSpecialValues.Int64SpecialValues' null' canUseFieldReference' SyntaxFactory.Literal); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateNonEnumValueExpression,The length of the statement  "                return GenerateLiteralExpression(type' (byte)value' LiteralSpecialValues.ByteSpecialValues' null' canUseFieldReference' (s' v) => SyntaxFactory.Literal(s' (int)v)); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateNonEnumValueExpression,The length of the statement  "                return GenerateLiteralExpression(type' (ushort)value' LiteralSpecialValues.UInt16SpecialValues' null' canUseFieldReference' (s' v) => SyntaxFactory.Literal(s' (uint)v)); " is 169.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateNonEnumValueExpression,The length of the statement  "                return GenerateLiteralExpression(type' (uint)value' LiteralSpecialValues.UInt32SpecialValues' null' canUseFieldReference' SyntaxFactory.Literal); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateNonEnumValueExpression,The length of the statement  "                return GenerateLiteralExpression(type' (ulong)value' LiteralSpecialValues.UInt64SpecialValues' null' canUseFieldReference' SyntaxFactory.Literal); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateNonEnumValueExpression,The length of the statement  "                return GenerateLiteralExpression(type' (decimal)value' LiteralSpecialValues.DecimalSpecialValues' null' canUseFieldReference' SyntaxFactory.Literal); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateDoubleLiteralExpression,The length of the statement  "                        SyntaxFactory.PrefixUnaryExpression(SyntaxKind.UnaryMinusExpression' GenerateDoubleLiteralExpression(null' 1.0' false))' " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateDoubleLiteralExpression,The length of the statement  "            return GenerateLiteralExpression(type' value' LiteralSpecialValues.DoubleSpecialValues' "R"' canUseFieldReference' SyntaxFactory.Literal); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateSingleLiteralExpression,The length of the statement  "                        SyntaxFactory.PrefixUnaryExpression(SyntaxKind.UnaryMinusExpression' GenerateSingleLiteralExpression(null' 1.0F' false))' " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateSingleLiteralExpression,The length of the statement  "            return GenerateLiteralExpression(type' value' LiteralSpecialValues.SingleSpecialValues' "R"' canUseFieldReference' SyntaxFactory.Literal); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,ExpressionGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\ExpressionGenerator.cs,GenerateFieldReference,The length of the statement  "                    var result = SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' memberAccess' SyntaxFactory.IdentifierName(constant.Value)); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,FieldGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\FieldGenerator.cs,GenerateEqualsValue,The length of the statement  "                return SyntaxFactory.EqualsValueClause(ExpressionGenerator.GenerateExpression(field.Type' field.ConstantValue' canUseFieldReference)); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,MethodGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\MethodGenerator.cs,GenerateMethodDeclarationWorker,The length of the statement  "                parameterList: ParameterGenerator.GenerateParameterList(method.Parameters' explicitInterfaceSpecifier != null' options)' " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,MethodGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\MethodGenerator.cs,GenerateAttributes,The length of the statement  "                attributes.AddRange(AttributeGenerator.GenerateAttributeLists(method.GetReturnTypeAttributes()' options' SyntaxFactory.Token(SyntaxKind.ReturnKeyword))); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamedTypeGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamedTypeGenerator.cs,GenerateNamedTypeDeclaration,The length of the statement  "                                     GetMembers(namedType).Where(s => s.Kind != SymbolKind.Property || PropertyGenerator.CanBeGenerated((IPropertySymbol)s))' " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamedTypeGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamedTypeGenerator.cs,GenerateEnumDeclaration,The length of the statement  "            var baseList = namedType.EnumUnderlyingType != null && namedType.EnumUnderlyingType.SpecialType != SpecialType.System_Int32 " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamedTypeGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamedTypeGenerator.cs,GenerateEnumDeclaration,The length of the statement  "                ? SyntaxFactory.BaseList(SyntaxFactory.SingletonSeparatedList<BaseTypeSyntax>(SyntaxFactory.SimpleBaseType(namedType.EnumUnderlyingType.GenerateTypeSyntax()))) " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamedTypeGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamedTypeGenerator.cs,GenerateModifiers,The length of the statement  "            var defaultAccessibility = destination == CodeGenerationDestination.CompilationUnit || destination == CodeGenerationDestination.Namespace " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,NamedTypeGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\NamedTypeGenerator.cs,GenerateBaseList,The length of the statement  "            if (namedType.TypeKind == TypeKind.Class && namedType.BaseType != null && namedType.BaseType.SpecialType != Microsoft.CodeAnalysis.SpecialType.System_Object) " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,OperatorGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\OperatorGenerator.cs,GenerateOperatorDeclarationWorker,The length of the statement  "                throw new ArgumentException(string.Format(WorkspacesResources.CannotCodeGenUnsupportedOperator' method.Name)' "method"); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,PropertyGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\PropertyGenerator.cs,GenerateIndexerDeclaration,The length of the statement  "                    parameterList: ParameterGenerator.GenerateBracketedParameterList(property.Parameters' explicitInterfaceSpecifier != null' options)' " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,UsingDirectivesAdder,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\UsingDirectivesAdder.cs,GetImportsContainer,The length of the statement  "            return node.GetInnermostNamespaceDeclarationWithUsings() ?? (SyntaxNode)node.GetAncestorOrThis<CompilationUnitSyntax>(); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,UsingDirectivesAdder,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\UsingDirectivesAdder.cs,GetInnermostNamespaceScope,The length of the statement  "            return node.GetAncestorOrThis<NamespaceDeclarationSyntax>() ?? (SyntaxNode)node.GetAncestorOrThis<CompilationUnitSyntax>(); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,UsingDirectivesAdder,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\UsingDirectivesAdder.cs,AddAsync,The length of the statement  "            var importsContainerToMissingNamespaces = await DetermineNamespaceToImportAsync(members' options' cancellationToken).ConfigureAwait(false); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.CodeGeneration,UsingDirectivesAdder,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\UsingDirectivesAdder.cs,AddAsync,The length of the statement  "            var rewriter = new Rewriter(this.Document' importsContainerToMissingNamespaces' options.PlaceSystemNamespaceFirst' cancellationToken); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSemanticFactsService.cs,IsPreProcessorDirectiveContext,The length of the statement  "                position' csharpModel.SyntaxTree.FindTokenOnLeftOfPosition(position' cancellationToken' includeDirectives: true)' cancellationToken); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSemanticFactsService.cs,LastEnumValueHasInitializer,The length of the statement  "            var enumDecl = namedTypeSymbol.DeclaringSyntaxReferences.Select(r => r.GetSyntax()).OfType<EnumDeclarationSyntax>().FirstOrDefault(); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSemanticFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSemanticFactsService.cs,TryGetSpeculativeSemanticModel,The length of the statement  "            bool success = model.TryGetSpeculativeSemanticModelForMethodBody(oldMethod.Body.OpenBraceToken.Span.End' newMethod' out csharpModel); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,IsVerbatimIdentifier,The length of the statement  "            return IsIdentifier(token) && !token.ContainsDiagnostics && token.ToString().Length == identifier.Length && token.IsVerbatimIdentifier(); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,IsMethodLevelMember,The length of the statement  "            return node is BaseMethodDeclarationSyntax || node is BasePropertyDeclarationSyntax || node is EnumMemberDeclarationSyntax || node is BaseFieldDeclarationSyntax; " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,TryGetDeclaredSymbolInfo,The length of the statement  "                    declaredSymbolInfo = new DeclaredSymbolInfo(ExpandExplicitInterfaceName(eventDecl.Identifier.ValueText' eventDecl.ExplicitInterfaceSpecifier)' " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,TryGetDeclaredSymbolInfo,The length of the statement  "                    declaredSymbolInfo = new DeclaredSymbolInfo(ExpandExplicitInterfaceName(property.Identifier.ValueText' property.ExplicitInterfaceSpecifier)' " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,GetContainer,The length of the statement  "                names.Add(currentParent.Identifier.ValueText + (immediate ? ExpandTypeParameterList(currentParent.TypeParameterList) : "")); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,GetNodeName,The length of the statement  "                return GetNodeName(qualified.Left' includeTypeParameters: false) + "." + GetNodeName(qualified.Right' includeTypeParameters: false); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxTreeFactoryService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxTreeFactory.PathSyntaxReference.cs,CreateRecoverableTree,The length of the statement  "                return RecoverableSyntaxTree.CreateRecoverableTree(this' cacheKey' filePath' optionsOpt ?? GetDefaultParseOptions()' text' (CompilationUnitSyntax)root); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp,RecoverableSyntaxTree,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxTreeFactoryService.RecoverableSyntaxTree.cs,CreateRecoverableTree,The length of the statement  "                        : new RecoverableSyntaxTree(service' cacheKey' root' new SyntaxTreeInfo(filePath' options' text' root.FullSpan.Length)); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,GetTypes,The length of the statement  "                    // BUG: The intent is to only use *usable* types' whether simple or complex. I have confirmed this intent with Ravi' who made the change.  " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,GetTypesComplex,The length of the statement  "                    var types = InferTypeInBinaryOrAssignmentExpression(expression' operatorToken' left' right' left).Where(t => !IsUnusableType(t)); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,GetTypesComplex,The length of the statement  "                        types = InferTypeInBinaryOrAssignmentExpression(expression' operatorToken' left' right' right).Where(t => !IsUnusableType(t)); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (BinaryExpressionSyntax binaryExpression) => InferTypeInBinaryOrAssignmentExpression(binaryExpression' binaryExpression.OperatorToken' binaryExpression.Left' binaryExpression.Right' expression)' " is 194.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (AssignmentExpressionSyntax assignmentExpression) => InferTypeInBinaryOrAssignmentExpression(assignmentExpression' assignmentExpression.OperatorToken' assignmentExpression.Left' assignmentExpression.Right' expression)' " is 218.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (ConditionalExpressionSyntax conditionalExpression) => InferTypeInConditionalExpression(conditionalExpression' expression)' " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (InitializerExpressionSyntax initializerExpression) => InferTypeInInitializerExpression(initializerExpression' expression)' " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (ParenthesizedLambdaExpressionSyntax parenthesizedLambdaExpression) => InferTypeInParenthesizedLambdaExpression(parenthesizedLambdaExpression)' " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (ArrayCreationExpressionSyntax arrayCreationExpression) => InferTypeInArrayCreationExpression(arrayCreationExpression' token)' " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (AttributeTargetSpecifierSyntax attributeTargetSpecifier) => InferTypeInAttributeTargetSpecifier(attributeTargetSpecifier' token)' " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (BinaryExpressionSyntax binaryExpression) => InferTypeInBinaryOrAssignmentExpression(binaryExpression' binaryExpression.OperatorToken' binaryExpression.Left' binaryExpression.Right' previousToken: token)' " is 204.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (AssignmentExpressionSyntax assignmentExpression) => InferTypeInBinaryOrAssignmentExpression(assignmentExpression' assignmentExpression.OperatorToken' assignmentExpression.Left' assignmentExpression.Right' previousToken: token)' " is 228.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (ConditionalExpressionSyntax conditionalExpression) => InferTypeInConditionalExpression(conditionalExpression' previousToken: token)' " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (InitializerExpressionSyntax initializerExpression) => InferTypeInInitializerExpression(initializerExpression' previousToken: token)' " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (ParenthesizedLambdaExpressionSyntax parenthesizedLambdaExpression) => InferTypeInParenthesizedLambdaExpression(parenthesizedLambdaExpression' token)' " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypesWorker,The length of the statement  "                    (SimpleLambdaExpressionSyntax simpleLambdaExpression) => InferTypeInSimpleLambdaExpression(simpleLambdaExpression' token)' " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInAttributeArgument,The length of the statement  "                    if (argument.NameColon == null || argument.NameColon.ColonToken != previousToken || argument.NameEquals.EqualsToken != previousToken) " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInAttributeArgument,The length of the statement  "                var name = argumentOpt != null && argumentOpt.NameColon != null ? argumentOpt.NameColon.Name.Identifier.ValueText : null; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInArgument,The length of the statement  "                var name = argumentOpt != null && argumentOpt.NameColon != null ? argumentOpt.NameColon.Name.Identifier.ValueText : null; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInBinaryOrAssignmentExpression,The length of the statement  "                    if (parentTypes.Any(parentType => parentType.SpecialType == SpecialType.System_String || parentType.TypeKind == TypeKind.Delegate)) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInBinaryOrAssignmentExpression,The length of the statement  "                        return parentTypes.Where(parentType => parentType.SpecialType == SpecialType.System_String || parentType.TypeKind == TypeKind.Delegate); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInYieldStatement,The length of the statement  "                if (previousToken.HasValue && (previousToken.Value != yieldStatement.ReturnOrBreakKeyword || yieldStatement.ReturnOrBreakKeyword.IsKind(SyntaxKind.BreakKeyword))) " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInYieldStatement,The length of the statement  "                var memberSymbol = GetDeclaredMemberSymbolFromOriginalSemanticModel(_semanticModel' yieldStatement.GetAncestorOrThis<MemberDeclarationSyntax>()); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeForReturnStatement,The length of the statement  "                var lambda = ancestorExpressions.FirstOrDefault(e => e.IsKind(SyntaxKind.ParenthesizedLambdaExpression' SyntaxKind.SimpleLambdaExpression)); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeForReturnStatement,The length of the statement  "                var memberSymbol = GetDeclaredMemberSymbolFromOriginalSemanticModel(_semanticModel' returnStatement.GetAncestorOrThis<MemberDeclarationSyntax>()); " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,GetDeclaredMemberSymbolFromOriginalSemanticModel,The length of the statement  "                    var tokenInOriginalTree = originalSemanticModel.SyntaxTree.GetRoot(_cancellationToken).FindToken(currentSemanticModel.OriginalPositionForSpeculation); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,TryCreateSpanForNode,The length of the statement  "                    return (methodDeclaration.Body != null) ? CreateSpanForBlock(methodDeclaration.Body' position) : methodDeclaration.ExpressionBody?.Expression.Span; " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,TryCreateSpanForNode,The length of the statement  "                    return (operatorDeclaration.Body != null) ? CreateSpanForBlock(operatorDeclaration.Body' position) : operatorDeclaration.ExpressionBody?.Expression.Span; " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,TryCreateSpanForNode,The length of the statement  "                    return (covnersionDeclaration.Body != null) ? CreateSpanForBlock(covnersionDeclaration.Body' position) : covnersionDeclaration.ExpressionBody?.Expression.Span; " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,CreateSpanForConstructorDeclaration,The length of the statement  "            return CreateSpan(constructorSyntax.Modifiers' constructorSyntax.Identifier' constructorSyntax.ParameterList.CloseParenToken); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,TryCreateSpanForFieldDeclaration,The length of the statement  "            return TryCreateSpanForVariableDeclaration(fieldDeclaration.Declaration' fieldDeclaration.Modifiers' fieldDeclaration.SemicolonToken' position); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,GetOuterCastType,The length of the statement  "                return GetOuterCastType(parentEpression' semanticModel' out parentIsOrAsExpression) ?? semanticModel.GetTypeInfo(parentEpression).ConvertedType; " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,GetSpeculatedExpressionToOuterTypeConversion,The length of the statement  "            var speculatedExpressionOuterType = GetOuterCastType(speculatedExpression' speculationAnalyzer.SpeculativeSemanticModel' out discarded) ?? typeInfo.ConvertedType; " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,GetSpeculatedExpressionToOuterTypeConversion,The length of the statement  "            return speculationAnalyzer.SpeculativeSemanticModel.ClassifyConversion(speculatedExpression' speculatedExpressionOuterType); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsDynamicInvocation,The length of the statement  "                    typeInfo = semanticModel.GetTypeInfo((InvocationExpressionSyntax)castExpression.Parent.Parent.Parent' cancellationToken); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsDynamicInvocation,The length of the statement  "                    typeInfo = semanticModel.GetTypeInfo((ElementAccessExpressionSyntax)castExpression.Parent.Parent.Parent' cancellationToken); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The length of the statement  "            var expressionToCastType = semanticModel.ClassifyConversion(cast.SpanStart' cast.Expression' castType' isExplicitInSource: true); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The length of the statement  "                // Note: speculationAnalyzer.ReplacementChangesSemantics() ensures that the parenting is or as expression are not broken. " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The length of the statement  "                var expressionToOuterType = GetSpeculatedExpressionToOuterTypeConversion(speculationAnalyzer.ReplacedExpression' speculationAnalyzer' cancellationToken); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The length of the statement  "                // CONSIDER: Anonymous function conversions cannot be compared from different semantic models as lambda symbol comparison requires syntax tree equality. Should this be a compiler bug? " is 183.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The length of the statement  "                        // Even though both the nullable conversions (castToOuterType and expressionToOuterType) are equal' we can guarantee no data loss only if there is an " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The length of the statement  "                        // implicit conversion from expression type to cast type and expression type is non-nullable. For example' consider the cast removal "(float?)" for below: " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The length of the statement  "                        return !speculationAnalyzer.ReplacementChangesSemanticsOfUnchangedLambda(cast.Expression' speculationAnalyzer.ReplacedExpression); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The length of the statement  "                    // If both expressionToCastType and castToOuterType are numeric' then this is a required cast as one of the conversions leads to loss of precision. " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The length of the statement  "                            !speculationAnalyzer.ReplacementChangesSemanticsOfUnchangedLambda(cast.Expression' speculationAnalyzer.ReplacedExpression); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CompilationUnitSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CompilationUnitSyntaxExtensions.cs,AddUsingDirectives,The length of the statement  "                var newNamespace = firstOuterNamespaceWithUsings.AddUsingDirectives(usingDirectives' placeSystemNamespaceFirst' annotations); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CompilationUnitSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CompilationUnitSyntaxExtensions.cs,AddUsingDirectives,The length of the statement  "                var newFirstToken = firstToken.WithLeadingTrivia(firstToken.LeadingTrivia.Where(t => t.IsDocComment() || t.IsElastic())); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CompilationUnitSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CompilationUnitSyntaxExtensions.cs,AddUsingDirectives,The length of the statement  "            // if the entire using is in a directive or there is a using list at the end outside of the directive add the using at the end'  " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CrefSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CrefSyntaxExtensions.cs,TryReduceOrSimplifyExplicitName,The length of the statement  "            if (optionSet.GetOption(SimplificationOptions.PreferIntrinsicPredefinedTypeKeywordInMemberAccess' LanguageNames.CSharp) && " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CrefSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CrefSyntaxExtensions.cs,TryReduceOrSimplifyExplicitName,The length of the statement  "                var newSymbol = semanticModel.GetSpeculativeSymbolInfo(crefSyntax.SpanStart' memberCref' speculativeBindingOption).Symbol; " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsMemberAccessExpressionName,The length of the statement  "            return (expression.IsParentKind(SyntaxKind.SimpleMemberAccessExpression) && ((MemberAccessExpressionSyntax)expression.Parent).Name == expression) || " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsRightSideOfQualifiedName,The length of the statement  "            return expression.IsParentKind(SyntaxKind.QualifiedName) && ((QualifiedNameSyntax)expression.Parent).Right == expression; " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsRightSideOfColonColon,The length of the statement  "            return expression.IsParentKind(SyntaxKind.AliasQualifiedName) && ((AliasQualifiedNameSyntax)expression.Parent).Name == expression; " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsLeftSideOfDot,The length of the statement  "                (expression.IsParentKind(SyntaxKind.SimpleMemberAccessExpression) && ((MemberAccessExpressionSyntax)expression.Parent).Expression == expression); " is 145.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsLeftSideOfDotOrArrow,The length of the statement  "                (expression.Parent is MemberAccessExpressionSyntax && ((MemberAccessExpressionSyntax)expression.Parent).Expression == expression); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsExpressionOfInvocation,The length of the statement  "                expression.IsParentKind(SyntaxKind.InvocationExpression) && ((InvocationExpressionSyntax)expression.Parent).Expression == expression; " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanAccessInstanceAndStaticMembersOffOf,The length of the statement  "                        var speculativeSymbolInfo = semanticModel.GetSpeculativeSymbolInfo(expression.SpanStart' expression' SpeculativeBindingOption.BindAsTypeOrNamespace); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduceOrSimplifyExplicitName,The length of the statement  "            if (expression.TryReduceExplicitName(semanticModel' out replacementTypeNode' out issueSpan' optionSet' cancellationToken)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The length of the statement  "                        GetPredefinedKeywordKind(SpecialTypeAnnotation.GetSpecialType(memberAccess.GetAnnotations(SpecialTypeAnnotation.Kind).First()))' " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The length of the statement  "                if (memberAccess.TryReplaceWithAlias(semanticModel' optionSet.GetOption(SimplificationOptions.PreferAliasToQualification)' cancellationToken' out aliasReplacement)) " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The length of the statement  "            replacementNode = memberAccess.Name.WithLeadingTrivia(memberAccess.GetLeadingTrivia()).WithTrailingTrivia(memberAccess.GetTrailingTrivia()); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,PreferPredefinedTypeKeywordInMemberAccess,The length of the statement  "            return (((memberAccess.Parent != null) && (memberAccess.Parent is MemberAccessExpressionSyntax)) || InsideCrefReference(memberAccess)) && " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReplaceWithAlias,The length of the statement  "                    var aliasTypeInfo = semanticModel.GetSpeculativeAliasInfo(node.SpanStart' aliasIdentifier' SpeculativeBindingOption.BindAsTypeOrNamespace); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReplaceWithAlias,The length of the statement  "            aliasReplacement = GetAliasForSymbol((INamespaceOrTypeSymbol)symbol' node.GetFirstToken()' semanticModel' cancellationToken); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,GetAliasForSymbol,The length of the statement  "                AliasSymbolCache.AddAliasSymbols(originalSemanticModel' namespaceId' semanticModel.LookupNamespacesAndTypes(token.SpanStart).OfType<IAliasSymbol>()); " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,GetStartNodeForNamespaceId,The length of the statement  "            token = originalSemanticMode.SyntaxTree.GetRoot(cancellationToken).FindToken(semanticModel.OriginalPositionForSpeculation); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The length of the statement  "                        GetPredefinedKeywordKind(SpecialTypeAnnotation.GetSpecialType(name.GetAnnotations(SpecialTypeAnnotation.Kind).First()))' " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The length of the statement  "                    if (name.TryReplaceWithAlias(semanticModel' optionSet.GetOption(SimplificationOptions.PreferAliasToQualification)' cancellationToken' out aliasReplacement)) " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The length of the statement  "                                    return CanReplaceWithPredefinedTypeKeywordInContext(name' semanticModel' out replacementNode' ref issueSpan' keywordKind' cancellationToken); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The length of the statement  "                                        return CanReplaceWithPredefinedTypeKeywordInContext(name' semanticModel' out replacementNode' ref issueSpan' keywordKind' cancellationToken); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CreatePredefinedTypeSyntax,The length of the statement  "            return SyntaxFactory.PredefinedType(SyntaxFactory.Token(expression.GetLeadingTrivia()' keywordKind' expression.GetTrailingTrivia())); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduceAttributeSuffix,The length of the statement  "                    if (identifierToken.ValueText != AttributeName && identifierToken.ValueText.EndsWith(AttributeName) && !identifierToken.HasAnnotation(SimplificationHelpers.DontSimplifyAnnotation)) " is 180.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TrySimplify,The length of the statement  "                        if (TrySimplifyMemberAccessOrQualifiedName(memberAccess.Expression' memberAccess.Name' semanticModel' optionSet' out newLeft' out issueSpan)) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TrySimplify,The length of the statement  "                        if (TrySimplifyMemberAccessOrQualifiedName(qualifiedName.Left' qualifiedName.Right' semanticModel' optionSet' out newLeft' out issueSpan)) " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,ReplacementChangesSemantics,The length of the statement  "            var speculationAnalyzer = new SpeculationAnalyzer(originalExpression' replacedExpression' semanticModel' CancellationToken.None); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,HidingTypeParameterSymbolExists,The length of the statement  "                    if (SymbolEquivalenceComparer.Instance.Equals(newCandidateSymbol.GetOriginalUnreducedDefinition()' enclosingTypeParameter.GetOriginalUnreducedDefinition())) " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,ParserWouldTreatExpressionAsCast,The length of the statement  "                    (SyntaxFacts.IsKeywordKind(nextToken.Kind()) && !(nextToken.Kind() == SyntaxKind.AsKeyword || nextToken.Kind() == SyntaxKind.IsKeyword)); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsReplacableByVar,The length of the statement  "            var checkSymbol = semanticModel.GetSpeculativeSymbolInfo(simpleName.SpanStart' candidateReplacementNode' SpeculativeBindingOption.BindAsTypeOrNamespace).Symbol; " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsReplacableByVar,The length of the statement  "            if (checkSymbol != null && checkSymbol.IsKind(SymbolKind.NamedType) && ((INamedTypeSymbol)checkSymbol).TypeKind == TypeKind.Class && checkSymbol.Name == "var") " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsReplacableByVar,The length of the statement  "            // If the simpleName is the type of the Variable Declaration Syntax belonging to LocalDeclaration' For Statement or Using statement " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsReplacableByVar,The length of the statement  "                simpleName.Parent.Parent.IsKind(SyntaxKind.LocalDeclarationStatement' SyntaxKind.ForStatement' SyntaxKind.UsingStatement)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,EqualsValueClauseNotSuitableForVar,The length of the statement  "            var possibleSameLocals = equalsValueClause.DescendantNodesAndSelf().Where(n => n.Kind() == SyntaxKind.IdentifierName && ((IdentifierNameSyntax)n).Identifier.ValueText.Equals(identifier.ValueText)); " is 197.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CommonSemanticModelExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ISemanticModelExtensions.cs,LookupName,The length of the statement  "            return semanticModel.LookupSymbols(expr.SpanStart' container: symbol' name: name' includeReducedExtensionMethods: true); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CommonSemanticModelExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ISemanticModelExtensions.cs,DetermineAccessibilityConstraint,The length of the statement  "                if (type.Parent is BaseTypeSyntax && type.Parent.IsParentKind(SyntaxKind.BaseList) && ((BaseTypeSyntax)type.Parent).Type == type) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,CommonSemanticModelExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ISemanticModelExtensions.cs,DetermineAccessibilityConstraint,The length of the statement  "                    var containingType = semanticModel.GetDeclaredSymbol(type.GetAncestor<BaseTypeDeclarationSyntax>()' cancellationToken) as INamedTypeSymbol; " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ITypeSymbolExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ITypeSymbolExtensions.cs,GetApplicableUsings,The length of the statement  "            var namespaceUsings = root.FindToken(position).Parent.GetAncestors<NamespaceDeclarationSyntax>().SelectMany(n => n.Usings); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxGeneratorVisitor,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ITypeSymbolExtensions.ExpressionSyntaxGeneratorVisitor.cs,AddInformationTo,The length of the statement  "                syntax = syntax.WithPrependedLeadingTrivia(SyntaxFactory.ElasticMarker).WithAppendedTrailingTrivia(SyntaxFactory.ElasticMarker); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,TypeSyntaxGeneratorVisitor,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ITypeSymbolExtensions.TypeSyntaxGeneratorVisitor.cs,AddInformationTo,The length of the statement  "                syntax = syntax.WithPrependedLeadingTrivia(SyntaxFactory.ElasticMarker).WithAppendedTrailingTrivia(SyntaxFactory.ElasticMarker); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,TypeSyntaxGeneratorVisitor,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ITypeSymbolExtensions.TypeSyntaxGeneratorVisitor.cs,VisitArrayType,The length of the statement  "                        SyntaxFactory.SeparatedList(Enumerable.Repeat<ExpressionSyntax>(SyntaxFactory.OmittedArraySizeExpression()' arrayType.Rank)))); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,SimpleNameSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SimpleNameSyntaxExtensions.cs,GetLeftSideOfDot,The length of the statement  "            Contract.Requires(name.IsMemberAccessExpressionName() || name.IsRightSideOfQualifiedName() || name.IsParentKind(SyntaxKind.NameMemberCref)); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,StringExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\StringExtensions.cs,EscapeIdentifier,The length of the statement  "            needsEscaping = needsEscaping || (isQueryContext && SyntaxFacts.IsQueryContextualKeyword(SyntaxFacts.GetContextualKeywordKind(identifier))); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,GetBraces,The length of the statement  "                return ValueTuple.Create(anonymousObjectCreationExpression.OpenBraceToken' anonymousObjectCreationExpression.CloseBraceToken); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTokenExtensions.cs,IsFirstTokenOnLine,The length of the statement  "            var previousToken = token.GetPreviousToken(includeSkipped: true' includeDirectives: true' includeDocumentationComments: true); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTokenExtensions.cs,GetAllTrailingTrivia,The length of the statement  "            var nextToken = token.GetNextTokenOrEndOfFile(includeZeroWidth: true' includeSkipped: true' includeDirectives: true' includeDocumentationComments: true); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTokenExtensions.cs,TryParseGenericName,The length of the statement  "                var name = SyntaxFactory.ParseName(syntaxTree.GetText(cancellationToken).ToString(TextSpan.FromBounds(genericIdentifier.SpanStart' lastToken.Span.End))); " is 153.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTokenListExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTokenListExtensions.cs,ToSyntaxTokenList,The length of the statement  "            return SyntaxFactory.TokenList(sequence.Aggregate(new List<SyntaxToken>()' (list' token) => { list.Add(token); return list; })); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,IsEntirelyWithinNonUserCodeComment,The length of the statement  "                syntaxTree.IsEntirelyWithinSingleLineDocComment(position' cancellationToken) && !syntaxTree.IsEntirelyWithinCrefSyntax(position' cancellationToken); " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,IsEntirelyWithinSingleLineDocComment,The length of the statement  "                var endsWithNewLine = trivia.GetStructure().GetLastToken(includeSkipped: true).Kind() == SyntaxKind.XmlTextLiteralNewLineToken; " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,AtEndOfIncompleteStringOrCharLiteral,The length of the statement  "                (token.Span.Length == startLength || (token.Span.Length > startLength && token.ToString().Cast<char>().LastOrDefault() != lastChar)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,IsEntirelyWithinStringLiteral,The length of the statement  "            if (token.IsKind(SyntaxKind.InterpolatedStringStartToken' SyntaxKind.InterpolatedStringTextToken' SyntaxKind.InterpolatedStringEndToken)) " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,IsFullyWrittenGeneric,The length of the statement  "                   genericName.TypeArgumentList.LessThanToken == lessThanToken && !genericName.TypeArgumentList.GreaterThanToken.IsMissing; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,EnsureToken,The length of the statement  "                var leadingTrivia = prependNewLineIfMissing ? token.LeadingTrivia.Insert(0' SyntaxFactory.CarriageReturnLineFeed) : token.LeadingTrivia; " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,EnsureToken,The length of the statement  "                var trailingTrivia = appendNewLineIfMissing ? token.TrailingTrivia.Insert(0' SyntaxFactory.CarriageReturnLineFeed) : token.TrailingTrivia; " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,EnsureToken,The length of the statement  "                return SyntaxFactory.Token(leadingTrivia' token.Kind()' trailingTrivia).WithAdditionalAnnotations(Formatter.Annotation); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions,TypeSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeSyntaxExtensions.cs,IsPotentialTypeName,The length of the statement  "            var symbols = semanticModelOpt.LookupName(nameToken' namespacesAndTypesOnly: true' cancellationToken: cancellationToken); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CreateContext,The length of the statement  "            var preProcessorTokenOnLeftOfPosition = syntaxTree.FindTokenOnLeftOfPosition(position' cancellationToken' includeDirectives: true); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CreateContext,The length of the statement  "            var isPreProcessorDirectiveContext = syntaxTree.IsPreProcessorDirectiveContext(position' preProcessorTokenOnLeftOfPosition' cancellationToken); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CreateContext,The length of the statement  "                ? syntaxTree.IsExpressionContext(position' leftToken' attributes: true' cancellationToken: cancellationToken' semanticModelOpt: semanticModel) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,CreateContext,The length of the statement  "                ? syntaxTree.IsExpressionContext(position' leftToken' attributes: false' cancellationToken: cancellationToken' semanticModelOpt: semanticModel) " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,IsTypeAttributeContext,The length of the statement  "                    token.SpanStart' contextOpt: null' validModifiers: null' validTypeDeclarations: SyntaxKindSet.ClassStructTypeDeclarations' canBePartial: false' cancellationToken: cancellationToken)) " is 182.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,IsTypeDeclarationContext,The length of the statement  "            return this.SyntaxTree.IsTypeDeclarationContext(this.Position' this' validModifiers' validTypeDeclarations' canBePartial' cancellationToken); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,IsMemberAttributeContext,The length of the statement  "                    token.SpanStart' contextOpt: null' validModifiers: null' validTypeDeclarations: validTypeDeclarations' canBePartial: false' cancellationToken: cancellationToken)) " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,CSharpSyntaxContext,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\CSharpSyntaxContext.cs,IsMemberDeclarationContext,The length of the statement  "            return this.SyntaxTree.IsMemberDeclarationContext(this.Position' this' validModifiers' validTypeDeclarations' canBePartial' cancellationToken); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsTypeContext,The length of the statement  "                syntaxTree.IsExpressionContext(position' tokenOnLeftOfPosition' attributes: true' cancellationToken: cancellationToken' semanticModelOpt: semanticModelOpt) || " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsGenericTypeArgumentContext,The length of the statement  "            var symbols = semanticModelOpt.LookupName(nameToken' namespacesAndTypesOnly: SyntaxFacts.IsInNamespaceOrTypeContext(name)' cancellationToken: cancellationToken); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsValidContextForFromClause,The length of the statement  "            if (syntaxTree.IsExpressionContext(position' tokenOnLeftOfPosition' attributes: false' cancellationToken: cancellationToken' semanticModelOpt: semanticModelOpt) && " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsNonConstantExpressionContext,The length of the statement  "                syntaxTree.IsExpressionContext(position' tokenOnLeftOfPosition' attributes: true' cancellationToken: cancellationToken) && " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsPossibleCastTypeContext,The length of the statement  "                syntaxTree.IsExpressionContext(token.SpanStart' syntaxTree.FindTokenOnLeftOfPosition(token.SpanStart' cancellationToken)' false' cancellationToken)) " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsExpressionContext,The length of the statement  "                if (semanticModelOpt != null && syntaxTree.IsGenericTypeArgumentContext(position' tokenOnLeftOfPosition' cancellationToken' semanticModelOpt)) " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsIsOrAsContext,The length of the statement  "                if (syntaxTree.IsLocalVariableDeclarationContext(token.SpanStart' syntaxTree.FindTokenOnLeftOfPosition(token.SpanStart' cancellationToken)' cancellationToken)) " is 159.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsIsOrAsContext,The length of the statement  "                    (token.Parent.IsParentKind(SyntaxKind.ObjectInitializerExpression) || token.Parent.IsParentKind(SyntaxKind.CollectionInitializerExpression))) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsIsOrAsContext,The length of the statement  "                if (syntaxTree.IsExpressionContext(nameExpr.SpanStart' syntaxTree.FindTokenOnLeftOfPosition(nameExpr.SpanStart' cancellationToken)' attributes: false' cancellationToken: cancellationToken)) " is 189.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,CSharpStructuredTriviaFormatEngine,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\CSharpStructuredTriviaFormatEngine.cs,Format,The length of the statement  "            var formatter = new CSharpStructuredTriviaFormatEngine(trivia' initialColumn' optionSet' formattingRules' root.GetFirstToken(includeZeroWidth: true)' root.GetLastToken(includeZeroWidth: true)); " is 193.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,FormattingResult,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\FormattingResult.cs,Rewriter,The length of the statement  "            var rewritter = new TriviaRewriter(this.TreeInfo.Root' SimpleIntervalTree.Create(TextSpanIntervalIntrospector.Instance' this.FormattedSpan)' changeMap' cancellationToken); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TriviaDataFactory,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.Analyzer.cs,GetWhitespaceOnlyTriviaInfo,The length of the statement  "                return new ModifiedWhitespace(this.OptionSet' result.LineBreaks' indentation: spaces' elastic: result.TreatAsElastic' language: LanguageNames.CSharp); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TriviaDataFactory,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.Analyzer.cs,GetWhitespaceOnlyTriviaInfo,The length of the statement  "            return GetWhitespaceTriviaData(lineCountAndIndentation.Item2' lineCountAndIndentation.Item3' canUseTriviaAsItIs' result.TreatAsElastic); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TriviaDataFactory,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.Analyzer.cs,CalculateSpaces,The length of the statement  "            var initialColumn = (token1.RawKind == 0) ? 0 : this.TreeInfo.GetOriginalColumn(this.OptionSet.GetOption(FormattingOptions.TabSize' LanguageNames.CSharp)' token1) + token1.Span.Length; " is 184.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TriviaDataFactory,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.Analyzer.cs,CalculateSpaces,The length of the statement  "            return textSnippet.ConvertTabToSpace(this.OptionSet.GetOption(FormattingOptions.TabSize' LanguageNames.CSharp)' initialColumn' textSnippet.Length); " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TriviaDataFactory,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.Analyzer.cs,GetLineBreaksAndIndentation,The length of the statement  "            var indentation = result.Tab * this.OptionSet.GetOption(FormattingOptions.TabSize' LanguageNames.CSharp) + result.Space; " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TriviaDataFactory,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.Analyzer.cs,GetLineBreaksAndIndentation,The length of the statement  "            Debug.Assert((indentation % this.OptionSet.GetOption(FormattingOptions.TabSize' LanguageNames.CSharp)) == result.Space); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,CodeShapeAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.CodeShapeAnalyzer.cs,OnWhitespace,The length of the statement  "                // if text contains tab' we will give up perf optimization and use more expensive one to see whether we need to replace this trivia " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,CodeShapeAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.CodeShapeAnalyzer.cs,OnWhitespace,The length of the statement  "                _indentation += text.ConvertTabToSpace(_optionSet.GetOption(FormattingOptions.TabSize' LanguageNames.CSharp)' _indentation' text.Length); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,CodeShapeAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.CodeShapeAnalyzer.cs,OnComment,The length of the statement  "                    ShouldFormatSingleLineDocumentationComment(_indentation' _optionSet.GetOption(FormattingOptions.TabSize' LanguageNames.CSharp)' trivia)) " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,ComplexTrivia,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.ComplexTrivia.cs,ExtractLineAndSpace,The length of the statement  "                text.ProcessTextBetweenTokens(this.TreeInfo' this.Token1' this.OptionSet.GetOption(FormattingOptions.TabSize' LanguageNames.CSharp)' out lines' out spaces); " is 156.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,ComplexTrivia,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.ComplexTrivia.cs,Format,The length of the statement  "                return new FormattedComplexTrivia(context' formattingRules' this.Token1' this.Token2' lines' spaces' this.OriginalString' cancellationToken); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,ComplexTrivia,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.ComplexTrivia.cs,Format,The length of the statement  "                formattingResultApplier(tokenPairIndex' Format(context' formattingRules' this.LineBreaks' this.Spaces' cancellationToken)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TriviaRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaRewriter.cs,GetTrailingAndLeadingTrivia,The length of the statement  "                return ValueTuple.Create(default(SyntaxTriviaList)' GetLeadingTriviaAtBeginningOfTree(pair.Key' pair.Value' cancellationToken)); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,FormattingHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\FormattingHelpers.cs,IsCommaInArgumentOrParameterList,The length of the statement  "            return token.Kind() == SyntaxKind.CommaToken && (token.Parent.IsAnyArgumentList() || token.Parent.Kind() == SyntaxKind.ParameterList); " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,FormattingHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\FormattingHelpers.cs,IsDotInMemberAccessOrQualifiedName,The length of the statement  "            return token.IsDotInMemberAccess() || (token.Kind() == SyntaxKind.DotToken && token.Parent.Kind() == SyntaxKind.QualifiedName); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,AnchorIndentationFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\AnchorIndentationFormattingRule.cs,AddAnchorIndentationOperation,The length of the statement  "            AddAnchorIndentationOperation(list' node.GetFirstToken(includeZeroWidth: true)' node.GetLastToken(includeZeroWidth: true)); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,AddUnindentBlockOperation,The length of the statement  "            list.Add(FormattingOperations.CreateIndentBlockOperation(startToken' endToken' textSpan' indentationDelta: -1' option: option)); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,AddUnindentBlockOperation,The length of the statement  "                list.Add(FormattingOperations.CreateIndentBlockOperation(startToken' endToken' TextSpan.FromBounds(startPosition' endPosition)' indentationDelta: -1' option: option)); " is 167.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,AddIndentBlockOperation,The length of the statement  "            list.Add(FormattingOperations.CreateIndentBlockOperation(startToken' endToken' textSpan' indentationDelta: 1' option: option)); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,AddIndentBlockOperation,The length of the statement  "            list.Add(FormattingOperations.CreateRelativeIndentBlockOperation(baseToken' startToken' endToken' indentationDelta: 1' option: option)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,SetAlignmentBlockOperation,The length of the statement  "            list.Add(FormattingOperations.CreateRelativeIndentBlockOperation(baseToken' startToken' endToken' indentationDelta: 0' option: option)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,AddSuppressAllOperationIfOnMultipleLine,The length of the statement  "            AddSuppressOperation(list' startToken' endToken' SuppressOption.NoSpacingIfOnMultipleLine | SuppressOption.NoWrapping | extraOption); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,BaseFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\BaseFormattingRule.cs,AddAlignIndentationOfTokensToBaseTokenOperation,The length of the statement  "            list.Add(FormattingOperations.CreateAlignTokensOperation(baseNode' tokens' AlignTokensOption.AlignIndentationOfTokensToBaseToken)); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,AddPropertyDeclarationSuppressOperations,The length of the statement  "                list.Add(FormattingOperations.CreateSuppressOperation(tokens.Item1' tokens.Item2' SuppressOption.NoWrapping | SuppressOption.IgnoreElastic)); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,AddInitializerSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' lastTokenOfType.Value' initializer.CloseBraceToken' SuppressOption.IgnoreElastic); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,AddInitializerSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' anonymousCreationNode.NewKeyword' anonymousCreationNode.CloseBraceToken' SuppressOption.IgnoreElastic); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,GetAdjustNewLinesOperation,The length of the statement  "            var betweenMemberOperation = GetAdjustNewLinesOperationBetweenMembers((SyntaxToken)previousToken' (SyntaxToken)currentToken); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,GetAdjustNewLinesOperationBetweenMembers,The length of the statement  "                return CreateAdjustNewLinesOperation(numberOfLines + 2 /* +1 for member itself and +1 for a blank line*/' AdjustNewLinesOption.ForceLines); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,GetAdjustNewLinesOperationBetweenMembers,The length of the statement  "            return FormattingOperations.CreateAdjustNewLinesOperation(2 /* +1 for member itself and +1 for a blank line*/' AdjustNewLinesOption.ForceLines); " is 144.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddSwitchIndentationOperation,The length of the statement  "                        TextSpan.FromBounds(lastTokenOfLabel.FullSpan.End' nextToken.SpanStart) : TextSpan.FromBounds(lastTokenOfLabel.FullSpan.End' lastTokenOfLabel.FullSpan.End)); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddAlignmentBlockOperation,The length of the statement  "                SetAlignmentBlockOperation(list' anonymousObjectCreation.NewKeyword' anonymousObjectCreation.OpenBraceToken' anonymousObjectCreation.CloseBraceToken' IndentBlockOption.RelativeToFirstTokenOnBaseTokenLine); " is 205.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddAlignmentBlockOperation,The length of the statement  "                SetAlignmentBlockOperation(list' arrayCreation.NewKeyword' arrayCreation.Initializer.OpenBraceToken' arrayCreation.Initializer.CloseBraceToken' IndentBlockOption.RelativeToFirstTokenOnBaseTokenLine); " is 199.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddAlignmentBlockOperation,The length of the statement  "                SetAlignmentBlockOperation(list' implicitArrayCreation.NewKeyword' implicitArrayCreation.Initializer.OpenBraceToken' implicitArrayCreation.Initializer.CloseBraceToken' IndentBlockOption.RelativeToFirstTokenOnBaseTokenLine); " is 223.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddBlockIndentationOperation,The length of the statement  "            if (node.IsKind(SyntaxKind.ArrayInitializerExpression) && node.Parent != null && node.Parent.IsKind(SyntaxKind.ArrayCreationExpression)) " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddBlockIndentationOperation,The length of the statement  "            AddIndentBlockOperation(list' bracePair.Item1.GetNextToken(includeZeroWidth: true)' bracePair.Item2.GetPreviousToken(includeZeroWidth: true)); " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddAlignmentBlockOperationRelativeToFirstTokenOnBaseTokenLine,The length of the statement  "            SetAlignmentBlockOperation(list' bracePair.Item1' bracePair.Item1.GetNextToken(includeZeroWidth: true)' bracePair.Item2' option); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddEmbeddedStatementsIndentationOperation,The length of the statement  "            if (usingStatement != null && usingStatement.Statement != null && !(usingStatement.Statement is BlockSyntax || usingStatement.Statement is UsingStatementSyntax)) " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddEmbeddedStatementsIndentationOperation,The length of the statement  "                AddIndentBlockOperation(list' firstToken' lastToken' TextSpan.FromBounds(firstToken.FullSpan.Start' lastToken.FullSpan.End)); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "            if (currentToken.Kind() == SyntaxKind.OpenBraceToken && (currentToken.Parent is BaseTypeDeclarationSyntax || currentToken.Parent is NamespaceDeclarationSyntax)) " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "            if (currentToken.IsKind(SyntaxKind.OpenBraceToken) && currentToken.Parent != null && currentToken.Parent.IsKind(SyntaxKind.AnonymousObjectCreationExpression)) " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "            if (currentToken.IsKind(SyntaxKind.OpenBraceToken) && currentToken.Parent != null && currentToken.Parent.IsKind(SyntaxKind.ObjectInitializerExpression)) " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "            if (currentToken.IsKind(SyntaxKind.OpenBraceToken) && currentTokenParentParent != null && currentTokenParentParent.IsKind(SyntaxKind.AnonymousMethodExpression)) " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "               (currentTokenParentParent.IsKind(SyntaxKind.SimpleLambdaExpression) || currentTokenParentParent.IsKind(SyntaxKind.ParenthesizedLambdaExpression))) " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The length of the statement  "            if (previousToken.Kind() == SyntaxKind.CommaToken && previousToken.Parent.Kind() == SyntaxKind.ObjectInitializerExpression) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The length of the statement  "            if (previousToken.Kind() == SyntaxKind.CommaToken && previousToken.Parent.Kind() == SyntaxKind.AnonymousObjectCreationExpression) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The length of the statement  "            if (currentToken.Kind() == SyntaxKind.OpenBraceToken && (currentToken.Parent is BaseTypeDeclarationSyntax || currentToken.Parent is NamespaceDeclarationSyntax)) " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The length of the statement  "            if (currentToken.Kind() == SyntaxKind.OpenBraceToken && currentToken.Parent != null && currentToken.Parent.Kind() == SyntaxKind.AnonymousObjectCreationExpression) " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The length of the statement  "                currentTokenParentParent != null && (currentTokenParentParent is MemberDeclarationSyntax || currentTokenParentParent is AccessorDeclarationSyntax)) " is 147.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The length of the statement  "            if (currentToken.Kind() == SyntaxKind.OpenBraceToken && currentTokenParentParent != null && currentTokenParentParent.Kind() == SyntaxKind.AnonymousMethodExpression) " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The length of the statement  "               (currentTokenParentParent.Kind() == SyntaxKind.SimpleLambdaExpression || currentTokenParentParent.Kind() == SyntaxKind.ParenthesizedLambdaExpression)) " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,QueryExpressionFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\QueryExpressionFormattingRule.cs,AddSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' queryExpression.GetFirstToken(includeZeroWidth: true)' queryExpression.GetLastToken(includeZeroWidth: true)); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "                return AdjustSpacesOperationZeroOrOne(optionSet' CSharpFormattingOptions.SpaceBetweenEmptyMethodDeclarationParentheses); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "                (previousKind == SyntaxKind.IfKeyword || previousKind == SyntaxKind.WhileKeyword || previousKind == SyntaxKind.SwitchKeyword || " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "                previousKind == SyntaxKind.ForKeyword || previousKind == SyntaxKind.ForEachKeyword || previousKind == SyntaxKind.CatchKeyword || " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "                (previousParentKind == SyntaxKind.IfStatement || previousParentKind == SyntaxKind.WhileStatement || previousParentKind == SyntaxKind.SwitchStatement || " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "                previousParentKind == SyntaxKind.ForStatement || previousParentKind == SyntaxKind.ForEachStatement || previousParentKind == SyntaxKind.DoStatement || " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "                (currentParentKind == SyntaxKind.IfStatement || currentParentKind == SyntaxKind.WhileStatement || currentParentKind == SyntaxKind.SwitchStatement || " is 148.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "                currentParentKind == SyntaxKind.ForStatement || currentParentKind == SyntaxKind.ForEachStatement || currentParentKind == SyntaxKind.DoStatement || " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "            if (previousKind == SyntaxKind.OpenBracketToken && currentKind == SyntaxKind.OmittedArraySizeExpressionToken && HasFormattableBracketParent(previousToken)) " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "                    if ((parent.Sizes.Any() && parent.Sizes.First().Kind() != SyntaxKind.OmittedArraySizeExpression) || parent.Sizes.SeparatorCount > 0) " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,HasFormattableBracketParent,The length of the statement  "            return token.Parent.IsKind(SyntaxKind.ArrayRankSpecifier' SyntaxKind.BracketedArgumentList' SyntaxKind.BracketedParameterList' SyntaxKind.ImplicitArrayCreationExpression); " is 171.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' ifStatementNode.IfKeyword' ifStatementNode.Statement.GetLastToken(includeZeroWidth: true)); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                    AddSuppressWrappingIfOnSingleLineOperation(list' ifStatementNode.Else.ElseKeyword' ifStatementNode.Else.Statement.GetLastToken(includeZeroWidth: true)); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' whileStatementNode.GetFirstToken(includeZeroWidth: true)' whileStatementNode.Statement.GetLastToken(includeZeroWidth: true)); " is 174.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' accessorDeclNode.GetFirstToken(includeZeroWidth: true)' accessorDeclNode.GetLastToken(includeZeroWidth: true)); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                    AddSuppressWrappingIfOnSingleLineOperation(list' switchSection.GetFirstToken(includeZeroWidth: true)' switchSection.GetLastToken(includeZeroWidth: true)); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                            AddSuppressWrappingIfOnSingleLineOperation(list' switchSection.Labels[i].GetFirstToken(includeZeroWidth: true)' switchSection.Labels[i].GetLastToken(includeZeroWidth: true)); " is 174.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                        AddSuppressWrappingIfOnSingleLineOperation(list' switchSection.Labels[switchSection.Labels.Count - 1].GetFirstToken(includeZeroWidth: true)' switchSection.GetLastToken(includeZeroWidth: true)); " is 193.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' anonymousMethod.DelegateKeyword' anonymousMethod.GetLastToken(includeZeroWidth: true)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                if (!finallyClause.FinallyKeyword.IsMissing && finallyClause.Block != null && !finallyClause.Block.CloseBraceToken.IsMissing) " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddInitializerSuppressOperations,The length of the statement  "                AddSuppressAllOperationIfOnMultipleLine(list' arrayOrCollectionInitializer.OpenBraceToken.GetPreviousToken(includeZeroWidth: true)' arrayOrCollectionInitializer.CloseBraceToken); " is 178.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddInitializerSuppressOperations,The length of the statement  "            AddSuppressWrappingIfOnSingleLineOperation(list' parent.GetFirstToken(includeZeroWidth: true)' parent.GetLastToken(includeZeroWidth: true)); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustNewLinesOperation,The length of the statement  "            if (previousToken.Kind() == SyntaxKind.CloseParenToken && previousToken.Parent.IsEmbeddedStatementOwnerWithCloseParen()) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustNewLinesOperation,The length of the statement  "                (currentToken.Kind() == SyntaxKind.CaseKeyword || currentToken.Kind() == SyntaxKind.DefaultKeyword || currentToken.Kind() == SyntaxKind.ElseKeyword)) " is 149.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "                if (previousToken.Kind() == SyntaxKind.CloseParenToken && previousToken.Parent.IsEmbeddedStatementOwnerWithCloseParen()) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "            if (previousToken.Kind() == SyntaxKind.CommaToken && currentToken.Kind() == SyntaxKind.OpenBracketToken && currentToken.Parent is AttributeListSyntax) " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "            if (previousToken.Parent.Kind() == SyntaxKind.TypeArgumentList || previousToken.Parent.Kind() == SyntaxKind.TypeParameterList) " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "                (currentToken.Parent.Kind() == SyntaxKind.TypeArgumentList || currentToken.Parent.Kind() == SyntaxKind.TypeParameterList)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "            if (currentToken.IsKind(SyntaxKind.QuestionToken) && currentToken.Parent.Kind() == SyntaxKind.ConditionalAccessExpression) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The length of the statement  "            if (previousToken.Kind() == SyntaxKind.TildeToken && (previousToken.Parent is PrefixUnaryExpressionSyntax || previousToken.Parent is DestructorDeclarationSyntax)) " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' ifStatementNode.IfKeyword' ifStatementNode.Statement.GetLastToken(includeZeroWidth: true)); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                    AddSuppressWrappingIfOnSingleLineOperation(list' ifStatementNode.Else.ElseKeyword' ifStatementNode.Else.Statement.GetLastToken(includeZeroWidth: true)); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' whileStatementNode.GetFirstToken(includeZeroWidth: true)' whileStatementNode.Statement.GetLastToken(includeZeroWidth: true)); " is 174.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' accessorDeclNode.GetFirstToken(includeZeroWidth: true)' accessorDeclNode.GetLastToken(includeZeroWidth: true)); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' switchSection.GetFirstToken(includeZeroWidth: true)' switchSection.GetLastToken(includeZeroWidth: true)); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,AddSpecificNodesSuppressOperations,The length of the statement  "                AddSuppressWrappingIfOnSingleLineOperation(list' anonymousMethod.DelegateKeyword' anonymousMethod.GetLastToken(includeZeroWidth: true)); " is 136.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,RemoveSuppressOperationForStatementMethodDeclaration,The length of the statement  "                RemoveSuppressOperation(list' ifStatementNode.IfKeyword' ifStatementNode.Statement.GetLastToken(includeZeroWidth: true)); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,RemoveSuppressOperationForStatementMethodDeclaration,The length of the statement  "                    RemoveSuppressOperation(list' ifStatementNode.Else.ElseKeyword' ifStatementNode.Else.Statement.GetLastToken(includeZeroWidth: true)); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,RemoveSuppressOperationForStatementMethodDeclaration,The length of the statement  "                RemoveSuppressOperation(list' whileStatementNode.GetFirstToken(includeZeroWidth: true)' whileStatementNode.Statement.GetLastToken(includeZeroWidth: true)); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,RemoveSuppressOperationForStatementMethodDeclaration,The length of the statement  "                RemoveSuppressOperation(list' switchSection.GetFirstToken(includeZeroWidth: true)' switchSection.GetLastToken(includeZeroWidth: true)); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Formatting,WrappingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\WrappingFormattingRule.cs,GetBracePair,The length of the statement  "                return ValueTuple.Create(propertyDeclaration.AccessorList.OpenBraceToken' propertyDeclaration.AccessorList.CloseBraceToken); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetSymbolsForCurrentContext,The length of the statement  "                return SpecializedCollections.SingletonEnumerable(context.SemanticModel.GetDeclaredSymbol(context.ContainingTypeOrEnumDeclaration' cancellationToken)); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetSymbolsOffOfContainer,The length of the statement  "                return GetSymbolsOffOfDereferencedExpression(context' ((MemberAccessExpressionSyntax)node).Expression' cancellationToken); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetSymbolsOffOfName,The length of the statement  "                var speculativeBinding = context.SemanticModel.GetSpeculativeSymbolInfo(name.SpanStart' name' SpeculativeBindingOption.BindAsExpression); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetSymbolsOffOfName,The length of the statement  "                var container = context.SemanticModel.GetSpeculativeTypeInfo(name.SpanStart' name' SpeculativeBindingOption.BindAsExpression).Type; " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetSymbolsOffOfExpression,The length of the statement  "            var normalSymbols = GetSymbolsOffOfBoundExpression(context' originalExpression' expression' leftHandBinding' container' cancellationToken); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetSymbolsOffOfExpression,The length of the statement  "                var speculativeSymbolInfo = context.SemanticModel.GetSpeculativeSymbolInfo(expression.SpanStart' expression' SpeculativeBindingOption.BindAsTypeOrNamespace); " is 157.
Long Statement,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetSymbolsOffOfExpression,The length of the statement  "                var typeMembers = GetSymbolsOffOfBoundExpression(context' originalExpression' expression' speculativeSymbolInfo' container' cancellationToken); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetSymbolsOffOfDereferencedExpression,The length of the statement  "            return GetSymbolsOffOfBoundExpression(context' originalExpression' expression' leftHandBinding' container' cancellationToken); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Recommendations,CSharpRecommendationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Recommendations\CSharpRecommendationService.cs,GetSymbolsOffOfConditionalReceiver,The length of the statement  "            return GetSymbolsOffOfBoundExpression(context' originalExpression' expression' leftHandBinding' container' cancellationToken); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputeDeclarationConflictsAsync,The length of the statement  "                    AddSymbolSourceSpans(conflicts' SpecializedCollections.SingletonEnumerable(renamedSymbol.ContainingType)' reverseMappedLocations); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputeDeclarationConflictsAsync,The length of the statement  "                    conflicts.AddRange(DeclarationConflictHelpers.GetMembersWithConflictingSignatures((IMethodSymbol)renamedSymbol' trimOptionalParameters: false).Select(t => reverseMappedLocations[t])); " is 183.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputeDeclarationConflictsAsync,The length of the statement  "                        var compilationUnit = (CompilationUnitSyntax)token.Parent.GetAncestorsOrThis(n => n.Kind() == SyntaxKind.CompilationUnit).Single(); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputeDeclarationConflictsAsync,The length of the statement  "                if (renamedSymbol.ContainingType != null && renamedSymbol.ContainingType.GetMembers(renamedSymbol.Name).Contains(renamedSymbol)) " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,GetVBPropertyFromAccessorOrAnOverrideAsync,The length of the statement  "                    var originalSourceSymbol = await SymbolFinder.FindSourceDefinitionAsync(symbol.OverriddenMember()' solution' cancellationToken).ConfigureAwait(false); " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,GetVBPropertyFromAccessorOrAnOverrideAsync,The length of the statement  "                        return await GetVBPropertyFromAccessorOrAnOverrideAsync(originalSourceSymbol' solution' cancellationToken).ConfigureAwait(false); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputeImplicitReferenceConflicts,The length of the statement  "                        var token = implicitReferenceLocation.Location.SourceTree.GetTouchingToken(implicitReferenceLocation.Location.SourceSpan.Start' cancellationToken' false); " is 154.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputeImplicitReferenceConflicts,The length of the statement  "                                return SpecializedCollections.SingletonEnumerable<Location>(((ForEachStatementSyntax)token.Parent).Expression.GetLocation()); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputePossibleImplicitUsageConflicts,The length of the statement  "            if ((renamedSymbol.Name == "MoveNext" || renamedSymbol.Name == "GetEnumerator" || renamedSymbol.Name == "Current") && renamedSymbol.GetAllTypeArguments().Length == 0) " is 166.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,GetExpansionTarget,The length of the statement  "                ? token.GetAncestors(n => n is SimpleLambdaExpressionSyntax || n is ParenthesizedLambdaExpressionSyntax).FirstOrDefault() " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,GetExpansionTarget,The length of the statement  "            if (enclosingStatement == null && enclosingInitializer != null && enclosingInitializer.Parent is VariableDeclaratorSyntax) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,GetExpansionTarget,The length of the statement  "            return enclosingStatement ?? enclosingNameMemberCrefOrnull ?? token.GetAncestors(n => n is SimpleNameSyntax).FirstOrDefault(); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,GetSemanticModelForNode,The length of the statement  "            return SpeculationAnalyzer.CreateSpeculativeSemanticModelForNode(nodeToSpeculate' (SemanticModel)originalSemanticModel' position' isInNamespaceOrTypeContext); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,Visit,The length of the statement  "                var lambdas = node.GetAncestorsOrThis(n => n is SimpleLambdaExpressionSyntax || n is ParenthesizedLambdaExpressionSyntax); " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,Complexify,The length of the statement  "                var expandParameter = originalNode.GetAncestorsOrThis(n => n is SimpleLambdaExpressionSyntax || n is ParenthesizedLambdaExpressionSyntax).Count() == 0; " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,Complexify,The length of the statement  "                newNode = _renameAnnotations.WithAdditionalAnnotations(newNode' new RenameNodeSimplificationAnnotation() { OriginalTextSpan = oldSpan }); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,Complexify,The length of the statement  "                _renameSpansTracker.AddComplexifiedSpan(_documentId' oldSpan' new TextSpan(oldSpan.Start' newSpan.Length)' _modifiedSubSpans); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameAndAnnotateAsync,The length of the statement  "                    var symbols = RenameUtilities.GetSymbolsTouchingPosition(token.Span.Start' _semanticModel' _solution.Workspace' _cancellationToken); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameAndAnnotateAsync,The length of the statement  "                        var sourceDefinition = await SymbolFinder.FindSourceDefinitionAsync(symbol' _solution' _cancellationToken).ConfigureAwait(false); " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameAndAnnotateAsync,The length of the statement  "                    newToken = _renameAnnotations.WithAdditionalAnnotations(newToken' renameAnnotation' new RenameTokenSimplificationAnnotation() { OriginalTextSpan = token.Span }); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,IsRenameLocation,The length of the statement  "                    if (token.Parent is SimpleNameSyntax && !token.IsKind(SyntaxKind.GlobalKeyword) && token.Parent.Parent.IsKind(SyntaxKind.AliasQualifiedName' SyntaxKind.QualifiedCref' SyntaxKind.QualifiedName)) " is 193.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,IsRenameLocation,The length of the statement  "                            (symbol == _renamedSymbol || SymbolKey.GetComparer(ignoreCase: true' ignoreAssemblyKeys: false).Equals(symbol.GetSymbolKey()' _renamedSymbol.GetSymbolKey()))) " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameToken,The length of the statement  "                    ? newToken = newToken.CopyAnnotationsTo(SyntaxFactory.VerbatimIdentifier(newToken.LeadingTrivia' currentNewIdentifier' valueText' newToken.TrailingTrivia)) " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameToken,The length of the statement  "                    : newToken = newToken.CopyAnnotationsTo(SyntaxFactory.Identifier(newToken.LeadingTrivia' SyntaxKind.IdentifierToken' currentNewIdentifier' valueText' newToken.TrailingTrivia)); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameInStringLiteral,The length of the statement  "                string replacedString = RenameLocationSet.ReferenceProcessing.ReplaceMatchingSubStrings(originalString' _originalText' _replacementText); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameInStringLiteral,The length of the statement  "                    return newToken.CopyAnnotationsTo(_renameAnnotations.WithAdditionalAnnotations(newToken' new RenameTokenSimplificationAnnotation() { OriginalTextSpan = oldSpan })); " is 164.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameInCommentTrivia,The length of the statement  "                string replacedString = RenameLocationSet.ReferenceProcessing.ReplaceMatchingSubStrings(originalString' _originalText' _replacementText); " is 137.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameInCommentTrivia,The length of the statement  "                    return trivia.CopyAnnotationsTo(_renameAnnotations.WithAdditionalAnnotations(newTrivia' new RenameTokenSimplificationAnnotation() { OriginalTextSpan = oldSpan })); " is 163.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameWithinToken,The length of the statement  "                    else if (newToken.IsKind(SyntaxKind.IdentifierToken) && newToken.Parent.IsKind(SyntaxKind.XmlName) && newToken.ValueText == _originalText) " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameWithinToken,The length of the statement  "                        newToken = newToken.CopyAnnotationsTo(_renameAnnotations.WithAdditionalAnnotations(newIdentifierToken' new RenameTokenSimplificationAnnotation() { OriginalTextSpan = oldToken.Span })); " is 184.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Rewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpCastReducer.Rewriter.cs,VisitBinaryExpression,The length of the statement  "                        // Cast simplification inside a binary expression' check if we need to parenthesize the binary expression to avoid breaking parent syntax. " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Rewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpCastReducer.Rewriter.cs,VisitBinaryExpression,The length of the statement  "                        // For example' cast removal in below case leads to syntax errors in error free code' unless parenting binary expression is parenthesized: " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpEscapingReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpEscapingReducer.cs,SimplifyIdentifierToken,The length of the statement  "                var enclosingLambdaExpression = parent.GetAncestorsOrThis(n => (n is SimpleLambdaExpressionSyntax || n is ParenthesizedLambdaExpressionSyntax)).FirstOrDefault(); " is 161.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpEscapingReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpEscapingReducer.cs,SimplifyIdentifierToken,The length of the statement  "                if (enclosingMethodBlock != null && ((MethodDeclarationSyntax)enclosingMethodBlock).Modifiers.Any(n => n.Kind() == SyntaxKind.AsyncKeyword)) " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpEscapingReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpEscapingReducer.cs,SimplifyIdentifierToken,The length of the statement  "            var result = token.Kind() == SyntaxKind.IdentifierToken ? CreateNewIdentifierTokenFromToken(token' escape: false) : token; " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpEscapingReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpEscapingReducer.cs,CreateNewIdentifierTokenFromToken,The length of the statement  "                ? originalToken.CopyAnnotationsTo(SyntaxFactory.VerbatimIdentifier(originalToken.LeadingTrivia' unescapedText' originalToken.ValueText' originalToken.TrailingTrivia)) " is 166.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpEscapingReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpEscapingReducer.cs,CreateNewIdentifierTokenFromToken,The length of the statement  "                : originalToken.CopyAnnotationsTo(SyntaxFactory.Identifier(originalToken.LeadingTrivia' SyntaxKind.IdentifierToken' unescapedText' originalToken.ValueText' originalToken.TrailingTrivia)); " is 187.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpExtensionMethodReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpExtensionMethodReducer.cs,TryReduceExtensionMethod,The length of the statement  "                            newMemberAccess = SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' argumentList.Arguments.ElementAt(0).Expression' ((MemberAccessExpressionSyntax)invocationExpressionNodeExpression).OperatorToken' ((MemberAccessExpressionSyntax)invocationExpressionNodeExpression).Name); " is 299.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpExtensionMethodReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpExtensionMethodReducer.cs,TryReduceExtensionMethod,The length of the statement  "                            newMemberAccess = SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' argumentList.Arguments.ElementAt(0).Expression' (IdentifierNameSyntax)invocationExpressionNodeExpression.WithoutLeadingTrivia()); " is 225.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpExtensionMethodReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpExtensionMethodReducer.cs,TryReduceExtensionMethod,The length of the statement  "                            newMemberAccess = SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' argumentList.Arguments.ElementAt(0).Expression' (GenericNameSyntax)invocationExpressionNodeExpression.WithoutLeadingTrivia()); " is 222.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpExtensionMethodReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpExtensionMethodReducer.cs,TryReduceExtensionMethod,The length of the statement  "                            Debug.Assert(false' "The expression kind is not MemberAccessExpression or IdentifierName or GenericName to be converted to Member Access Expression for Ext Method Reduction"); " is 175.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpExtensionMethodReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpExtensionMethodReducer.cs,TryReduceExtensionMethod,The length of the statement  "                        var newArguments = SyntaxFactory.SeparatedList<ArgumentSyntax>(argumentList.Arguments.GetWithSeparators().AsEnumerable().Skip(2)); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpMiscellaneousReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpMiscellaneousReducer.cs,CanRemoveTypeFromParameter,The length of the statement  "            if (node != null && node.IsParentKind(SyntaxKind.ParameterList) && node.Parent.IsParentKind(SyntaxKind.ParenthesizedLambdaExpression)) " is 134.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpMiscellaneousReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpMiscellaneousReducer.cs,CanRemoveTypeFromParameter,The length of the statement  "                    newParameterSyntax = (ParameterSyntax)speculationAnalyzer.ReplacedExpression.GetAnnotatedNodesAndTokens(annotation).First(); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpMiscellaneousReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpMiscellaneousReducer.cs,SimplifyParameter,The length of the statement  "                newParameterSyntax = SimplificationHelpers.CopyAnnotations(node' newParameterSyntax).WithoutAnnotations(Simplifier.Annotation); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpMiscellaneousReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpMiscellaneousReducer.cs,SimplifyParenthesizedLambdaExpression,The length of the statement  "                        return SimplificationHelpers.CopyAnnotations(parenthesizedLambda' newSimpleLambda).WithoutAnnotations(Simplifier.Annotation); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpNameReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpNameReducer.cs,SimplifyName,The length of the statement  "                if (!crefSyntax.TryReduceOrSimplifyExplicitName(semanticModel' out crefReplacement' out issueSpan' optionSet' cancellationToken)) " is 129.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpNameReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpNameReducer.cs,SimplifyName,The length of the statement  "                if (!expressionSyntax.TryReduceOrSimplifyExplicitName(semanticModel' out expressionReplacement' out issueSpan' optionSet' cancellationToken)) " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,Expand,The length of the statement  "                    var rewriter = new Expander(semanticModel' expandInsideNode' expandParameter' cancellationToken' annotationForReplacedAliasIdentifier); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,Expand,The length of the statement  "                var rewrittenToken = TryEscapeIdentifierToken(rewriter.VisitToken(token)' token.Parent' csharpSemanticModel).WithAdditionalAnnotations(Simplifier.Annotation); " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,TryEscapeIdentifierToken,The length of the statement  "            if (SyntaxFacts.GetKeywordKind(syntaxToken.ValueText) == SyntaxKind.None && SyntaxFacts.GetContextualKeywordKind(syntaxToken.ValueText) == SyntaxKind.None) " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,AppendElasticTriviaIfNecessary,The length of the statement  "            if (TryAddLeadingElasticTriviaIfNecessary(firstRewrittenToken' firstOriginalToken' out rewrittenTokenWithLeadingElasticTrivia)) " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,TryAddLeadingElasticTriviaIfNecessary,The length of the statement  "            tokenWithLeadingWhitespace = token.WithLeadingTrivia(SyntaxFactory.ElasticMarker).WithAdditionalAnnotations(Formatter.Annotation); " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,GetSpeculativeSemanticModel,The length of the statement  "            return SpeculationAnalyzer.CreateSpeculativeSemanticModelForNode(originalNode' syntaxNodeToSpeculate' (SemanticModel)originalSemanticModel); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitArgument,The length of the statement  "                    var specAnalyzer = new SpeculationAnalyzer(node.Expression' newArgument.Expression' _semanticModel' _cancellationToken); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitArgument,The length of the statement  "                    var newArgumentExpression = speculatedExpession.CastIfPossible(argumentType' speculatedExpession.SpanStart' speculativeSemanticModel' out wasCastAdded); " is 152.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitBinaryExpression,The length of the statement  "                if ((node.Kind() == SyntaxKind.GreaterThanExpression || node.Kind() == SyntaxKind.RightShiftExpression) && !node.IsParentKind(SyntaxKind.ParenthesizedExpression)) " is 162.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitSimpleName,The length of the statement  "                        identifier = identifier.CopyAnnotationsTo(SyntaxFactory.VerbatimIdentifier(identifier.LeadingTrivia' name' name' identifier.TrailingTrivia)); " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitSimpleName,The length of the statement  "                identifier = TryEscapeIdentifierToken(identifier' originalSimpleName' _semanticModel).WithAdditionalAnnotations(Simplifier.Annotation); " is 135.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitSimpleName,The length of the statement  "                    ((parent.Kind() == SyntaxKind.SimpleMemberAccessExpression || parent.Kind() == SyntaxKind.NameMemberCref) && originalSimpleName.IsRightSideOfDot()) || " is 150.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitSimpleName,The length of the statement  "                //// 4. If this is a standalone identifier or the left side of a qualified name or member access try to fully qualify it " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitSimpleName,The length of the statement  "                if (symbol.IsConstructor() && (parent.Kind() == SyntaxKind.ObjectCreationExpression || parent.Kind() == SyntaxKind.NameMemberCref)) " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,TryAddTypeArgumentToIdentifierName,The length of the statement  "                                                typeArguments.Select(p => SyntaxFactory.ParseTypeName(p.ToDisplayParts(s_typeNameFormatWithGenerics).ToDisplayString()))))) " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,IsInvocationWithDynamicArguments,The length of the statement  "                if (invocationExpression != null && invocationExpression.Expression.GetLastToken() == originalSimpleName.GetLastToken()) " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,IsTypeArgumentDefinedRecursive,The length of the statement  "                TypeArgumentsInAllContainingSymbol(symbol.OriginalDefinition' typeArgumentsInOriginalDefinition' enterContainingSymbol' isRecursive: false); " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,FullyQualifyIdentifierName,The length of the statement  "                                    result = rewrittenNode.CopyAnnotationsTo(SyntaxFactory.QualifiedName((NameSyntax)left' right.WithAdditionalAnnotations(Simplifier.SpecialTypeAnnotation))); " is 155.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitInvocationExpression,The length of the statement  "                        rewrittenNode = RewriteExtensionMethodInvocation(originalNode' rewrittenNode' ((MemberAccessExpressionSyntax)rewrittenNode.Expression).Expression' (IMethodSymbol)targetSymbol); " is 176.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,RewriteExtensionMethodInvocation,The length of the statement  "                var expression = RewriteExtensionMethodInvocation(rewrittenNode' thisExpression' reducedExtensionMethod' s_typeNameFormatWithoutGenerics); " is 138.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,RewriteExtensionMethodInvocation,The length of the statement  "                var binding = _semanticModel.GetSpeculativeSymbolInfo(originalNode.SpanStart' expression' SpeculativeBindingOption.BindAsExpression); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,RewriteExtensionMethodInvocation,The length of the statement  "                return RewriteExtensionMethodInvocation(rewrittenNode' thisExpression' reducedExtensionMethod' s_typeNameFormatWithGenerics); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,RewriteExtensionMethodInvocation,The length of the statement  "                var newMemberAccess = SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression' SyntaxFactory.ParseExpression(containingType)' ((MemberAccessExpressionSyntax)originalNode.Expression).OperatorToken' ((MemberAccessExpressionSyntax)originalNode.Expression).Name) " is 279.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,RewriteExtensionMethodInvocation,The length of the statement  "                newMemberAccess = originalNode.Expression.CopyAnnotationsTo(newMemberAccess).WithAdditionalAnnotations(Simplifier.Annotation); " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,RewriteExtensionMethodInvocation,The length of the statement  "                // Copies the annotation for the left hand side of the member access expression to the first argument in the complexified form " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Simplification,NodesAndTokensToReduceComputer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.NodesAndTokensToReduceComputer.cs,Visit,The length of the statement  "                    if (_simplifyAllDescendants || node.DescendantNodesAndTokens(s_containsAnnotations' descendIntoTrivia: true).Any(s_hasSimplifierAnnotation)) " is 140.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FixupOpenBrace,The length of the statement  "            // with a auto brace completion which will do auto formatting when a user types "{"' it is quite common that we will automatically put a space " is 142.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FixupOpenBrace,The length of the statement  "            // between "{" and "}". but user might blindly type without knowing that " " has automatically inserted for him. and ends up have two spaces. " is 141.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FindAppropriateRangeForSemicolon,The length of the statement  "                return ValueTuple.Create(GetAppropriatePreviousToken(parent.GetFirstToken()' canTokenBeFirstInABlock: true)' parent.GetLastToken()); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FindAppropriateRangeForSemicolon,The length of the statement  "                    AreTwoTokensOnSameLine(propertyDeclaration.AccessorList.OpenBraceToken' propertyDeclaration.AccessorList.CloseBraceToken)) " is 122.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FindAppropriateRangeForSemicolon,The length of the statement  "                    return ValueTuple.Create(propertyDeclaration.AccessorList.OpenBraceToken' propertyDeclaration.AccessorList.CloseBraceToken); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FindAppropriateRangeForSemicolon,The length of the statement  "                return ValueTuple.Create(GetAppropriatePreviousToken(parent.GetFirstToken()' canTokenBeFirstInABlock: true)' parent.GetLastToken()); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FindAppropriateRangeForSemicolon,The length of the statement  "                return ValueTuple.Create(GetAppropriatePreviousToken(parent.GetFirstToken()' canTokenBeFirstInABlock: true)' parent.GetLastToken()); " is 132.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FindAppropriateRangeForCloseBrace,The length of the statement  "                    return ValueTuple.Create(GetAppropriatePreviousToken(containerOfBlock.GetFirstToken())' containerOfBlock.GetLastToken()); " is 121.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,CreateSpeculativeSemanticModelForNode,The length of the statement  "                    semanticModel.TryGetSpeculativeSemanticModel(position' (ConstructorInitializerSyntax)nodeToSpeculate' out speculativeModel); " is 124.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,CreateSpeculativeSemanticModelForNode,The length of the statement  "                    semanticModel.TryGetSpeculativeSemanticModel(position' (ArrowExpressionClauseSyntax)nodeToSpeculate' out speculativeModel); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsOfUnchangedLambda,The length of the statement  "            var originalIdentifierNodes = originalLambdaBody.DescendantNodes().OfType<IdentifierNameSyntax>().Where(node => paramNames.Contains(node.Identifier.ValueText)); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsOfUnchangedLambda,The length of the statement  "            var replacedIdentifierNodes = replacedLambdaBody.DescendantNodes().OfType<IdentifierNameSyntax>().Where(node => paramNames.Contains(node.Identifier.ValueText)); " is 160.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsOfUnchangedLambda,The length of the statement  "            return ReplacementChangesSemanticsForNodes(originalIdentifierNodes' replacedIdentifierNodes' originalLambdaBody' replacedLambdaBody); " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsForNodes,The length of the statement  "                if (ReplacementChangesSemantics(originalChildNodeEnum.Current' replacedChildNodeEnum.Current' originalRoot' skipVerificationForCurrentNode: true)) " is 146.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsForNodeLanguageSpecific,The length of the statement  "                return ReplacementBreaksBinaryExpression((BinaryExpressionSyntax)currentOriginalNode' (BinaryExpressionSyntax)currentReplacedNode); " is 131.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsForNodeLanguageSpecific,The length of the statement  "                return ReplacementBreaksAssignmentExpression((AssignmentExpressionSyntax)currentOriginalNode' (AssignmentExpressionSyntax)currentReplacedNode); " is 143.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsForNodeLanguageSpecific,The length of the statement  "                    var originalConversion = this.OriginalSemanticModel.ClassifyConversion(originalOtherPartOfConditional' originalExpressionType); " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsForNodeLanguageSpecific,The length of the statement  "                    // Switch expression changed' verify that the conversions from switch case labels to new switch expression type are not broken. " is 127.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsForNodeLanguageSpecific,The length of the statement  "                    var originalExpressionType = this.OriginalSemanticModel.GetTypeInfo(originalSwitchStatement.Expression' this.CancellationToken).Type; " is 133.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsForNodeLanguageSpecific,The length of the statement  "                    var newExpressionType = this.SpeculativeSemanticModel.GetTypeInfo(newSwitchStatement.Expression' this.CancellationToken).Type; " is 126.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementChangesSemanticsForNodeLanguageSpecific,The length of the statement  "                    ReplacementBreaksCollectionInitializerAddMethod((ExpressionSyntax)previousOriginalNode' (ExpressionSyntax)previousReplacedNode); " is 128.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementBreaksCollectionInitializerAddMethod,The length of the statement  "            var originalSymbol = this.OriginalSemanticModel.GetCollectionInitializerSymbolInfo(originalInitializer' CancellationToken).Symbol; " is 130.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementBreaksCollectionInitializerAddMethod,The length of the statement  "            var newSymbol = this.SpeculativeSemanticModel.GetCollectionInitializerSymbolInfo(newInitializer' CancellationToken).Symbol; " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementBreaksIsOrAsExpression,The length of the statement  "            var originalConversion = this.OriginalSemanticModel.ClassifyConversion(originalIsOrAsExpression.Left' originalConvertedType' isExplicitInSource: true); " is 151.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementBreaksIsOrAsExpression,The length of the statement  "            var newConversion = this.SpeculativeSemanticModel.ClassifyConversion(newIsOrAsExpression.Left' newConvertedType' isExplicitInSource: true); " is 139.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementBreaksAssignmentExpression,The length of the statement  "                ReplacementBreaksCompoundAssignExpression(assignmentExpression.Left' assignmentExpression.Right' newAssignmentExpression.Left' newAssignmentExpression.Right)) " is 158.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementBreaksQueryClause,The length of the statement  "            QueryClauseInfo originalClauseInfo = this.OriginalSemanticModel.GetQueryClauseInfo(originalClause' this.CancellationToken); " is 123.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ConversionsAreCompatible,The length of the statement  "            return ConversionsAreCompatible(originalModel.GetConversion(originalExpression)' newModel.GetConversion(newExpression)); " is 120.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,UsingsAndExternAliasesDirectiveComparer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\UsingsAndExternAliasesDirectiveComparer.cs,Compare,The length of the statement  "            var directive1IsNamespace = using1 != null && using1.Alias == null && !using1.StaticKeyword.IsKind(SyntaxKind.StaticKeyword); " is 125.
Long Statement,Microsoft.CodeAnalysis.CSharp.Utilities,UsingsAndExternAliasesDirectiveComparer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\UsingsAndExternAliasesDirectiveComparer.cs,Compare,The length of the statement  "            var directive2IsNamespace = using2 != null && using2.Alias == null && !using2.StaticKeyword.IsKind(SyntaxKind.StaticKeyword); " is 125.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Classification,ClassificationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\ClassificationHelpers.cs,AdjustStaleClassification,The conditional expression  "(wasKeyword && !isKeyword) ||                              (wasIdentifier && !isIdentifier)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Classification.Classifiers,NameSyntaxClassifier,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Classifiers\NameSyntaxClassifier.cs,ClassifyTypeSyntax,The conditional expression  "TryClassifySymbol(name' symbolInfo' semanticModel' cancellationToken' out result) ||                      TryClassifyFromIdentifier(name' symbolInfo' out result) ||                      TryClassifyValueIdentifier(name' symbolInfo' out result) ||                      TryClassifyNameOfIdentifier(name' symbolInfo' out result)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Classification.Classifiers,NameSyntaxClassifier,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Classifiers\NameSyntaxClassifier.cs,TryClassifyNameOfIdentifier,The conditional expression  "identifierName != null &&                  identifierName.Identifier.IsKindOrHasMatchingText(SyntaxKind.NameOfKeyword) &&                  symbolInfo.Symbol == null &&                  !symbolInfo.CandidateSymbols.Any()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpDeclarationComparer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpDeclarationComparer.cs,Compare,The conditional expression  "EqualStaticness(x.Modifiers' y.Modifiers' out result) &&                  EqualAccessibility(x' x.Modifiers' y' y.Modifiers' out result) &&                  EqualIdentifierName(x.Identifier' y.Identifier' out result) &&                  EqualTypeParameterCount(x.TypeParameterList' y.TypeParameterList' out result)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,ParenthesizeLeft,The conditional expression  "expression is TypeSyntax                  || expression.IsKind(SyntaxKind.ThisExpression)                  || expression.IsKind(SyntaxKind.BaseExpression)                  || expression.IsKind(SyntaxKind.ParenthesizedExpression)                  || expression.IsKind(SyntaxKind.SimpleMemberAccessExpression)                  || expression.IsKind(SyntaxKind.InvocationExpression)                  || expression.IsKind(SyntaxKind.ElementAccessExpression)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.CodeGeneration,EnumMemberGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\EnumMemberGenerator.cs,CreateEnumMemberValue,The conditional expression  "!(enumMember.ConstantValue is byte) &&                  !(enumMember.ConstantValue is sbyte) &&                  !(enumMember.ConstantValue is ushort) &&                  !(enumMember.ConstantValue is short) &&                  !(enumMember.ConstantValue is int) &&                  !(enumMember.ConstantValue is uint) &&                  !(enumMember.ConstantValue is long) &&                  !(enumMember.ConstantValue is ulong)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInArgument,The conditional expression  "argument.Parent.IsParentKind(SyntaxKind.ImplicitElementAccess) &&                      argument.Parent.Parent.IsParentKind(SyntaxKind.SimpleAssignmentExpression) &&                      argument.Parent.Parent.Parent.IsParentKind(SyntaxKind.ObjectInitializerExpression) &&                      argument.Parent.Parent.Parent.Parent.IsParentKind(SyntaxKind.ObjectCreationExpression)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInBinaryOrAssignmentExpression,The conditional expression  "operatorToken.Kind() == SyntaxKind.AmpersandToken ||                      operatorToken.Kind() == SyntaxKind.AmpersandEqualsToken ||                      operatorToken.Kind() == SyntaxKind.BarToken ||                      operatorToken.Kind() == SyntaxKind.BarEqualsToken ||                      operatorToken.Kind() == SyntaxKind.CaretToken ||                      operatorToken.Kind() == SyntaxKind.CaretEqualsToken"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInInitializerExpression,The conditional expression  "(initializerExpression.IsParentKind(SyntaxKind.ComplexElementInitializerExpression) &&                            initializerExpression.Parent.IsParentKind(SyntaxKind.ObjectCreationExpression)) ||                           (initializerExpression.IsKind(SyntaxKind.ComplexElementInitializerExpression) &&                            initializerExpression.IsParentKind(SyntaxKind.CollectionInitializerExpression) &&                            initializerExpression.Parent.IsParentKind(SyntaxKind.ObjectCreationExpression))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The conditional expression  "(expressionType != null &&                  (expressionType.IsErrorType() ||                   expressionType.Kind == SymbolKind.DynamicType)) ||                  IsDynamicInvocation(cast' semanticModel' cancellationToken)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The conditional expression  "expressionToCastType.IsImplicit && expressionToCastType.IsReference &&                      castToOuterType.IsIdentity &&                      IsRequiredCastForReferenceEqualityComparison(outerType' cast' semanticModel' out other)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The conditional expression  "expressionToOuterType.IsIdentity &&                      expressionToCastType.IsImplicit &&                      (expressionToCastType.IsNumeric || expressionToCastType.IsConstantExpression)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,CastExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CastExpressionSyntaxExtensions.cs,IsUnnecessaryCast,The conditional expression  "(!castToOuterType.IsBoxing || expressionToCastType.IsNullLiteral) &&                      castToOuterType.IsImplicit &&                      expressionToCastType.IsImplicit &&                      expressionToOuterType.IsImplicit"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,CompilationUnitSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\CompilationUnitSyntaxExtensions.cs,AddUsingDirectives,The conditional expression  "(startOfLastDirective == 0 && (endOfLastDirective == endOfList || endOfLastDirective == -1)) ||                  (startOfLastDirective == -1 && endOfLastDirective == -1) ||                  (endOfLastDirective != endOfList && endOfLastDirective != -1)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanReplaceWithLValue,The conditional expression  "expression.IsKind(SyntaxKind.BaseExpression) ||                  expression.IsKind(SyntaxKind.CollectionInitializerExpression) ||                  expression.IsKind(SyntaxKind.ObjectInitializerExpression) ||                  expression.IsKind(SyntaxKind.ComplexElementInitializerExpression)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanReplaceWithLValue,The conditional expression  "parentNonExpression != null &&                  parentNonExpression.IsKind(SyntaxKind.FromClause) &&                  topExpression != null &&                  ((FromClauseSyntax)parentNonExpression).Type == topExpression"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanReplaceWithLValue,The conditional expression  "expression.Parent is PostfixUnaryExpressionSyntax ||                  expression.Parent is BinaryExpressionSyntax ||                  expression.Parent is AssignmentExpressionSyntax ||                  expression.Parent is QueryClauseSyntax ||                  expression.Parent is SelectOrGroupClauseSyntax ||                  expression.Parent is CheckedExpressionSyntax"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TrySimplifyMemberAccessOrQualifiedName,The conditional expression  "(namedType.GetBaseTypes().Contains(containingType) &&                                      !optionSet.GetOption(SimplificationOptions.AllowSimplificationToBaseType)) ||                                      (!optionSet.GetOption(SimplificationOptions.AllowSimplificationToGenericType) &&                                      containingType.TypeArguments.Count() != 0)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanReplaceWithReducedName,The conditional expression  "enclosingNamedType != null &&                      !enclosingNamedType.IsSealed &&                      symbol != null &&                      symbol.IsOverridable()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanReplaceWithReducedNameInContext,The conditional expression  "invalidTransformation1 || invalidTransformation2 || invalidTransformation3 || invalidTransformation4                  || isNotNullableReplacable"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsThisOrTypeOrNamespace,The conditional expression  "previousToken.Kind() == SyntaxKind.OpenParenToken &&                      previousToken.Parent.IsKind(SyntaxKind.ParenthesizedExpression) &&                      !previousToken.Parent.IsParentKind(SyntaxKind.ParenthesizedExpression) &&                      ((ParenthesizedExpressionSyntax)previousToken.Parent).Expression.Kind() == SyntaxKind.SimpleMemberAccessExpression &&                      symbol != null && symbol.Kind == SymbolKind.Method"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsReplacableByVar,The conditional expression  "checkSymbol != null && checkSymbol.IsKind(SymbolKind.NamedType) && ((INamedTypeSymbol)checkSymbol).TypeKind == TypeKind.Class && checkSymbol.Name == "var""  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,CommonSemanticModelExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ISemanticModelExtensions.cs,DetermineAccessibilityConstraint,The conditional expression  "type.IsParentKind(SyntaxKind.DelegateDeclaration) ||                  type.IsParentKind(SyntaxKind.MethodDeclaration) ||                  type.IsParentKind(SyntaxKind.PropertyDeclaration) ||                  type.IsParentKind(SyntaxKind.EventDeclaration) ||                  type.IsParentKind(SyntaxKind.IndexerDeclaration) ||                  type.IsParentKind(SyntaxKind.OperatorDeclaration)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,CommonSemanticModelExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ISemanticModelExtensions.cs,DetermineAccessibilityConstraint,The conditional expression  "type.Parent.Parent.IsParentKind(SyntaxKind.DelegateDeclaration) ||                      type.Parent.Parent.IsParentKind(SyntaxKind.MethodDeclaration) ||                      type.Parent.Parent.IsParentKind(SyntaxKind.IndexerDeclaration) ||                      type.Parent.Parent.IsParentKind(SyntaxKind.OperatorDeclaration)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,NameSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\NameSyntaxExtensions.cs,CanBeReplacedWithAnyName,The conditional expression  "nameSyntax.IsParentKind(SyntaxKind.AliasQualifiedName) ||                  nameSyntax.IsParentKind(SyntaxKind.NameColon) ||                  nameSyntax.IsParentKind(SyntaxKind.NameEquals) ||                  nameSyntax.IsParentKind(SyntaxKind.TypeParameterConstraintClause)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ParenthesizedExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ParenthesizedExpressionSyntaxExtensions.cs,CanRemoveParentheses,The conditional expression  "(node.IsParentKind(SyntaxKind.EqualsValueClause) && ((EqualsValueClauseSyntax)node.Parent).Value == node) ||                  (node.IsParentKind(SyntaxKind.IfStatement) && ((IfStatementSyntax)node.Parent).Condition == node) ||                  (node.IsParentKind(SyntaxKind.ReturnStatement) && ((ReturnStatementSyntax)node.Parent).Expression == node) ||                  (node.IsParentKind(SyntaxKind.YieldReturnStatement) && ((YieldStatementSyntax)node.Parent).Expression == node) ||                  (node.IsParentKind(SyntaxKind.ThrowStatement) && ((ThrowStatementSyntax)node.Parent).Expression == node) ||                  (node.IsParentKind(SyntaxKind.SwitchStatement) && ((SwitchStatementSyntax)node.Parent).Expression == node) ||                  (node.IsParentKind(SyntaxKind.WhileStatement) && ((WhileStatementSyntax)node.Parent).Condition == node) ||                  (node.IsParentKind(SyntaxKind.DoStatement) && ((DoStatementSyntax)node.Parent).Condition == node) ||                  (node.IsParentKind(SyntaxKind.ForStatement) && ((ForStatementSyntax)node.Parent).Condition == node) ||                  (node.IsParentKind(SyntaxKind.ForEachStatement) && ((ForEachStatementSyntax)node.Parent).Expression == node) ||                  (node.IsParentKind(SyntaxKind.LockStatement) && ((LockStatementSyntax)node.Parent).Expression == node) ||                  (node.IsParentKind(SyntaxKind.UsingStatement) && ((UsingStatementSyntax)node.Parent).Expression == node) ||                  (node.IsParentKind(SyntaxKind.CatchFilterClause) && ((CatchFilterClauseSyntax)node.Parent).FilterExpression == node)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ParenthesizedExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ParenthesizedExpressionSyntaxExtensions.cs,RemovalMayIntroduceInterpolationAmbiguity,The conditional expression  "node.Expression.IsKind(SyntaxKind.ConditionalExpression) &&                      interpolation.AlignmentClause == null &&                      interpolation.FormatClause != null &&                      !interpolation.FormatClause.ColonToken.IsMissing"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ParenthesizedExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ParenthesizedExpressionSyntaxExtensions.cs,RemovalMayIntroduceCommaListAmbiguity,The conditional expression  "binaryExpression != null &&                      binaryExpression.IsKind(SyntaxKind.LessThanExpression' SyntaxKind.GreaterThanExpression) &&                      (binaryExpression.IsParentKind(SyntaxKind.Argument) || binaryExpression.Parent is InitializerExpressionSyntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,ParenthesizedExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ParenthesizedExpressionSyntaxExtensions.cs,RemovalMayIntroduceCommaListAmbiguity,The conditional expression  "(binaryExpression.Left == node && IsSimpleOrDottedName(binaryExpression.Right)) ||                              (binaryExpression.Right == node && IsSimpleOrDottedName(binaryExpression.Left))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions,TypeSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeSyntaxExtensions.cs,IsPotentialTypeName,The conditional expression  "typeSyntax is PredefinedTypeSyntax ||                  typeSyntax is ArrayTypeSyntax ||                  typeSyntax is GenericNameSyntax ||                  typeSyntax is PointerTypeSyntax ||                  typeSyntax is NullableTypeSyntax"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTokenExtensions.cs,IsBeginningOfStatementContext,The conditional expression  "token.Parent.IsParentKind(SyntaxKind.ElseClause) ||                      token.Parent.IsParentKind(SyntaxKind.FinallyClause) ||                      token.Parent.IsParentKind(SyntaxKind.CatchClause) ||                      token.Parent.IsParentKind(SyntaxKind.SwitchSection)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTokenExtensions.cs,IsBeginningOfStatementContext,The conditional expression  "parent.IsKind(SyntaxKind.ForStatement) ||                      parent.IsKind(SyntaxKind.ForEachStatement) ||                      parent.IsKind(SyntaxKind.WhileStatement) ||                      parent.IsKind(SyntaxKind.IfStatement) ||                      parent.IsKind(SyntaxKind.LockStatement) ||                      parent.IsKind(SyntaxKind.UsingStatement)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTokenExtensions.cs,IsConstructorOrMethodParameterArgumentContext,The conditional expression  "targetToken.Kind() == SyntaxKind.ColonToken &&                  targetToken.Parent.IsKind(SyntaxKind.NameColon) &&                  targetToken.Parent.IsParentKind(SyntaxKind.Argument) &&                  targetToken.Parent.GetParent().IsParentKind(SyntaxKind.ArgumentList)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTokenExtensions.cs,IsConstructorOrMethodParameterArgumentContext,The conditional expression  "owner.IsKind(SyntaxKind.InvocationExpression) ||                      owner.IsKind(SyntaxKind.ObjectCreationExpression) ||                      owner.IsKind(SyntaxKind.BaseConstructorInitializer) ||                      owner.IsKind(SyntaxKind.ThisConstructorInitializer)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTokenExtensions.cs,IsConstructorOrMethodParameterArgumentContext,The conditional expression  "targetToken.Parent.IsParentKind(SyntaxKind.InvocationExpression) ||                          targetToken.Parent.IsParentKind(SyntaxKind.ObjectCreationExpression) ||                          targetToken.Parent.IsParentKind(SyntaxKind.BaseConstructorInitializer) ||                          targetToken.Parent.IsParentKind(SyntaxKind.ThisConstructorInitializer)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTokenExtensions.cs,IsAccessorDeclarationContextWorker,The conditional expression  "targetToken.Kind() == SyntaxKind.InternalKeyword ||                  targetToken.Kind() == SyntaxKind.PublicKeyword ||                  targetToken.Kind() == SyntaxKind.ProtectedKeyword ||                  targetToken.Kind() == SyntaxKind.PrivateKeyword"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTokenExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTokenExtensions.cs,IsTypeParameterVarianceContext,The conditional expression  "targetToken.Kind() == SyntaxKind.CloseBracketToken &&                  targetToken.Parent.IsKind(SyntaxKind.AttributeList) &&                  targetToken.Parent.IsParentKind(SyntaxKind.TypeParameter) &&                  IsGenericInterfaceOrDelegateTypeParameterList(targetToken.Parent.GetParent().GetParent())"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsTypeDeclarationContext,The conditional expression  "container.IsKind(SyntaxKind.CompilationUnit) ||                      container.IsKind(SyntaxKind.NamespaceDeclaration) ||                      container.IsKind(SyntaxKind.ClassDeclaration) ||                      container.IsKind(SyntaxKind.StructDeclaration)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsTypeDeclarationContext,The conditional expression  "container.IsKind(SyntaxKind.CompilationUnit) ||                      container.IsKind(SyntaxKind.NamespaceDeclaration) ||                      container.IsKind(SyntaxKind.ClassDeclaration) ||                      container.IsKind(SyntaxKind.StructDeclaration)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsTypeArgumentOfConstraintClause,The conditional expression  "token.Kind() == SyntaxKind.IdentifierToken &&                  token.HasMatchingText(SyntaxKind.WhereKeyword) &&                  token.Parent.IsKind(SyntaxKind.IdentifierName) &&                  token.Parent.IsParentKind(SyntaxKind.SimpleBaseType) &&                  token.Parent.Parent.IsParentKind(SyntaxKind.BaseList)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsGenericTypeArgumentContext,The conditional expression  "name.IsParentKind(SyntaxKind.LessThanExpression) &&                  name.Parent.IsParentKind(SyntaxKind.ConditionalExpression) &&                  name.Parent.Parent.IsParentKind(SyntaxKind.ExpressionStatement) &&                  name.Parent.Parent.Parent.IsParentKind(SyntaxKind.GlobalStatement)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsParameterModifierContext,The conditional expression  "token.Kind() == SyntaxKind.CloseBracketToken &&                  token.Parent.IsKind(SyntaxKind.AttributeList) &&                  token.Parent.IsParentKind(SyntaxKind.Parameter) &&                  token.Parent.GetParent().GetParent().IsDelegateOrConstructorOrMethodParameterList()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsParameterTypeContext,The conditional expression  "token.Kind() == SyntaxKind.RefKeyword ||                  token.Kind() == SyntaxKind.OutKeyword ||                  token.Kind() == SyntaxKind.ParamsKeyword ||                  token.Kind() == SyntaxKind.ThisKeyword"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsLabelContext,The conditional expression  "gotoStatement.Expression != null &&                      !gotoStatement.Expression.IsMissing &&                      gotoStatement.Expression is IdentifierNameSyntax &&                      ((IdentifierNameSyntax)gotoStatement.Expression).Identifier == token &&                      token.IntersectsWith(position)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsExpressionContext,The conditional expression  "token.Kind() == SyntaxKind.EqualsToken ||                  token.Kind() == SyntaxKind.MinusEqualsToken ||                  token.Kind() == SyntaxKind.AsteriskEqualsToken ||                  token.Kind() == SyntaxKind.PlusEqualsToken ||                  token.Kind() == SyntaxKind.SlashEqualsToken ||                  token.Kind() == SyntaxKind.ExclamationEqualsToken ||                  token.Kind() == SyntaxKind.CaretEqualsToken ||                  token.Kind() == SyntaxKind.AmpersandEqualsToken ||                  token.Kind() == SyntaxKind.BarEqualsToken ||                  token.Kind() == SyntaxKind.PercentEqualsToken ||                  token.Kind() == SyntaxKind.LessThanLessThanEqualsToken ||                  token.Kind() == SyntaxKind.GreaterThanGreaterThanEqualsToken"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsNameOfContext,The conditional expression  "!invocationExpression.IsParentKind(SyntaxKind.ConditionalAccessExpression) &&                      !invocationExpression.IsParentKind(SyntaxKind.SimpleMemberAccessExpression) &&                      !invocationExpression.IsParentKind(SyntaxKind.PointerMemberAccessExpression) &&                      invocationExpression.Expression.IsKind(SyntaxKind.IdentifierName) &&                      ((IdentifierNameSyntax)invocationExpression.Expression).Identifier.IsKindOrHasMatchingText(SyntaxKind.NameOfKeyword)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsIsOrAsContext,The conditional expression  "CodeAnalysis.CSharpExtensions.IsKind(token' SyntaxKind.IdentifierToken) &&                      token.Parent.IsKind(SyntaxKind.IdentifierName) &&                      (token.Parent.IsParentKind(SyntaxKind.ObjectInitializerExpression) || token.Parent.IsParentKind(SyntaxKind.CollectionInitializerExpression))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,TriviaDataFactory,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.Analyzer.cs,ContainsOnlyWhitespace,The conditional expression  "result.HasComments || result.HasPreprocessor || result.HasSkippedTokens || result.HasSkippedOrDisabledText"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,TriviaDataFactory,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.Analyzer.cs,GetSpaceOnSingleLine,The conditional expression  "result.HasTrailingSpace || result.HasUnknownWhitespace || result.LineBreaks > 0 || result.Tab > 0"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,CodeShapeAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.CodeShapeAnalyzer.cs,ShouldFormat,The conditional expression  "OnElastic(trivia) ||                          OnWhitespace(trivia) ||                          OnEndOfLine(trivia' index) ||                          OnTouchedNoisyCharacter(trivia) ||                          OnComment(trivia' index) ||                          OnSkippedTokensOrText(trivia) ||                          OnRegion(trivia' index) ||                          OnPreprocessor(trivia' index)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,FormattingHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\FormattingHelpers.cs,IsInitializerForArrayOrCollectionCreationExpression,The conditional expression  "parent is ArrayCreationExpressionSyntax ||                  parent is ImplicitArrayCreationExpressionSyntax ||                  parent is EqualsValueClauseSyntax ||                  parent.Kind() == SyntaxKind.SimpleAssignmentExpression"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,AddPropertyDeclarationSuppressOperations,The conditional expression  "basePropertyDeclaration != null && basePropertyDeclaration.AccessorList != null &&                  basePropertyDeclaration.AccessorList.Accessors.All(a => a.Body == null) &&                  basePropertyDeclaration.GetAnnotatedTrivia(SyntaxAnnotation.ElasticAnnotation).Any()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,LineBreaksAfter,The conditional expression  "(currentToken.Kind() == SyntaxKind.FromKeyword && currentToken.Parent.Kind() == SyntaxKind.FromClause) ||                  (currentToken.Kind() == SyntaxKind.LetKeyword && currentToken.Parent.Kind() == SyntaxKind.LetClause) ||                  (currentToken.Kind() == SyntaxKind.WhereKeyword && currentToken.Parent.Kind() == SyntaxKind.WhereClause) ||                  (currentToken.Kind() == SyntaxKind.JoinKeyword && currentToken.Parent.Kind() == SyntaxKind.JoinClause) ||                  (currentToken.Kind() == SyntaxKind.JoinKeyword && currentToken.Parent.Kind() == SyntaxKind.JoinIntoClause) ||                  (currentToken.Kind() == SyntaxKind.OrderByKeyword && currentToken.Parent.Kind() == SyntaxKind.OrderByClause) ||                  (currentToken.Kind() == SyntaxKind.SelectKeyword && currentToken.Parent.Kind() == SyntaxKind.SelectClause) ||                  (currentToken.Kind() == SyntaxKind.GroupKeyword && currentToken.Parent.Kind() == SyntaxKind.GroupClause)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,IndentBlockFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\IndentBlockFormattingRule.cs,AddEmbeddedStatementsIndentationOperation,The conditional expression  "usingStatement != null && usingStatement.Statement != null && !(usingStatement.Statement is BlockSyntax || usingStatement.Statement is UsingStatementSyntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "currentToken.IsKind(SyntaxKind.OpenBraceToken) && currentTokenParentParent != null &&                 (currentTokenParentParent is MemberDeclarationSyntax || currentTokenParentParent is AccessorDeclarationSyntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "currentToken.IsKind(SyntaxKind.OpenBraceToken) && currentTokenParentParent != null &&                 (currentTokenParentParent.IsKind(SyntaxKind.SimpleLambdaExpression) || currentTokenParentParent.IsKind(SyntaxKind.ParenthesizedLambdaExpression))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The conditional expression  "currentToken.Kind() == SyntaxKind.OpenBraceToken && currentToken.Parent != null &&                  (currentToken.Parent.Kind() == SyntaxKind.ObjectInitializerExpression ||                  currentToken.Parent.Kind() == SyntaxKind.CollectionInitializerExpression)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The conditional expression  "currentToken.IsKind(SyntaxKind.OpenBraceToken) && currentToken.Parent != null &&                  (currentToken.Parent.Kind() == SyntaxKind.ArrayInitializerExpression ||                  currentToken.Parent.Kind() == SyntaxKind.ImplicitArrayCreationExpression)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The conditional expression  "currentToken.Kind() == SyntaxKind.OpenBraceToken &&                  currentTokenParentParent != null && (currentTokenParentParent is MemberDeclarationSyntax || currentTokenParentParent is AccessorDeclarationSyntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The conditional expression  "currentToken.Kind() == SyntaxKind.OpenBraceToken && currentTokenParentParent != null &&                 (currentTokenParentParent.Kind() == SyntaxKind.SimpleLambdaExpression || currentTokenParentParent.Kind() == SyntaxKind.ParenthesizedLambdaExpression)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,NewLineUserSettingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\NewLineUserSettingFormattingRule.cs,GetAdjustNewLinesOperation,The conditional expression  "previousToken.Kind() == SyntaxKind.SemicolonToken                  && (previousToken.Parent is StatementSyntax && !previousToken.Parent.IsKind(SyntaxKind.ForStatement))                  && !optionSet.GetOption(CSharpFormattingOptions.WrappingKeepStatementsOnSingleLine)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "currentKind == SyntaxKind.OpenParenToken &&                  (previousKind == SyntaxKind.IfKeyword || previousKind == SyntaxKind.WhileKeyword || previousKind == SyntaxKind.SwitchKeyword ||                  previousKind == SyntaxKind.ForKeyword || previousKind == SyntaxKind.ForEachKeyword || previousKind == SyntaxKind.CatchKeyword ||                  previousKind == SyntaxKind.UsingKeyword)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "(previousParentKind == SyntaxKind.ParenthesizedExpression && previousKind == SyntaxKind.OpenParenToken) ||                  (currentParentKind == SyntaxKind.ParenthesizedExpression && currentKind == SyntaxKind.CloseParenToken)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "(previousParentKind == SyntaxKind.CastExpression && previousKind == SyntaxKind.OpenParenToken) ||                  (currentParentKind == SyntaxKind.CastExpression && currentKind == SyntaxKind.CloseParenToken)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "previousKind == SyntaxKind.OpenParenToken &&                  (previousParentKind == SyntaxKind.IfStatement || previousParentKind == SyntaxKind.WhileStatement || previousParentKind == SyntaxKind.SwitchStatement ||                  previousParentKind == SyntaxKind.ForStatement || previousParentKind == SyntaxKind.ForEachStatement || previousParentKind == SyntaxKind.DoStatement ||                  previousParentKind == SyntaxKind.CatchDeclaration || previousParentKind == SyntaxKind.UsingStatement)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "currentKind == SyntaxKind.CloseParenToken &&                  (currentParentKind == SyntaxKind.IfStatement || currentParentKind == SyntaxKind.WhileStatement || currentParentKind == SyntaxKind.SwitchStatement ||                  currentParentKind == SyntaxKind.ForStatement || currentParentKind == SyntaxKind.ForEachStatement || currentParentKind == SyntaxKind.DoStatement ||                  currentParentKind == SyntaxKind.UsingStatement || previousParentKind == SyntaxKind.CatchDeclaration)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "currentToken.Parent is BinaryExpressionSyntax ||                  previousToken.Parent is BinaryExpressionSyntax ||                  currentToken.Parent is AssignmentExpressionSyntax ||                  previousToken.Parent is AssignmentExpressionSyntax"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "(currentKind == SyntaxKind.OpenBraceToken && currentToken.Parent is InterpolationSyntax) ||                  (previousKind == SyntaxKind.CloseBraceToken && previousToken.Parent is InterpolationSyntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "(previousKind == SyntaxKind.OpenBraceToken && previousToken.Parent is InterpolationSyntax) ||                  (currentKind == SyntaxKind.CloseBraceToken && currentToken.Parent is InterpolationSyntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "(previousKind == SyntaxKind.CommaToken && previousToken.Parent is InterpolationAlignmentClauseSyntax) ||                  (currentKind == SyntaxKind.CommaToken && currentToken.Parent is InterpolationAlignmentClauseSyntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "(previousKind == SyntaxKind.ColonToken && previousToken.Parent is InterpolationFormatClauseSyntax) ||                  (currentKind == SyntaxKind.ColonToken && currentToken.Parent is InterpolationFormatClauseSyntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,SpacingFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SpacingFormattingRule.cs,SuppressVariableDeclaration,The conditional expression  "node.IsKind(SyntaxKind.FieldDeclaration) || node.IsKind(SyntaxKind.EventDeclaration) ||                  node.IsKind(SyntaxKind.EventFieldDeclaration) || node.IsKind(SyntaxKind.LocalDeclarationStatement)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustNewLinesOperation,The conditional expression  "currentToken.Kind() != SyntaxKind.SemicolonToken &&                              !currentToken.IsParenInParenthesizedExpression() &&                              !currentToken.IsCommaInInitializerExpression() &&                              !currentToken.IsCommaInAnyArgumentsList() &&                              !currentToken.IsParenInArgumentList() &&                              !currentToken.IsDotInMemberAccess() &&                              !currentToken.IsCloseParenInStatement()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustNewLinesOperation,The conditional expression  "previousToken.Kind() == SyntaxKind.SemicolonToken &&                  (currentToken.Kind() == SyntaxKind.CaseKeyword || currentToken.Kind() == SyntaxKind.DefaultKeyword || currentToken.Kind() == SyntaxKind.ElseKeyword)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "previousToken.Kind() == SyntaxKind.OmittedArraySizeExpressionToken ||                  previousToken.Kind() == SyntaxKind.OmittedTypeArgumentToken ||                  currentToken.Kind() == SyntaxKind.OmittedArraySizeExpressionToken ||                  currentToken.Kind() == SyntaxKind.OmittedTypeArgumentToken"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "previousToken.Kind() == SyntaxKind.IdentifierToken ||                      previousToken.Kind() == SyntaxKind.DefaultKeyword ||                      previousToken.Kind() == SyntaxKind.BaseKeyword ||                      previousToken.Kind() == SyntaxKind.ThisKeyword ||                      previousToken.Kind() == SyntaxKind.NewKeyword ||                      previousToken.Parent.Kind() == SyntaxKind.OperatorDeclaration ||                      previousToken.IsGenericGreaterThanToken() ||                      currentToken.IsParenInArgumentList()"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "(currentToken.Kind() == SyntaxKind.LessThanToken || currentToken.Kind() == SyntaxKind.GreaterThanToken) &&                  (currentToken.Parent.Kind() == SyntaxKind.TypeArgumentList || currentToken.Parent.Kind() == SyntaxKind.TypeParameterList)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The conditional expression  "(currentToken.Kind() == SyntaxKind.AsteriskToken && currentToken.Parent is PointerTypeSyntax) ||                  (previousToken.Kind() == SyntaxKind.AsteriskToken && previousToken.Parent is PrefixUnaryExpressionSyntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,LocalVariableConflict,The conditional expression  "token.Parent.IsKind(SyntaxKind.IdentifierName) &&                  token.Parent.IsParentKind(SyntaxKind.InvocationExpression) &&                  token.GetPreviousToken().Kind() != SyntaxKind.DotToken &&                  token.GetNextToken().Kind() != SyntaxKind.DotToken"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputePossibleImplicitUsageConflicts,The conditional expression  "(renamedSymbol.Name == "MoveNext" || renamedSymbol.Name == "GetEnumerator" || renamedSymbol.Name == "Current") && renamedSymbol.GetAllTypeArguments().Length == 0"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,IsRenameLocation,The conditional expression  "symbol != null && _renamedSymbol.Kind != SymbolKind.Local && _renamedSymbol.Kind != SymbolKind.RangeVariable &&                              (symbol == _renamedSymbol || SymbolKey.GetComparer(ignoreCase: true' ignoreAssemblyKeys: false).Equals(symbol.GetSymbolKey()' _renamedSymbol.GetSymbolKey()))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Simplification,Rewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpCastReducer.Rewriter.cs,VisitBinaryExpression,The conditional expression  "(node.Left.IsKind(SyntaxKind.CastExpression) && !reducedNode.Left.IsKind(SyntaxKind.CastExpression)) ||                          (node.Right.IsKind(SyntaxKind.CastExpression) && !reducedNode.Right.IsKind(SyntaxKind.CastExpression))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpSimplificationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.cs,Expand,The conditional expression  "node is AttributeSyntax ||                      node is AttributeArgumentSyntax ||                      node is ConstructorInitializerSyntax ||                      node is ExpressionSyntax ||                      node is FieldDeclarationSyntax ||                      node is StatementSyntax ||                      node is CrefSyntax ||                      node is XmlNameAttributeSyntax ||                      node is TypeConstraintSyntax ||                      node is BaseTypeSyntax"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitParameter,The conditional expression  "node != null && node.IsParentKind(SyntaxKind.ParameterList) &&                      newNode != null && newNode.Type == null &&                      _expandParameter"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Simplification,Expander,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpSimplificationService.Expander.cs,VisitSimpleName,The conditional expression  "parent is MemberDeclarationSyntax ||                      parent is MemberBindingExpressionSyntax ||                      originalSimpleName.GetAncestor<NameEqualsSyntax>() != null ||                      (parent is MemberAccessExpressionSyntax && parent.Kind() != SyntaxKind.SimpleMemberAccessExpression) ||                      ((parent.Kind() == SyntaxKind.SimpleMemberAccessExpression || parent.Kind() == SyntaxKind.NameMemberCref) && originalSimpleName.IsRightSideOfDot()) ||                      (parent.Kind() == SyntaxKind.QualifiedName && originalSimpleName.IsRightSideOfQualifiedName()) ||                      (parent.Kind() == SyntaxKind.AliasQualifiedName)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Utilities,FormattingRangeHelper,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\FormattingRangeHelper.cs,FindAppropriateRangeForSemicolon,The conditional expression  "(parent is UsingDirectiveSyntax) ||                  (parent is DelegateDeclarationSyntax) ||                  (parent is FieldDeclarationSyntax) ||                  (parent is EventFieldDeclarationSyntax) ||                  (parent is MethodDeclarationSyntax)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,IsInvocableExpression,The conditional expression  "node.IsKind(SyntaxKind.SimpleMemberAccessExpression) &&                  !node.IsParentKind(SyntaxKind.InvocationExpression) &&                  !node.IsParentKind(SyntaxKind.ObjectCreationExpression) &&                  !node.IsParentKind(SyntaxKind.ElementAccessExpression)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,ReplacementBreaksAssignmentExpression,The conditional expression  "assignmentExpression.IsCompoundAssignExpression() &&                  assignmentExpression.Kind() != SyntaxKind.LeftShiftAssignmentExpression &&                  assignmentExpression.Kind() != SyntaxKind.RightShiftAssignmentExpression &&                  ReplacementBreaksCompoundAssignExpression(assignmentExpression.Left' assignmentExpression.Right' newAssignmentExpression.Left' newAssignmentExpression.Right)"  is complex.
Virtual Method Call from Constructor,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,CSharpCodeGenerationService,The constructor "CSharpCodeGenerationService" calls a virtual method "GetService".
Virtual Method Call from Constructor,Microsoft.CodeAnalysis.CSharp,RecoverableSyntaxTree,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxTreeFactoryService.RecoverableSyntaxTree.cs,RecoverableSyntaxTree,The constructor "RecoverableSyntaxTree" calls a virtual method "GetService".
Virtual Method Call from Constructor,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,RenameRewriter,The constructor "RenameRewriter" calls a virtual method "GetService".
Magic Number,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationHelpers.cs,ReplaceUnterminatedConstruct,The following statement contains a magic number: tokenText.Length <= 2 || tokenText.Last() != '"'
Magic Number,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,GetArgumentListIndex,The following statement contains a magic number: return (tokenIndex + 1) / 2;
Magic Number,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,GetArgumentListIndex,The following statement contains a magic number: return (tokenIndex + 1) / 2;
Magic Number,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduceAttributeSuffix,The following statement contains a magic number: var newAttributeName = identifierToken.ValueText.Substring(0' identifierToken.ValueText.Length - 9);
Magic Number,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduceAttributeSuffix,The following statement contains a magic number: issueSpan = new TextSpan(identifierToken.Span.End - 9' 9);
Magic Number,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduceAttributeSuffix,The following statement contains a magic number: issueSpan = new TextSpan(identifierToken.Span.End - 9' 9);
Magic Number,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,ChildThatContainsPosition,The following statement contains a magic number: int middle = left + ((right - left) / 2);
Magic Number,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,AtEndOfIncompleteStringOrCharLiteral,The following statement contains a magic number: startLength = 2;
Magic Number,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTriviaExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTriviaExtensions.cs,IsCompleteMultiLineComment,The following statement contains a magic number: return text.Length >= 4                  && text[text.Length - 1] == '/'                  && text[text.Length - 2] == '*';
Magic Number,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTriviaExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTriviaExtensions.cs,IsCompleteMultiLineComment,The following statement contains a magic number: return text.Length >= 4                  && text[text.Length - 1] == '/'                  && text[text.Length - 2] == '*';
Magic Number,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTriviaExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTriviaExtensions.cs,GetCommentText,The following statement contains a magic number: commentText = commentText.Substring(2);
Magic Number,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsParameterModifierContext,The following statement contains a magic number: var index = commaIndex / 2 + 1;
Magic Number,Microsoft.CodeAnalysis.CSharp.Formatting,CodeShapeAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Engine\Trivia\TriviaDataFactory.CodeShapeAnalyzer.cs,ShouldFormatSingleLineDocumentationComment,The following statement contains a magic number: xmlCommentText.GetColumnFromLineOffset(xmlCommentText.Length - 3' tabSize) != indentation
Magic Number,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,GetAdjustNewLinesOperationBetweenMembers,The following statement contains a magic number: return CreateAdjustNewLinesOperation(numberOfLines + 2 /* +1 for member itself and +1 for a blank line*/' AdjustNewLinesOption.ForceLines);
Magic Number,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,GetAdjustNewLinesOperationBetweenMembers,The following statement contains a magic number: return FormattingOperations.CreateAdjustNewLinesOperation(2 /* +1 for member itself and +1 for a blank line*/' AdjustNewLinesOption.ForceLines);
Magic Number,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,LineBreaksAfter,The following statement contains a magic number: switch (previousToken.Kind())              {                  case SyntaxKind.None:                      return 0;                    case SyntaxKind.OpenBraceToken:                  case SyntaxKind.FinallyKeyword:                      return 1;                    case SyntaxKind.CloseBraceToken:                      return LineBreaksAfterCloseBrace(currentToken);                    case SyntaxKind.CloseParenToken:                      return (((previousToken.Parent is StatementSyntax) && currentToken.Parent != previousToken.Parent)                          || currentToken.Kind() == SyntaxKind.OpenBraceToken) ? 1 : 0;                    case SyntaxKind.CloseBracketToken:                      if (previousToken.Parent is AttributeListSyntax)                      {                          // Assembly and module-level attributes followed by non-attributes should have                          // a blank line after them.                          var parent = (AttributeListSyntax)previousToken.Parent;                          if (parent.Target != null &&                              (parent.Target.Identifier.IsKindOrHasMatchingText(SyntaxKind.AssemblyKeyword) ||                               parent.Target.Identifier.IsKindOrHasMatchingText(SyntaxKind.ModuleKeyword)))                          {                              if (!(currentToken.Parent is AttributeListSyntax))                              {                                  return 2;                              }                          }                            if (previousToken.GetAncestor<ParameterSyntax>() == null)                          {                              return 1;                          }                      }                        break;                    case SyntaxKind.SemicolonToken:                      return LineBreaksAfterSemicolon(previousToken' currentToken);                    case SyntaxKind.CommaToken:                      return previousToken.Parent is EnumDeclarationSyntax ? 1 : 0;                    case SyntaxKind.ElseKeyword:                      return currentToken.Kind() != SyntaxKind.IfKeyword ? 1 : 0;                    case SyntaxKind.ColonToken:                      if (previousToken.Parent is LabeledStatementSyntax || previousToken.Parent is SwitchLabelSyntax)                      {                          return 1;                      }                        break;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,LineBreaksAfter,The following statement contains a magic number: switch (currentToken.Kind())              {                  case SyntaxKind.OpenBraceToken:                  case SyntaxKind.CloseBraceToken:                  case SyntaxKind.ElseKeyword:                  case SyntaxKind.FinallyKeyword:                      return 1;                    case SyntaxKind.OpenBracketToken:                      if (currentToken.Parent is AttributeListSyntax)                      {                          // Assembly and module-level attributes preceded by non-attributes should have                          // a blank line separating them.                          var parent = (AttributeListSyntax)currentToken.Parent;                          if (parent.Target != null)                          {                              if (parent.Target.Identifier == SyntaxFactory.Token(SyntaxKind.AssemblyKeyword) ||                                  parent.Target.Identifier == SyntaxFactory.Token(SyntaxKind.ModuleKeyword))                              {                                  if (!(previousToken.Parent is AttributeListSyntax))                                  {                                      return 2;                                  }                              }                          }                            // Attributes on parameters should have no lines between them.                          if (parent.Parent is ParameterSyntax)                          {                              return 0;                          }                            return 1;                      }                        break;                    case SyntaxKind.WhereKeyword:                      return previousToken.Parent is TypeParameterListSyntax ? 1 : 0;              }
Magic Number,Microsoft.CodeAnalysis.CSharp.Formatting,SuppressFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\SuppressFormattingRule.cs,AddSpecificNodesSuppressOperations,The following statement contains a magic number: switchSection.Labels.Count < 2
Magic Number,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,TryAddPossibleNameConflicts,The following statement contains a magic number: var conflict = replacementText.Substring(0' replacementText.Length - 9);
Magic Number,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,TryAddPossibleNameConflicts,The following statement contains a magic number: replacementText.EndsWith("Attribute") && replacementText.Length > 9
Magic Number,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpExtensionMethodReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpExtensionMethodReducer.cs,TryReduceExtensionMethod,The following statement contains a magic number: var newArguments = SyntaxFactory.SeparatedList<ArgumentSyntax>(argumentList.Arguments.GetWithSeparators().AsEnumerable().Skip(2));
Missing Default,Microsoft.CodeAnalysis.CSharp.Classification,ClassificationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\ClassificationHelpers.cs,IsVerbatimStringToken,The following switch statement is missing a default case: switch (token.Kind())              {                  case SyntaxKind.InterpolatedVerbatimStringStartToken:                      return true;                  case SyntaxKind.InterpolatedStringStartToken:                      return false;                    case SyntaxKind.InterpolatedStringEndToken:                      {                          var interpolatedString = token.Parent as InterpolatedStringExpressionSyntax;                            return interpolatedString != null                              && interpolatedString.StringStartToken.IsKind(SyntaxKind.InterpolatedVerbatimStringStartToken);                      }                    case SyntaxKind.InterpolatedStringTextToken:                      {                          var interpolatedStringText = token.Parent as InterpolatedStringTextSyntax;                          if (interpolatedStringText == null)                          {                              return false;                          }                            var interpolatedString = interpolatedStringText.Parent as InterpolatedStringExpressionSyntax;                            return interpolatedString != null                              && interpolatedString.StringStartToken.IsKind(SyntaxKind.InterpolatedVerbatimStringStartToken);                      }              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Classification,ClassificationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\ClassificationHelpers.cs,GetClassificationForPunctuation,The following switch statement is missing a default case: switch (token.Kind())                  {                      case SyntaxKind.LessThanToken:                      case SyntaxKind.GreaterThanToken:                          // the < and > tokens of a type parameter list should be classified as                          // punctuation; otherwise' they're operators.                          if (token.Parent != null)                          {                              if (token.Parent.Kind() == SyntaxKind.TypeParameterList ||                                  token.Parent.Kind() == SyntaxKind.TypeArgumentList)                              {                                  return ClassificationTypeNames.Punctuation;                              }                          }                            break;                      case SyntaxKind.ColonToken:                          // the : for inheritance/implements or labels should be classified as                          // punctuation; otherwise' it's from a conditional operator.                          if (token.Parent != null)                          {                              if (token.Parent.Kind() != SyntaxKind.ConditionalExpression)                              {                                  return ClassificationTypeNames.Punctuation;                              }                          }                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Classification,ClassificationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\ClassificationHelpers.cs,IsActualContextualKeyword,The following switch statement is missing a default case: switch (token.ValueText)                  {                      case FromKeyword:                          var fromClause = token.Parent.FirstAncestorOrSelf<FromClauseSyntax>();                          return fromClause != null && fromClause.FromKeyword == token;                        case VarKeyword:                          // we allow var any time it looks like a variable declaration' and is not in a                          // field or event field.                          return                              token.Parent is IdentifierNameSyntax &&                              token.Parent.Parent is VariableDeclarationSyntax &&                              !(token.Parent.Parent.Parent is FieldDeclarationSyntax) &&                              !(token.Parent.Parent.Parent is EventFieldDeclarationSyntax);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Classification,Worker,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Worker.cs,ClassifyXmlNode,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.XmlElement:                      ClassifyXmlElement((XmlElementSyntax)node);                      break;                  case SyntaxKind.XmlEmptyElement:                      ClassifyXmlEmptyElement((XmlEmptyElementSyntax)node);                      break;                  case SyntaxKind.XmlText:                      ClassifyXmlText((XmlTextSyntax)node);                      break;                  case SyntaxKind.XmlComment:                      ClassifyXmlComment((XmlCommentSyntax)node);                      break;                  case SyntaxKind.XmlCDataSection:                      ClassifyXmlCDataSection((XmlCDataSectionSyntax)node);                      break;                  case SyntaxKind.XmlProcessingInstruction:                      ClassifyXmlProcessingInstruction((XmlProcessingInstructionSyntax)node);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Classification,Worker,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Worker.cs,ClassifyXmlTrivia,The following switch statement is missing a default case: switch (t.Kind())                  {                      case SyntaxKind.DocumentationCommentExteriorTrivia:                          ClassifyExteriorTrivia(t);                          break;                        case SyntaxKind.WhitespaceTrivia:                          if (whitespaceClassificationType != null)                          {                              AddClassification(t' whitespaceClassificationType);                          }                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Classification,Worker,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Worker.cs,ClassifyXmlTextToken,The following switch statement is missing a default case: switch (token.Parent.Kind())                  {                      case SyntaxKind.XmlText:                          AddClassification(token' ClassificationTypeNames.XmlDocCommentText);                          break;                      case SyntaxKind.XmlTextAttribute:                          AddClassification(token' ClassificationTypeNames.XmlDocCommentAttributeValue);                          break;                      case SyntaxKind.XmlComment:                          AddClassification(token' ClassificationTypeNames.XmlDocCommentComment);                          break;                      case SyntaxKind.XmlCDataSection:                          AddClassification(token' ClassificationTypeNames.XmlDocCommentCDataSection);                          break;                      case SyntaxKind.XmlProcessingInstruction:                          AddClassification(token' ClassificationTypeNames.XmlDocCommentProcessingInstruction);                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Classification,Worker,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Worker.cs,ClassifyXmlAttribute,The following switch statement is missing a default case: switch (attribute.Kind())              {                  case SyntaxKind.XmlTextAttribute:                      ClassifyXmlTextTokens(((XmlTextAttributeSyntax)attribute).TextTokens);                      break;                  case SyntaxKind.XmlCrefAttribute:                      ClassifyNode(((XmlCrefAttributeSyntax)attribute).Cref);                      break;                  case SyntaxKind.XmlNameAttribute:                      ClassifyNode(((XmlNameAttributeSyntax)attribute).Identifier);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Classification,Worker,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Worker.cs,ClassifyPreprocessorDirective,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.IfDirectiveTrivia:                      ClassifyIfDirective((IfDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.ElifDirectiveTrivia:                      ClassifyElifDirective((ElifDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.ElseDirectiveTrivia:                      ClassifyElseDirective((ElseDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.EndIfDirectiveTrivia:                      ClassifyEndIfDirective((EndIfDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.RegionDirectiveTrivia:                      ClassifyRegionDirective((RegionDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.EndRegionDirectiveTrivia:                      ClassifyEndRegionDirective((EndRegionDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.ErrorDirectiveTrivia:                      ClassifyErrorDirective((ErrorDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.WarningDirectiveTrivia:                      ClassifyWarningDirective((WarningDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.BadDirectiveTrivia:                      ClassifyBadDirective((BadDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.DefineDirectiveTrivia:                      ClassifyDefineDirective((DefineDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.UndefDirectiveTrivia:                      ClassifyUndefDirective((UndefDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.LineDirectiveTrivia:                      ClassifyLineDirective((LineDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.PragmaChecksumDirectiveTrivia:                      ClassifyPragmaChecksumDirective((PragmaChecksumDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.PragmaWarningDirectiveTrivia:                      ClassifyPragmaWarningDirective((PragmaWarningDirectiveTriviaSyntax)node);                      break;                  case SyntaxKind.ReferenceDirectiveTrivia:                      ClassifyReferenceDirective((ReferenceDirectiveTriviaSyntax)node);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Classification,Worker,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Worker.cs,ClassifyLineDirective,The following switch statement is missing a default case: switch (node.Line.Kind())              {                  case SyntaxKind.HiddenKeyword:                  case SyntaxKind.DefaultKeyword:                      AddClassification(node.Line' ClassificationTypeNames.PreprocessorKeyword);                      break;                  case SyntaxKind.NumericLiteralToken:                      AddClassification(node.Line' ClassificationTypeNames.NumericLiteral);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Classification.Classifiers,NameSyntaxClassifier,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Classification\Classifiers\NameSyntaxClassifier.cs,TryGetSymbol,The following switch statement is missing a default case: switch (symbolInfo.CandidateReason)                  {                      case CandidateReason.NotAValue:                          return firstSymbol;                        case CandidateReason.NotCreatable:                          // We want to color types even if they can't be constructed.                          if (firstSymbol.IsConstructor() || firstSymbol is ITypeSymbol)                          {                              return firstSymbol;                          }                            break;                        case CandidateReason.OverloadResolutionFailure:                          // If we couldn't bind to a constructor' still classify the type.                          if (firstSymbol.IsConstructor())                          {                              return firstSymbol;                          }                            break;                        case CandidateReason.Inaccessible:                          // If a constructor wasn't accessible' still classify the type if it's accessible.                          if (firstSymbol.IsConstructor() && semanticModel.IsAccessible(name.SpanStart' firstSymbol.ContainingType))                          {                              return firstSymbol;                          }                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationHelpers.cs,AddAccessibilityModifiers,The following switch statement is missing a default case: switch (accessibility)              {                  case Accessibility.Public:                      tokens.Add(SyntaxFactory.Token(SyntaxKind.PublicKeyword));                      break;                  case Accessibility.Protected:                      tokens.Add(SyntaxFactory.Token(SyntaxKind.ProtectedKeyword));                      break;                  case Accessibility.Private:                      tokens.Add(SyntaxFactory.Token(SyntaxKind.PrivateKeyword));                      break;                  case Accessibility.ProtectedAndInternal:                  case Accessibility.Internal:                      tokens.Add(SyntaxFactory.Token(SyntaxKind.InternalKeyword));                      break;                  case Accessibility.ProtectedOrInternal:                      tokens.Add(SyntaxFactory.Token(SyntaxKind.ProtectedKeyword));                      tokens.Add(SyntaxFactory.Token(SyntaxKind.InternalKeyword));                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpCodeGenerationService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpCodeGenerationService.cs,UpdateDeclarationMembers,The following switch statement is missing a default case: switch (syntaxNode.Kind())                  {                      case SyntaxKind.CompilationUnit:                      case SyntaxKind.NamespaceDeclaration:                          return Cast<TDeclarationNode>(NamespaceGenerator.UpdateCompilationUnitOrNamespaceDeclaration(this' syntaxNode' newMembers' options' cancellationToken));                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsPrivateInterfaceImplementation,The following switch statement is missing a default case: switch (d.Kind())                  {                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)d).WithExplicitInterfaceSpecifier(specifier);                      case SyntaxKind.PropertyDeclaration:                          return ((PropertyDeclarationSyntax)d).WithExplicitInterfaceSpecifier(specifier);                      case SyntaxKind.IndexerDeclaration:                          return ((IndexerDeclarationSyntax)d).WithExplicitInterfaceSpecifier(specifier);                      case SyntaxKind.EventDeclaration:                          return ((EventDeclarationSyntax)d).WithExplicitInterfaceSpecifier(specifier);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithBodies,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.MethodDeclaration:                      var method = (MethodDeclarationSyntax)declaration;                      return (method.Body == null) ? method.WithSemicolonToken(default(SyntaxToken)).WithBody(CreateBlock(null)) : method;                  case SyntaxKind.OperatorDeclaration:                      var op = (OperatorDeclarationSyntax)declaration;                      return op.Body == null ? op.WithSemicolonToken(default(SyntaxToken)).WithBody(CreateBlock(null)) : op;                  case SyntaxKind.ConversionOperatorDeclaration:                      var cop = (ConversionOperatorDeclarationSyntax)declaration;                      return cop.Body == null ? cop.WithSemicolonToken(default(SyntaxToken)).WithBody(CreateBlock(null)) : cop;                  case SyntaxKind.PropertyDeclaration:                      var prop = (PropertyDeclarationSyntax)declaration;                      return prop.WithAccessorList(WithBodies(prop.AccessorList));                  case SyntaxKind.IndexerDeclaration:                      var ind = (IndexerDeclarationSyntax)declaration;                      return ind.WithAccessorList(WithBodies(ind.AccessorList));                  case SyntaxKind.EventDeclaration:                      var ev = (EventDeclarationSyntax)declaration;                      return ev.WithAccessorList(WithBodies(ev.AccessorList));              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithoutBodies,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.MethodDeclaration:                      var method = (MethodDeclarationSyntax)declaration;                      return (method.Body != null) ? method.WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)).WithBody(null) : method;                  case SyntaxKind.OperatorDeclaration:                      var op = (OperatorDeclarationSyntax)declaration;                      return op.Body != null ? op.WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)).WithBody(null) : op;                  case SyntaxKind.ConversionOperatorDeclaration:                      var cop = (ConversionOperatorDeclarationSyntax)declaration;                      return cop.Body == null ? cop.WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)).WithBody(null) : cop;                  case SyntaxKind.PropertyDeclaration:                      var prop = (PropertyDeclarationSyntax)declaration;                      return prop.WithAccessorList(WithoutBodies(prop.AccessorList));                  case SyntaxKind.IndexerDeclaration:                      var ind = (IndexerDeclarationSyntax)declaration;                      return ind.WithAccessorList(WithoutBodies(ind.AccessorList));                  case SyntaxKind.EventDeclaration:                      var ev = (EventDeclarationSyntax)declaration;                      return ev.WithAccessorList(WithoutBodies(ev.AccessorList));              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsClassMember,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ConstructorDeclaration:                      node = ((ConstructorDeclarationSyntax)node).WithIdentifier(className.ToIdentifierToken());                      break;                    case SyntaxKind.VariableDeclaration:                  case SyntaxKind.VariableDeclarator:                      node = this.AsIsolatedDeclaration(node);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsEnumMember,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.IdentifierName:                      var id = (IdentifierNameSyntax)node;                      return (EnumMemberDeclarationSyntax)EnumMember(id.Identifier.ToString()' null);                    case SyntaxKind.FieldDeclaration:                      var fd = (FieldDeclarationSyntax)node;                      if (fd.Declaration.Variables.Count == 1)                      {                          var vd = fd.Declaration.Variables[0];                          return (EnumMemberDeclarationSyntax)EnumMember(vd.Identifier.ToString()' vd.Initializer);                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetAttributeArguments,The following switch statement is missing a default case: switch (attributeDeclaration.Kind())              {                  case SyntaxKind.AttributeList:                      var list = (AttributeListSyntax)attributeDeclaration;                      if (list.Attributes.Count == 1)                      {                          return GetAttributeArguments(list.Attributes[0]);                      }                      break;                  case SyntaxKind.Attribute:                      var attr = (AttributeSyntax)attributeDeclaration;                      if (attr.ArgumentList != null)                      {                          return attr.ArgumentList.Arguments;                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetAttributeArgumentList,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.AttributeList:                      var list = (AttributeListSyntax)declaration;                      if (list.Attributes.Count == 1)                      {                          return list.Attributes[0].ArgumentList;                      }                      break;                  case SyntaxKind.Attribute:                      var attr = (AttributeSyntax)declaration;                      return attr.ArgumentList;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithAttributeArgumentList,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.AttributeList:                      var list = (AttributeListSyntax)declaration;                      if (list.Attributes.Count == 1)                      {                          return ReplaceWithTrivia(declaration' list.Attributes[0]' list.Attributes[0].WithArgumentList(argList));                      }                      break;                  case SyntaxKind.Attribute:                      var attr = (AttributeSyntax)declaration;                      return attr.WithArgumentList(argList);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetModifierTokens,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.EnumDeclaration:                      return ((EnumDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.DelegateDeclaration:                      return ((DelegateDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.MethodDeclaration:                      return ((MethodDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.OperatorDeclaration:                      return ((OperatorDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.ConversionOperatorDeclaration:                      return ((ConversionOperatorDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.ConstructorDeclaration:                      return ((ConstructorDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.DestructorDeclaration:                      return ((DestructorDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.FieldDeclaration:                      return ((FieldDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.PropertyDeclaration:                      return ((PropertyDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.IndexerDeclaration:                      return ((IndexerDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.EventFieldDeclaration:                      return ((EventFieldDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.EventDeclaration:                      return ((EventDeclarationSyntax)declaration).Modifiers;                  case SyntaxKind.Parameter:                      return ((ParameterSyntax)declaration).Modifiers;                  case SyntaxKind.LocalDeclarationStatement:                      return ((LocalDeclarationStatementSyntax)declaration).Modifiers;                  case SyntaxKind.VariableDeclaration:                  case SyntaxKind.VariableDeclarator:                      if (declaration.Parent != null)                      {                          return GetModifierTokens(declaration.Parent);                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsModifierList,The following switch statement is missing a default case: switch (accessibility)              {                  case Accessibility.Internal:                      list = list.Add(SyntaxFactory.Token(SyntaxKind.InternalKeyword));                      break;                  case Accessibility.Public:                      list = list.Add(SyntaxFactory.Token(SyntaxKind.PublicKeyword));                      break;                  case Accessibility.Private:                      list = list.Add(SyntaxFactory.Token(SyntaxKind.PrivateKeyword));                      break;                  case Accessibility.Protected:                      list = list.Add(SyntaxFactory.Token(SyntaxKind.ProtectedKeyword));                      break;                  case Accessibility.ProtectedOrInternal:                      list = list.Add(SyntaxFactory.Token(SyntaxKind.InternalKeyword))                                 .Add(SyntaxFactory.Token(SyntaxKind.ProtectedKeyword));                      break;                  case Accessibility.NotApplicable:                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetAccessibilityAndModifiers,The following switch statement is missing a default case: switch (token.Kind())                  {                      case SyntaxKind.PublicKeyword:                          accessibility = Accessibility.Public;                          break;                        case SyntaxKind.PrivateKeyword:                          accessibility = Accessibility.Private;                          break;                        case SyntaxKind.InternalKeyword:                          if (accessibility == Accessibility.Protected)                          {                              accessibility = Accessibility.ProtectedOrInternal;                          }                          else                          {                              accessibility = Accessibility.Internal;                          }                            break;                        case SyntaxKind.ProtectedKeyword:                          if (accessibility == Accessibility.Internal)                          {                              accessibility = Accessibility.ProtectedOrInternal;                          }                          else                          {                              accessibility = Accessibility.Protected;                          }                            break;                        case SyntaxKind.AbstractKeyword:                          modifiers = modifiers | DeclarationModifiers.Abstract;                          break;                        case SyntaxKind.NewKeyword:                          modifiers = modifiers | DeclarationModifiers.New;                          break;                        case SyntaxKind.OverrideKeyword:                          modifiers = modifiers | DeclarationModifiers.Override;                          break;                        case SyntaxKind.VirtualKeyword:                          modifiers = modifiers | DeclarationModifiers.Virtual;                          break;                        case SyntaxKind.StaticKeyword:                          modifiers = modifiers | DeclarationModifiers.Static;                          break;                        case SyntaxKind.AsyncKeyword:                          modifiers = modifiers | DeclarationModifiers.Async;                          break;                        case SyntaxKind.ConstKeyword:                          modifiers = modifiers | DeclarationModifiers.Const;                          break;                        case SyntaxKind.ReadOnlyKeyword:                          modifiers = modifiers | DeclarationModifiers.ReadOnly;                          break;                        case SyntaxKind.SealedKeyword:                          modifiers = modifiers | DeclarationModifiers.Sealed;                          break;                        case SyntaxKind.UnsafeKeyword:                          modifiers = modifiers | DeclarationModifiers.Unsafe;                          break;                        case SyntaxKind.PartialKeyword:                          modifiers = modifiers | DeclarationModifiers.Partial;                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetDeclarationKind,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return DeclarationKind.Class;                  case SyntaxKind.StructDeclaration:                      return DeclarationKind.Struct;                  case SyntaxKind.InterfaceDeclaration:                      return DeclarationKind.Interface;                  case SyntaxKind.EnumDeclaration:                      return DeclarationKind.Enum;                  case SyntaxKind.DelegateDeclaration:                      return DeclarationKind.Delegate;                    case SyntaxKind.MethodDeclaration:                      return DeclarationKind.Method;                  case SyntaxKind.OperatorDeclaration:                      return DeclarationKind.Operator;                  case SyntaxKind.ConversionOperatorDeclaration:                      return DeclarationKind.ConversionOperator;                  case SyntaxKind.ConstructorDeclaration:                      return DeclarationKind.Constructor;                  case SyntaxKind.DestructorDeclaration:                      return DeclarationKind.Destructor;                    case SyntaxKind.PropertyDeclaration:                      return DeclarationKind.Property;                  case SyntaxKind.IndexerDeclaration:                      return DeclarationKind.Indexer;                  case SyntaxKind.EventDeclaration:                      return DeclarationKind.CustomEvent;                  case SyntaxKind.EnumMemberDeclaration:                      return DeclarationKind.EnumMember;                  case SyntaxKind.CompilationUnit:                      return DeclarationKind.CompilationUnit;                  case SyntaxKind.NamespaceDeclaration:                      return DeclarationKind.Namespace;                  case SyntaxKind.UsingDirective:                      return DeclarationKind.NamespaceImport;                  case SyntaxKind.Parameter:                      return DeclarationKind.Parameter;                    case SyntaxKind.ParenthesizedLambdaExpression:                  case SyntaxKind.SimpleLambdaExpression:                      return DeclarationKind.LambdaExpression;                    case SyntaxKind.FieldDeclaration:                      var fd = (FieldDeclarationSyntax)declaration;                      if (fd.Declaration != null && fd.Declaration.Variables.Count == 1)                      {                          // this node is considered the declaration if it contains only one variable.                          return DeclarationKind.Field;                      }                      else                      {                          return DeclarationKind.None;                      }                    case SyntaxKind.EventFieldDeclaration:                      var ef = (EventFieldDeclarationSyntax)declaration;                      if (ef.Declaration != null && ef.Declaration.Variables.Count == 1)                      {                          // this node is considered the declaration if it contains only one variable.                          return DeclarationKind.Event;                      }                      else                      {                          return DeclarationKind.None;                      }                    case SyntaxKind.LocalDeclarationStatement:                      var ld = (LocalDeclarationStatementSyntax)declaration;                      if (ld.Declaration != null && ld.Declaration.Variables.Count == 1)                      {                          // this node is considered the declaration if it contains only one variable.                          return DeclarationKind.Variable;                      }                      else                      {                          return DeclarationKind.None;                      }                    case SyntaxKind.VariableDeclaration:                      {                          var vd = (VariableDeclarationSyntax)declaration;                          if (vd.Variables.Count == 1 && vd.Parent == null)                          {                              // this node is the declaration if it contains only one variable and has no parent.                              return DeclarationKind.Variable;                          }                          else                          {                              return DeclarationKind.None;                          }                      }                    case SyntaxKind.VariableDeclarator:                      {                          var vd = declaration.Parent as VariableDeclarationSyntax;                            // this node is considered the declaration if it is one among many' or it has no parent                          if (vd == null || vd.Variables.Count > 1)                          {                              if (ParentIsFieldDeclaration(vd))                              {                                  return DeclarationKind.Field;                              }                              else if (ParentIsEventFieldDeclaration(vd))                              {                                  return DeclarationKind.Event;                              }                              else                              {                                  return DeclarationKind.Variable;                              }                          }                          break;                      }                    case SyntaxKind.AttributeList:                      var list = (AttributeListSyntax)declaration;                      if (list.Attributes.Count == 1)                      {                          return DeclarationKind.Attribute;                      }                      break;                    case SyntaxKind.Attribute:                      var parentList = declaration.Parent as AttributeListSyntax;                      if (parentList == null || parentList.Attributes.Count > 1)                      {                          return DeclarationKind.Attribute;                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetName,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.EnumDeclaration:                      return ((EnumDeclarationSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.DelegateDeclaration:                      return ((DelegateDeclarationSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.MethodDeclaration:                      return ((MethodDeclarationSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.FieldDeclaration:                      return GetName(((FieldDeclarationSyntax)declaration).Declaration);                  case SyntaxKind.PropertyDeclaration:                      return ((PropertyDeclarationSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.EnumMemberDeclaration:                      return ((EnumMemberDeclarationSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.EventFieldDeclaration:                      return GetName(((EventFieldDeclarationSyntax)declaration).Declaration);                  case SyntaxKind.EventDeclaration:                      return ((EventDeclarationSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.NamespaceDeclaration:                      return ((NamespaceDeclarationSyntax)declaration).Name.ToString();                  case SyntaxKind.UsingDirective:                      return ((UsingDirectiveSyntax)declaration).Name.ToString();                  case SyntaxKind.Parameter:                      return ((ParameterSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.LocalDeclarationStatement:                      return GetName(((LocalDeclarationStatementSyntax)declaration).Declaration);                  case SyntaxKind.VariableDeclaration:                      var vd = ((VariableDeclarationSyntax)declaration);                      if (vd.Variables.Count == 1)                      {                          return vd.Variables[0].Identifier.ValueText;                      }                      break;                  case SyntaxKind.VariableDeclarator:                      return ((VariableDeclaratorSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.TypeParameter:                      return ((TypeParameterSyntax)declaration).Identifier.ValueText;                  case SyntaxKind.AttributeList:                      var al = (AttributeListSyntax)declaration;                      if (al.Attributes.Count == 1)                      {                          return al.Attributes[0].Name.ToString();                      }                      break;                  case SyntaxKind.Attribute:                      return ((AttributeSyntax)declaration).Name.ToString();              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithNameInternal,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ReplaceWithTrivia(declaration' ((ClassDeclarationSyntax)declaration).Identifier' id);                  case SyntaxKind.StructDeclaration:                      return ReplaceWithTrivia(declaration' ((StructDeclarationSyntax)declaration).Identifier' id);                  case SyntaxKind.InterfaceDeclaration:                      return ReplaceWithTrivia(declaration' ((InterfaceDeclarationSyntax)declaration).Identifier' id);                  case SyntaxKind.EnumDeclaration:                      return ReplaceWithTrivia(declaration' ((EnumDeclarationSyntax)declaration).Identifier' id);                  case SyntaxKind.DelegateDeclaration:                      return ReplaceWithTrivia(declaration' ((DelegateDeclarationSyntax)declaration).Identifier' id);                  case SyntaxKind.MethodDeclaration:                      return ReplaceWithTrivia(declaration' ((MethodDeclarationSyntax)declaration).Identifier' id);                  case SyntaxKind.FieldDeclaration:                      var fd = (FieldDeclarationSyntax)declaration;                      if (fd.Declaration.Variables.Count == 1)                      {                          return ReplaceWithTrivia(declaration' fd.Declaration.Variables[0].Identifier' id);                      }                      break;                  case SyntaxKind.PropertyDeclaration:                      return ReplaceWithTrivia(declaration' ((PropertyDeclarationSyntax)declaration).Identifier' id);                  case SyntaxKind.EnumMemberDeclaration:                      return ReplaceWithTrivia(declaration' ((EnumMemberDeclarationSyntax)declaration).Identifier' id);                  case SyntaxKind.EventFieldDeclaration:                      var efd = (EventFieldDeclarationSyntax)declaration;                      if (efd.Declaration.Variables.Count == 1)                      {                          return ReplaceWithTrivia(declaration' efd.Declaration.Variables[0].Identifier' id);                      }                      break;                  case SyntaxKind.EventDeclaration:                      return ReplaceWithTrivia(declaration' ((EventDeclarationSyntax)declaration).Identifier' id);                  case SyntaxKind.NamespaceDeclaration:                      return ReplaceWithTrivia(declaration' ((NamespaceDeclarationSyntax)declaration).Name' this.DottedName(name));                  case SyntaxKind.UsingDirective:                      return ReplaceWithTrivia(declaration' ((UsingDirectiveSyntax)declaration).Name' this.DottedName(name));                  case SyntaxKind.Parameter:                      return ReplaceWithTrivia(declaration' ((ParameterSyntax)declaration).Identifier' id);                  case SyntaxKind.LocalDeclarationStatement:                      var ld = (LocalDeclarationStatementSyntax)declaration;                      if (ld.Declaration.Variables.Count == 1)                      {                          return ReplaceWithTrivia(declaration' ld.Declaration.Variables[0].Identifier' id);                      }                      break;                  case SyntaxKind.TypeParameter:                      return ReplaceWithTrivia(declaration' ((TypeParameterSyntax)declaration).Identifier' id);                  case SyntaxKind.AttributeList:                      var al = (AttributeListSyntax)declaration;                      if (al.Attributes.Count == 1)                      {                          return ReplaceWithTrivia(declaration' al.Attributes[0].Name' this.DottedName(name));                      }                      break;                  case SyntaxKind.Attribute:                      return ReplaceWithTrivia(declaration' ((AttributeSyntax)declaration).Name' this.DottedName(name));                  case SyntaxKind.VariableDeclaration:                      var vd = (VariableDeclarationSyntax)declaration;                      if (vd.Variables.Count == 1)                      {                          return ReplaceWithTrivia(declaration' vd.Variables[0].Identifier' id);                      }                      break;                  case SyntaxKind.VariableDeclarator:                      return ReplaceWithTrivia(declaration' ((VariableDeclaratorSyntax)declaration).Identifier' id);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetType,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.DelegateDeclaration:                      return NotVoid(((DelegateDeclarationSyntax)declaration).ReturnType);                  case SyntaxKind.MethodDeclaration:                      return NotVoid(((MethodDeclarationSyntax)declaration).ReturnType);                  case SyntaxKind.FieldDeclaration:                      return ((FieldDeclarationSyntax)declaration).Declaration.Type;                  case SyntaxKind.PropertyDeclaration:                      return ((PropertyDeclarationSyntax)declaration).Type;                  case SyntaxKind.IndexerDeclaration:                      return ((IndexerDeclarationSyntax)declaration).Type;                  case SyntaxKind.EventFieldDeclaration:                      return ((EventFieldDeclarationSyntax)declaration).Declaration.Type;                  case SyntaxKind.EventDeclaration:                      return ((EventDeclarationSyntax)declaration).Type;                  case SyntaxKind.Parameter:                      return ((ParameterSyntax)declaration).Type;                  case SyntaxKind.LocalDeclarationStatement:                      return ((LocalDeclarationStatementSyntax)declaration).Declaration.Type;                  case SyntaxKind.VariableDeclaration:                      return ((VariableDeclarationSyntax)declaration).Type;                  case SyntaxKind.VariableDeclarator:                      if (declaration.Parent != null)                      {                          return GetType(declaration.Parent);                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithTypeInternal,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.DelegateDeclaration:                      return ((DelegateDeclarationSyntax)declaration).WithReturnType((TypeSyntax)type);                  case SyntaxKind.MethodDeclaration:                      return ((MethodDeclarationSyntax)declaration).WithReturnType((TypeSyntax)type);                  case SyntaxKind.FieldDeclaration:                      return ((FieldDeclarationSyntax)declaration).WithDeclaration(((FieldDeclarationSyntax)declaration).Declaration.WithType((TypeSyntax)type));                  case SyntaxKind.PropertyDeclaration:                      return ((PropertyDeclarationSyntax)declaration).WithType((TypeSyntax)type);                  case SyntaxKind.IndexerDeclaration:                      return ((IndexerDeclarationSyntax)declaration).WithType((TypeSyntax)type);                  case SyntaxKind.EventFieldDeclaration:                      return ((EventFieldDeclarationSyntax)declaration).WithDeclaration(((EventFieldDeclarationSyntax)declaration).Declaration.WithType((TypeSyntax)type));                  case SyntaxKind.EventDeclaration:                      return ((EventDeclarationSyntax)declaration).WithType((TypeSyntax)type);                  case SyntaxKind.Parameter:                      return ((ParameterSyntax)declaration).WithType((TypeSyntax)type);                  case SyntaxKind.LocalDeclarationStatement:                      return ((LocalDeclarationStatementSyntax)declaration).WithDeclaration(((LocalDeclarationStatementSyntax)declaration).Declaration.WithType((TypeSyntax)type));                  case SyntaxKind.VariableDeclaration:                      return ((VariableDeclarationSyntax)declaration).WithType((TypeSyntax)type);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsIsolatedDeclaration,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.VariableDeclaration:                      var vd = (VariableDeclarationSyntax)declaration;                      if (vd.Parent != null && vd.Variables.Count == 1)                      {                          return AsIsolatedDeclaration(vd.Parent);                      }                      break;                    case SyntaxKind.VariableDeclarator:                      var v = (VariableDeclaratorSyntax)declaration;                      if (v.Parent != null && v.Parent.Parent != null)                      {                          return this.ClearTrivia(this.WithVariable(v.Parent.Parent' v));                      }                      break;                    case SyntaxKind.Attribute:                      var attr = (AttributeSyntax)declaration;                      if (attr.Parent != null)                      {                          var attrList = (AttributeListSyntax)attr.Parent;                          return attrList.WithAttributes(SyntaxFactory.SingletonSeparatedList(attr)).WithTarget(null);                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetFullDeclaration,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.VariableDeclaration:                      var vd = (VariableDeclarationSyntax)declaration;                      if (ParentIsFieldDeclaration(vd)                          || ParentIsEventFieldDeclaration(vd)                          || ParentIsLocalDeclarationStatement(vd))                      {                          return vd.Parent;                      }                      else                      {                          return vd;                      }                    case SyntaxKind.VariableDeclarator:                  case SyntaxKind.Attribute:                      if (declaration.Parent != null)                      {                          return GetFullDeclaration(declaration.Parent);                      }                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AsNodeLike,The following switch statement is missing a default case: switch (GetDeclarationKind(existingNode))              {                  case DeclarationKind.Class:                  case DeclarationKind.Interface:                  case DeclarationKind.Struct:                  case DeclarationKind.Enum:                  case DeclarationKind.Namespace:                  case DeclarationKind.CompilationUnit:                      var container = this.GetDeclaration(existingNode.Parent);                      if (container != null)                      {                          return this.AsMemberOf(container' newNode);                      }                      break;                    case DeclarationKind.Attribute:                      return this.AsAttributeList(newNode);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,GetEqualsValue,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.FieldDeclaration:                      var fd = ((FieldDeclarationSyntax)declaration);                      if (fd.Declaration.Variables.Count == 1)                      {                          return fd.Declaration.Variables[0].Initializer;                      }                      break;                  case SyntaxKind.LocalDeclarationStatement:                      var ld = ((LocalDeclarationStatementSyntax)declaration);                      if (ld.Declaration.Variables.Count == 1)                      {                          return ld.Declaration.Variables[0].Initializer;                      }                      break;                  case SyntaxKind.VariableDeclaration:                      var vd = ((VariableDeclarationSyntax)declaration);                      if (vd.Variables.Count == 1)                      {                          return vd.Variables[0].Initializer;                      }                      break;                  case SyntaxKind.VariableDeclarator:                      return ((VariableDeclaratorSyntax)declaration).Initializer;                  case SyntaxKind.Parameter:                      return ((ParameterSyntax)declaration).Default;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,WithEqualsValue,The following switch statement is missing a default case: switch (declaration.Kind())              {                  case SyntaxKind.FieldDeclaration:                      var fd = ((FieldDeclarationSyntax)declaration);                      if (fd.Declaration.Variables.Count == 1)                      {                          return ReplaceWithTrivia(declaration' fd.Declaration.Variables[0]' fd.Declaration.Variables[0].WithInitializer(eq));                      }                      break;                  case SyntaxKind.LocalDeclarationStatement:                      var ld = ((LocalDeclarationStatementSyntax)declaration);                      if (ld.Declaration.Variables.Count == 1)                      {                          return ReplaceWithTrivia(declaration' ld.Declaration.Variables[0]' ld.Declaration.Variables[0].WithInitializer(eq));                      }                      break;                  case SyntaxKind.VariableDeclaration:                      var vd = ((VariableDeclarationSyntax)declaration);                      if (vd.Variables.Count == 1)                      {                          return ReplaceWithTrivia(declaration' vd.Variables[0]' vd.Variables[0].WithInitializer(eq));                      }                      break;                  case SyntaxKind.VariableDeclarator:                      return ((VariableDeclaratorSyntax)declaration).WithInitializer(eq);                  case SyntaxKind.Parameter:                      return ((ParameterSyntax)declaration).WithDefault(eq);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AreInlineReplaceableSubDeclarations,The following switch statement is missing a default case: switch (kind)                  {                      case SyntaxKind.Attribute:                      case SyntaxKind.VariableDeclarator:                          return AreSimilarExceptForSubDeclarations(decl1.Parent' decl2.Parent);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,AreSimilarExceptForSubDeclarations,The following switch statement is missing a default case: switch (kind)                  {                      case SyntaxKind.FieldDeclaration:                          var fd1 = (FieldDeclarationSyntax)decl1;                          var fd2 = (FieldDeclarationSyntax)decl2;                          return SyntaxFactory.AreEquivalent(fd1.Modifiers' fd2.Modifiers)                              && SyntaxFactory.AreEquivalent(fd1.AttributeLists' fd2.AttributeLists);                        case SyntaxKind.EventFieldDeclaration:                          var efd1 = (EventFieldDeclarationSyntax)decl1;                          var efd2 = (EventFieldDeclarationSyntax)decl2;                          return SyntaxFactory.AreEquivalent(efd1.Modifiers' efd2.Modifiers)                              && SyntaxFactory.AreEquivalent(efd1.AttributeLists' efd2.AttributeLists);                        case SyntaxKind.LocalDeclarationStatement:                          var ld1 = (LocalDeclarationStatementSyntax)decl1;                          var ld2 = (LocalDeclarationStatementSyntax)decl2;                          return SyntaxFactory.AreEquivalent(ld1.Modifiers' ld2.Modifiers);                        case SyntaxKind.AttributeList:                          // don't compare targets' since aren't part of the abstraction                          return true;                        case SyntaxKind.VariableDeclaration:                          var vd1 = (VariableDeclarationSyntax)decl1;                          var vd2 = (VariableDeclarationSyntax)decl2;                          return SyntaxFactory.AreEquivalent(vd1.Type' vd2.Type) && AreSimilarExceptForSubDeclarations(vd1.Parent' vd2.Parent);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,RemoveNodeInternal,The following switch statement is missing a default case: switch (parent.Kind())                          {                              case SyntaxKind.SimpleBaseType:                                  return RemoveNodeInternal(root' parent);                          }
Missing Default,Microsoft.CodeAnalysis.CSharp.CodeGeneration,CSharpSyntaxGenerator,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\CodeGeneration\CSharpSyntaxGenerator.cs,DefaultExpression,The following switch statement is missing a default case: switch (type.SpecialType)              {                  case SpecialType.System_Boolean:                      return SyntaxFactory.LiteralExpression(SyntaxKind.FalseLiteralExpression);                  case SpecialType.System_SByte:                  case SpecialType.System_Byte:                  case SpecialType.System_Int16:                  case SpecialType.System_UInt16:                  case SpecialType.System_Int32:                  case SpecialType.System_UInt32:                  case SpecialType.System_Int64:                  case SpecialType.System_UInt64:                  case SpecialType.System_Decimal:                  case SpecialType.System_Single:                  case SpecialType.System_Double:                      return SyntaxFactory.LiteralExpression(                          SyntaxKind.NumericLiteralExpression' SyntaxFactory.Literal("0"' 0));              }
Missing Default,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,GetPredefinedOperator,The following switch statement is missing a default case: switch ((SyntaxKind)token.RawKind)              {                  case SyntaxKind.PlusToken:                  case SyntaxKind.PlusEqualsToken:                      return PredefinedOperator.Addition;                    case SyntaxKind.MinusToken:                  case SyntaxKind.MinusEqualsToken:                      return PredefinedOperator.Subtraction;                    case SyntaxKind.AmpersandToken:                  case SyntaxKind.AmpersandEqualsToken:                      return PredefinedOperator.BitwiseAnd;                    case SyntaxKind.BarToken:                  case SyntaxKind.BarEqualsToken:                      return PredefinedOperator.BitwiseOr;                    case SyntaxKind.MinusMinusToken:                      return PredefinedOperator.Decrement;                    case SyntaxKind.PlusPlusToken:                      return PredefinedOperator.Increment;                    case SyntaxKind.SlashToken:                  case SyntaxKind.SlashEqualsToken:                      return PredefinedOperator.Division;                    case SyntaxKind.EqualsEqualsToken:                      return PredefinedOperator.Equality;                    case SyntaxKind.CaretToken:                  case SyntaxKind.CaretEqualsToken:                      return PredefinedOperator.ExclusiveOr;                    case SyntaxKind.GreaterThanToken:                      return PredefinedOperator.GreaterThan;                    case SyntaxKind.GreaterThanEqualsToken:                      return PredefinedOperator.GreaterThanOrEqual;                    case SyntaxKind.ExclamationEqualsToken:                      return PredefinedOperator.Inequality;                    case SyntaxKind.LessThanLessThanToken:                  case SyntaxKind.LessThanLessThanEqualsToken:                      return PredefinedOperator.LeftShift;                    case SyntaxKind.LessThanEqualsToken:                      return PredefinedOperator.LessThanOrEqual;                    case SyntaxKind.AsteriskToken:                  case SyntaxKind.AsteriskEqualsToken:                      return PredefinedOperator.Multiplication;                    case SyntaxKind.PercentToken:                  case SyntaxKind.PercentEqualsToken:                      return PredefinedOperator.Modulus;                    case SyntaxKind.ExclamationToken:                  case SyntaxKind.TildeToken:                      return PredefinedOperator.Complement;                    case SyntaxKind.GreaterThanGreaterThanToken:                  case SyntaxKind.GreaterThanGreaterThanEqualsToken:                      return PredefinedOperator.RightShift;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,IsLiteral,The following switch statement is missing a default case: switch (token.Kind())              {                  case SyntaxKind.NumericLiteralToken:                  case SyntaxKind.CharacterLiteralToken:                  case SyntaxKind.StringLiteralToken:                  case SyntaxKind.NullKeyword:                  case SyntaxKind.TrueKeyword:                  case SyntaxKind.FalseKeyword:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,IsBindableToken,The following switch statement is missing a default case: switch ((SyntaxKind)token.RawKind)                  {                      case SyntaxKind.DelegateKeyword:                      case SyntaxKind.VoidKeyword:                          return false;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,CSharpSyntaxFactsService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpSyntaxFactsService.cs,TryGetDeclaredSymbolInfo,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ClassDeclaration:                      var classDecl = (ClassDeclarationSyntax)node;                      declaredSymbolInfo = new DeclaredSymbolInfo(classDecl.Identifier.ValueText'                          GetContainerDisplayName(node.Parent)'                           GetFullyQualifiedContainerName(node.Parent)'                          DeclaredSymbolInfoKind.Class' classDecl.Identifier.Span);                      return true;                  case SyntaxKind.ConstructorDeclaration:                      var ctorDecl = (ConstructorDeclarationSyntax)node;                      declaredSymbolInfo = new DeclaredSymbolInfo(                          ctorDecl.Identifier.ValueText'                          GetContainerDisplayName(node.Parent)'                          GetFullyQualifiedContainerName(node.Parent)'                          DeclaredSymbolInfoKind.Constructor'                          ctorDecl.Identifier.Span'                          parameterCount: (ushort)(ctorDecl.ParameterList?.Parameters.Count ?? 0));                      return true;                  case SyntaxKind.DelegateDeclaration:                      var delegateDecl = (DelegateDeclarationSyntax)node;                      declaredSymbolInfo = new DeclaredSymbolInfo(delegateDecl.Identifier.ValueText'                          GetContainerDisplayName(node.Parent)'                          GetFullyQualifiedContainerName(node.Parent)'                          DeclaredSymbolInfoKind.Delegate' delegateDecl.Identifier.Span);                      return true;                  case SyntaxKind.EnumDeclaration:                      var enumDecl = (EnumDeclarationSyntax)node;                      declaredSymbolInfo = new DeclaredSymbolInfo(enumDecl.Identifier.ValueText'                          GetContainerDisplayName(node.Parent)'                          GetFullyQualifiedContainerName(node.Parent)'                          DeclaredSymbolInfoKind.Enum' enumDecl.Identifier.Span);                      return true;                  case SyntaxKind.EnumMemberDeclaration:                      var enumMember = (EnumMemberDeclarationSyntax)node;                      declaredSymbolInfo = new DeclaredSymbolInfo(enumMember.Identifier.ValueText'                          GetContainerDisplayName(node.Parent)'                          GetFullyQualifiedContainerName(node.Parent)'                           DeclaredSymbolInfoKind.EnumMember' enumMember.Identifier.Span);                      return true;                  case SyntaxKind.EventDeclaration:                      var eventDecl = (EventDeclarationSyntax)node;                      declaredSymbolInfo = new DeclaredSymbolInfo(ExpandExplicitInterfaceName(eventDecl.Identifier.ValueText' eventDecl.ExplicitInterfaceSpecifier)'                          GetContainerDisplayName(node.Parent)'                          GetFullyQualifiedContainerName(node.Parent)'                          DeclaredSymbolInfoKind.Event' eventDecl.Identifier.Span);                      return true;                  case SyntaxKind.IndexerDeclaration:                      var indexerDecl = (IndexerDeclarationSyntax)node;                      declaredSymbolInfo = new DeclaredSymbolInfo(WellKnownMemberNames.Indexer'                          GetContainerDisplayName(node.Parent)'                          GetFullyQualifiedContainerName(node.Parent)'                           DeclaredSymbolInfoKind.Indexer' indexerDecl.ThisKeyword.Span);                      return true;                  case SyntaxKind.InterfaceDeclaration:                      var interfaceDecl = (InterfaceDeclarationSyntax)node;                      declaredSymbolInfo = new DeclaredSymbolInfo(interfaceDecl.Identifier.ValueText'                          GetContainerDisplayName(node.Parent)'                          GetFullyQualifiedContainerName(node.Parent)'                          DeclaredSymbolInfoKind.Interface' interfaceDecl.Identifier.Span);                      return true;                  case SyntaxKind.MethodDeclaration:                      var method = (MethodDeclarationSyntax)node;                      declaredSymbolInfo = new DeclaredSymbolInfo(                          ExpandExplicitInterfaceName(method.Identifier.ValueText' method.ExplicitInterfaceSpecifier)'                          GetContainerDisplayName(node.Parent)'                          GetFullyQualifiedContainerName(node.Parent)'                          DeclaredSymbolInfoKind.Method'                          method.Identifier.Span'                          parameterCount: (ushort)(method.ParameterList?.Parameters.Count ?? 0)'                          typeParameterCount: (ushort)(method.TypeParameterList?.Parameters.Count ?? 0));                      return true;                  case SyntaxKind.PropertyDeclaration:                      var property = (PropertyDeclarationSyntax)node;                      declaredSymbolInfo = new DeclaredSymbolInfo(ExpandExplicitInterfaceName(property.Identifier.ValueText' property.ExplicitInterfaceSpecifier)'                          GetContainerDisplayName(node.Parent)'                          GetFullyQualifiedContainerName(node.Parent)'                          DeclaredSymbolInfoKind.Property' property.Identifier.Span);                      return true;                  case SyntaxKind.StructDeclaration:                      var structDecl = (StructDeclarationSyntax)node;                      declaredSymbolInfo = new DeclaredSymbolInfo(structDecl.Identifier.ValueText'                          GetContainerDisplayName(node.Parent)'                          GetFullyQualifiedContainerName(node.Parent)'                           DeclaredSymbolInfoKind.Struct' structDecl.Identifier.Span);                      return true;                  case SyntaxKind.VariableDeclarator:                      // could either be part of a field declaration or an event field declaration                      var variableDeclarator = (VariableDeclaratorSyntax)node;                      var variableDeclaration = variableDeclarator.Parent as VariableDeclarationSyntax;                      var fieldDeclaration = variableDeclaration?.Parent as BaseFieldDeclarationSyntax;                      if (fieldDeclaration != null)                      {                          var kind = fieldDeclaration is EventFieldDeclarationSyntax                              ? DeclaredSymbolInfoKind.Event                              : fieldDeclaration.Modifiers.Any(m => m.Kind() == SyntaxKind.ConstKeyword)                                  ? DeclaredSymbolInfoKind.Constant                                  : DeclaredSymbolInfoKind.Field;                            declaredSymbolInfo = new DeclaredSymbolInfo(variableDeclarator.Identifier.ValueText'                          GetContainerDisplayName(fieldDeclaration.Parent)'                          GetFullyQualifiedContainerName(fieldDeclaration.Parent)'                           kind' variableDeclarator.Identifier.Span);                          return true;                      }                        break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInBinaryOrAssignmentExpression,The following switch statement is missing a default case: switch (operatorToken.Kind())                  {                      case SyntaxKind.LessThanLessThanToken:                      case SyntaxKind.GreaterThanGreaterThanToken:                      case SyntaxKind.LessThanLessThanEqualsToken:                      case SyntaxKind.GreaterThanGreaterThanEqualsToken:                            if (onRightOfToken)                          {                              // x << Foo()' x >> Foo()' x <<= Foo()' x >>= Foo()                              return SpecializedCollections.SingletonEnumerable(this.Compilation.GetSpecialType(SpecialType.System_Int32));                          }                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInBinaryOrAssignmentExpression,The following switch statement is missing a default case: switch (operatorToken.Kind())                  {                      case SyntaxKind.BarToken:                      case SyntaxKind.CaretToken:                      case SyntaxKind.AmpersandToken:                      case SyntaxKind.LessThanToken:                      case SyntaxKind.LessThanEqualsToken:                      case SyntaxKind.GreaterThanToken:                      case SyntaxKind.GreaterThanEqualsToken:                      case SyntaxKind.PlusToken:                      case SyntaxKind.MinusToken:                      case SyntaxKind.AsteriskToken:                      case SyntaxKind.SlashToken:                      case SyntaxKind.PercentToken:                      case SyntaxKind.CaretEqualsToken:                      case SyntaxKind.PlusEqualsToken:                      case SyntaxKind.MinusEqualsToken:                      case SyntaxKind.AsteriskEqualsToken:                      case SyntaxKind.SlashEqualsToken:                      case SyntaxKind.PercentEqualsToken:                      case SyntaxKind.LessThanLessThanToken:                      case SyntaxKind.GreaterThanGreaterThanToken:                      case SyntaxKind.LessThanLessThanEqualsToken:                      case SyntaxKind.GreaterThanGreaterThanEqualsToken:                          return SpecializedCollections.SingletonEnumerable(this.Compilation.GetSpecialType(SpecialType.System_Int32));                        case SyntaxKind.BarEqualsToken:                      case SyntaxKind.AmpersandEqualsToken:                          // NOTE(cyrusn): |= and &= can be used for both ints and bools  However' in the                          // case where there isn't enough information to determine which the user wanted'                          // i'm just defaulting to bool based on personal preference.                          return SpecializedCollections.SingletonEnumerable(this.Compilation.GetSpecialType(SpecialType.System_Boolean));                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInPostfixUnaryExpression,The following switch statement is missing a default case: switch (postfixUnaryExpressionSyntax.Kind())                  {                      case SyntaxKind.PostDecrementExpression:                      case SyntaxKind.PostIncrementExpression:                          return SpecializedCollections.SingletonEnumerable(this.Compilation.GetSpecialType(SpecialType.System_Int32));                  }
Missing Default,Microsoft.CodeAnalysis.CSharp,TypeInferrer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\LanguageServices\CSharpTypeInferenceService.TypeInferrer.cs,InferTypeInPrefixUnaryExpression,The following switch statement is missing a default case: switch (prefixUnaryExpression.Kind())                  {                      case SyntaxKind.PreDecrementExpression:                      case SyntaxKind.PreIncrementExpression:                      case SyntaxKind.UnaryPlusExpression:                      case SyntaxKind.UnaryMinusExpression:                      case SyntaxKind.BitwiseNotExpression:                          // ++' --' +Foo()' -Foo()' ~Foo();                          return SpecializedCollections.SingletonEnumerable(this.Compilation.GetSpecialType(SpecialType.System_Int32));                        case SyntaxKind.LogicalNotExpression:                          // !Foo()                          return SpecializedCollections.SingletonEnumerable(this.Compilation.GetSpecialType(SpecialType.System_Boolean));                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,BaseArgumentListSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BaseArgumentListSyntaxExtensions.cs,GetOpenToken,The following switch statement is missing a default case: switch (node.Kind())                  {                      case SyntaxKind.ArgumentList:                          return ((ArgumentListSyntax)node).OpenParenToken;                      case SyntaxKind.BracketedArgumentList:                          return ((BracketedArgumentListSyntax)node).OpenBracketToken;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,BaseArgumentListSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BaseArgumentListSyntaxExtensions.cs,GetCloseToken,The following switch statement is missing a default case: switch (node.Kind())                  {                      case SyntaxKind.ArgumentList:                          return ((ArgumentListSyntax)node).CloseParenToken;                      case SyntaxKind.BracketedArgumentList:                          return ((BracketedArgumentListSyntax)node).CloseBracketToken;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,BaseParameterListSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BaseParameterListSyntaxExtensions.cs,WithParameters,The following switch statement is missing a default case: switch (parameterList.Kind())              {                  case SyntaxKind.BracketedParameterList:                      return ((BracketedParameterListSyntax)parameterList).WithParameters(parameters);                  case SyntaxKind.ParameterList:                      return ((ParameterListSyntax)parameterList).WithParameters(parameters);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,TryCreateSpanForVariableDeclaration,The following switch statement is missing a default case: switch (declaration.Parent.Kind())              {                  case SyntaxKind.LocalDeclarationStatement:                  case SyntaxKind.EventFieldDeclaration:                  case SyntaxKind.FieldDeclaration:                      // parent node will handle:                      return null;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,BreakpointSpans,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\BreakpointSpans.cs,IsBreakableExpression,The following switch statement is missing a default case: switch (parent.Kind())              {                  case SyntaxKind.ArrowExpressionClause:                      Debug.Assert(((ArrowExpressionClauseSyntax)parent).Expression == expression);                      return true;                    case SyntaxKind.SimpleLambdaExpression:                  case SyntaxKind.ParenthesizedLambdaExpression:                      Debug.Assert(((AnonymousFunctionExpressionSyntax)parent).Body == expression);                      return true;                    case SyntaxKind.ForStatement:                      var forStatement = (ForStatementSyntax)parent;                      return                          forStatement.Initializers.Contains(expression) ||                          forStatement.Condition == expression ||                          forStatement.Incrementors.Contains(expression);                    case SyntaxKind.ForEachStatement:                      var forEachStatement = (ForEachStatementSyntax)parent;                      return forEachStatement.Expression == expression;                    // Query clauses                  case SyntaxKind.FromClause:                      var fromClause = (FromClauseSyntax)parent;                        // We can break on the expression in a from clause' except for the first clause in a                      // query. For example:                       //   from c in LookupCustomers() // not here                       //   from o in LookupBarOrders() + LookupBazOrders() // but here                       //   group ... into y                      //   from d in SomeOtherExpression() // and after a continuation' too                        return fromClause.Expression == expression && fromClause.Parent is QueryBodySyntax;                    case SyntaxKind.JoinClause:                      var joinClause = (JoinClauseSyntax)parent;                        // We can break on the inner and outer key expressions' but not the                      // initializer expression. For example:                      //                      //  join a in alpha /* no */ on beta /* yes */ equals gamma /* yes */                      return joinClause.LeftExpression == expression || joinClause.RightExpression == expression;                    case SyntaxKind.LetClause:                      var letClause = (LetClauseSyntax)parent;                      return letClause.Expression == expression;                    case SyntaxKind.WhereClause:                      var whereClause = (WhereClauseSyntax)parent;                      return whereClause.Condition == expression;                    case SyntaxKind.AscendingOrdering:                  case SyntaxKind.DescendingOrdering:                      var ordering = (OrderingSyntax)parent;                      return ordering.Expression == expression;                    case SyntaxKind.SelectClause:                      var selectClause = (SelectClauseSyntax)parent;                      return selectClause.Expression == expression;                    case SyntaxKind.GroupClause:                      var groupClause = (GroupClauseSyntax)parent;                      return groupClause.GroupExpression == expression || groupClause.ByExpression == expression;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,DirectiveWalker,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\DirectiveSyntaxExtensions.DirectiveWalker.cs,VisitToken,The following switch statement is missing a default case: switch (directive.Kind())                      {                          case SyntaxKind.RegionDirectiveTrivia:                              HandleRegionDirective((DirectiveTriviaSyntax)directive.GetStructure());                              break;                          case SyntaxKind.IfDirectiveTrivia:                              HandleIfDirective((DirectiveTriviaSyntax)directive.GetStructure());                              break;                          case SyntaxKind.EndRegionDirectiveTrivia:                              HandleEndRegionDirective((DirectiveTriviaSyntax)directive.GetStructure());                              break;                          case SyntaxKind.EndIfDirectiveTrivia:                              HandleEndIfDirective((DirectiveTriviaSyntax)directive.GetStructure());                              break;                          case SyntaxKind.ElifDirectiveTrivia:                              HandleElifDirective((DirectiveTriviaSyntax)directive.GetStructure());                              break;                          case SyntaxKind.ElseDirectiveTrivia:                              HandleElseDirective((DirectiveTriviaSyntax)directive.GetStructure());                              break;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,IsWrittenTo,The following switch statement is missing a default case: switch (expression.Parent.Kind())                      {                          case SyntaxKind.PostIncrementExpression:                          case SyntaxKind.PreIncrementExpression:                          case SyntaxKind.PostDecrementExpression:                          case SyntaxKind.PreDecrementExpression:                              return true;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanReplace,The following switch statement is missing a default case: switch (symbol.Kind)              {                  case SymbolKind.Field:                  case SymbolKind.Local:                  case SymbolKind.Method:                  case SymbolKind.Parameter:                  case SymbolKind.Property:                  case SymbolKind.RangeVariable:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,CanReplaceWithLValue,The following switch statement is missing a default case: switch (expression.Parent.Kind())              {                  case SyntaxKind.InvocationExpression:                      // Technically' you could introduce an LValue for "Foo" in "Foo()" even if "Foo" binds                      // to a method.  (i.e. by assigning to a Func<...> type).  However' this is so contrived                      // and none of the features that use this extension consider this replaceable.                      if (expression.IsKind(SyntaxKind.IdentifierName) || expression is MemberAccessExpressionSyntax)                      {                          // If it looks like a method then we don't allow it to be replaced if it is a                          // method (or if it doesn't bind).                            var symbolInfo = semanticModel.GetSymbolInfo(expression' cancellationToken);                          return symbolInfo.GetBestOrAllSymbols().Any() && !symbolInfo.GetBestOrAllSymbols().Any(s => s is IMethodSymbol);                      }                      else                      {                          // It doesn't look like a method' we allow this to be replaced.                          return true;                      }                    case SyntaxKind.IsExpression:                  case SyntaxKind.AsExpression:                      // Can't introduce a variable for the type portion of an is/as check.                      var isOrAsExpression = (BinaryExpressionSyntax)expression.Parent;                      return expression == isOrAsExpression.Left;                  case SyntaxKind.EqualsValueClause:                  case SyntaxKind.ExpressionStatement:                  case SyntaxKind.ArrayInitializerExpression:                  case SyntaxKind.CollectionInitializerExpression:                  case SyntaxKind.ConditionalAccessExpression:                  case SyntaxKind.Argument:                  case SyntaxKind.AttributeArgument:                  case SyntaxKind.AnonymousObjectMemberDeclarator:                  case SyntaxKind.ArrowExpressionClause:                  case SyntaxKind.AwaitExpression:                  case SyntaxKind.ReturnStatement:                  case SyntaxKind.YieldReturnStatement:                  case SyntaxKind.ParenthesizedLambdaExpression:                  case SyntaxKind.SimpleLambdaExpression:                  case SyntaxKind.ParenthesizedExpression:                  case SyntaxKind.ArrayRankSpecifier:                  case SyntaxKind.ConditionalExpression:                  case SyntaxKind.IfStatement:                  case SyntaxKind.CatchFilterClause:                  case SyntaxKind.WhileStatement:                  case SyntaxKind.DoStatement:                  case SyntaxKind.ThrowStatement:                  case SyntaxKind.SwitchStatement:                  case SyntaxKind.InterpolatedStringExpression:                  case SyntaxKind.ComplexElementInitializerExpression:                  case SyntaxKind.Interpolation:                      // Direct parent kind checks.                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TryReduce,The following switch statement is missing a default case: switch (name.Kind())                  {                      case SyntaxKind.AliasQualifiedName:                          var simpleName = ((AliasQualifiedNameSyntax)name).Name                              .WithLeadingTrivia(name.GetLeadingTrivia());                            simpleName = simpleName.ReplaceToken(simpleName.Identifier'                              ((AliasQualifiedNameSyntax)name).Name.Identifier.CopyAnnotationsTo(                                  simpleName.Identifier.WithLeadingTrivia(                                      ((AliasQualifiedNameSyntax)name).Alias.Identifier.LeadingTrivia)));                            replacementNode = simpleName;                            issueSpan = ((AliasQualifiedNameSyntax)name).Alias.Span;                            break;                        case SyntaxKind.QualifiedName:                          replacementNode = ((QualifiedNameSyntax)name).Right.WithLeadingTrivia(name.GetLeadingTrivia());                          issueSpan = ((QualifiedNameSyntax)name).Left.Span;                            break;                        case SyntaxKind.IdentifierName:                          identifier = ((IdentifierNameSyntax)name).Identifier;                            // we can try to remove the Attribute suffix if this is the attribute name                          TryReduceAttributeSuffix(name' identifier' semanticModel' out replacementNode' out issueSpan' cancellationToken);                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,TrySimplify,The following switch statement is missing a default case: switch (expression.Kind())              {                  case SyntaxKind.SimpleMemberAccessExpression:                      {                          var memberAccess = (MemberAccessExpressionSyntax)expression;                          ExpressionSyntax newLeft;                            if (IsMemberAccessADynamicInvocation(memberAccess' semanticModel))                          {                              return false;                          }                            if (TrySimplifyMemberAccessOrQualifiedName(memberAccess.Expression' memberAccess.Name' semanticModel' optionSet' out newLeft' out issueSpan))                          {                              // replacement node might not be in it's simplest form' so add simplify annotation to it.                              replacementNode = memberAccess.Update(newLeft' memberAccess.OperatorToken' memberAccess.Name)                                  .WithAdditionalAnnotations(Simplifier.Annotation);                                // Ensure that replacement doesn't change semantics.                              return !ReplacementChangesSemantics(memberAccess' replacementNode' semanticModel);                          }                            return false;                      }                    case SyntaxKind.QualifiedName:                      {                          var qualifiedName = (QualifiedNameSyntax)expression;                          ExpressionSyntax newLeft;                          if (TrySimplifyMemberAccessOrQualifiedName(qualifiedName.Left' qualifiedName.Right' semanticModel' optionSet' out newLeft' out issueSpan))                          {                              // replacement node might not be in it's simplest form' so add simplify annotation to it.                              replacementNode = qualifiedName.Update((NameSyntax)newLeft' qualifiedName.DotToken' qualifiedName.Right)                                  .WithAdditionalAnnotations(Simplifier.Annotation);                                // Ensure that replacement doesn't change semantics.                              return !ReplacementChangesSemantics(qualifiedName' replacementNode' semanticModel);                          }                            return false;                      }              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,ExpressionSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ExpressionSyntaxExtensions.cs,FindImmediatelyEnclosingLocalVariableDeclarationSpace,The following switch statement is missing a default case: switch (declSpace.Kind())                  {                      // These are declaration-space-defining syntaxes' by the spec:                      case SyntaxKind.MethodDeclaration:                      case SyntaxKind.IndexerDeclaration:                      case SyntaxKind.OperatorDeclaration:                      case SyntaxKind.ConstructorDeclaration:                      case SyntaxKind.Block:                      case SyntaxKind.ParenthesizedLambdaExpression:                      case SyntaxKind.SimpleLambdaExpression:                      case SyntaxKind.AnonymousMethodExpression:                      case SyntaxKind.SwitchStatement:                      case SyntaxKind.ForEachKeyword:                      case SyntaxKind.ForStatement:                      case SyntaxKind.UsingStatement:                        // SPEC VIOLATION: We also want to stop walking out if' say' we are in a field                      // initializer. Technically according to the wording of the spec it should be                      // legal to use a simple name inconsistently inside a field initializer because                      // it does not define a local variable declaration space. In practice of course                      // we want to check for that. (As the native compiler does as well.)                        case SyntaxKind.FieldDeclaration:                          return declSpace;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,CommonSemanticModelExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ISemanticModelExtensions.cs,CanBindToken,The following switch statement is missing a default case: switch (token.Kind())              {                  case SyntaxKind.CommaToken:                  case SyntaxKind.DelegateKeyword:                      return false;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,TypeSyntaxGeneratorVisitor,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ITypeSymbolExtensions.TypeSyntaxGeneratorVisitor.cs,CreateSimpleTypeSyntax,The following switch statement is missing a default case: switch (symbol.SpecialType)                  {                      case SpecialType.System_Object:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("Object"));                      case SpecialType.System_Void:                          return SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword));                      case SpecialType.System_Boolean:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("Boolean"));                      case SpecialType.System_Char:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("Char"));                      case SpecialType.System_SByte:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("SByte"));                      case SpecialType.System_Byte:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("Byte"));                      case SpecialType.System_Int16:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("Int16"));                      case SpecialType.System_UInt16:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("UInt16"));                      case SpecialType.System_Int32:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("Int32"));                      case SpecialType.System_UInt32:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("UInt32"));                      case SpecialType.System_Int64:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("Int64"));                      case SpecialType.System_UInt64:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("UInt64"));                      case SpecialType.System_Decimal:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("Decimal"));                      case SpecialType.System_Single:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("Single"));                      case SpecialType.System_Double:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("Double"));                      case SpecialType.System_String:                          return SyntaxFactory.QualifiedName(SyntaxFactory.IdentifierName("System")' SyntaxFactory.IdentifierName("String"));                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,GetAttributes,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.EnumDeclaration:                          return ((EnumDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.EnumMemberDeclaration:                          return ((EnumMemberDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.ClassDeclaration:                      case SyntaxKind.InterfaceDeclaration:                      case SyntaxKind.StructDeclaration:                          return ((TypeDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.DelegateDeclaration:                          return ((DelegateDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.FieldDeclaration:                          return ((FieldDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.EventFieldDeclaration:                          return ((EventFieldDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.ConstructorDeclaration:                          return ((ConstructorDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.DestructorDeclaration:                          return ((DestructorDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.PropertyDeclaration:                          return ((PropertyDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.EventDeclaration:                          return ((EventDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.IndexerDeclaration:                          return ((IndexerDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.OperatorDeclaration:                          return ((OperatorDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.ConversionOperatorDeclaration:                          return ((ConversionOperatorDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)member).AttributeLists;                      case SyntaxKind.IncompleteMember:                          return ((IncompleteMemberSyntax)member).AttributeLists;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,GetNameToken,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.EnumDeclaration:                          return ((EnumDeclarationSyntax)member).Identifier;                      case SyntaxKind.ClassDeclaration:                      case SyntaxKind.InterfaceDeclaration:                      case SyntaxKind.StructDeclaration:                          return ((TypeDeclarationSyntax)member).Identifier;                      case SyntaxKind.DelegateDeclaration:                          return ((DelegateDeclarationSyntax)member).Identifier;                      case SyntaxKind.FieldDeclaration:                          return ((FieldDeclarationSyntax)member).Declaration.Variables.First().Identifier;                      case SyntaxKind.EventFieldDeclaration:                          return ((EventFieldDeclarationSyntax)member).Declaration.Variables.First().Identifier;                      case SyntaxKind.PropertyDeclaration:                          return ((PropertyDeclarationSyntax)member).Identifier;                      case SyntaxKind.EventDeclaration:                          return ((EventDeclarationSyntax)member).Identifier;                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)member).Identifier;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,GetArity,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.ClassDeclaration:                      case SyntaxKind.InterfaceDeclaration:                      case SyntaxKind.StructDeclaration:                          return ((TypeDeclarationSyntax)member).Arity;                      case SyntaxKind.DelegateDeclaration:                          return ((DelegateDeclarationSyntax)member).Arity;                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)member).Arity;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,GetTypeParameterList,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.ClassDeclaration:                      case SyntaxKind.InterfaceDeclaration:                      case SyntaxKind.StructDeclaration:                          return ((TypeDeclarationSyntax)member).TypeParameterList;                      case SyntaxKind.DelegateDeclaration:                          return ((DelegateDeclarationSyntax)member).TypeParameterList;                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)member).TypeParameterList;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,GetParameterList,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.DelegateDeclaration:                          return ((DelegateDeclarationSyntax)member).ParameterList;                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)member).ParameterList;                      case SyntaxKind.ConstructorDeclaration:                          return ((ConstructorDeclarationSyntax)member).ParameterList;                      case SyntaxKind.IndexerDeclaration:                          return ((IndexerDeclarationSyntax)member).ParameterList;                      case SyntaxKind.OperatorDeclaration:                          return ((OperatorDeclarationSyntax)member).ParameterList;                      case SyntaxKind.ConversionOperatorDeclaration:                          return ((ConversionOperatorDeclarationSyntax)member).ParameterList;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,WithParameterList,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.DelegateDeclaration:                          return ((DelegateDeclarationSyntax)member).WithParameterList((ParameterListSyntax)parameterList);                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)member).WithParameterList((ParameterListSyntax)parameterList);                      case SyntaxKind.ConstructorDeclaration:                          return ((ConstructorDeclarationSyntax)member).WithParameterList((ParameterListSyntax)parameterList);                      case SyntaxKind.IndexerDeclaration:                          return ((IndexerDeclarationSyntax)member).WithParameterList((BracketedParameterListSyntax)parameterList);                      case SyntaxKind.OperatorDeclaration:                          return ((OperatorDeclarationSyntax)member).WithParameterList((ParameterListSyntax)parameterList);                      case SyntaxKind.ConversionOperatorDeclaration:                          return ((ConversionOperatorDeclarationSyntax)member).WithParameterList((ParameterListSyntax)parameterList);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,WithAttributeLists,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.EnumDeclaration:                          return ((EnumDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.EnumMemberDeclaration:                          return ((EnumMemberDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.ClassDeclaration:                      case SyntaxKind.InterfaceDeclaration:                      case SyntaxKind.StructDeclaration:                          return ((TypeDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.DelegateDeclaration:                          return ((DelegateDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.FieldDeclaration:                          return ((FieldDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.EventFieldDeclaration:                          return ((EventFieldDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.ConstructorDeclaration:                          return ((ConstructorDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.DestructorDeclaration:                          return ((DestructorDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.PropertyDeclaration:                          return ((PropertyDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.EventDeclaration:                          return ((EventDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.IndexerDeclaration:                          return ((IndexerDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.OperatorDeclaration:                          return ((OperatorDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.ConversionOperatorDeclaration:                          return ((ConversionOperatorDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)member).WithAttributeLists(attributeLists);                      case SyntaxKind.IncompleteMember:                          return ((IncompleteMemberSyntax)member).WithAttributeLists(attributeLists);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,GetMemberType,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.DelegateDeclaration:                          return ((DelegateDeclarationSyntax)member).ReturnType;                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)member).ReturnType;                      case SyntaxKind.OperatorDeclaration:                          return ((OperatorDeclarationSyntax)member).ReturnType;                      case SyntaxKind.PropertyDeclaration:                          return ((PropertyDeclarationSyntax)member).Type;                      case SyntaxKind.IndexerDeclaration:                          return ((IndexerDeclarationSyntax)member).Type;                      case SyntaxKind.EventDeclaration:                          return ((EventDeclarationSyntax)member).Type;                      case SyntaxKind.EventFieldDeclaration:                          return ((EventFieldDeclarationSyntax)member).Declaration.Type;                      case SyntaxKind.FieldDeclaration:                          return ((FieldDeclarationSyntax)member).Declaration.Type;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,HasMethodShape,The following switch statement is missing a default case: switch (memberDeclaration.Kind())                  {                      case SyntaxKind.MethodDeclaration:                      case SyntaxKind.OperatorDeclaration:                      case SyntaxKind.ConversionOperatorDeclaration:                      case SyntaxKind.ConstructorDeclaration:                      case SyntaxKind.DestructorDeclaration:                          return true;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,GetBody,The following switch statement is missing a default case: switch (memberDeclaration.Kind())                  {                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)memberDeclaration).Body;                      case SyntaxKind.OperatorDeclaration:                          return ((OperatorDeclarationSyntax)memberDeclaration).Body;                      case SyntaxKind.ConversionOperatorDeclaration:                          return ((ConversionOperatorDeclarationSyntax)memberDeclaration).Body;                      case SyntaxKind.ConstructorDeclaration:                          return ((ConstructorDeclarationSyntax)memberDeclaration).Body;                      case SyntaxKind.DestructorDeclaration:                          return ((DestructorDeclarationSyntax)memberDeclaration).Body;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,MemberDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\MemberDeclarationSyntaxExtensions.cs,WithBody,The following switch statement is missing a default case: switch (memberDeclaration.Kind())                  {                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)memberDeclaration).WithBody(body);                      case SyntaxKind.OperatorDeclaration:                          return ((OperatorDeclarationSyntax)memberDeclaration).WithBody(body);                      case SyntaxKind.ConversionOperatorDeclaration:                          return ((ConversionOperatorDeclarationSyntax)memberDeclaration).WithBody(body);                      case SyntaxKind.ConstructorDeclaration:                          return ((ConstructorDeclarationSyntax)memberDeclaration).WithBody(body);                      case SyntaxKind.DestructorDeclaration:                          return ((DestructorDeclarationSyntax)memberDeclaration).WithBody(body);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,IsInStaticContext,The following switch statement is missing a default case: switch (memberDeclaration.Kind())              {                  case SyntaxKind.MethodDeclaration:                  case SyntaxKind.ConstructorDeclaration:                  case SyntaxKind.PropertyDeclaration:                  case SyntaxKind.EventDeclaration:                  case SyntaxKind.IndexerDeclaration:                      return memberDeclaration.GetModifiers().Any(SyntaxKind.StaticKeyword);                    case SyntaxKind.FieldDeclaration:                      // Inside a field one can only access static members of a type.                      return true;                    case SyntaxKind.DestructorDeclaration:                      return false;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,IsBreakableConstruct,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.DoStatement:                  case SyntaxKind.WhileStatement:                  case SyntaxKind.SwitchStatement:                  case SyntaxKind.ForStatement:                  case SyntaxKind.ForEachStatement:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,IsContinuableConstruct,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.DoStatement:                  case SyntaxKind.WhileStatement:                  case SyntaxKind.ForStatement:                  case SyntaxKind.ForEachStatement:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,IsReturnableConstruct,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.AnonymousMethodExpression:                  case SyntaxKind.SimpleLambdaExpression:                  case SyntaxKind.ParenthesizedLambdaExpression:                  case SyntaxKind.MethodDeclaration:                  case SyntaxKind.ConstructorDeclaration:                  case SyntaxKind.DestructorDeclaration:                  case SyntaxKind.GetAccessorDeclaration:                  case SyntaxKind.SetAccessorDeclaration:                  case SyntaxKind.OperatorDeclaration:                  case SyntaxKind.AddAccessorDeclaration:                  case SyntaxKind.RemoveAccessorDeclaration:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,IsCompoundAssignExpression,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.AddAssignmentExpression:                  case SyntaxKind.SubtractAssignmentExpression:                  case SyntaxKind.MultiplyAssignmentExpression:                  case SyntaxKind.DivideAssignmentExpression:                  case SyntaxKind.ModuloAssignmentExpression:                  case SyntaxKind.AndAssignmentExpression:                  case SyntaxKind.ExclusiveOrAssignmentExpression:                  case SyntaxKind.OrAssignmentExpression:                  case SyntaxKind.LeftShiftAssignmentExpression:                  case SyntaxKind.RightShiftAssignmentExpression:                      return true;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,GetModifiers,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.EnumDeclaration:                          return ((EnumDeclarationSyntax)member).Modifiers;                      case SyntaxKind.ClassDeclaration:                      case SyntaxKind.InterfaceDeclaration:                      case SyntaxKind.StructDeclaration:                          return ((TypeDeclarationSyntax)member).Modifiers;                      case SyntaxKind.DelegateDeclaration:                          return ((DelegateDeclarationSyntax)member).Modifiers;                      case SyntaxKind.FieldDeclaration:                          return ((FieldDeclarationSyntax)member).Modifiers;                      case SyntaxKind.EventFieldDeclaration:                          return ((EventFieldDeclarationSyntax)member).Modifiers;                      case SyntaxKind.ConstructorDeclaration:                          return ((ConstructorDeclarationSyntax)member).Modifiers;                      case SyntaxKind.DestructorDeclaration:                          return ((DestructorDeclarationSyntax)member).Modifiers;                      case SyntaxKind.PropertyDeclaration:                          return ((PropertyDeclarationSyntax)member).Modifiers;                      case SyntaxKind.EventDeclaration:                          return ((EventDeclarationSyntax)member).Modifiers;                      case SyntaxKind.IndexerDeclaration:                          return ((IndexerDeclarationSyntax)member).Modifiers;                      case SyntaxKind.OperatorDeclaration:                          return ((OperatorDeclarationSyntax)member).Modifiers;                      case SyntaxKind.ConversionOperatorDeclaration:                          return ((ConversionOperatorDeclarationSyntax)member).Modifiers;                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)member).Modifiers;                      case SyntaxKind.GetAccessorDeclaration:                      case SyntaxKind.SetAccessorDeclaration:                      case SyntaxKind.AddAccessorDeclaration:                      case SyntaxKind.RemoveAccessorDeclaration:                          return ((AccessorDeclarationSyntax)member).Modifiers;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxNodeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxNodeExtensions.cs,WithModifiers,The following switch statement is missing a default case: switch (member.Kind())                  {                      case SyntaxKind.EnumDeclaration:                          return ((EnumDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.ClassDeclaration:                      case SyntaxKind.InterfaceDeclaration:                      case SyntaxKind.StructDeclaration:                          return ((TypeDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.DelegateDeclaration:                          return ((DelegateDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.FieldDeclaration:                          return ((FieldDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.EventFieldDeclaration:                          return ((EventFieldDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.ConstructorDeclaration:                          return ((ConstructorDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.DestructorDeclaration:                          return ((DestructorDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.PropertyDeclaration:                          return ((PropertyDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.EventDeclaration:                          return ((EventDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.IndexerDeclaration:                          return ((IndexerDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.OperatorDeclaration:                          return ((OperatorDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.ConversionOperatorDeclaration:                          return ((ConversionOperatorDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.MethodDeclaration:                          return ((MethodDeclarationSyntax)member).WithModifiers(modifiers);                      case SyntaxKind.GetAccessorDeclaration:                      case SyntaxKind.SetAccessorDeclaration:                      case SyntaxKind.AddAccessorDeclaration:                      case SyntaxKind.RemoveAccessorDeclaration:                          return ((AccessorDeclarationSyntax)member).WithModifiers(modifiers);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\SyntaxTreeExtensions.cs,GetPrecedingModifiers,The following switch statement is missing a default case: switch (token.Kind())                  {                      case SyntaxKind.PublicKeyword:                      case SyntaxKind.InternalKeyword:                      case SyntaxKind.ProtectedKeyword:                      case SyntaxKind.PrivateKeyword:                      case SyntaxKind.SealedKeyword:                      case SyntaxKind.AbstractKeyword:                      case SyntaxKind.StaticKeyword:                      case SyntaxKind.VirtualKeyword:                      case SyntaxKind.ExternKeyword:                      case SyntaxKind.NewKeyword:                      case SyntaxKind.OverrideKeyword:                      case SyntaxKind.ReadOnlyKeyword:                      case SyntaxKind.VolatileKeyword:                      case SyntaxKind.UnsafeKeyword:                      case SyntaxKind.AsyncKeyword:                          result.Add(token.Kind());                          token = token.GetPreviousToken(includeSkipped: true);                          continue;                      case SyntaxKind.IdentifierToken:                          if (token.HasMatchingText(SyntaxKind.AsyncKeyword))                          {                              result.Add(SyntaxKind.AsyncKeyword);                              token = token.GetPreviousToken(includeSkipped: true);                              continue;                          }                            break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,AddMembers,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)node).AddMembers(members);                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)node).AddMembers(members);                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)node).AddMembers(members);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,WithMembers,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)node).WithMembers(members);                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)node).WithMembers(members);                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)node).WithMembers(members);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,WithAttributeLists,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)node).WithAttributeLists(attributes);                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)node).WithAttributeLists(attributes);                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)node).WithAttributeLists(attributes);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,WithIdentifier,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)node).WithIdentifier(identifier);                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)node).WithIdentifier(identifier);                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)node).WithIdentifier(identifier);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,WithModifiers,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)node).WithModifiers(modifiers);                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)node).WithModifiers(modifiers);                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)node).WithModifiers(modifiers);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,WithTypeParameterList,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)node).WithTypeParameterList(list);                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)node).WithTypeParameterList(list);                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)node).WithTypeParameterList(list);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,WithBaseList,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)node).WithBaseList(list);                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)node).WithBaseList(list);                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)node).WithBaseList(list);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,WithConstraintClauses,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)node).WithConstraintClauses(constraintClauses);                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)node).WithConstraintClauses(constraintClauses);                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)node).WithConstraintClauses(constraintClauses);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,WithOpenBraceToken,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)node).WithOpenBraceToken(openBrace);                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)node).WithOpenBraceToken(openBrace);                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)node).WithOpenBraceToken(openBrace);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions,TypeDeclarationSyntaxExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\TypeDeclarationSyntaxExtensions.cs,WithCloseBraceToken,The following switch statement is missing a default case: switch (node.Kind())              {                  case SyntaxKind.ClassDeclaration:                      return ((ClassDeclarationSyntax)node).WithCloseBraceToken(closeBrace);                  case SyntaxKind.InterfaceDeclaration:                      return ((InterfaceDeclarationSyntax)node).WithCloseBraceToken(closeBrace);                  case SyntaxKind.StructDeclaration:                      return ((StructDeclarationSyntax)node).WithCloseBraceToken(closeBrace);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsRightSideName,The following switch statement is missing a default case: switch (name.Parent.Kind())                  {                      case SyntaxKind.QualifiedName:                          return ((QualifiedNameSyntax)name.Parent).Right == name;                      case SyntaxKind.AliasQualifiedName:                          return ((AliasQualifiedNameSyntax)name.Parent).Name == name;                      case SyntaxKind.SimpleMemberAccessExpression:                          return ((MemberAccessExpressionSyntax)name.Parent).Name == name;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery,SyntaxTreeExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Extensions\ContextQuery\SyntaxTreeExtensions.cs,IsEnumTypeMemberAccessContext,The following switch statement is missing a default case: switch (symbol.Kind)              {                  case SymbolKind.NamedType:                      return ((INamedTypeSymbol)symbol).TypeKind == TypeKind.Enum;                  case SymbolKind.Alias:                      var target = ((IAliasSymbol)symbol).Target;                      return target.IsType && ((ITypeSymbol)target).TypeKind == TypeKind.Enum;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Formatting,FormattingHelpers,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\FormattingHelpers.cs,IsParenInArgumentList,The following switch statement is missing a default case: switch (parent.Kind())              {                  case SyntaxKind.SizeOfExpression:                      var sizeOfExpression = (SizeOfExpressionSyntax)parent;                      return sizeOfExpression.OpenParenToken == token || sizeOfExpression.CloseParenToken == token;                    case SyntaxKind.TypeOfExpression:                      var typeOfExpression = (TypeOfExpressionSyntax)parent;                      return typeOfExpression.OpenParenToken == token || typeOfExpression.CloseParenToken == token;                    case SyntaxKind.CheckedExpression:                  case SyntaxKind.UncheckedExpression:                      var checkedOfExpression = (CheckedExpressionSyntax)parent;                      return checkedOfExpression.OpenParenToken == token || checkedOfExpression.CloseParenToken == token;                    case SyntaxKind.DefaultExpression:                      var defaultExpression = (DefaultExpressionSyntax)parent;                      return defaultExpression.OpenParenToken == token || defaultExpression.CloseParenToken == token;                    case SyntaxKind.MakeRefExpression:                      var makeRefExpression = (MakeRefExpressionSyntax)parent;                      return makeRefExpression.OpenParenToken == token || makeRefExpression.CloseParenToken == token;                    case SyntaxKind.RefTypeExpression:                      var refTypeOfExpression = (RefTypeExpressionSyntax)parent;                      return refTypeOfExpression.OpenParenToken == token || refTypeOfExpression.CloseParenToken == token;                    case SyntaxKind.RefValueExpression:                      var refValueExpression = (RefValueExpressionSyntax)parent;                      return refValueExpression.OpenParenToken == token || refValueExpression.CloseParenToken == token;                    case SyntaxKind.ArgumentList:                      var argumentList = (ArgumentListSyntax)parent;                      return argumentList.OpenParenToken == token || argumentList.CloseParenToken == token;                    case SyntaxKind.AttributeArgumentList:                      var attributeArgumentList = (AttributeArgumentListSyntax)parent;                      return attributeArgumentList.OpenParenToken == token || attributeArgumentList.CloseParenToken == token;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,LineBreaksAfter,The following switch statement is missing a default case: switch (previousToken.Kind())              {                  case SyntaxKind.None:                      return 0;                    case SyntaxKind.OpenBraceToken:                  case SyntaxKind.FinallyKeyword:                      return 1;                    case SyntaxKind.CloseBraceToken:                      return LineBreaksAfterCloseBrace(currentToken);                    case SyntaxKind.CloseParenToken:                      return (((previousToken.Parent is StatementSyntax) && currentToken.Parent != previousToken.Parent)                          || currentToken.Kind() == SyntaxKind.OpenBraceToken) ? 1 : 0;                    case SyntaxKind.CloseBracketToken:                      if (previousToken.Parent is AttributeListSyntax)                      {                          // Assembly and module-level attributes followed by non-attributes should have                          // a blank line after them.                          var parent = (AttributeListSyntax)previousToken.Parent;                          if (parent.Target != null &&                              (parent.Target.Identifier.IsKindOrHasMatchingText(SyntaxKind.AssemblyKeyword) ||                               parent.Target.Identifier.IsKindOrHasMatchingText(SyntaxKind.ModuleKeyword)))                          {                              if (!(currentToken.Parent is AttributeListSyntax))                              {                                  return 2;                              }                          }                            if (previousToken.GetAncestor<ParameterSyntax>() == null)                          {                              return 1;                          }                      }                        break;                    case SyntaxKind.SemicolonToken:                      return LineBreaksAfterSemicolon(previousToken' currentToken);                    case SyntaxKind.CommaToken:                      return previousToken.Parent is EnumDeclarationSyntax ? 1 : 0;                    case SyntaxKind.ElseKeyword:                      return currentToken.Kind() != SyntaxKind.IfKeyword ? 1 : 0;                    case SyntaxKind.ColonToken:                      if (previousToken.Parent is LabeledStatementSyntax || previousToken.Parent is SwitchLabelSyntax)                      {                          return 1;                      }                        break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Formatting,ElasticTriviaFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\ElasticTriviaFormattingRule.cs,LineBreaksAfter,The following switch statement is missing a default case: switch (currentToken.Kind())              {                  case SyntaxKind.OpenBraceToken:                  case SyntaxKind.CloseBraceToken:                  case SyntaxKind.ElseKeyword:                  case SyntaxKind.FinallyKeyword:                      return 1;                    case SyntaxKind.OpenBracketToken:                      if (currentToken.Parent is AttributeListSyntax)                      {                          // Assembly and module-level attributes preceded by non-attributes should have                          // a blank line separating them.                          var parent = (AttributeListSyntax)currentToken.Parent;                          if (parent.Target != null)                          {                              if (parent.Target.Identifier == SyntaxFactory.Token(SyntaxKind.AssemblyKeyword) ||                                  parent.Target.Identifier == SyntaxFactory.Token(SyntaxKind.ModuleKeyword))                              {                                  if (!(previousToken.Parent is AttributeListSyntax))                                  {                                      return 2;                                  }                              }                          }                            // Attributes on parameters should have no lines between them.                          if (parent.Parent is ParameterSyntax)                          {                              return 0;                          }                            return 1;                      }                        break;                    case SyntaxKind.WhereKeyword:                      return previousToken.Parent is TypeParameterListSyntax ? 1 : 0;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Formatting,QueryExpressionFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\QueryExpressionFormattingRule.cs,GetAdjustNewLinesOperation,The following switch statement is missing a default case: switch (currentToken.Kind())              {                  case SyntaxKind.FromKeyword:                  case SyntaxKind.WhereKeyword:                  case SyntaxKind.LetKeyword:                  case SyntaxKind.JoinKeyword:                  case SyntaxKind.OrderByKeyword:                  case SyntaxKind.GroupKeyword:                  case SyntaxKind.SelectKeyword:                      if (currentToken.GetAncestor<QueryExpressionSyntax>() != null)                      {                          if (optionSet.GetOption(CSharpFormattingOptions.NewLineForClausesInQuery))                          {                              return CreateAdjustNewLinesOperation(1' AdjustNewLinesOption.PreserveLines);                          }                          else                          {                              return CreateAdjustNewLinesOperation(0' AdjustNewLinesOption.PreserveLines);                          }                      }                        break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustNewLinesOperation,The following switch statement is missing a default case: switch (currentToken.Kind())              {                  case SyntaxKind.OpenBraceToken:                      if (currentToken.IsInterpolation())                      {                          return null;                      }                        if (!previousToken.IsParenInParenthesizedExpression())                      {                          return CreateAdjustNewLinesOperation(1' AdjustNewLinesOption.PreserveLines);                      }                        break;                    case SyntaxKind.CloseBraceToken:                      if (currentToken.IsInterpolation())                      {                          return null;                      }                        return CreateAdjustNewLinesOperation(1' AdjustNewLinesOption.PreserveLines);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustNewLinesOperation,The following switch statement is missing a default case: switch (previousToken.Kind())              {                  case SyntaxKind.CloseBraceToken:                      if (previousToken.IsInterpolation())                      {                          return null;                      }                        if (!previousToken.IsCloseBraceOfExpression())                      {                          if (currentToken.Kind() != SyntaxKind.SemicolonToken &&                              !currentToken.IsParenInParenthesizedExpression() &&                              !currentToken.IsCommaInInitializerExpression() &&                              !currentToken.IsCommaInAnyArgumentsList() &&                              !currentToken.IsParenInArgumentList() &&                              !currentToken.IsDotInMemberAccess() &&                              !currentToken.IsCloseParenInStatement())                          {                              return CreateAdjustNewLinesOperation(1' AdjustNewLinesOption.PreserveLines);                          }                      }                        break;                    case SyntaxKind.OpenBraceToken:                      if (previousToken.IsInterpolation())                      {                          return null;                      }                        return CreateAdjustNewLinesOperation(1' AdjustNewLinesOption.PreserveLines);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The following switch statement is missing a default case: switch (currentToken.Kind())              {                  case SyntaxKind.CloseParenToken:                  case SyntaxKind.OpenBracketToken:                  case SyntaxKind.CloseBracketToken:                  case SyntaxKind.CommaToken:                  case SyntaxKind.DotToken:                  case SyntaxKind.MinusGreaterThanToken:                      return CreateAdjustSpacesOperation(0' AdjustSpacesOption.ForceSpacesIfOnSingleLine);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Formatting,TokenBasedFormattingRule,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Formatting\Rules\TokenBasedFormattingRule.cs,GetAdjustSpacesOperation,The following switch statement is missing a default case: switch (previousToken.Kind())              {                  case SyntaxKind.OpenParenToken:                  case SyntaxKind.OpenBracketToken:                  case SyntaxKind.DotToken:                  case SyntaxKind.MinusGreaterThanToken:                      return CreateAdjustSpacesOperation(0' AdjustSpacesOption.ForceSpacesIfOnSingleLine);                    case SyntaxKind.CloseParenToken:                  case SyntaxKind.CloseBracketToken:                      int space = (previousToken.Kind() == currentToken.Kind()) ? 0 : 1;                      return CreateAdjustSpacesOperation(space' AdjustSpacesOption.ForceSpacesIfOnSingleLine);              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Rename,CSharpRenameConflictLanguageService,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,ComputeImplicitReferenceConflicts,The following switch statement is missing a default case: switch (token.Kind())                          {                              case SyntaxKind.ForEachKeyword:                                  return SpecializedCollections.SingletonEnumerable<Location>(((ForEachStatementSyntax)token.Parent).Expression.GetLocation());                          }
Missing Default,Microsoft.CodeAnalysis.CSharp.Rename,RenameRewriter,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\CSharpRenameRewriterLanguageService.cs,GetAnnotationForInvocationExpression,The following switch statement is missing a default case: switch (expressionOfInvocation.Kind())                      {                          case SyntaxKind.IdentifierName:                          case SyntaxKind.GenericName:                              identifierToken = ((SimpleNameSyntax)expressionOfInvocation).Identifier;                              break;                            case SyntaxKind.SimpleMemberAccessExpression:                              identifierToken = ((MemberAccessExpressionSyntax)expressionOfInvocation).Name.Identifier;                              break;                            case SyntaxKind.QualifiedName:                              identifierToken = ((QualifiedNameSyntax)expressionOfInvocation).Right.Identifier;                              break;                            case SyntaxKind.AliasQualifiedName:                              identifierToken = ((AliasQualifiedNameSyntax)expressionOfInvocation).Name.Identifier;                              break;                            case SyntaxKind.ParenthesizedExpression:                              expressionOfInvocation = ((ParenthesizedExpressionSyntax)expressionOfInvocation).Expression;                              continue;                      }
Missing Default,Microsoft.CodeAnalysis.CSharp.Rename,LocalConflictVisitor,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Rename\LocalConflictVisitor.cs,VisitQueryInternal,The following switch statement is missing a default case: switch (clause.Kind())                  {                      case SyntaxKind.FromClause:                            tokens.Add(((FromClauseSyntax)clause).Identifier);                          break;                        case SyntaxKind.LetClause:                            tokens.Add(((LetClauseSyntax)clause).Identifier);                          break;                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Simplification,CSharpEscapingReducer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Simplification\CSharpEscapingReducer.cs,SimplifyIdentifierToken,The following switch statement is missing a default case: switch (SyntaxFacts.GetContextualKeywordKind(unescapedIdentifier))                  {                      case SyntaxKind.FromKeyword:                      case SyntaxKind.WhereKeyword:                      case SyntaxKind.SelectKeyword:                      case SyntaxKind.GroupKeyword:                      case SyntaxKind.IntoKeyword:                      case SyntaxKind.OrderByKeyword:                      case SyntaxKind.JoinKeyword:                      case SyntaxKind.LetKeyword:                      case SyntaxKind.InKeyword:                      case SyntaxKind.OnKeyword:                      case SyntaxKind.EqualsKeyword:                      case SyntaxKind.ByKeyword:                      case SyntaxKind.AscendingKeyword:                      case SyntaxKind.DescendingKeyword:                          return CreateNewIdentifierTokenFromToken(token' escape: true);                  }
Missing Default,Microsoft.CodeAnalysis.CSharp.Utilities,NameSyntaxComparer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\NameSyntaxComparer.cs,DecomposeNameParts,The following switch statement is missing a default case: switch (name.Kind())              {                  case SyntaxKind.QualifiedName:                      var dottedName = (QualifiedNameSyntax)name;                      DecomposeNameParts(dottedName.Left' result);                      DecomposeNameParts(dottedName.Right' result);                      break;                  case SyntaxKind.AliasQualifiedName:                      var aliasedName = (AliasQualifiedNameSyntax)name;                      result.Add(aliasedName.Alias);                      DecomposeNameParts(aliasedName.Name' result);                      break;                  case SyntaxKind.IdentifierName:                      result.Add((IdentifierNameSyntax)name);                      break;                  case SyntaxKind.GenericName:                      result.Add((GenericNameSyntax)name);                      break;              }
Missing Default,Microsoft.CodeAnalysis.CSharp.Utilities,SpeculationAnalyzer,C:\research\architectureSmells\repos\mono_roslyn\src\Workspaces\CSharp\Portable\Utilities\SpeculationAnalyzer.cs,CreateSpeculativeSemanticModelForNode,The following switch statement is missing a default case: switch (nodeToSpeculate.Kind())              {                  case SyntaxKind.Attribute:                      semanticModel.TryGetSpeculativeSemanticModel(position' (AttributeSyntax)nodeToSpeculate' out speculativeModel);                      return speculativeModel;                    case SyntaxKind.BaseConstructorInitializer:                  case SyntaxKind.ThisConstructorInitializer:                      semanticModel.TryGetSpeculativeSemanticModel(position' (ConstructorInitializerSyntax)nodeToSpeculate' out speculativeModel);                      return speculativeModel;                    case SyntaxKind.EqualsValueClause:                      semanticModel.TryGetSpeculativeSemanticModel(position' (EqualsValueClauseSyntax)nodeToSpeculate' out speculativeModel);                      return speculativeModel;                    case SyntaxKind.ArrowExpressionClause:                      semanticModel.TryGetSpeculativeSemanticModel(position' (ArrowExpressionClauseSyntax)nodeToSpeculate' out speculativeModel);                      return speculativeModel;              }
