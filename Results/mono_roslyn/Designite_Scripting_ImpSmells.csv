Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectRecursive,The method has 129 lines of code.
Long Method,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectMembersRecursive,The method has 135 lines of code.
Long Method,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveType,The method has 179 lines of code.
Long Method,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,EmitWorker,The method has 149 lines of code.
Long Method,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,The method has 102 lines of code.
Long Method,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,GetMarshalAsAttribute,The method has 101 lines of code.
Complex Method,Microsoft.CodeAnalysis,FusionAssemblyIdentity,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\FusionAssemblyIdentity.cs,ToAssemblyNameObject,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis,FusionAssemblyIdentity,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\FusionAssemblyIdentity.cs,GetBestMatch,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CodeAnalysis,GlobalAssemblyCache,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\GlobalAssemblyCache.cs,GetAssemblyObjects,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.Scripting,ObjectFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.cs,ResolveMember,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.CodeAnalysis.Scripting,ObjectFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.cs,FormatPrimitive,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectRecursive,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectMembersRecursive,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.CodeAnalysis.Scripting,Script,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Script.cs,Run,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.Scripting,InteractiveAssemblyLoader,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\InteractiveAssemblyLoader.cs,AssemblyResolve,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveType,Cyclomatic complexity of the method is 27
Complex Method,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,EmitWorker,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,OrderTypeBuilders,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,DefineParameter,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,GetMarshalAsAttribute,Cyclomatic complexity of the method is 15
Long Parameter List,Microsoft.CodeAnalysis,GlobalAssemblyCache,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\GlobalAssemblyCache.cs,CreateAssemblyEnum,The method has 5 parameters. Parameters: ppEnum' pAppCtx' pName' dwFlags' pvReserved
Long Parameter List,Microsoft.CodeAnalysis,GlobalAssemblyCache,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\GlobalAssemblyCache.cs,ResolvePartialName,The method has 5 parameters. Parameters: displayName' architectureFilter' preferredCulture' location' resolveLocation
Long Parameter List,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectRecursive,The method has 5 parameters. Parameters: result' obj' quoteStrings' memberFormat' name
Long Parameter List,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectMembers,The method has 5 parameters. Parameters: result' obj' originalType' includeNonPublic' inline
Long Parameter List,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,ParseSimpleMemberName,The method has 5 parameters. Parameters: str' start' end' noQuotes' isCallable
Long Parameter List,Microsoft.CodeAnalysis.Scripting,Script,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Script.cs,Script,The method has 7 parameters. Parameters: code' path' options' globalsType' returnType' builder' previous
Long Parameter List,Microsoft.CodeAnalysis.Scripting,Script,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Script.cs,With,The method has 7 parameters. Parameters: code' path' options' globalsType' returnType' builder' previous
Long Parameter List,Microsoft.CodeAnalysis.Scripting,Script,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Script.cs,Make,The method has 7 parameters. Parameters: code' path' options' globalsType' returnType' builder' previous
Long Parameter List,Microsoft.CodeAnalysis.Scripting,ObjectFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormattingOptions.cs,ObjectFormattingOptions,The method has 9 parameters. Parameters: memberFormat' quoteStrings' useHexadecimalNumbers' includeCodePoints' maxLineLength' maxOutputLength' memberIndentation' ellipsis' lineBreak
Long Parameter List,Microsoft.CodeAnalysis.Scripting,ObjectFormattingOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormattingOptions.cs,Copy,The method has 9 parameters. Parameters: memberFormat' quoteStrings' useHexadecimalNumbers' includeCodePoints' maxLineLength' maxOutputLength' memberIndentation' ellipsis' newLine
Long Parameter List,Microsoft.CodeAnalysis.Scripting,ScriptOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ScriptOptions.cs,ScriptOptions,The method has 5 parameters. Parameters: references' namespaces' referenceResolver' isInteractive' isCollectible
Long Parameter List,Microsoft.CodeAnalysis.Scripting,ScriptOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ScriptOptions.cs,With,The method has 5 parameters. Parameters: references' namespaces' resolver' isInteractive' isCollectible
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,CommonCompilationExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\CommonCompilationExtensions.cs,Emit,The method has 9 parameters. Parameters: compilation' moduleBuilder' assemblyLoader' assemblySymbolMapper' recoverOnError' diagnostics' cancellationToken' entryPoint' compiledAssemblyImage
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,MakeMethodParameters,The method has 5 parameters. Parameters: method' methodRef' methodGenericParameters' parameters' returnParameter
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,MakeParameterInfo,The method has 6 parameters. Parameters: containingMethod' position' typeRef' genericContext' customModifiers' isByReference
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,Emit,The method has 6 parameters. Parameters: context' referencedAssemblies' builder' assemblyLoader' entryPoint' cancellationToken
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,UnimplementedType,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,GetConstructorImpl,The method has 5 parameters. Parameters: bindingAttr' binder' callConvention' types' modifiers
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,UnimplementedType,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,GetMethodImpl,The method has 6 parameters. Parameters: name' bindingAttr' binder' callConvention' types' modifiers
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,UnimplementedType,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,GetPropertyImpl,The method has 6 parameters. Parameters: name' bindingAttr' binder' returnType' types' modifiers
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,UnimplementedType,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,InvokeMember,The method has 8 parameters. Parameters: name' invokeAttr' binder' target' args' modifiers' culture' namedParameters
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,UnimplementedMethodInfo,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,Invoke,The method has 5 parameters. Parameters: obj' invokeAttr' binder' parameters' culture
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,UnimplementedConstructorInfo,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,Invoke,The method has 5 parameters. Parameters: obj' invokeAttr' binder' parameters' culture
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,UnimplementedFieldInfo,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,SetValue,The method has 5 parameters. Parameters: obj' value' invokeAttr' binder' culture
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,UnimplementedPropertyInfo,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,GetValue,The method has 5 parameters. Parameters: obj' invokeAttr' binder' index' culture
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,UnimplementedPropertyInfo,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,SetValue,The method has 6 parameters. Parameters: obj' value' invokeAttr' binder' index' culture
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,ModifiedParameterInfo,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,ModifiedParameterInfo,The method has 5 parameters. Parameters: containingMember' position' type' reqMods' optMods
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,MethodRef,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,MethodRef,The method has 5 parameters. Parameters: containingType' name' callingConvention' unspecializedDefinition' extraParameterTypes
Long Parameter List,Microsoft.CodeAnalysis.Scripting.Emit,ModifiedFieldRef,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.Refs.cs,ModifiedFieldRef,The method has 5 parameters. Parameters: containingType' name' type' reqMods' optMods
Long Identifier,Microsoft.CodeAnalysis,FusionAssemblyIdentity,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\FusionAssemblyIdentity.cs,GetDisplayName,The length of the parameter characterCountIncludingTerminator is 33.
Long Identifier,Microsoft.CodeAnalysis.Scripting,InteractiveAssemblyLoader,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\InteractiveAssemblyLoader.cs,RegisterDependencyNoLock,The length of the parameter sameSimpleNameAssemblyIdentities is 32.
Long Identifier,Microsoft.CodeAnalysis.Scripting,MetadataShadowCopyProvider,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\MetadataShadowCopyProvider.cs,,The length of the parameter s_systemNoShadowCopyDirectories is 31.
Long Identifier,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,,The length of the parameter s_marshalSafeArrayUserDefinedSubType is 36.
Long Identifier,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,,The length of the parameter s_lazyTypeBuilder_SetPInvokeData is 32.
Long Identifier,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,,The length of the parameter s_lazyTypeBuilder_SetConstantValue is 34.
Long Statement,Microsoft.CodeAnalysis,FusionAssemblyIdentity,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\FusionAssemblyIdentity.cs,ToAssemblyNameObject,The length of the statement  "                    throw new ArgumentException(Microsoft.CodeAnalysis.Scripting.ScriptingResources.InvalidCharactersInAssemblyName' "name"); " is 121.
Long Statement,Microsoft.CodeAnalysis,FusionAssemblyIdentity,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\FusionAssemblyIdentity.cs,ToAssemblyNameObject,The length of the statement  "                    throw new ArgumentException(Microsoft.CodeAnalysis.Scripting.ScriptingResources.InvalidCharactersInAssemblyName' "name"); " is 121.
Long Statement,Microsoft.CodeAnalysis,GlobalAssemblyCache,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\GlobalAssemblyCache.cs,GetAssemblyObjects,The length of the statement  "                    // for some reason it might happen that CreateAssemblyEnum returns non-zero HR that doesn't correspond to any exception: " is 120.
Long Statement,Microsoft.CodeAnalysis.Scripting,ObjectFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.cs,GetApplicableDebuggerDisplayAttribute,The length of the statement  "            var result = (DebuggerDisplayAttribute)member.GetCustomAttributes(typeof(DebuggerDisplayAttribute)' inherit: true).FirstOrDefault(); " is 132.
Long Statement,Microsoft.CodeAnalysis.Scripting,ObjectFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.cs,GetApplicableDebuggerDisplayAttribute,The length of the statement  "                foreach (DebuggerDisplayAttribute attr in type.Assembly.GetCustomAttributes(typeof(DebuggerDisplayAttribute)' inherit: true)) " is 125.
Long Statement,Microsoft.CodeAnalysis.Scripting,ObjectFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.cs,GetApplicableDebuggerTypeProxyAttribute,The length of the statement  "            var result = (DebuggerTypeProxyAttribute)type.GetCustomAttributes(typeof(DebuggerTypeProxyAttribute)' inherit: true).FirstOrDefault(); " is 134.
Long Statement,Microsoft.CodeAnalysis.Scripting,ObjectFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.cs,GetApplicableDebuggerTypeProxyAttribute,The length of the statement  "            foreach (DebuggerTypeProxyAttribute attr in type.Assembly.GetCustomAttributes(typeof(DebuggerTypeProxyAttribute)' inherit: true)) " is 129.
Long Statement,Microsoft.CodeAnalysis.Scripting,ObjectFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.cs,ResolveMember,The length of the statement  "            const Ref.BindingFlags flags = Ref.BindingFlags.Instance | Ref.BindingFlags.Static | Ref.BindingFlags.Public | Ref.BindingFlags.NonPublic | " is 139.
Long Statement,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectRecursive,The length of the statement  "                string primitive = _language.FormatPrimitive(obj' quoteStrings' _options.IncludeCodePoints' _options.UseHexadecimalNumbers); " is 124.
Long Statement,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectMembersRecursive,The length of the statement  "                    var browsable = (DebuggerBrowsableAttribute)member.GetCustomAttributes(typeof(DebuggerBrowsableAttribute)' false).FirstOrDefault(); " is 131.
Long Statement,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectMembersRecursive,The length of the statement  "                        if (!AddMember(result' new FormattedMember(-1' _language.FormatMemberName(member)' memberValueBuilder.ToString())' ref lengthLimit)) " is 132.
Long Statement,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectMembersRecursive,The length of the statement  "                            else if (_language.FormatPrimitive(value' _options.QuoteStrings' _options.IncludeCodePoints' _options.UseHexadecimalNumbers) == null && VisitedObjects.Add(value)) " is 162.
Long Statement,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatDictionary,The length of the statement  "                            FormatObjectRecursive(result' entry.Key' quoteStrings: true' memberFormat: MemberDisplayFormat.InlineValue' name: out _); " is 121.
Long Statement,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatDictionary,The length of the statement  "                            FormatObjectRecursive(result' entry.Value' quoteStrings: true' memberFormat: MemberDisplayFormat.InlineValue' name: out _); " is 123.
Long Statement,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatMultidimensionalArray,The length of the statement  "                    FormatObjectRecursive(result' array.GetValue(indices)' quoteStrings: true' memberFormat: MemberDisplayFormat.InlineValue' name: out name); " is 138.
Long Statement,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatWithEmbeddedExpressions,The length of the statement  "                return FormatWithEmbeddedExpressions(new Builder(lengthLimit' _options' insertEllipsis: false)' format' obj).ToString(); " is 120.
Long Statement,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatWithEmbeddedExpressions,The length of the statement  "                            if (expressionEnd == -1 || (memberName = ParseSimpleMemberName(format' i' expressionEnd' out noQuotes' out callableOnly)) == null) " is 130.
Long Statement,Microsoft.CodeAnalysis.Scripting,ScriptBuilder,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ScriptBuilder.cs,CreateDynamicModule,The length of the statement  "                    new object[] { DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations })); " is 120.
Long Statement,Microsoft.CodeAnalysis.Scripting,InteractiveAssemblyLoader,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\InteractiveAssemblyLoader.cs,AssemblyResolve,The length of the statement  "                        if (_loadedAssembliesByPath.TryGetValue(originalDllPath' out assembly) || _loadedAssembliesByPath.TryGetValue(originalExePath' out assembly)) " is 141.
Long Statement,Microsoft.CodeAnalysis.Scripting,InteractiveAssemblyLoader,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\InteractiveAssemblyLoader.cs,ShadowCopyAndLoadAndAddEntry,The length of the statement  "                    result = AssemblyLoadResult.CreateSuccessful(assembly.Location' assembly.GlobalAssemblyCache ? assembly.Location : originalPath); " is 129.
Long Statement,Microsoft.CodeAnalysis.Scripting,InteractiveAssemblyLoader,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\InteractiveAssemblyLoader.cs,ShadowCopyAndLoadAndAddEntry,The length of the statement  "                    _loadedAssemblies.Add(assembly' new LoadedAssembly { LoadedExplicitly = explicitLoad' OriginalPath = result.OriginalPath }); " is 124.
Long Statement,Microsoft.CodeAnalysis.Scripting,MetadataShadowCopyProvider,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\MetadataShadowCopyProvider.cs,CreateMetadataShadowCopy,The length of the statement  "                    return new CacheEntry<MetadataShadowCopy>(new MetadataShadowCopy(manifestModuleCopy' documentationFileCopy' publicMetadata)' privateMetadata); " is 142.
Long Statement,Microsoft.CodeAnalysis.Scripting,MetadataShadowCopyProvider,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\MetadataShadowCopyProvider.cs,CopyFile,The length of the statement  "                // tomat: Ideally we would mark the handle as "delete on close". Unfortunately any subsequent attempt to create a handle to the file is denied if we do so. " is 155.
Long Statement,Microsoft.CodeAnalysis.Scripting,MetadataShadowCopyProvider,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\MetadataShadowCopyProvider.cs,CopyFile,The length of the statement  "                // The only way to read the file is via the handle we open here' however we need to use APIs that take a path to the shadow copy and open it for read " is 149.
Long Statement,Microsoft.CodeAnalysis.Scripting,MetadataShadowCopyProvider,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\MetadataShadowCopyProvider.cs,CopyFile,The length of the statement  "                var stream = new FileStream(shadowCopyPath' FileMode.Open' FileAccess.Read' FileShare.Read | FileShare.Delete' bufferSize: 0x1000' options: FileOptions.DeleteOnClose); " is 167.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,CommonCompilationExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\CommonCompilationExtensions.cs,Emit,The length of the statement  "            entryPoint = (cciEntryPoint != null) ? ReflectionEmitter.ResolveEntryPoint(compiledAssembly' cciEntryPoint' context) : null; " is 124.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,LoadReferencedAssemblies,The length of the statement  "            // The referenced assemblies are going to be loaded during emit at some point so there is no point in deferring the loads. " is 122.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,AddDependency,The length of the statement  "            // TODO (tomat): builder == dependentType fails for enums (see InteractiveSessionTests.Enums). Is this a Reflection bug? " is 120.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveType,The length of the statement  "                Type unspecialized = ResolveType(specializedNestedRef.UnspecializedVersion' genericContext' dependentType' valueTypeDependency); " is 128.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveType,The length of the statement  "                result = containingType.GetNestedType(Cci.MetadataWriter.GetMangledName(nestedRef)' BindingFlags.Public | BindingFlags.NonPublic); " is 130.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveType,The length of the statement  "                Type elementType = ResolveType(arrayType.GetElementType(_context)' genericContext' valueTypeDependency ? null : dependentType); " is 127.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveType,The length of the statement  "                Type elementType = ResolveType(refType.GetTargetType(_context)' genericContext' valueTypeDependency ? null : dependentType); " is 124.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveType,The length of the statement  "                Type elementType = ResolveType(ptrType.GetTargetType(_context)' genericContext' valueTypeDependency ? null : dependentType); " is 124.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveType,The length of the statement  "                    return genericContext.TypeParameters[GetConsolidatedGenericTypeParameterIndex(genericParamRef.AsGenericTypeParameterReference)]; " is 128.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveField,The length of the statement  "                    FieldBuilder fieldBuilder = _fieldBuilders[(Cci.IFieldDefinition)specializedRef.UnspecializedVersion.AsDefinition(_context)]; " is 125.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveMethod,The length of the statement  "                MethodBuilder methodBuilder = _methodBuilders[(Cci.IMethodDefinition)specializedRef.UnspecializedVersion.AsDefinition(_context)]; " is 129.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveConstructor,The length of the statement  "                ConstructorBuilder ctorBuilder = _constructorBuilders[(Cci.IMethodDefinition)specializedRef.UnspecializedVersion.AsDefinition(_context)]; " is 137.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,MakeMethodRef,The length of the statement  "                unspecializedDefinition = isConstructor ? ResolveConstructor(specializedRef.UnspecializedVersion) : ResolveMethod(specializedRef.UnspecializedVersion); " is 151.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,MakeMethodRef,The length of the statement  "            var m = new MethodRef(declaringType' methodRef.Name' GetManagedCallingConvention(methodRef.CallingConvention)' unspecializedDefinition' GetExtraParameterTypes(methodRef)); " is 171.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,MakeMethodParameters,The length of the statement  "                parameters[i] = MakeParameterInfo(method' i + 1' parameter.GetType(_context)' genericContext' parameter.CustomModifiers' parameter.IsByReference); " is 146.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,MakeMethodParameters,The length of the statement  "            returnParameter = MakeParameterInfo(method' 0' methodRef.GetType(_context)' genericContext' methodRef.ReturnValueCustomModifiers' methodRef.ReturnValueIsByRef); " is 160.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveEntryPoint,The length of the statement  "            return type.GetMethod(method.Name' BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static); " is 131.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveRuntimeMethodOrConstructor,The length of the statement  "            BindingFlags bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 147.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveRuntimeMethodOrConstructor,The length of the statement  "                // Generic types instantiated with TypeBuilder(s) or GenericParameterBuilder(s) are represented by TypeBuilderInstantiation in Ref.Emit. " is 136.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveRuntimeMethodOrConstructor,The length of the statement  "                // Unfortunately TypeBuilderInstantiation.GetMember throws NotSupportedException so we need to resolve the overload on generic definition " is 137.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveRuntimeMethodOrConstructor,The length of the statement  "                // So we can't handle all specializedRef != null cases here' only those such that declaringType.ContainsGenericParameters. " is 122.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveRuntimeMethodOrConstructor,The length of the statement  "                    // Their tokens are the same as tokens of their respectie generic definitions. We can use this to figure out which is which. " is 124.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveRuntimeMethodOrConstructor,The length of the statement  "                    MethodBase unspecializedOverload = ResolveRuntimeMethodOrConstructor(genericDefinition' specializedRef.UnspecializedVersion' isConstructor); " is 140.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,ResolveOverload,The length of the statement  "                if (ParametersMatch(resolvedParameters' method.GetParameters()) && ReturnTypeMatches(methodRef' method' genericContext)) " is 120.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,EmitWorker,The length of the statement  "                // TypeBuilder that represents an enum determines its underlying type based upon the first (and only) instance field type (__value). " is 132.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,EmitWorker,The length of the statement  "                    // TODO(tomat): This fails for enum fields if the enum is a nested type in a generic type (TypeBuilderInstantiation throws in IsSubclassOf) " is 139.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,EmitWorker,The length of the statement  "            // bodies (IL may need a method token of a generic method' which bakes its generic parameters -> we need to emit generic parameters first) " is 138.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,DefineType,The length of the statement  "                typeBuilder = containingTypeBuilder.DefineNestedType(mangledName' attrs' null' (PackingSize)typeDef.Alignment' (int)typeDef.SizeOf); " is 132.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,DefineField,The length of the statement  "                // TODO (tomat' Dev12): Unfortunately' Reflection.Emit doesn't allow us to directly set FieldRVA on arbitrary FieldBuilder. " is 123.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,DefineField,The length of the statement  "                // If the field type is a nested type' e.g. A.B.C only the inner-most type needs to be loaded before the declaring type. " is 120.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,DefineGenericParameters,The length of the statement  "            var gpBuilders = (typeBuilder != null) ? typeBuilder.DefineGenericParameters(names) : methodBuilder.DefineGenericParameters(names); " is 131.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,DefineGenericParameterConstraints,The length of the statement  "                var typeConstraint = ResolveType(constraint' dependentType: (TypeBuilder)gpBuilder.DeclaringType' valueTypeDependency: false); " is 126.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,DefineGenericParameterConstraints,The length of the statement  "            // The types actually don't need to be interfaces. Ref.Emit merges them eventually with base type constraint into a single list. " is 128.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,DefineGenericParameterConstraints,The length of the statement  "            // Besides there might be multiple non-interface constraints applied on the parameter if they are another type parameters. " is 122.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,DefineParameter,The length of the statement  "                        // e.g. of type Int16 for parameter of type Int32 to metadata' Ref.Emit checks if these types are Type.IsAssignableFrom. " is 120.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,GetMarshalAsAttribute,The length of the statement  "            return new CustomAttributeBuilder(s_marshalAsCtor' new object[] { marshallingInformation.UnmanagedType }' fields' values); " is 122.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SetPInvokeAttributes,The length of the statement  "                s_lazyTypeBuilder_SetPInvokeData = typeof(TypeBuilder).GetMethod("SetPInvokeData"' BindingFlags.NonPublic | BindingFlags.Static); " is 129.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SetPInvokeAttributes,The length of the statement  "            s_lazyTypeBuilder_SetPInvokeData.Invoke(null' new[] { RuntimeModule' dllName' importName' method.GetToken().Token' attributes }); " is 129.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SetParameterDefaultStructValue,The length of the statement  "                s_lazyTypeBuilder_SetConstantValue = (MethodInfo)typeof(TypeBuilder).GetMember("SetConstantValue"' BindingFlags.NonPublic | BindingFlags.Static). " is 145.
Long Statement,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SetParameterDefaultStructValue,The length of the statement  "            s_lazyTypeBuilder_SetConstantValue.Invoke(null' new[] { RuntimeModule' builder.GetToken().Token' ELEMENT_TYPE_VALUETYPE' null }); " is 129.
Complex Conditional,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectMembersRecursive,The conditional expression  "!(includeNonPublic || ignoreVisibility || field.IsPublic || field.IsFamily || field.IsFamilyOrAssembly)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatObjectMembersRecursive,The conditional expression  "!(includeNonPublic || ignoreVisibility ||                              getter != null && (getter.IsPublic || getter.IsFamily || getter.IsFamilyOrAssembly) ||                              setter != null && (setter.IsPublic || setter.IsFamily || setter.IsFamilyOrAssembly))"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.Scripting,Script,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Script.cs,With,The conditional expression  "ReferenceEquals(newCode' _code) &&                  ReferenceEquals(newPath' _path) &&                  newOptions == _options &&                  newGlobalsType == _globalsType &&                  newReturnType == _returnType &&                  newBuilder == _lazyBuilder &&                  newPrevious == this.Previous"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.Scripting,UncollectibleCodeManager,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ScriptBuilder.cs,Resolve,The conditional expression  "_dynamicModule != null && _dynamicModule.Assembly == args.RequestingAssembly ||                          _fallBackAssemblies != null && _fallBackAssemblies.Contains(args.RequestingAssembly)"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.Scripting,ScriptOptions,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ScriptOptions.cs,With,The conditional expression  "newReferences == _references &&                  newNamespaces == _namespaces &&                  newResolver == _referenceResolver &&                  newIsInteractive == _isInteractive &&                  newIsCollectible == _isCollectible"  is complex.
Complex Conditional,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,DefineParameter,The conditional expression  "defaultValue != null ||                  paramDef.IsOptional ||                  paramDef.IsOut ||                  paramDef.IsMarshalledExplicitly ||                  attributes.Any() ||                  paramDef.Name.Length > 0"  is complex.
Empty Catch Block,Microsoft.CodeAnalysis.Scripting,ObjectFormatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.cs,GetDebuggerTypeProxy,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatCollectionHeader,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.Scripting,MetadataShadowCopyProvider,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\MetadataShadowCopyProvider.cs,DeleteShadowCopyDirectory,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.Scripting,MetadataShadowCopyProvider,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\MetadataShadowCopyProvider.cs,StripReadOnlyAttributeFromFile,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.Scripting.Emit,CommonCompilationExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\CommonCompilationExtensions.cs,Emit,The method has an empty catch block.
Empty Catch Block,Microsoft.CodeAnalysis.Scripting.Emit,CommonCompilationExtensions,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\CommonCompilationExtensions.cs,Emit,The method has an empty catch block.
Magic Number,Microsoft.CodeAnalysis,FusionAssemblyIdentity,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\FusionAssemblyIdentity.cs,GetDisplayName,The following statement contains a magic number: byte[] data = new byte[(int)characterCountIncludingTerminator * 2];
Magic Number,Microsoft.CodeAnalysis,FusionAssemblyIdentity,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\FusionAssemblyIdentity.cs,GetPropertyString,The following statement contains a magic number: return Marshal.PtrToStringUni((IntPtr)p' (data.Length / 2) - 1);
Magic Number,Microsoft.CodeAnalysis,FusionAssemblyIdentity,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\FusionAssemblyIdentity.cs,GetVersion,The following statement contains a magic number: return new Version((int)(hi >> 16)' (int)(hi & 0xffff)' (int)(lo >> 16)' (int)(lo & 0xffff));
Magic Number,Microsoft.CodeAnalysis,FusionAssemblyIdentity,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\FusionAssemblyIdentity.cs,GetVersion,The following statement contains a magic number: return new Version((int)(hi >> 16)' (int)(hi & 0xffff)' (int)(lo >> 16)' (int)(lo & 0xffff));
Magic Number,Microsoft.CodeAnalysis,GlobalAssemblyCache,C:\research\architectureSmells\repos\mono_roslyn\src\Compilers\Helpers\GlobalAssemblyCacheHelpers\GlobalAssemblyCache.cs,GetLocation,The following statement contains a magic number: byte[] data = new byte[((int)characterCount + 1) * 2];
Magic Number,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatWithEmbeddedExpressions,The following statement contains a magic number: i >= 2 && format[i - 2] == '\\'
Magic Number,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,FormatWithEmbeddedExpressions,The following statement contains a magic number: i >= 2 && format[i - 2] == '\\'
Magic Number,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,ParseSimpleMemberName,The following statement contains a magic number: int j = end - 3;
Magic Number,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,ParseSimpleMemberName,The following statement contains a magic number: end - 3 >= start && str[end - 2] == 'n' && str[end - 1] == 'q'
Magic Number,Microsoft.CodeAnalysis.Scripting,Formatter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,ParseSimpleMemberName,The following statement contains a magic number: end - 3 >= start && str[end - 2] == 'n' && str[end - 1] == 'q'
Magic Number,Microsoft.CodeAnalysis.Scripting,FormattedMember,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,HasKeyName,The following statement contains a magic number: return Index >= 0 && Name != null && Name.Length >= 2 && Name[0] == '[' && Name[Name.Length - 1] == ']';
Magic Number,Microsoft.CodeAnalysis.Scripting,FormattedMember,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ObjectFormatter.Formatter.cs,AppendAsCollectionEntry,The following statement contains a magic number: result.Append(Name' 1' Name.Length - 2);
Magic Number,Microsoft.CodeAnalysis.Scripting,MetadataShadowCopyProvider,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\MetadataShadowCopyProvider.cs,CreateMetadataShadowCopy,The following statement contains a magic number: int attempts = 10;
Magic Number,Microsoft.CodeAnalysis.Scripting,MetadataShadowCopyProvider,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\MetadataShadowCopyProvider.cs,CreateUniqueDirectory,The following statement contains a magic number: int attempts = 10;
Magic Number,Microsoft.CodeAnalysis.Scripting,ScriptExecutionState,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ScriptExecutionState.cs,Create,The following statement contains a magic number: var submissionStates = new object[2];
Magic Number,Microsoft.CodeAnalysis.Scripting,ScriptExecutionState,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\ScriptExecutionState.cs,RunSubmission,The following statement contains a magic number: Array.Resize(ref _submissionStates' Math.Max(_count + 1' _submissionStates.Length * 2));
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,WriteInt,The following statement contains a magic number: buffer[pos++] = (byte)(value >> 8);
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,WriteInt,The following statement contains a magic number: buffer[pos++] = (byte)(value >> 16);
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,WriteInt,The following statement contains a magic number: buffer[pos] = (byte)(value >> 24);
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,The following statement contains a magic number: switch (operandType)                  {                      case OperandType.InlineField:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineMethod:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineType:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineTok: // ldtoken                          tokenFixupOffsets.Add(curIndex);                            // FieldRef' MethodRef' TypeRef                          var symbolRef = ReadSymbolRef(buffer' curIndex);                            Cci.ITypeReference typeRef;                          Cci.IMethodReference methodRef;                          Cci.IFieldReference fieldRef;                          if ((typeRef = symbolRef as Cci.ITypeReference) != null)                          {                              member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((methodRef = symbolRef as Cci.IMethodReference) != null)                          {                              member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((fieldRef = symbolRef as Cci.IFieldReference) != null)                          {                              member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          }                          else                          {                              throw ExceptionUtilities.Unreachable;                          }                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineString: // ldstr                          tokenFixupOffsets.Add(curIndex);                          string str = ReadString(buffer' curIndex);                          WriteInt(buffer' _builder.GetStringConstant(str).Token' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineSig: // calli (not emitted by C#/VB)                          throw new NotSupportedException();                        case OperandType.InlineBrTarget:                      case OperandType.InlineI:                      case OperandType.ShortInlineR:                          curIndex += 4;                          break;                        case OperandType.InlineI8:                      case OperandType.InlineR:                          curIndex += 8;                          break;                        case OperandType.InlineNone:                          break;                        case OperandType.InlineVar:                          curIndex += 2;                          break;                        case OperandType.ShortInlineBrTarget:                      case OperandType.ShortInlineI:                      case OperandType.ShortInlineVar:                          curIndex += 1;                          break;                        case OperandType.InlineSwitch:                          // skip switch arguments                          curIndex += 4 + BitConverter.ToInt32(buffer' curIndex) * 4;                          break;                        default:                          throw ExceptionUtilities.UnexpectedValue(operandType);                  }
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,The following statement contains a magic number: switch (operandType)                  {                      case OperandType.InlineField:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineMethod:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineType:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineTok: // ldtoken                          tokenFixupOffsets.Add(curIndex);                            // FieldRef' MethodRef' TypeRef                          var symbolRef = ReadSymbolRef(buffer' curIndex);                            Cci.ITypeReference typeRef;                          Cci.IMethodReference methodRef;                          Cci.IFieldReference fieldRef;                          if ((typeRef = symbolRef as Cci.ITypeReference) != null)                          {                              member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((methodRef = symbolRef as Cci.IMethodReference) != null)                          {                              member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((fieldRef = symbolRef as Cci.IFieldReference) != null)                          {                              member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          }                          else                          {                              throw ExceptionUtilities.Unreachable;                          }                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineString: // ldstr                          tokenFixupOffsets.Add(curIndex);                          string str = ReadString(buffer' curIndex);                          WriteInt(buffer' _builder.GetStringConstant(str).Token' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineSig: // calli (not emitted by C#/VB)                          throw new NotSupportedException();                        case OperandType.InlineBrTarget:                      case OperandType.InlineI:                      case OperandType.ShortInlineR:                          curIndex += 4;                          break;                        case OperandType.InlineI8:                      case OperandType.InlineR:                          curIndex += 8;                          break;                        case OperandType.InlineNone:                          break;                        case OperandType.InlineVar:                          curIndex += 2;                          break;                        case OperandType.ShortInlineBrTarget:                      case OperandType.ShortInlineI:                      case OperandType.ShortInlineVar:                          curIndex += 1;                          break;                        case OperandType.InlineSwitch:                          // skip switch arguments                          curIndex += 4 + BitConverter.ToInt32(buffer' curIndex) * 4;                          break;                        default:                          throw ExceptionUtilities.UnexpectedValue(operandType);                  }
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,The following statement contains a magic number: switch (operandType)                  {                      case OperandType.InlineField:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineMethod:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineType:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineTok: // ldtoken                          tokenFixupOffsets.Add(curIndex);                            // FieldRef' MethodRef' TypeRef                          var symbolRef = ReadSymbolRef(buffer' curIndex);                            Cci.ITypeReference typeRef;                          Cci.IMethodReference methodRef;                          Cci.IFieldReference fieldRef;                          if ((typeRef = symbolRef as Cci.ITypeReference) != null)                          {                              member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((methodRef = symbolRef as Cci.IMethodReference) != null)                          {                              member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((fieldRef = symbolRef as Cci.IFieldReference) != null)                          {                              member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          }                          else                          {                              throw ExceptionUtilities.Unreachable;                          }                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineString: // ldstr                          tokenFixupOffsets.Add(curIndex);                          string str = ReadString(buffer' curIndex);                          WriteInt(buffer' _builder.GetStringConstant(str).Token' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineSig: // calli (not emitted by C#/VB)                          throw new NotSupportedException();                        case OperandType.InlineBrTarget:                      case OperandType.InlineI:                      case OperandType.ShortInlineR:                          curIndex += 4;                          break;                        case OperandType.InlineI8:                      case OperandType.InlineR:                          curIndex += 8;                          break;                        case OperandType.InlineNone:                          break;                        case OperandType.InlineVar:                          curIndex += 2;                          break;                        case OperandType.ShortInlineBrTarget:                      case OperandType.ShortInlineI:                      case OperandType.ShortInlineVar:                          curIndex += 1;                          break;                        case OperandType.InlineSwitch:                          // skip switch arguments                          curIndex += 4 + BitConverter.ToInt32(buffer' curIndex) * 4;                          break;                        default:                          throw ExceptionUtilities.UnexpectedValue(operandType);                  }
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,The following statement contains a magic number: switch (operandType)                  {                      case OperandType.InlineField:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineMethod:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineType:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineTok: // ldtoken                          tokenFixupOffsets.Add(curIndex);                            // FieldRef' MethodRef' TypeRef                          var symbolRef = ReadSymbolRef(buffer' curIndex);                            Cci.ITypeReference typeRef;                          Cci.IMethodReference methodRef;                          Cci.IFieldReference fieldRef;                          if ((typeRef = symbolRef as Cci.ITypeReference) != null)                          {                              member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((methodRef = symbolRef as Cci.IMethodReference) != null)                          {                              member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((fieldRef = symbolRef as Cci.IFieldReference) != null)                          {                              member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          }                          else                          {                              throw ExceptionUtilities.Unreachable;                          }                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineString: // ldstr                          tokenFixupOffsets.Add(curIndex);                          string str = ReadString(buffer' curIndex);                          WriteInt(buffer' _builder.GetStringConstant(str).Token' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineSig: // calli (not emitted by C#/VB)                          throw new NotSupportedException();                        case OperandType.InlineBrTarget:                      case OperandType.InlineI:                      case OperandType.ShortInlineR:                          curIndex += 4;                          break;                        case OperandType.InlineI8:                      case OperandType.InlineR:                          curIndex += 8;                          break;                        case OperandType.InlineNone:                          break;                        case OperandType.InlineVar:                          curIndex += 2;                          break;                        case OperandType.ShortInlineBrTarget:                      case OperandType.ShortInlineI:                      case OperandType.ShortInlineVar:                          curIndex += 1;                          break;                        case OperandType.InlineSwitch:                          // skip switch arguments                          curIndex += 4 + BitConverter.ToInt32(buffer' curIndex) * 4;                          break;                        default:                          throw ExceptionUtilities.UnexpectedValue(operandType);                  }
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,The following statement contains a magic number: switch (operandType)                  {                      case OperandType.InlineField:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineMethod:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineType:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineTok: // ldtoken                          tokenFixupOffsets.Add(curIndex);                            // FieldRef' MethodRef' TypeRef                          var symbolRef = ReadSymbolRef(buffer' curIndex);                            Cci.ITypeReference typeRef;                          Cci.IMethodReference methodRef;                          Cci.IFieldReference fieldRef;                          if ((typeRef = symbolRef as Cci.ITypeReference) != null)                          {                              member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((methodRef = symbolRef as Cci.IMethodReference) != null)                          {                              member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((fieldRef = symbolRef as Cci.IFieldReference) != null)                          {                              member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          }                          else                          {                              throw ExceptionUtilities.Unreachable;                          }                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineString: // ldstr                          tokenFixupOffsets.Add(curIndex);                          string str = ReadString(buffer' curIndex);                          WriteInt(buffer' _builder.GetStringConstant(str).Token' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineSig: // calli (not emitted by C#/VB)                          throw new NotSupportedException();                        case OperandType.InlineBrTarget:                      case OperandType.InlineI:                      case OperandType.ShortInlineR:                          curIndex += 4;                          break;                        case OperandType.InlineI8:                      case OperandType.InlineR:                          curIndex += 8;                          break;                        case OperandType.InlineNone:                          break;                        case OperandType.InlineVar:                          curIndex += 2;                          break;                        case OperandType.ShortInlineBrTarget:                      case OperandType.ShortInlineI:                      case OperandType.ShortInlineVar:                          curIndex += 1;                          break;                        case OperandType.InlineSwitch:                          // skip switch arguments                          curIndex += 4 + BitConverter.ToInt32(buffer' curIndex) * 4;                          break;                        default:                          throw ExceptionUtilities.UnexpectedValue(operandType);                  }
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,The following statement contains a magic number: switch (operandType)                  {                      case OperandType.InlineField:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineMethod:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineType:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineTok: // ldtoken                          tokenFixupOffsets.Add(curIndex);                            // FieldRef' MethodRef' TypeRef                          var symbolRef = ReadSymbolRef(buffer' curIndex);                            Cci.ITypeReference typeRef;                          Cci.IMethodReference methodRef;                          Cci.IFieldReference fieldRef;                          if ((typeRef = symbolRef as Cci.ITypeReference) != null)                          {                              member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((methodRef = symbolRef as Cci.IMethodReference) != null)                          {                              member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((fieldRef = symbolRef as Cci.IFieldReference) != null)                          {                              member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          }                          else                          {                              throw ExceptionUtilities.Unreachable;                          }                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineString: // ldstr                          tokenFixupOffsets.Add(curIndex);                          string str = ReadString(buffer' curIndex);                          WriteInt(buffer' _builder.GetStringConstant(str).Token' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineSig: // calli (not emitted by C#/VB)                          throw new NotSupportedException();                        case OperandType.InlineBrTarget:                      case OperandType.InlineI:                      case OperandType.ShortInlineR:                          curIndex += 4;                          break;                        case OperandType.InlineI8:                      case OperandType.InlineR:                          curIndex += 8;                          break;                        case OperandType.InlineNone:                          break;                        case OperandType.InlineVar:                          curIndex += 2;                          break;                        case OperandType.ShortInlineBrTarget:                      case OperandType.ShortInlineI:                      case OperandType.ShortInlineVar:                          curIndex += 1;                          break;                        case OperandType.InlineSwitch:                          // skip switch arguments                          curIndex += 4 + BitConverter.ToInt32(buffer' curIndex) * 4;                          break;                        default:                          throw ExceptionUtilities.UnexpectedValue(operandType);                  }
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,The following statement contains a magic number: switch (operandType)                  {                      case OperandType.InlineField:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineMethod:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineType:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineTok: // ldtoken                          tokenFixupOffsets.Add(curIndex);                            // FieldRef' MethodRef' TypeRef                          var symbolRef = ReadSymbolRef(buffer' curIndex);                            Cci.ITypeReference typeRef;                          Cci.IMethodReference methodRef;                          Cci.IFieldReference fieldRef;                          if ((typeRef = symbolRef as Cci.ITypeReference) != null)                          {                              member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((methodRef = symbolRef as Cci.IMethodReference) != null)                          {                              member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((fieldRef = symbolRef as Cci.IFieldReference) != null)                          {                              member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          }                          else                          {                              throw ExceptionUtilities.Unreachable;                          }                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineString: // ldstr                          tokenFixupOffsets.Add(curIndex);                          string str = ReadString(buffer' curIndex);                          WriteInt(buffer' _builder.GetStringConstant(str).Token' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineSig: // calli (not emitted by C#/VB)                          throw new NotSupportedException();                        case OperandType.InlineBrTarget:                      case OperandType.InlineI:                      case OperandType.ShortInlineR:                          curIndex += 4;                          break;                        case OperandType.InlineI8:                      case OperandType.InlineR:                          curIndex += 8;                          break;                        case OperandType.InlineNone:                          break;                        case OperandType.InlineVar:                          curIndex += 2;                          break;                        case OperandType.ShortInlineBrTarget:                      case OperandType.ShortInlineI:                      case OperandType.ShortInlineVar:                          curIndex += 1;                          break;                        case OperandType.InlineSwitch:                          // skip switch arguments                          curIndex += 4 + BitConverter.ToInt32(buffer' curIndex) * 4;                          break;                        default:                          throw ExceptionUtilities.UnexpectedValue(operandType);                  }
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,The following statement contains a magic number: switch (operandType)                  {                      case OperandType.InlineField:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineMethod:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineType:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineTok: // ldtoken                          tokenFixupOffsets.Add(curIndex);                            // FieldRef' MethodRef' TypeRef                          var symbolRef = ReadSymbolRef(buffer' curIndex);                            Cci.ITypeReference typeRef;                          Cci.IMethodReference methodRef;                          Cci.IFieldReference fieldRef;                          if ((typeRef = symbolRef as Cci.ITypeReference) != null)                          {                              member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((methodRef = symbolRef as Cci.IMethodReference) != null)                          {                              member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((fieldRef = symbolRef as Cci.IFieldReference) != null)                          {                              member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          }                          else                          {                              throw ExceptionUtilities.Unreachable;                          }                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineString: // ldstr                          tokenFixupOffsets.Add(curIndex);                          string str = ReadString(buffer' curIndex);                          WriteInt(buffer' _builder.GetStringConstant(str).Token' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineSig: // calli (not emitted by C#/VB)                          throw new NotSupportedException();                        case OperandType.InlineBrTarget:                      case OperandType.InlineI:                      case OperandType.ShortInlineR:                          curIndex += 4;                          break;                        case OperandType.InlineI8:                      case OperandType.InlineR:                          curIndex += 8;                          break;                        case OperandType.InlineNone:                          break;                        case OperandType.InlineVar:                          curIndex += 2;                          break;                        case OperandType.ShortInlineBrTarget:                      case OperandType.ShortInlineI:                      case OperandType.ShortInlineVar:                          curIndex += 1;                          break;                        case OperandType.InlineSwitch:                          // skip switch arguments                          curIndex += 4 + BitConverter.ToInt32(buffer' curIndex) * 4;                          break;                        default:                          throw ExceptionUtilities.UnexpectedValue(operandType);                  }
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,The following statement contains a magic number: switch (operandType)                  {                      case OperandType.InlineField:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineMethod:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineType:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineTok: // ldtoken                          tokenFixupOffsets.Add(curIndex);                            // FieldRef' MethodRef' TypeRef                          var symbolRef = ReadSymbolRef(buffer' curIndex);                            Cci.ITypeReference typeRef;                          Cci.IMethodReference methodRef;                          Cci.IFieldReference fieldRef;                          if ((typeRef = symbolRef as Cci.ITypeReference) != null)                          {                              member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((methodRef = symbolRef as Cci.IMethodReference) != null)                          {                              member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((fieldRef = symbolRef as Cci.IFieldReference) != null)                          {                              member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          }                          else                          {                              throw ExceptionUtilities.Unreachable;                          }                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineString: // ldstr                          tokenFixupOffsets.Add(curIndex);                          string str = ReadString(buffer' curIndex);                          WriteInt(buffer' _builder.GetStringConstant(str).Token' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineSig: // calli (not emitted by C#/VB)                          throw new NotSupportedException();                        case OperandType.InlineBrTarget:                      case OperandType.InlineI:                      case OperandType.ShortInlineR:                          curIndex += 4;                          break;                        case OperandType.InlineI8:                      case OperandType.InlineR:                          curIndex += 8;                          break;                        case OperandType.InlineNone:                          break;                        case OperandType.InlineVar:                          curIndex += 2;                          break;                        case OperandType.ShortInlineBrTarget:                      case OperandType.ShortInlineI:                      case OperandType.ShortInlineVar:                          curIndex += 1;                          break;                        case OperandType.InlineSwitch:                          // skip switch arguments                          curIndex += 4 + BitConverter.ToInt32(buffer' curIndex) * 4;                          break;                        default:                          throw ExceptionUtilities.UnexpectedValue(operandType);                  }
Magic Number,Microsoft.CodeAnalysis.Scripting.Emit,ReflectionEmitter,C:\research\architectureSmells\repos\mono_roslyn\src\Scripting\Core\Emit\ReflectionEmitter.cs,SubstituteTokens,The following statement contains a magic number: switch (operandType)                  {                      case OperandType.InlineField:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineMethod:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineType:                          tokenFixupOffsets.Add(curIndex);                          member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineTok: // ldtoken                          tokenFixupOffsets.Add(curIndex);                            // FieldRef' MethodRef' TypeRef                          var symbolRef = ReadSymbolRef(buffer' curIndex);                            Cci.ITypeReference typeRef;                          Cci.IMethodReference methodRef;                          Cci.IFieldReference fieldRef;                          if ((typeRef = symbolRef as Cci.ITypeReference) != null)                          {                              member = ResolveType((Cci.ITypeReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((methodRef = symbolRef as Cci.IMethodReference) != null)                          {                              member = ResolveMethodOrConstructor((Cci.IMethodReference)ReadSymbolRef(buffer' curIndex));                          }                          else if ((fieldRef = symbolRef as Cci.IFieldReference) != null)                          {                              member = ResolveField((Cci.IFieldReference)ReadSymbolRef(buffer' curIndex));                          }                          else                          {                              throw ExceptionUtilities.Unreachable;                          }                          WriteInt(buffer' GetToken(member)' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineString: // ldstr                          tokenFixupOffsets.Add(curIndex);                          string str = ReadString(buffer' curIndex);                          WriteInt(buffer' _builder.GetStringConstant(str).Token' curIndex);                          curIndex += 4;                          break;                        case OperandType.InlineSig: // calli (not emitted by C#/VB)                          throw new NotSupportedException();                        case OperandType.InlineBrTarget:                      case OperandType.InlineI:                      case OperandType.ShortInlineR:                          curIndex += 4;                          break;                        case OperandType.InlineI8:                      case OperandType.InlineR:                          curIndex += 8;                          break;                        case OperandType.InlineNone:                          break;                        case OperandType.InlineVar:                          curIndex += 2;                          break;                        case OperandType.ShortInlineBrTarget:                      case OperandType.ShortInlineI:                      case OperandType.ShortInlineVar:                          curIndex += 1;                          break;                        case OperandType.InlineSwitch:                          // skip switch arguments                          curIndex += 4 + BitConverter.ToInt32(buffer' curIndex) * 4;                          break;                        default:                          throw ExceptionUtilities.UnexpectedValue(operandType);                  }
